<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>雷达原理-ukf 滤波器 | Kelin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">雷达原理-ukf 滤波器</h1><a id="logo" href="/.">Kelin's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">雷达原理-ukf 滤波器</h1><div class="post-meta">2025-06-13<span> | </span><span class="category"><a href="/categories/Radar-Principle/">Radar Principle</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.1k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 7</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h2 id="UKF（无迹卡尔曼滤波器）和-KF（卡尔曼滤波器）？">UKF（无迹卡尔曼滤波器）和 KF（卡尔曼滤波器）？</h2>
<ul>
<li><strong>卡尔曼滤波器（KF）</strong> 适用于线性系统；</li>
<li><strong>无迹卡尔曼滤波器（UKF）</strong> 是它的非线性扩展，精度更高，且比EKF更稳健。</li>
</ul>
<h3 id="KF（Kalman-Filter）适用于什么？">KF（Kalman Filter）适用于什么？</h3>
<ul>
<li>
<p>系统必须是<strong>线性</strong>的</p>
</li>
<li>
<p>系统模型可以写成：</p>
<p>$$<br>
x_k = F x_{k-1} + w_k \<br>
z_k = H x_k + v_k<br>
$$</p>
</li>
<li>
<p>状态转移（<code>F</code>）和观测（<code>H</code>）都是<strong>线性矩阵</strong></p>
</li>
<li>
<p>噪声是高斯的</p>
</li>
</ul>
<blockquote>
<p>KF 的优势：计算简单、推理快速<br>
KF 的局限：无法处理非线性，比如角度、旋转、曲线运动等</p>
</blockquote>
<h3 id="UKF（Unscented-Kalman-Filter）是什么？">UKF（Unscented Kalman Filter）是什么？</h3>
<p>UKF 设计来处理<strong>非线性系统</strong>，不再用简单矩阵来描述状态和观测，而是使用函数形式：</p>
<p>$$<br>
x_k = f(x_{k-1}) + w_k \<br>
z_k = h(x_k) + v_k<br>
$$</p>
<blockquote>
<p><strong>核心思想：Unscented Transform（无迹变换）</strong><br>
用一组“<strong>sigma点</strong>”来近似高斯分布，通过这些点来传递非线性变换的影响，比线性化方式更精确。</p>
</blockquote>
<hr>
<h3 id="KF-vs-UKF：具体对比">KF vs UKF：具体对比</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th>KF（卡尔曼滤波）</th>
<th>UKF（无迹卡尔曼滤波）</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否能处理非线性</td>
<td>不能</td>
<td>可以</td>
</tr>
<tr>
<td>状态转移模型</td>
<td>线性 <code>F</code></td>
<td>非线性 <code>f(x)</code></td>
</tr>
<tr>
<td>观测模型</td>
<td>线性 <code>H</code></td>
<td>非线性 <code>h(x)</code></td>
</tr>
<tr>
<td>处理非线性方式</td>
<td>不支持</td>
<td>用 sigma 点传播分布</td>
</tr>
<tr>
<td>精度</td>
<td>高（在线性系统）</td>
<td>更高（在非线性系统）</td>
</tr>
<tr>
<td>稳定性</td>
<td>易于理解和实现</td>
<td>更强健，但复杂些</td>
</tr>
<tr>
<td>计算量</td>
<td>低</td>
<td>略高一些</td>
</tr>
<tr>
<td>应用场景</td>
<td>匀速直线、线性加速度</td>
<td>飞行姿态估计、目标跟踪（非直线）</td>
</tr>
</tbody>
</table>
<h3 id="一个直观的例子">一个直观的例子</h3>
<p>假设要估计目标的<strong>位置和朝向（角度）</strong>：</p>
<ul>
<li>KF 会认为朝向线性变化，但实际上角度是一个非线性变量（会 wrap-around，例如 359° → 0°）</li>
<li>UKF 会用 sigma 点来“描绘”一小群可能的位置+角度，然后对这些点做真实的非线性变换，结果比直接线性化更靠谱！</li>
</ul>
<h3 id="UKF-的适用场景">UKF 的适用场景</h3>
<ul>
<li>目标非线性运动（比如目标在弯道或做曲线移动）</li>
<li>系统模型或测量模型是非线性函数</li>
<li>IMU+GPS 融合、SLAM、雷达目标跟踪、姿态估计等</li>
</ul>
<p>很好，你已经对卡尔曼滤波（KF）有一定了解，这会非常有助于理解无迹卡尔曼滤波（UKF）。你提到“不太懂 UKF 中是不是用了很多协方差矩阵”，我们就围绕<strong>UKF 中的协方差矩阵</strong>来解释它和 KF 的关系与不同。</p>
<h2 id="UKF-中用到了哪些协方差矩阵？">UKF 中用到了哪些协方差矩阵？</h2>
<p>实际上，<strong>UKF 使用的协方差矩阵和 KF 是一样的，仍然是这三个</strong>：</p>
<table>
<thead>
<tr>
<th>矩阵</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>P</code></td>
<td>状态协方差矩阵</td>
<td>当前对导弹位置/速度估计的可信度（不确定性）</td>
</tr>
<tr>
<td><code>Q</code></td>
<td>过程噪声协方差矩阵</td>
<td>描述导弹运动过程中模型误差（比如风力、系统扰动）</td>
</tr>
<tr>
<td><code>R</code></td>
<td>观测噪声协方差矩阵</td>
<td>描述雷达测量的不确定性（比如雷达噪声、精度限制）</td>
</tr>
</tbody>
</table>
<p>这些矩阵的作用和卡尔曼滤波中的一致，只不过 <strong>UKF 的更新方式是通过“采样多个可能点”（Sigma 点）计算协方差</strong>，而不是用一阶线性估计（雅可比矩阵）去近似。</p>
<h3 id="它们分别在-UKF-哪些步骤中用到？">它们分别在 UKF 哪些步骤中用到？</h3>
<table>
<thead>
<tr>
<th>步骤</th>
<th>用到的协方差矩阵</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1. 状态预测</td>
<td><code>Q</code></td>
<td>每个 Sigma 点预测之后，要加上过程噪声协方差 <code>Q</code></td>
</tr>
<tr>
<td>2. 状态协方差预测</td>
<td><code>Q</code> + 预测协方差</td>
<td>生成新的预测协方差矩阵 <code>P</code></td>
</tr>
<tr>
<td>3. 观测预测协方差</td>
<td><code>R</code></td>
<td>将预测观测值的散布计算协方差，并加上测量噪声协方差 <code>R</code></td>
</tr>
<tr>
<td>4. 更新卡尔曼增益</td>
<td><code>P</code>, <code>R</code></td>
<td>用于计算 Kalman 增益，融合观测</td>
</tr>
<tr>
<td>5. 状态更新</td>
<td><code>P</code></td>
<td>根据观测误差和增益调整状态与 <code>P</code></td>
</tr>
</tbody>
</table>
<hr>
<h3 id="一个直观的例子理解三者作用（导弹观测）">一个直观的例子理解三者作用（导弹观测）</h3>
<p>假设我们预测导弹下一步在 <code>(x=100, y=50)</code>，然后：</p>
<ol>
<li>
<p><strong>Q（过程噪声）</strong><br>
表示我们对导弹运动模型的不确定，比如可能有风，预测可能偏了：</p>
<ul>
<li>Q 越大 → 说明你不太信模型 → 卡尔曼增益会更偏向观测值。</li>
<li>Q 越小 → 说明你非常信模型 → 更偏向预测轨迹。</li>
</ul>
</li>
<li>
<p><strong>R（观测噪声）</strong><br>
雷达测出 <code>(102, 52)</code>，但你知道雷达有 ±5 米误差，所以 R=25。</p>
<ul>
<li>R 越大 → 说明你不信雷达 → 更信模型预测。</li>
<li>R 越小 → 说明雷达很准 → 卡尔曼增益更依赖观测值。</li>
</ul>
</li>
<li>
<p><strong>P（状态协方差）</strong><br>
你自己对预测值的置信度，也会影响 Kalman 增益 K 的计算：</p>
<ul>
<li>P 很大 → 说明你对自己预测很不自信 → 更信观测。</li>
<li>P 很小 → 你信预测 → 更忽略观测。</li>
</ul>
</li>
</ol>
<p>非常好问题！我们来<strong>完整梳理 UKF 的工作流程</strong>，包括：</p>
<ol>
<li>每一步的计算公式；</li>
<li><code>P</code>、<code>Q</code>、<code>R</code> 等协方差矩阵的作用；</li>
<li>如何初始化这些值（有经验法也有实践法）。</li>
</ol>
<h2 id="UKF-的具体计算步骤">UKF 的具体计算步骤</h2>
<p>设状态维度为 <code>n</code>，观测维度为 <code>m</code>。</p>
<h3 id="0-初始化（初值设定）">0. 初始化（初值设定）</h3>
<p>需要提供：</p>
<ul>
<li>
<p>初始状态估计向量 <code>x₀</code>，比如导弹初始位置和速度<br>
<code>x₀ = [x, y, vx, vy]^T</code></p>
</li>
<li>
<p>初始状态协方差 <code>P₀</code>：你对这个估计的信心，通常用对角矩阵，如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P</span>₀ = diag([<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>系统过程噪声协方差 <code>Q</code>：运动模型的误差，比如风、引擎干扰</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Q</span> = diag([<span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">05</span>, <span class="number">0</span>.<span class="number">05</span>])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>观测噪声协方差 <code>R</code>：传感器的误差，比如雷达误差 ±2 米 → 方差为 4</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">R</span> = diag([<span class="number">4</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-生成-Sigma-点">1. 生成 Sigma 点</h3>
<p>给定当前状态 <code>x_k</code> 和协方差 <code>P_k</code>，生成 <code>2n + 1</code> 个 Sigma 点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X[0] = x_k</span><br><span class="line">X[i]   = x_k + (sqrt((n+λ) * P))_i,   i = 1...n</span><br><span class="line">X[i+n] = x_k - (sqrt((n+λ) * P))_i,   i = 1...n</span><br></pre></td></tr></table></figure>
<p>λ 是一个超参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ = α²(n + κ) - n</span><br></pre></td></tr></table></figure>
<p>一般经验设置：</p>
<ul>
<li>α = 1e-3（影响 Sigma 点间距）</li>
<li>κ = 0</li>
<li>β = 2（高斯分布的最优值）</li>
</ul>
<hr>
<h3 id="2-预测步骤">2. 预测步骤</h3>
<h4 id="a-对每个-Sigma-点用系统动力学函数-f-传播">(a) 对每个 Sigma 点用系统动力学函数 f 传播</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X⁻[i] = f(X[i])</span><br></pre></td></tr></table></figure>
<h4 id="b-用加权平均计算预测状态均值：">(b) 用加权平均计算预测状态均值：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x⁻ = Σ Wm[i] * X⁻[i]</span><br></pre></td></tr></table></figure>
<h4 id="©-计算预测协方差：">© 计算预测协方差：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P⁻ = Σ Wc[i] * (X⁻[i] - x⁻)(X⁻[i] - x⁻)^T + Q</span><br></pre></td></tr></table></figure>
<h3 id="3-更新步骤（测量观测更新）">3. 更新步骤（测量观测更新）</h3>
<h4 id="a-通过观测模型-h-·-将预测点投影到观测空间：">(a) 通过观测模型 h(·) 将预测点投影到观测空间：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z[i] = h(X⁻[i])</span><br></pre></td></tr></table></figure>
<h4 id="b-计算预测观测均值：">(b) 计算预测观测均值：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z⁻ = Σ Wm[i] * Z[i]</span><br></pre></td></tr></table></figure>
<h4 id="©-计算观测协方差矩阵-S：">© 计算观测协方差矩阵 <code>S</code>：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = Σ Wc[i] * (Z[i] - z⁻)(Z[i] - z⁻)^T + R</span><br></pre></td></tr></table></figure>
<h4 id="d-计算状态与观测之间的协方差矩阵-P-xz：">(d) 计算状态与观测之间的协方差矩阵 <code>P_xz</code>：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_xz = Σ Wc[i] * (X⁻[i] - x⁻)(Z[i] - z⁻)^T</span><br></pre></td></tr></table></figure>
<h4 id="e-计算-Kalman-增益：">(e) 计算 Kalman 增益：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = P_xz * S⁻¹</span><br></pre></td></tr></table></figure>
<h4 id="f-更新状态估计和协方差：">(f) 更新状态估计和协方差：</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_k = x⁻ + K * (z_k - z⁻)</span><br><span class="line">P_k = P⁻ - K * S * K^T</span><br></pre></td></tr></table></figure>
<h2 id="初始状态协方差矩阵-P₀"><strong>初始状态协方差矩阵 P₀</strong></h2>
<h3 id="1-P₀-的含义是什么？">1. P₀ 的含义是什么？</h3>
<ul>
<li>
<p><strong>P₀ 是状态估计的初始“不确定性”矩阵。</strong></p>
</li>
<li>
<p>它告诉滤波器“我对初始状态估计有多大的信心”。</p>
</li>
<li>
<p>P₀ 是一个方阵，大小是状态向量维度的平方。</p>
</li>
<li>
<p>典型情况下，P₀ 是对角矩阵，表示各个状态变量之间的估计误差<strong>不相关</strong>，对角线上元素代表各状态分量的<strong>方差（不确定度大小）</strong>。</p>
</li>
</ul>
<p>举例：状态向量是四维 <code>[位置_x, 位置_y, 速度_x, 速度_y]</code>，那么</p>
<p>$$<br>
P_0 = \begin{bmatrix}<br>
\sigma_{x}^2 &amp; 0 &amp; 0 &amp; 0 \<br>
0 &amp; \sigma_{y}^2 &amp; 0 &amp; 0 \<br>
0 &amp; 0 &amp; \sigma_{v_x}^2 &amp; 0 \<br>
0 &amp; 0 &amp; 0 &amp; \sigma_{v_y}^2<br>
\end{bmatrix}<br>
$$</p>
<p>这里的 $\sigma_x, \sigma_y, \sigma_{v_x}, \sigma_{v_y}$ 是对应变量的<strong>标准差</strong>，平方即是方差。</p>
<hr>
<h3 id="2-为什么一般用对角矩阵？">2. 为什么一般用对角矩阵？</h3>
<ul>
<li>
<p>因为初始状态估计的不同维度变量误差通常被假设<strong>相互独立</strong>（没有协方差）。</p>
</li>
<li>
<p>如果你有更详细的先验知识，知道某些变量误差相关，可以把相应位置设置非零协方差。</p>
</li>
</ul>
<hr>
<h4 id="4-不同-P₀-会对滤波有什么影响？">4. 不同 P₀ 会对滤波有什么影响？</h4>
<ul>
<li>
<p><strong>P₀ 太小</strong> → 滤波器对初始估计过于自信，遇到真实状态大幅偏离时反应迟钝，收敛慢。</p>
</li>
<li>
<p><strong>P₀ 太大</strong> → 表示对初始估计不确定，滤波器会更快信任观测数据，收敛较快，但可能有较大抖动。</p>
</li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://kelinkong.github.io/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-ukf-%E6%BB%A4%E6%B3%A2%E5%99%A8/" data-id="cmkvx67r6004x7oogg9keghy5" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD4UlEQVR42u3aQW7jQAwEwPz/015gr47lbnLkZLGlkxHIkqYUgGYPv77i4/H3eP58ff7z8eqaz9+6vu+rM9vnHB44cODAgWP06Pnt86VeL6y9+/X127vgwIEDB46zHHlxTR76+pxkSa8WlpfkpOjiwIEDB46f5bg+c1YaW9xZi4gDBw4cOH4/x2dSyfZHAA4cOHDg+D0cbet1XXrbCO9s2PehrBQHDhw4cLx//nqg4V/5/KH5Dhw4cOD47zkeo6ON55JIsV3SLHZ8sy4cOHDgwHGmRKzaqna8ICl+M5r2FUZZKQ4cOHDgWHAkZS8pk5sy3N63jTiTDS0cOHDgwLHn2AwWzJqr5C9J05jg5j8XcODAgQPHZzja5bVLagcX9qN7q7EGHDhw4MARc8zCu7wla0E3xbJt4XDgwIEDxx0cyXbRbDGnor12c+vAZhgOHDhw4Cg58kYo/zyL59qIMC+xRZHGgQMHDhyHOPJgLi+BswGIvKWcRYFv/glw4MCBA8eaYxbJtUs6NTyRD/O1ryd6IBw4cODAEawxHzhry+dm8ykP9fbnfxMO4sCBAweONcdmlGFf29uA7xEfdYuIAwcOHDgOcbRjDZtl5J/zMtkOzBW/O3DgwIEDR8nRbuHMgrxZXHgKtL0yDhw4cODYcLQh2iz4a0t4Pr6QtG3Fi8GBAwcOHEc52mK2GZjLC2TbZCb3GmafOHDgwIHjEEc+QJCXvbZMzprG+vo4cODAgePM9euj3Si6716nwkEcOHDgwHGKI2+68vG1NhacnZOX/6Js48CBAweONccsKJyNPmwivztGGd68Qhw4cODAseB4BEdyyz3ofqltkX6ZmOLAgQMHjhHHZjyuHXrbl8y8DUu2xHDgwIEDx2c42sXnowP5lWejFRumwhsHDhw4cMR7Q7NNo3x8oW0I9w1bG03iwIEDB449R9uwJRCnHi5pCDc/BaKUFAcOHDhwrDnysbl8Y6ml3DDlPxpw4MCBA8fdHMnXZjFf8UCjqHEfMuLAgQMHjjs49uHdvoi24wvtC3jzT4ADBw4cOA5xtA3bvky2QWReVvP275sr4MCBAweONUde0tryfN/8Rf6cs0KOAwcOHDg2HI/y2HQ6bbSXF+l9yIgDBw4cOE5xtGUpL7r7zaF8c6u9/oEDBw4cOHCU20Wngrn7mE5tg9WNHA4cOHDgiDlmQwB5g7ev/EnIuBmVwIEDBw4cP8uxGYzbNF2bqDEZyMCBAwcOHJ/kOLXVNFvYpuQX5R8HDhw4cBziaIO8WWyXE9xXyN9cHwcOHDhwrDlmAw15aZwVws1G12wAAgcOHDhwrDn+AEHElfDFOp1LAAAAAElFTkSuQmCC">Share</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2025/09/11/Java-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">Java-项目开发记录</a><a class="next" href="/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">雷达原理-卡尔曼滤波器基础学习</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kelinkong.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/logo.jpg"/></a><p>Kelin is a boring girl, but not always.</p><a class="info-icon" href="https://github.com/kelinkong" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digital-Human/">Digital Human</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Security/">Network-Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating-System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Radar-Principle/">Radar Principle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/solutions/">solutions</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/CMU15-445/" style="font-size: 15px;">CMU15-445</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/" style="font-size: 15px;">雷达原理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2026/01/22/%E3%80%90c++%E3%80%91brtc%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">【c++】brtc项目开发记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/12/08/Java-copy%E6%A8%A1%E5%BC%8F/">Java-copy模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/11/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-tryHackMe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">网络安全-学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/11/18/Java-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">Java-命令模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/09/11/Java-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/">Java-项目开发记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-ukf-%E6%BB%A4%E6%B3%A2%E5%99%A8/">雷达原理-ukf 滤波器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">雷达原理-卡尔曼滤波器基础学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/Java-Java%E7%9A%84%E5%AE%B9%E5%99%A8%E5%92%8CC-%E7%9A%84STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94/">Java-Java的容器和C++的STL容器的对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-%E9%9F%B3%E9%A2%91%E6%8E%A8%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">数字人-Java音视频处理-音频推流失败问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/21/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/">数字人-Java音视频处理-推流和拉流</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2026 <a href="/." rel="nofollow">Kelin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js?v=1.0.0"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript">window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true
  },
  svg: { fontCache: 'global' },
  startup: {
    pageReady: () => {
      return MathJax.typesetPromise().catch(err => console.log(err))
    }
  }
};</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>