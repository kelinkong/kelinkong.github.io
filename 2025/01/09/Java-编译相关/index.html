<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java-编译相关 | Kelin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-编译相关</h1><a id="logo" href="/.">Kelin's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-编译相关</h1><div class="post-meta">2025-01-09<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.5k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h2 id="Jvm">Jvm</h2>
<h3 id="1-一次编写，处处运行（Write-Once-Run-Anywhere）">1. <strong>一次编写，处处运行（Write Once, Run Anywhere）</strong></h3>
<ul>
<li>Java 程序被编译成 <strong>字节码（<code>.class</code>）</strong>，不是平台相关的机器码。</li>
<li>字节码由 <strong>JVM 解释或编译执行</strong>，只要目标机器有 JVM，就能运行。</li>
<li>不需要为每个操作系统单独编译！</li>
</ul>
<p>举例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你写了一个 HelloWorld.java</span><br><span class="line">→ 编译得到 HelloWorld.class</span><br><span class="line">→ Windows 装 JVM → 可以跑</span><br><span class="line">→ Linux 装 JVM → 也可以跑</span><br><span class="line">→ Mac 装 JVM → 继续跑</span><br></pre></td></tr></table></figure>
<h3 id="2-更强的安全性和隔离性">2. <strong>更强的安全性和隔离性</strong></h3>
<ul>
<li>Java 程序运行在 <strong>JVM 沙箱中</strong>，不会直接访问底层内存（不像 C++ 有指针）。</li>
<li>JVM 会做<strong>字节码校验、安全检查</strong>，减少恶意代码运行风险。</li>
</ul>
<h3 id="3-跨平台的标准化生态">3. <strong>跨平台的标准化生态</strong></h3>
<ul>
<li>JVM 提供统一的接口和行为定义，开发者不必关心 OS 差异。</li>
<li>Java 的生态（如 Spring、Hadoop、Spark）可以无缝运行在多种平台上。</li>
</ul>
<h3 id="4-JIT（即时编译）-GC（自动内存管理）">4. <strong>JIT（即时编译）+ GC（自动内存管理）</strong></h3>
<ul>
<li>JVM 运行时会监控热点代码，使用 JIT 将字节码编译为机器码，优化性能。</li>
<li>自动垃圾回收（GC）减轻了开发者的负担，减少内存泄漏风险。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>Java JVM</th>
<th>C++ 编译器（g++/clang）</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译方式</td>
<td>源码 → 字节码（跨平台中间码）</td>
<td>源码 → 机器码（平台绑定）</td>
</tr>
<tr>
<td>平台相关性</td>
<td>字节码不平台相关，但 JVM 是</td>
<td>编译结果是平台相关</td>
</tr>
<tr>
<td>编译时 vs 运行时</td>
<td>编译时平台无关，运行时需 JVM</td>
<td>编译时决定平台，运行时直接执行</td>
</tr>
</tbody>
</table>
<p>JVM 与 C++ 编译器最大不同是：</p>
<blockquote>
<p>JVM 将“平台相关性”推迟到运行时（由 JVM 屏蔽平台差异），而 C++ 是在编译时就决定目标平台。</p>
</blockquote>
<p>所以只需要：</p>
<ul>
<li>一次写 Java 程序 + 编译成 <code>.class</code></li>
<li>每个平台装对应的 JVM，就能<strong>不重编译地运行</strong></li>
</ul>
<p>但 C++：</p>
<ul>
<li>写完程序，如果要在不同平台运行，就要用不同的编译器重新编译成不同平台的机器码。</li>
</ul>
<p><strong>那 JVM 不就是额外多装一个运行环境？很麻烦？</strong></p>
<p>是的，这是它的“成本”。但：</p>
<ul>
<li>Java 项目往往是“部署一次、跑在任意云环境或服务器上”</li>
<li>JVM 可以预装在环境中，运行效率也越来越高（GraalVM、ZGC、JIT等）</li>
</ul>
<h2 id="Java的即时编译器">Java的即时编译器</h2>
<p>Java 的即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中的重要组成部分，它在程序运行时将 Java 字节码 (Bytecode) 转换为本地机器代码，从而提高程序运行效率。以下是关于 JIT 的详细科普：</p>
<h3 id="1-JIT-编译器的作用">1. <strong>JIT 编译器的作用</strong></h3>
<ul>
<li>Java 程序先被编译为字节码，这是一种中间代码，独立于底层硬件和操作系统。</li>
<li>JVM 通过<strong>解释器 (Interpreter)</strong> 将字节码逐行解释为机器代码执行，但逐行解释速度较慢。</li>
<li>为了优化性能，JVM 使用 JIT 将热代码段（执行频率高的代码）直接编译成机器码并缓存起来。之后再运行这些代码时，无需解释，直接执行机器码，极大提高了性能。</li>
</ul>
<h3 id="2-JIT-的工作原理">2. <strong>JIT 的工作原理</strong></h3>
<ol>
<li><strong>字节码加载</strong>：
<ul>
<li>JVM 通过类加载器加载字节码到内存。</li>
</ul>
</li>
<li><strong>初始执行</strong>：
<ul>
<li>字节码开始由解释器逐行解释执行。</li>
</ul>
</li>
<li><strong>热点代码检测</strong>：
<ul>
<li>JIT 使用<strong>热点探测技术</strong>（如计数器）来识别频繁执行的代码（如循环体）。</li>
</ul>
</li>
<li><strong>即时编译</strong>：
<ul>
<li>识别到热点代码后，JIT 将其编译为本地机器代码并优化执行。</li>
</ul>
</li>
<li><strong>缓存与复用</strong>：
<ul>
<li>已编译的机器代码被缓存起来供后续直接使用。</li>
</ul>
</li>
</ol>
<h3 id="3-JIT-编译的优化技术">3. <strong>JIT 编译的优化技术</strong></h3>
<p>JIT 编译器除了简单地将字节码翻译为机器码，还会进行多种优化，如：</p>
<ul>
<li><strong>方法内联</strong>：将小方法的代码直接嵌入调用处，减少方法调用的开销。</li>
<li><strong>常量折叠</strong>：在编译时计算出常量表达式的结果。</li>
<li><strong>循环展开</strong>：减少循环中的控制逻辑，增加运行效率。</li>
<li><strong>消除冗余代码</strong>：去掉多余的、不必要的代码执行。</li>
<li><strong>逃逸分析</strong>：检测对象是否会逃出方法作用域，从而优化内存分配。</li>
</ul>
<h3 id="4-JIT-的类型">4. <strong>JIT 的类型</strong></h3>
<p>JVM 中的 JIT 编译器主要分为以下几种：</p>
<ol>
<li><strong>C1（Client Compiler）</strong>：
<ul>
<li>针对客户端应用优化，启动速度快。</li>
<li>适用于需要快速响应的程序。</li>
</ul>
</li>
<li><strong>C2（Server Compiler）</strong>：
<ul>
<li>针对服务器端应用优化，执行速度更快。</li>
<li>适用于长时间运行、对性能要求高的程序。</li>
</ul>
</li>
<li><strong>Graal JIT</strong>：
<ul>
<li>新一代 JIT 编译器，基于 Java 实现，优化更为激进。</li>
<li>提供更好的性能和可扩展性。</li>
</ul>
</li>
</ol>
<h3 id="5-JIT-的优缺点">5. <strong>JIT 的优缺点</strong></h3>
<h4 id="优点：">优点：</h4>
<ul>
<li><strong>高性能</strong>：将热点代码编译为本地机器码，大幅提升执行效率。</li>
<li><strong>动态优化</strong>：根据运行时的实际情况进行优化（如分支预测、内存管理）。</li>
<li><strong>跨平台性</strong>：结合字节码和本地机器码，既实现跨平台，又提升性能。</li>
</ul>
<h4 id="缺点：">缺点：</h4>
<ul>
<li><strong>启动延迟</strong>：JIT 编译需要时间，可能导致程序启动较慢。</li>
<li><strong>内存占用</strong>：缓存的机器码会占用额外的内存。</li>
</ul>
<h3 id="6-JIT-和-AOT（Ahead-Of-Time）-编译的对比">6. <strong>JIT 和 AOT（Ahead-Of-Time） 编译的对比</strong></h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>JIT 编译</th>
<th>AOT 编译</th>
</tr>
</thead>
<tbody>
<tr>
<td>编译时间</td>
<td>运行时动态编译</td>
<td>编译前静态完成</td>
</tr>
<tr>
<td>性能优化</td>
<td>基于运行时动态信息进行优化</td>
<td>基于编译时静态信息优化</td>
</tr>
<tr>
<td>启动速度</td>
<td>启动较慢，需等待编译完成</td>
<td>启动较快</td>
</tr>
<tr>
<td>可移植性</td>
<td>字节码跨平台，动态编译本地代码</td>
<td>编译后的本地代码与平台绑定</td>
</tr>
</tbody>
</table>
<h3 id="7-如何调整-JIT-设置">7. <strong>如何调整 JIT 设置</strong></h3>
<p>JVM 提供了一些参数用于调整 JIT 的行为：</p>
<ul>
<li><code>-Xint</code>：强制 JVM 只使用解释模式，禁用 JIT（通常用于调试）。</li>
<li><code>-Xcomp</code>：强制 JVM 编译所有代码（可能导致启动变慢）。</li>
<li><code>-Xmixed</code>：默认模式，解释与编译结合使用。</li>
</ul>
<h3 id="8-常见问题">8. <strong>常见问题</strong></h3>
<ul>
<li><strong>为什么程序启动时较慢？</strong>
<ul>
<li>因为 JIT 需要对热点代码进行编译，初期可能依赖解释器运行。</li>
</ul>
</li>
<li><strong>JIT 编译会带来性能下降吗？</strong>
<ul>
<li>在某些情况下（如频繁的代码编译或不适当的优化策略），可能会出现<strong>编译抖动</strong>（过多的编译开销）。</li>
</ul>
</li>
</ul>
<h2 id="AOT-编译">AOT 编译</h2>
<p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p>
<h3 id="1-AOT-编译的基本概念">1. <strong>AOT 编译的基本概念</strong></h3>
<p>AOT 编译将源代码或中间代码（如 Java 字节码）编译为目标平台的机器代码，生成一个独立的、可以直接运行的本地二进制文件。编译后的程序无需依赖运行时解释器，直接运行在目标硬件上。</p>
<h3 id="2-AOT-编译的工作流程">2. <strong>AOT 编译的工作流程</strong></h3>
<ol>
<li><strong>源代码编写</strong>：
<ul>
<li>开发者使用高级编程语言（如 Java、C#）。</li>
</ul>
</li>
<li><strong>编译为中间代码</strong>：
<ul>
<li>像 Java 这样的语言通常会先编译为字节码（例如 <code>.class</code> 文件）。</li>
</ul>
</li>
<li><strong>AOT 编译</strong>：
<ul>
<li>AOT 编译器（如 GraalVM 的 AOT 工具）将字节码转换为本地机器代码。</li>
</ul>
</li>
<li><strong>生成可执行文件</strong>：
<ul>
<li>输出结果是一个可以直接运行的二进制文件，无需额外的运行时编译步骤。</li>
</ul>
</li>
</ol>
<h3 id="3-AOT-编译的优点">3. <strong>AOT 编译的优点</strong></h3>
<h4 id="1-启动速度快">(1) <strong>启动速度快</strong></h4>
<ul>
<li>编译在运行前完成，程序启动时不需要动态解释或即时编译，因此启动速度显著提高。</li>
</ul>
<h4 id="2-优化性能">(2) <strong>优化性能</strong></h4>
<ul>
<li>AOT 编译可以提前执行许多优化步骤，比如方法内联、循环优化和消除冗余代码。</li>
<li>特别适合对启动时间敏感的应用程序，比如微服务或 CLI 工具。</li>
</ul>
<h4 id="3-内存占用低">(3) <strong>内存占用低</strong></h4>
<ul>
<li>不需要运行时 JIT 编译缓存，因此内存占用更低。</li>
<li>适合内存受限的环境，如嵌入式设备和移动应用。</li>
</ul>
<h4 id="4-跨语言整合">(4) <strong>跨语言整合</strong></h4>
<ul>
<li>AOT 编译可以方便地将不同语言编写的模块编译成统一的本地代码，便于跨语言调用。</li>
</ul>
<h4 id="5-更容易分发">(5) <strong>更容易分发</strong></h4>
<ul>
<li>生成的可执行文件独立于编译器或运行时环境，可以轻松分发和部署。</li>
</ul>
<h3 id="4-AOT-编译的缺点">4. <strong>AOT 编译的缺点</strong></h3>
<h4 id="1-灵活性不足">(1) <strong>灵活性不足</strong></h4>
<ul>
<li>AOT 编译缺乏运行时动态优化的能力，无法基于实际运行情况调整性能。</li>
<li>某些优化（如分支预测、逃逸分析）需要运行时信息，AOT 无法完成。</li>
</ul>
<h4 id="2-编译时间长">(2) <strong>编译时间长</strong></h4>
<ul>
<li>编译过程通常比 JIT 更复杂，生成本地代码需要更多时间和资源。</li>
</ul>
<h4 id="3-平台绑定">(3) <strong>平台绑定</strong></h4>
<ul>
<li>AOT 编译生成的可执行文件与目标平台紧密绑定，跨平台能力不如字节码+JVM 的方案。</li>
</ul>
<h4 id="4-文件体积大">(4) <strong>文件体积大</strong></h4>
<ul>
<li>AOT 编译后的可执行文件可能包含额外的运行时支持代码，文件体积较大。</li>
</ul>
<h3 id="5-AOT-编译的应用场景">5. <strong>AOT 编译的应用场景</strong></h3>
<p>AOT 编译在以下场景中特别有用：</p>
<ol>
<li><strong>启动速度敏感的应用</strong>：
<ul>
<li>微服务、命令行工具、图形用户界面（GUI）程序等需要快速启动的应用。</li>
</ul>
</li>
<li><strong>资源受限设备</strong>：
<ul>
<li>嵌入式系统、物联网设备和移动设备等内存有限的平台。</li>
</ul>
</li>
<li><strong>无运行时环境的环境</strong>：
<ul>
<li>部署时无法安装完整的虚拟机或运行时（如 JVM）的场景。</li>
</ul>
</li>
<li><strong>安全性要求高的应用</strong>：
<ul>
<li>直接编译为本地代码可以减少对运行时的依赖，降低潜在的安全风险。</li>
</ul>
</li>
</ol>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://kelinkong.github.io/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/" data-id="cmbuhqyyt0012z4ogc81q448x" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsUlEQVR42u3a0W7jQAgF0P7/T3elvq1cJxcY3FY6forSSewzlQYCfHzE1+fXdX19XXO9rn+9+57rmtfvH7vw8PDwWo8+ebjkU3drki1L7ni7BXh4eHhrvF4wmKzfC054eHh4v4eXBINTG5SEHDw8PLy/wnudECeliuix8PDw8H49LylGJJj8s5ONW6m14OHh4cW8SSHgp14/1N/Dw8PDK3bVq+2rXvpbTdwLT4iHh4e3wJsUHXqFgxxQLSVHtRY8PDy8Me/10rOtrzxpzr+/+X/Dw8PDG/B6jai8AjC5SzU8REg8PDy8o7zXX109pjdKwJPhBjw8PLxTvO3H6m1KPlD15h08PDy8B3nVhlZvDCsvf+T3xcPDw3uGl5dQ5+2rZ0IOHh4e3vO8PLGubkSvAJGPcP33Gg8PD2+ZN2liVcsZ1UQ5H/P6poyLh4eHd5RXzUJ741Pzdlc1fW8m2Xh4eHgxb14C6A1R9cq7ecqOh4eHt8erhopqc6sXBvItKKTUeHh4eGNePnSVH/q9hHgysnC7Eg8PD2+B1xxmGpRl862pptS334aHh4e3xkvS33lTPw88vRmqQgTDw8PDa/GaR20R0Cso9FL8b34x4OHh4R3lVQPDpK1VLf7mASAatMLDw8M7xJsUanvjVnkgyd+/XYOHh4e3wEsO63njapJq91JzPDw8vD1eXgKYrOml7NVK7JvJCDw8PLxDvGpZttf4zwNMuXfXa6fh4eHhDXifxWu7GHE24cbDw8Pb4E0GnvJyRvOWg1QbDw8Pb5uX/7yfDApU7zUPGHh4eHjbvORQ7q1MPtWsmuDh4eH9Ed6kKZUf6Hmx403Sj4eHh/ejvL2yxeRJ3twRDw8Pb42XH+u9hlY12FRLw80uHx4eHl6L1zvu8wJEPnRVLe9WNxoPDw9vzPsHikTkKdmJ1JEAAAAASUVORK5CYII=">Share</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/">DB-图数据库Neo4j</a><a class="next" href="/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/">AI-动手学深度学习-笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kelinkong.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/logo.jpg"/></a><p>Kelin is a boring girl, but not always.</p><a class="info-icon" href="https://github.com/kelinkong" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digital-Human/">Digital Human</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Security/">Network-Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating-System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Radar-Principle/">Radar Principle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/frontend/">frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/solutions/">solutions</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/architecture/" style="font-size: 15px;">architecture</a> <a href="/tags/CMU15-445/" style="font-size: 15px;">CMU15-445</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/" style="font-size: 15px;">雷达原理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-ukf-%E6%BB%A4%E6%B3%A2%E5%99%A8/">雷达原理-ukf 滤波器</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">雷达原理-卡尔曼滤波器基础学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/Java-Java%E7%9A%84%E5%AE%B9%E5%99%A8%E5%92%8CC-%E7%9A%84STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94/">Java-Java的容器和C++的STL容器的对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-%E9%9F%B3%E9%A2%91%E6%8E%A8%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">数字人-Java音视频处理-音频推流失败问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/21/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/">数字人-Java音视频处理-推流和拉流</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/">数字人-基础扫盲</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">Java-基础学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/">deepseek-v3技术报告学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/">DB-图数据库Neo4j</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/">Java-编译相关</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Kelin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js?v=1.0.0"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>