<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java-基础学习 | Kelin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java-基础学习</h1><a id="logo" href="/.">Kelin's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java-基础学习</h1><div class="post-meta">2025-04-18<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.2k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 24</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul>
<li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li>
<li><strong>存储方式</strong>:基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中</li>
<li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li>
<li><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>
<li><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li>
</ul>
<h2 id="Java的垃圾回收（GC算法）、内存模型（堆-栈）、类加载机制和C-的区别"><a href="#Java的垃圾回收（GC算法）、内存模型（堆-栈）、类加载机制和C-的区别" class="headerlink" title="Java的垃圾回收（GC算法）、内存模型（堆&#x2F;栈）、类加载机制和C++的区别"></a>Java的垃圾回收（GC算法）、内存模型（堆&#x2F;栈）、类加载机制和C++的区别</h2><p>Java和C++在内存管理、内存模型和类加载机制上有显著区别，主要源于Java的自动内存管理（GC）和运行时环境（JVM）的设计。以下是详细对比：</p>
<h3 id="1-垃圾回收（GC）-vs-手动内存管理"><a href="#1-垃圾回收（GC）-vs-手动内存管理" class="headerlink" title="1. 垃圾回收（GC） vs. 手动内存管理"></a>1. 垃圾回收（GC） vs. 手动内存管理</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Java</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>内存管理方式</td>
<td>自动垃圾回收（GC）</td>
<td>手动管理（<code>new</code>&#x2F;<code>delete</code>或智能指针）</td>
</tr>
<tr>
<td>内存泄漏风险</td>
<td>较低（GC自动回收不可达对象）</td>
<td>较高（需手动释放，易遗漏或重复删除）</td>
</tr>
<tr>
<td>回收算法</td>
<td>分代收集（Young&#x2F;Old区）、标记-清除、G1等</td>
<td>无内置GC，需手动实现或依赖第三方库（如Boehm GC）</td>
</tr>
<tr>
<td>性能影响</td>
<td>GC可能导致STW（Stop-The-World）暂停</td>
<td>无GC开销，但手动管理可能引入性能问题</td>
</tr>
<tr>
<td>典型工具</td>
<td>JVM参数调优（<code>-Xms</code>, <code>-Xmx</code>）、VisualVM</td>
<td>Valgrind（检测内存泄漏）、智能指针（<code>shared_ptr</code>）</td>
</tr>
</tbody></table>
<p>关键区别：<br>• Java的GC自动处理对象生命周期，而C++依赖程序员手动控制（或通过RAII模式）。  </p>
<p>• Java的GC算法针对不同对象生命周期优化（如分代假设），C++无此机制。</p>
<h3 id="2-内存模型（堆-栈）"><a href="#2-内存模型（堆-栈）" class="headerlink" title="2. 内存模型（堆&#x2F;栈）"></a>2. 内存模型（堆&#x2F;栈）</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Java</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>对象存储位置</td>
<td>所有对象在堆上（栈仅存基本类型和引用）</td>
<td>对象可分配在堆（<code>new</code>）或栈（局部变量）</td>
</tr>
<tr>
<td>栈分配效率</td>
<td>栈仅存基本类型（如<code>int</code>）和对象引用</td>
<td>栈可存完整对象，访问更快（无堆分配开销）</td>
</tr>
<tr>
<td>堆内存释放</td>
<td>由GC自动回收</td>
<td>需手动<code>delete</code>或依赖作用域结束（栈对象）</td>
</tr>
<tr>
<td>内存碎片问题</td>
<td>GC会整理内存（如CMS的压缩阶段）</td>
<td>需手动处理（如自定义内存池）</td>
</tr>
</tbody></table>
<p>示例代码对比：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java：对象只能在堆上</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// obj是引用，存储在栈；Object实例在堆</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++：对象可在栈或堆上</span></span><br><span class="line">Object obj_stack;          <span class="comment">// 对象在栈上（自动析构）</span></span><br><span class="line">Object* obj_heap = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 对象在堆上（需手动delete）</span></span><br></pre></td></tr></table></figure>

<p>关键区别：<br>• Java强制对象分配在堆上（栈仅存引用），C++允许灵活选择。  </p>
<p>• C++栈对象生命周期与作用域绑定，Java需依赖GC。</p>
<h3 id="3-类加载机制-vs-编译链接"><a href="#3-类加载机制-vs-编译链接" class="headerlink" title="3. 类加载机制 vs. 编译链接"></a>3. 类加载机制 vs. 编译链接</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Java</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>代码加载时机</td>
<td>运行时动态加载（按需由ClassLoader加载）</td>
<td>编译时静态链接（所有符号在编译期解析）</td>
</tr>
<tr>
<td>动态性</td>
<td>支持运行时反射、动态代理等</td>
<td>无原生反射，需额外库（如RTTI）</td>
</tr>
<tr>
<td>类初始化顺序</td>
<td>严格规范（静态块、父类优先）</td>
<td>依赖编译顺序，无明确规范</td>
</tr>
<tr>
<td>依赖管理</td>
<td>通过ClassPath&#x2F;Jar包隔离</td>
<td>通过头文件（<code>.h</code>）和库文件（<code>.so</code>&#x2F;<code>.dll</code>）</td>
</tr>
</tbody></table>
<p>Java类加载流程：  </p>
<ol>
<li>加载：查找字节码（<code>.class</code>文件）→ 生成<code>Class</code>对象。  </li>
<li>验证：检查字节码安全性。  </li>
<li>准备：分配静态变量内存（默认值）。  </li>
<li>解析：将符号引用转为直接引用。  </li>
<li>初始化：执行静态代码块和赋值。</li>
</ol>
<p>C++编译流程：  </p>
<ol>
<li>预处理 → 编译 → 汇编 → 链接（静态&#x2F;动态）。</li>
</ol>
<p>关键区别：<br>• Java的类加载是运行时行为，支持动态特性（如热部署）；C++在编译时完成链接，更静态。  </p>
<p>• Java通过ClassLoader实现隔离（如Tomcat的多Web应用），C++需手动管理符号冲突。</p>
<h3 id="4-其他重要区别"><a href="#4-其他重要区别" class="headerlink" title="4. 其他重要区别"></a>4. 其他重要区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>Java</th>
<th>C++</th>
</tr>
</thead>
<tbody><tr>
<td>指针与引用</td>
<td>无显式指针，只有引用（安全）</td>
<td>支持指针和引用（灵活但危险）</td>
</tr>
<tr>
<td>多继承</td>
<td>不支持（通过接口<code>interface</code>模拟）</td>
<td>支持多继承（菱形继承问题需虚继承解决）</td>
</tr>
<tr>
<td>运行时类型</td>
<td>反射API完整（<code>Class</code>对象、方法调用等）</td>
<td>有限RTTI（<code>typeid</code>、<code>dynamic_cast</code>）</td>
</tr>
</tbody></table>
<h2 id="Java反射的原理"><a href="#Java反射的原理" class="headerlink" title="Java反射的原理"></a>Java反射的原理</h2><p>Java的反射（Reflection）和C++的类似功能实现有本质区别，主要源于两者在运行时类型信息（RTTI）和语言设计哲学上的差异。以下是详细对比和原理分析：</p>
<hr>
<p><strong>一、Java反射的原理</strong><br><strong>1. 核心机制</strong><br>• Class对象：每个加载的类在JVM中都有一个唯一的<code>Class</code>对象，存储类的元数据（字段、方法、构造器等）。</p>
<p>• 动态访问：通过<code>Class</code>对象，可以在运行时获取并操作类的成员，无需在编译时知道具体类结构。</p>
<p>• 关键类库：</p>
<p>  • <code>Class&lt;T&gt;</code>：表示类的元数据。</p>
<p>  • <code>Field</code>：类的字段（包括私有字段）。</p>
<p>  • <code>Method</code>：类的方法。</p>
<p>  • <code>Constructor</code>：类的构造器。</p>
<p><strong>2. 实现原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：通过反射调用String的substring方法</span></span><br><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(<span class="string">&quot;Hello World&quot;</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
<p>• 步骤解析：</p>
<ol>
<li>类加载：JVM的类加载子系统加载目标类（如<code>String</code>），生成<code>Class</code>对象。 <strong>因为Java的每一个类的类名都是唯一的，所以可以通过类名来获取Class对象。</strong></li>
<li>元数据提取：通过<code>Class</code>对象的方法（如<code>getMethod()</code>）从方法区中查找元数据。</li>
<li>动态调用：<code>Method.invoke()</code>通过JNI（Java Native Interface）或JVM内部方法触发实际调用。</li>
</ol>
<p><strong>3. 底层支持</strong><br>• 方法区：存储类的元数据（JVM规范中的“类数据”部分）。</p>
<p>• JVM指令：</p>
<p>  • <code>invokevirtual</code>：普通方法调用。</p>
<p>  • <code>invokespecial</code>：构造器&#x2F;私有方法调用。</p>
<p>  • <code>invokeinterface</code>：接口方法调用。</p>
<p>  • <code>invokedynamic</code>：动态语言支持（如Lambda表达式）。</p>
<p><strong>4. 性能开销</strong><br>• 原因：</p>
<p>  • 运行时解析方法&#x2F;字段（跳过编译期优化）。</p>
<p>  • 安全检查（如私有方法访问权限）。</p>
<p>• 优化手段：</p>
<p>  • 缓存<code>Class</code>&#x2F;<code>Method</code>对象。</p>
<p>  • 使用<code>MethodHandle</code>（JSR 292，类似C++的函数指针）。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>这里通过一个必须使用反射的典型场景——动态加载并调用未知类的私有方法，结合代码示例详细说明：</p>
<hr>
<p><strong>场景描述</strong><br>假设你正在开发一个插件系统，需要加载第三方开发的插件类（编译时无法获知具体实现），并调用其私有初始化方法 <code>init()</code>。<br>由于以下限制，必须使用反射：  </p>
<ol>
<li>插件类名和方法名仅在运行时通过配置文件获取（编译时无法确定）。  </li>
<li>目标方法是<code>private</code>的，常规调用无法访问。</li>
</ol>
<hr>
<p><strong>示例代码</strong><br><strong>1. 插件类（第三方提供，编译时未知）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三方插件（实际开发中可能是动态加载的jar包中的类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecretPlugin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; <span class="comment">// 私有方法，常规方式无法调用</span></span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&quot;ACTIVE&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;插件已秘密初始化，状态：&quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 主程序（通过反射强制调用私有方法）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 动态获取插件类名（例如从配置文件中读取）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pluginClassName</span> <span class="operator">=</span> <span class="string">&quot;SecretPlugin&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反射加载类（编译时无法知道SecretPlugin的存在）</span></span><br><span class="line">        Class&lt;?&gt; pluginClass = Class.forName(pluginClassName);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">pluginInstance</span> <span class="operator">=</span> pluginClass.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 反射获取私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">initMethod</span> <span class="operator">=</span> pluginClass.getDeclaredMethod(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 突破私有限制！</span></span><br><span class="line">        initMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// 关键操作：关闭访问检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 调用私有方法</span></span><br><span class="line">        initMethod.invoke(pluginInstance); <span class="comment">// 输出：插件已秘密初始化，状态：ACTIVE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>为什么必须用反射？</strong></p>
<table>
<thead>
<tr>
<th>限制条件</th>
<th>常规Java代码</th>
<th>反射的解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>类名在编译时未知</td>
<td>无法直接<code>new SecretPlugin()</code></td>
<td><code>Class.forName()</code>动态加载</td>
</tr>
<tr>
<td>方法是<code>private</code>的</td>
<td>无法通过对象调用<code>plugin.init()</code></td>
<td><code>getDeclaredMethod()</code> + <code>setAccessible(true)</code></td>
</tr>
<tr>
<td>方法签名可能变化</td>
<td>硬编码调用会导致编译错误</td>
<td>通过字符串名称获取方法，灵活适应变化</td>
</tr>
</tbody></table>
<hr>
<p><strong>关键反射API解析</strong></p>
<ol>
<li><p><code>Class.forName(String)</code><br>• 动态加载类，完全通过字符串类名操作。  </p>
<p>• <em>类似场景</em>：JDBC驱动加载（如<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）。</p>
</li>
<li><p><code>getDeclaredMethod(String)</code><br>• 获取类声明的任意方法（包括私有方法），而<code>getMethod()</code>只能获取公共方法。</p>
</li>
<li><p><code>setAccessible(true)</code><br>• 关闭Java的访问控制检查，突破<code>private</code>&#x2F;<code>protected</code>限制。  </p>
<p>• <em>警告</em>：滥用会破坏封装性，应谨慎使用！</p>
</li>
<li><p><code>Method.invoke(Object)</code><br>• 动态调用方法，第一个参数是方法所属对象实例。</p>
</li>
</ol>
<hr>
<p><strong>实际应用场景</strong></p>
<ol>
<li><p>框架开发<br>• Spring：通过反射注入<code>@Autowired</code>依赖，调用<code>@PostConstruct</code>方法。  </p>
<p>• JUnit：发现并运行测试方法（标记<code>@Test</code>的方法名在编译时未知）。</p>
<p><img src="/../imgs/image-91.png"></p>
</li>
<li><p>动态代理<br>• <code>InvocationHandler</code>内部用反射调用目标方法。</p>
</li>
<li><p>序列化&#x2F;反序列化<br>• Jackson&#x2F;GSON通过反射访问私有字段将JSON转为对象。</p>
</li>
</ol>
<h2 id="使用-Autowired注解和手动创建的区别"><a href="#使用-Autowired注解和手动创建的区别" class="headerlink" title="使用@Autowired注解和手动创建的区别"></a>使用@Autowired注解和手动创建的区别</h2><p>在Spring框架中，使用<code>@Autowired</code>自动注入依赖和手动创建（如<code>new</code>关键字）有显著区别，主要体现在对象生命周期管理、代码耦合度和扩展性等方面。以下是详细对比：</p>
<hr>
<p><strong>1. 核心区别对比</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>使用<code>@Autowired</code></th>
<th>手动创建（<code>new</code>）</th>
</tr>
</thead>
<tbody><tr>
<td>控制权</td>
<td>Spring容器管理对象的创建、依赖注入和生命周期</td>
<td>开发者手动控制</td>
</tr>
<tr>
<td>耦合度</td>
<td>低（依赖接口而非具体实现）</td>
<td>高（直接依赖具体类）</td>
</tr>
<tr>
<td>单例管理</td>
<td>默认单例（共享实例）</td>
<td>每次<code>new</code>生成独立实例</td>
</tr>
<tr>
<td>依赖注入</td>
<td>自动解析并注入嵌套依赖（如A依赖B，B依赖C）</td>
<td>需手动逐层创建依赖链</td>
</tr>
<tr>
<td>扩展性</td>
<td>轻松替换实现（如通过<code>@Primary</code>或<code>@Qualifier</code>）</td>
<td>需修改代码重新编译</td>
</tr>
<tr>
<td>测试友好性</td>
<td>方便Mock依赖（如<code>@MockBean</code>）</td>
<td>需手动构造测试环境</td>
</tr>
<tr>
<td>AOP支持</td>
<td>自动代理（事务、日志等切面生效）</td>
<td>手动创建的对象无法被Spring AOP增强</td>
</tr>
</tbody></table>
<hr>
<p><strong>2. 代码示例对比</strong><br><strong>场景</strong>：订单服务（<code>OrderService</code>）依赖支付服务（<code>PaymentService</code>）</p>
<p><strong>方案1：使用<code>@Autowired</code>（推荐）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 由Spring注入</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方案2：手动创建（不推荐）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手动创建依赖（高耦合）</span></span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 关键差异解析</strong><br><strong>(1) 对象生命周期管理</strong><br>• <code>@Autowired</code>：  </p>
<p>  • Spring容器统一管理Bean，默认单例模式（整个应用共享一个<code>PaymentService</code>实例）。  </p>
<p>  • 可通过<code>@Scope(&quot;prototype&quot;)</code>改为多例。  </p>
<p>• 手动创建：  </p>
<p>  • 每次<code>new</code>都会生成新实例，生命周期由开发者控制，容易导致内存泄漏或资源浪费。</p>
<p><strong>(2) 依赖解耦</strong><br>• <code>@Autowired</code>：  </p>
<p>  • <code>OrderService</code>仅依赖<code>PaymentService</code>的接口（如果提取了接口），后续替换实现（如<code>AlipayService</code>替换<code>PaymentService</code>）无需修改<code>OrderService</code>代码。  </p>
<p>• 手动创建：  </p>
<p>  • <code>OrderService</code>直接绑定<code>PaymentService</code>的具体实现，变更实现需修改源代码并重新编译。</p>
<p><strong>(3) 复杂依赖链处理</strong><br>假设依赖链：<code>OrderService → PaymentService → FraudDetectionService</code><br>• <code>@Autowired</code>：  </p>
<p>  Spring自动完成整个依赖链的注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FraudDetectionService fraudDetectionService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 手动创建：  </p>
<p>  需手动逐层构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>(<span class="keyword">new</span> <span class="title class_">FraudDetectionService</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4) AOP与代理支持</strong><br>• <code>@Autowired</code>：  </p>
<p>  • 若<code>PaymentService</code>有<code>@Transactional</code>注解，Spring会自动生成代理对象实现事务管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; <span class="comment">/* 事务生效 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 手动创建：  </p>
<p>  • <code>new PaymentService()</code>的对象不会被代理，事务、日志等AOP功能全部失效。</p>
<hr>
<p><strong>4. 何时选择手动创建？</strong><br>尽管<code>@Autowired</code>是推荐做法，但在以下场景可能需要手动创建：  </p>
<ol>
<li>不可控的第三方类：某些库需要手动实例化（如<code>new Gson()</code>）。  </li>
<li>性能敏感代码：避免Spring代理开销（但99%的场景无需考虑）。  </li>
<li>单元测试：测试中可能需要手动构造对象（但Spring也提供<code>@TestConfiguration</code>）。</li>
</ol>
<hr>
<p><strong>5. 常见误区</strong><br><strong>误区1：<code>@Autowired</code>等于<code>new</code>？</strong><br>• 错误认知：认为<code>@Autowired</code>只是“自动帮你写<code>new</code>”。  </p>
<p>• 真相：<code>@Autowired</code>是依赖注入（DI），强调控制反转（IoC），容器负责管理对象及其依赖关系。</p>
<p><strong>误区2：手动创建更简单？</strong><br>• 短期看：手动创建似乎更直接。  </p>
<p>• 长期看：随着项目复杂化，手动管理依赖会变成灾难（如修改依赖需全局搜索<code>new</code>语句）。</p>
<hr>
<p><strong>6. 最佳实践</strong></p>
<ol>
<li>始终优先使用<code>@Autowired</code>：<br>让Spring管理依赖，享受单例、AOP、易于测试等优势。  </li>
<li>面向接口编程：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentGateway paymentGateway; <span class="comment">// 依赖接口而非具体类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>必要时配合<code>@Bean</code>：<br>在配置类中手动定义Bean（仍由Spring管理）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaymentService <span class="title function_">paymentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaymentService</span>(customConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用-Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新"><a href="#使用-Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新" class="headerlink" title="使用@Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新"></a>使用@Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新</h3><p>是的，如果Bean是单例（默认）且状态可变，修改其字段会影响所有依赖该Bean的地方。这是Spring单例模式的核心特性，需要根据业务场景谨慎设计。以下是详细分析和解决方案：</p>
<hr>
<p><strong>1. 问题复现：单例Bean的字段共享</strong><br><strong>示例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 默认单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 可变字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入单例Human</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入同一个单例Human</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>操作后的影响</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">personServiceA.getHuman().setAge(<span class="number">30</span>); </span><br><span class="line">System.out.println(personServiceB.getHuman().getAge()); <span class="comment">// 输出30！所有注入的地方同步修改</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 解决方案（根据场景选择）</strong></p>
<p><strong>方案1：改用原型（Prototype）作用域</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 每次注入新实例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>效果：  </p>
<p>  • 每次<code>@Autowired</code>或<code>getBean()</code>时生成新实例，修改字段互不影响。  </p>
<p>缺点：  </p>
<p>  • 内存开销增大（适合轻量级对象）。  </p>
<p>  • 需确保无循环依赖（原型Bean注入单例Bean需额外配置）。</p>
<p><strong>方案2：使用线程局部变量（ThreadLocal）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; age = ThreadLocal.withInitial(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age.set(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 效果：  </p>
<p>  • 每个线程独立修改<code>age</code>字段（适合Web应用的请求级隔离）。  </p>
<p>• 注意：  </p>
<p>  • 需在请求结束时调用<code>age.remove()</code>防止内存泄漏（可通过拦截器实现）。</p>
<p><strong>方案3：无状态设计（最佳实践）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 不存储可变状态，仅提供方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateRetirementAge</span><span class="params">(<span class="type">int</span> currentAge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentAge + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：  </p>
<p>  • 所有方法参数由调用方传入，Bean本身无字段。  </p>
<p>  • 彻底避免线程安全问题，适合工具类。</p>
<p><strong>方案4：动态获取Bean（手动控制生命周期）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context; <span class="comment">// 注入Spring上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> context.getBean(Human.class); <span class="comment">// 每次获取新实例（需配合@Scope(&quot;prototype&quot;)）</span></span><br><span class="line">        human.setAge(<span class="number">30</span>); <span class="comment">// 不影响其他Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适用场景：  </p>
<p>  • 需要精细控制Bean生命周期的特殊逻辑。</p>
<p><strong>3. 不同场景的推荐策略</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>配置类（如数据库连接参数）</td>
<td>单例 + 不可变字段</td>
<td>配置通常全局一致，启动后不应修改</td>
</tr>
<tr>
<td>用户会话信息（如购物车）</td>
<td>原型作用域或Request作用域</td>
<td>每个用户需要独立实例</td>
</tr>
<tr>
<td>工具类（如日期计算）</td>
<td>单例 + 无状态</td>
<td>无需存储状态，线程安全</td>
</tr>
<tr>
<td>缓存管理</td>
<td>单例 + ConcurrentHashMap</td>
<td>共享缓存数据，但需线程安全容器</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 关键注意事项</strong></p>
<ol>
<li><p>不要滥用单例：<br>• 单例Bean应尽量设计为无状态或只读状态（如<code>@Service</code>、<code>@Repository</code>）。  </p>
<p>• 可变状态单例Bean是线程安全的大敌（除非用同步锁或并发容器）。</p>
</li>
<li><p>慎用<code>@Scope(&quot;prototype&quot;)</code>：<br>• 原型Bean注入单例Bean时，需配合<code>@Lookup</code>或<code>ObjectProvider</code>：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonBean</span> &#123;</span><br><span class="line">    <span class="meta">@Lookup</span> <span class="comment">// Spring会动态生成子类覆盖此方法</span></span><br><span class="line">    <span class="keyword">public</span> PrototypeBean <span class="title function_">getPrototypeBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 实际由Spring实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Web应用的作用域：<br>• 使用<code>@RequestScope</code>或<code>@SessionScope</code>替代手动线程隔离：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequestScope</span> <span class="comment">// 每个HTTP请求独立实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="autowired注解和-RequiredArgConstructor的区别"><a href="#autowired注解和-RequiredArgConstructor的区别" class="headerlink" title="@autowired注解和@RequiredArgConstructor的区别"></a>@autowired注解和@RequiredArgConstructor的区别</h2><p><code>@Autowired</code> 和 <code>@RequiredArgsConstructor</code> 都是用于依赖注入的注解，但它们的实现方式、使用场景和底层机制有显著区别。以下是详细对比：</p>
<hr>
<p><strong>1. 核心区别总结</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>@Autowired</code> (Spring原生)</th>
<th><code>@RequiredArgsConstructor</code> (Lombok)</th>
</tr>
</thead>
<tbody><tr>
<td>所属框架</td>
<td>Spring 原生注解</td>
<td>Lombok 生成的代码（编译时生效）</td>
</tr>
<tr>
<td>注入方式</td>
<td>反射（运行时通过字段或构造器注入）</td>
<td>编译时生成全参构造器（基于final或<code>@NonNull</code>字段）</td>
</tr>
<tr>
<td>代码可见性</td>
<td>显式出现在代码中</td>
<td>编译后生成实际代码（开发时不可见）</td>
</tr>
<tr>
<td>灵活性</td>
<td>支持字段、构造器、Setter注入</td>
<td>仅支持构造器注入</td>
</tr>
<tr>
<td>依赖范围</td>
<td>必须引入Spring</td>
<td>需引入Lombok（不依赖Spring）</td>
</tr>
<tr>
<td>适用场景</td>
<td>需要动态代理或复杂注入逻辑时</td>
<td>追求代码简洁、减少样板代码</td>
</tr>
</tbody></table>
<hr>
<p><strong>2. 使用示例对比</strong><br><strong>场景</strong>：一个服务类依赖两个组件</p>
<p><strong>方案1：<code>@Autowired</code>（字段注入）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 字段注入（反射直接赋值）</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 特点：  </p>
<p>  • 代码简洁，但违反了”不可变对象”原则（字段可被反射修改）。  </p>
<p>  • 依赖Spring容器运行时通过反射注入。</p>
<p><strong>方案2：<code>@Autowired</code>（构造器注入）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 构造器注入（Spring推荐方式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">        <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 特点：  </p>
<p>  • 明确依赖关系，支持不可变对象（final字段）。  </p>
<p>  • Spring 4.3+ 可省略<code>@Autowired</code>（单一构造器时自动注入）。</p>
<p><strong>方案3：<code>@RequiredArgsConstructor</code>（Lombok）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  <span class="comment">// 自动生成final字段的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译后等效于方案2的构造器注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• 特点：  </p>
<p>  • 代码最简洁，Lombok在编译时生成完整构造器。  </p>
<p>  • 需要字段标记为<code>final</code>或添加<code>@NonNull</code>注解。  </p>
<p>  • 不依赖Spring（也可用于非Spring项目）。</p>
<hr>
<p><strong>3. 关键差异解析</strong><br><strong>(1) 实现原理</strong><br>• <code>@Autowired</code>：  </p>
<p>  • 运行时通过反射或代理注入依赖，Spring容器负责查找并赋值。  </p>
<p>  • 支持三种注入方式：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 字段注入（不推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Setter注入</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123; <span class="built_in">this</span>.a = a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构造器注入（推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(A a)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>• <code>@RequiredArgsConstructor</code>：  </p>
<p>  • 编译时由Lombok生成包含所有<code>final</code>&#x2F;<code>@NonNull</code>字段的构造器。  </p>
<p>  • 生成的代码示例：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后实际代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">    <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) 依赖验证</strong><br>• <code>@Autowired</code>：  </p>
<p>  • 默认要求依赖必须存在（可通过<code>@Autowired(required=false)</code>设为可选）。  </p>
<p>  • 启动时如果依赖缺失，抛出<code>BeanCreationException</code>。</p>
<p>• <code>@RequiredArgsConstructor</code>：  </p>
<p>  • 依赖的校验基于<code>final</code>或<code>@NonNull</code>：  </p>
<pre><code>◦ 如果字段有`@NonNull`且依赖为null，抛出`NullPointerException`。  

◦ 非final字段不包含在生成构造器中。
</code></pre>
<p><strong>(3) 与Spring的整合</strong></p>
<table>
<thead>
<tr>
<th>行为</th>
<th><code>@Autowired</code></th>
<th><code>@RequiredArgsConstructor</code></th>
</tr>
</thead>
<tbody><tr>
<td>AOP代理</td>
<td>支持（如<code>@Transactional</code>生效）</td>
<td>支持（生成的构造器能被Spring处理）</td>
</tr>
<tr>
<td>循环依赖</td>
<td>支持（通过三级缓存）</td>
<td>支持（同构造器注入）</td>
</tr>
<tr>
<td>Qualifier选择</td>
<td>支持（<code>@Qualifier</code>指定Bean）</td>
<td>需手动在字段添加<code>@Qualifier</code></td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 如何选择？</strong><br><strong>优先使用 <code>@RequiredArgsConstructor</code> 当：</strong><br>• 项目已引入Lombok。  </p>
<p>• 追求代码简洁性，减少样板代码。  </p>
<p>• 需要不可变对象（final字段）。  </p>
<p><strong>优先使用 <code>@Autowired</code> 当：</strong><br>• 需要非final字段注入。  </p>
<p>• 需要Setter注入或字段注入（尽管不推荐）。  </p>
<p>• 需要动态条件注入（如<code>@Autowired(required=false)</code>）。  </p>
<p><strong>最佳实践组合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;  <span class="comment">// 必须的依赖</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span>  <span class="comment">// 可选的依赖</span></span><br><span class="line">    <span class="keyword">private</span> DiscountService discountService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>5. 常见问题</strong><br><strong>Q1: 两者能混用吗？</strong><br>• 可以，但通常没必要。例如：  </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 额外注入非final依赖</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Q2: Lombok和Spring谁先执行？</strong><br>• Lombok在编译时生成代码，Spring在运行时处理注解。顺序：  </p>
<p>  Lombok生成代码 → 编译 → Spring扫描注解。</p>
<p><strong>Q3: 为什么IDEA提示<code>@Autowired</code>警告？</strong><br>• 现代IDE推荐构造器注入（明确依赖+不可变），而<code>@Autowired</code>字段注入隐藏了依赖关系。使用<code>@RequiredArgsConstructor</code>可避免此警告。</p>
<hr>
<p><strong>总结</strong><br>• <code>@Autowired</code>：Spring原生的灵活注入方式，适合复杂场景。  </p>
<p>• <code>@RequiredArgsConstructor</code>：Lombok的简洁方案，适合追求代码整洁和不可变性。  </p>
<p>• 推荐：在新项目中优先使用<code>@RequiredArgsConstructor</code>，保持代码简洁且线程安全。</p>
<h2 id="Java中的构造器注入和C-中的组合有什么区别？"><a href="#Java中的构造器注入和C-中的组合有什么区别？" class="headerlink" title="Java中的构造器注入和C++中的组合有什么区别？"></a>Java中的构造器注入和C++中的组合有什么区别？</h2><p>你提到了一个非常关键的问题！其实在 现代Spring（尤其是Spring 4.3+版本）中，构造器注入的<code>@Autowired</code>注解是可以省略的，这正是为了减少代码的冗余，让它更接近“纯Java”的风格（类似C++的组合）。下面分几个层面解释：</p>
<hr>
<p><strong>1. 为什么早期需要<code>@Autowired</code>？</strong><br>在Spring 4.3之前，如果类有多个构造器，Spring不知道应该用哪个构造器来注入依赖，必须用<code>@Autowired</code>明确标注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 告诉Spring用这个构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123; <span class="comment">/* Spring不会用这个无参构造器 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2. 现代Spring的改进（省略<code>@Autowired</code>）</strong><br>从 Spring 4.3 开始，如果类只有一个构造器，Spring会自动选择它进行依赖注入，无需<code>@Autowired</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 4.3+ 可以省略@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动被Spring用于依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，代码看起来和C++的组合（Composition）几乎一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++的依赖注入（手动组合）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService paymentService) </span><br><span class="line">        : <span class="built_in">paymentService</span>(paymentService) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 和C++组合的核心区别</strong><br>虽然语法相似，但Spring的构造器注入和C++手动组合有本质区别：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Spring构造器注入</th>
<th>C++手动组合</th>
</tr>
</thead>
<tbody><tr>
<td>对象创建权</td>
<td>Spring容器负责实例化并注入依赖</td>
<td>开发者手动<code>new</code>依赖对象</td>
</tr>
<tr>
<td>依赖解析</td>
<td>Spring自动查找匹配的Bean（按类型&#x2F;名称）</td>
<td>需手动构造依赖链（如<code>new PaymentService()</code>）</td>
</tr>
<tr>
<td>单例管理</td>
<td>默认单例（共享实例）</td>
<td>每次<code>new</code>生成独立实例</td>
</tr>
<tr>
<td>动态代理</td>
<td>支持AOP（如<code>@Transactional</code>生效）</td>
<td>无原生支持</td>
</tr>
<tr>
<td>测试友好性</td>
<td>可轻松替换为Mock（Spring测试支持）</td>
<td>需手动替换依赖</td>
</tr>
</tbody></table>
<hr>
<p><strong>4. 为什么Spring仍然比C++组合强大？</strong></p>
<p><strong>(1) 自动依赖解析</strong><br>• Spring：  </p>
<p>  若<code>PaymentService</code>本身依赖其他Bean（如<code>@Repository</code>），Spring会自动递归解决整个依赖树。<br>• C++：  </p>
<p>  需手动构造所有嵌套依赖：<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动管理依赖链</span></span><br><span class="line">Database db = <span class="keyword">new</span> <span class="built_in">Database</span>();</span><br><span class="line">Logger logger = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">PaymentService ps = <span class="keyword">new</span> <span class="built_in">PaymentService</span>(db, logger);</span><br><span class="line">OrderService os = <span class="keyword">new</span> <span class="built_in">OrderService</span>(ps);</span><br></pre></td></tr></table></figure></p>
<p><strong>(2) 动态扩展能力</strong><br>• Spring：  </p>
<p>  通过<code>@Profile</code>、<code>@Conditional</code>等动态选择实现类，无需修改代码：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span> <span class="comment">// 仅在开发环境生效</span></span><br><span class="line"><span class="keyword">public</span> PaymentService <span class="title function_">mockPaymentService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockPaymentService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• C++：  </p>
<p>  需通过预编译宏或工厂模式硬编码：<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV</span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">MockPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">RealPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>(3) 解耦与测试</strong><br>Spring：  </p>
<p>  单元测试时可直接注入Mock对象：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PaymentService</span> <span class="variable">mockPs</span> <span class="operator">=</span> Mockito.mock(PaymentService.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockPs); <span class="comment">// 不依赖Spring容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++：  </p>
<p>  需依赖虚接口或模板技巧实现类似效果。</p>
<hr>
<p><strong>5. 什么情况下该用<code>@Autowired</code>？</strong><br>虽然构造器注入可以省略<code>@Autowired</code>，但在以下场景仍需显式标注：</p>
<ol>
<li>多个构造器时：指定哪个构造器用于注入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 明确告诉Spring用这个构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(paymentService, <span class="keyword">new</span> <span class="title class_">DefaultLogger</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService, Logger logger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">        <span class="built_in">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可选依赖：结合<code>@Autowired(required=false)</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span>  <span class="comment">// discountService可选</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, DiscountService ds)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>6. 终极对比：Spring vs C++</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring构造器注入（现代写法）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++手动组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService* paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService* ps) : <span class="built_in">paymentService</span>(ps) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">OrderService</span>() &#123; <span class="keyword">delete</span> paymentService; &#125; <span class="comment">// 需手动管理内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相同点：表面语法相似，都通过构造器传入依赖。  </p>
<p>不同点：  </p>
<p>  • Spring的依赖是容器管理的Bean，C++是原始对象指针。  </p>
<p>  • Spring自动处理依赖链、代理、作用域，C++需手动实现。  </p>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a class="article-share-link" data-url="https://kelinkong.github.io/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" data-id="cma1va0b7000013ogfhfvfoa3" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACvElEQVR42u3aMXIjMQwEQP3/03dVl+pMzYAL20Fv5JJkkc2AoAZ8veLnz7/n/O778/7u+fPvo5zffezBw8PDG009meJXf5+ndf5kMqvzuB+WAA8PD2+Ndy4G+fadDN8Wj/MSf7Dg4eHh/Sgv37iTo3n+v/lYeHh4eL+Nlw+QhAjFsfg76x4eHh5ezJsdec9lIw8s8kP5YtaCh4eH1+26RQPsN/y92N/Dw8PDu+iq55ty2+JqRxzOFg8PD2+BlxyIZwflhNRGGLNwBA8PD2+Dl0931gabXZxKFu5covDw8PC2efm2nnw+n1A7Yn5Mx8PDw9vgtc349rjcHqPbZf3wOh4eHt4C76lhZgVmdhBvAxQ8PDy8bd7s9XyBrqKE+HIDHh4e3jbv5nCcR7T3BSmfQ10D8fDw8EpeHhm0G/cstE2aZEXgi4eHh7fAK/pjF6HtLGLIy8MDiQseHh5ewGsbVHk7/9l217BE4eHh4S3w2hj0/LO/LSdFRlLOBA8PD2+PNwtkb9LiWats1pDDw8PD2+C1kWt7jSAvPMlCz/B4eHh4G7ybCGBWJNqC1B7Kvwxz8fDw8B7i3ZDab3jqlXxx8fDw8J7l5dt6G1IkkWsbbbSLi4eHh7fByyc6u1CVU2/eHQa4eHh4eCNeor/Z+l/xkxeJ4uoDHh4e3hpvFjG0R+r7mLj9Tjw8PLwNXtKen4UCs+N4+53R1QQ8PDy8R3l5uz0/fM9ijpuj+ZczwcPDw/sWXn5QvokV2lLRXvCqfwHg4eHhxbw2Zp193WyKswsNwwcPDw+vnEN78L3vLuXXC5Js4cPoeHh4eGu8fEO/4d3EFrPShYeHh/ezvJvmWQ5LulcrhQEPDw9vjZdv6znjqWX9z+h4eHh4a7y8cdVOIt/c28ITFQk8PDy8Bd7sp/5smPYawc3S4OHh4S3w/gJtvtpPpU9ANwAAAABJRU5ErkJggg==">Share</a><div class="tags"></div><div class="post-nav"><a class="pre" href="/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/">数字人-基础扫盲</a><a class="next" href="/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/">deepseek-v3技术报告学习</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kelinkong.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/logo.jpg"/></a><p>Kelin is a boring girl, but not always.</p><a class="info-icon" href="https://github.com/kelinkong" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Digital-Human/">Digital Human</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Security/">Network-Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating-System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/frontend/">frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/solutions/">solutions</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/CMU15-445/" style="font-size: 15px;">CMU15-445</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/Java-Java%E7%9A%84%E5%AE%B9%E5%99%A8%E5%92%8CC-%E7%9A%84STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94/">Java-Java的容器和C++的STL容器的对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/06/05/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-%E9%9F%B3%E9%A2%91%E6%8E%A8%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/">数字人-Java音视频处理-音频推流失败问题排查</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/05/21/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/">数字人-Java音视频处理-推流和拉流</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/">数字人-基础扫盲</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">Java-基础学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/">deepseek-v3技术报告学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/">DB-图数据库Neo4j</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/">Java-编译相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/">AI-动手学深度学习-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/24/AI-%E5%9F%BA%E4%BA%8Etransformers%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP-%E5%85%A5%E9%97%A8/">AI-基于transformers的自然语言处理(NLP)入门</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Kelin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js?v=1.0.0"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>