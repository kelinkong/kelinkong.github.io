---
title: Java-编译相关
date: 2025-01-09 11:36:18
categories: [Java]
---

## Jvm

### 1. **一次编写，处处运行（Write Once, Run Anywhere）**

* Java 程序被编译成 **字节码（`.class`）**，不是平台相关的机器码。
* 字节码由 **JVM 解释或编译执行**，只要目标机器有 JVM，就能运行。
* 不需要为每个操作系统单独编译！

举例：

```bash
你写了一个 HelloWorld.java
→ 编译得到 HelloWorld.class
→ Windows 装 JVM → 可以跑
→ Linux 装 JVM → 也可以跑
→ Mac 装 JVM → 继续跑
```

### 2. **更强的安全性和隔离性**

* Java 程序运行在 **JVM 沙箱中**，不会直接访问底层内存（不像 C++ 有指针）。
* JVM 会做**字节码校验、安全检查**，减少恶意代码运行风险。

### 3. **跨平台的标准化生态**

* JVM 提供统一的接口和行为定义，开发者不必关心 OS 差异。
* Java 的生态（如 Spring、Hadoop、Spark）可以无缝运行在多种平台上。


### 4. **JIT（即时编译）+ GC（自动内存管理）**

* JVM 运行时会监控热点代码，使用 JIT 将字节码编译为机器码，优化性能。
* 自动垃圾回收（GC）减轻了开发者的负担，减少内存泄漏风险。


| 特性         | Java JVM         | C++ 编译器（g++/clang） |
| ---------- | ---------------- | ------------------ |
| 编译方式       | 源码 → 字节码（跨平台中间码） | 源码 → 机器码（平台绑定）     |
| 平台相关性      | 字节码不平台相关，但 JVM 是 | 编译结果是平台相关          |
| 编译时 vs 运行时 | 编译时平台无关，运行时需 JVM | 编译时决定平台，运行时直接执行    |

JVM 与 C++ 编译器最大不同是：

> JVM 将“平台相关性”推迟到运行时（由 JVM 屏蔽平台差异），而 C++ 是在编译时就决定目标平台。

所以只需要：

* 一次写 Java 程序 + 编译成 `.class`
* 每个平台装对应的 JVM，就能**不重编译地运行**

但 C++：

* 写完程序，如果要在不同平台运行，就要用不同的编译器重新编译成不同平台的机器码。

**那 JVM 不就是额外多装一个运行环境？很麻烦？**

是的，这是它的“成本”。但：

* Java 项目往往是“部署一次、跑在任意云环境或服务器上”
* JVM 可以预装在环境中，运行效率也越来越高（GraalVM、ZGC、JIT等）

## Java的即时编译器

Java 的即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中的重要组成部分，它在程序运行时将 Java 字节码 (Bytecode) 转换为本地机器代码，从而提高程序运行效率。以下是关于 JIT 的详细科普：

### 1. **JIT 编译器的作用**
- Java 程序先被编译为字节码，这是一种中间代码，独立于底层硬件和操作系统。
- JVM 通过**解释器 (Interpreter)** 将字节码逐行解释为机器代码执行，但逐行解释速度较慢。
- 为了优化性能，JVM 使用 JIT 将热代码段（执行频率高的代码）直接编译成机器码并缓存起来。之后再运行这些代码时，无需解释，直接执行机器码，极大提高了性能。


### 2. **JIT 的工作原理**
1. **字节码加载**：
   - JVM 通过类加载器加载字节码到内存。
2. **初始执行**：
   - 字节码开始由解释器逐行解释执行。
3. **热点代码检测**：
   - JIT 使用**热点探测技术**（如计数器）来识别频繁执行的代码（如循环体）。
4. **即时编译**：
   - 识别到热点代码后，JIT 将其编译为本地机器代码并优化执行。
5. **缓存与复用**：
   - 已编译的机器代码被缓存起来供后续直接使用。


### 3. **JIT 编译的优化技术**
JIT 编译器除了简单地将字节码翻译为机器码，还会进行多种优化，如：
- **方法内联**：将小方法的代码直接嵌入调用处，减少方法调用的开销。
- **常量折叠**：在编译时计算出常量表达式的结果。
- **循环展开**：减少循环中的控制逻辑，增加运行效率。
- **消除冗余代码**：去掉多余的、不必要的代码执行。
- **逃逸分析**：检测对象是否会逃出方法作用域，从而优化内存分配。


### 4. **JIT 的类型**
JVM 中的 JIT 编译器主要分为以下几种：
1. **C1（Client Compiler）**：
   - 针对客户端应用优化，启动速度快。
   - 适用于需要快速响应的程序。
2. **C2（Server Compiler）**：
   - 针对服务器端应用优化，执行速度更快。
   - 适用于长时间运行、对性能要求高的程序。
3. **Graal JIT**：
   - 新一代 JIT 编译器，基于 Java 实现，优化更为激进。
   - 提供更好的性能和可扩展性。

### 5. **JIT 的优缺点**
#### 优点：
- **高性能**：将热点代码编译为本地机器码，大幅提升执行效率。
- **动态优化**：根据运行时的实际情况进行优化（如分支预测、内存管理）。
- **跨平台性**：结合字节码和本地机器码，既实现跨平台，又提升性能。

#### 缺点：
- **启动延迟**：JIT 编译需要时间，可能导致程序启动较慢。
- **内存占用**：缓存的机器码会占用额外的内存。


### 6. **JIT 和 AOT（Ahead-Of-Time） 编译的对比**
| 特性              | JIT 编译                         | AOT 编译                        |
|-------------------|----------------------------------|----------------------------------|
| 编译时间          | 运行时动态编译                   | 编译前静态完成                  |
| 性能优化          | 基于运行时动态信息进行优化       | 基于编译时静态信息优化          |
| 启动速度          | 启动较慢，需等待编译完成         | 启动较快                        |
| 可移植性          | 字节码跨平台，动态编译本地代码   | 编译后的本地代码与平台绑定      |


### 7. **如何调整 JIT 设置**
JVM 提供了一些参数用于调整 JIT 的行为：
- `-Xint`：强制 JVM 只使用解释模式，禁用 JIT（通常用于调试）。
- `-Xcomp`：强制 JVM 编译所有代码（可能导致启动变慢）。
- `-Xmixed`：默认模式，解释与编译结合使用。


### 8. **常见问题**
- **为什么程序启动时较慢？**
  - 因为 JIT 需要对热点代码进行编译，初期可能依赖解释器运行。
- **JIT 编译会带来性能下降吗？**
  - 在某些情况下（如频繁的代码编译或不适当的优化策略），可能会出现**编译抖动**（过多的编译开销）。

## AOT 编译

JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

### 1. **AOT 编译的基本概念**
AOT 编译将源代码或中间代码（如 Java 字节码）编译为目标平台的机器代码，生成一个独立的、可以直接运行的本地二进制文件。编译后的程序无需依赖运行时解释器，直接运行在目标硬件上。

### 2. **AOT 编译的工作流程**
1. **源代码编写**：
   - 开发者使用高级编程语言（如 Java、C#）。
2. **编译为中间代码**：
   - 像 Java 这样的语言通常会先编译为字节码（例如 `.class` 文件）。
3. **AOT 编译**：
   - AOT 编译器（如 GraalVM 的 AOT 工具）将字节码转换为本地机器代码。
4. **生成可执行文件**：
   - 输出结果是一个可以直接运行的二进制文件，无需额外的运行时编译步骤。

### 3. **AOT 编译的优点**
#### (1) **启动速度快**
- 编译在运行前完成，程序启动时不需要动态解释或即时编译，因此启动速度显著提高。

#### (2) **优化性能**
- AOT 编译可以提前执行许多优化步骤，比如方法内联、循环优化和消除冗余代码。
- 特别适合对启动时间敏感的应用程序，比如微服务或 CLI 工具。

#### (3) **内存占用低**
- 不需要运行时 JIT 编译缓存，因此内存占用更低。
- 适合内存受限的环境，如嵌入式设备和移动应用。

#### (4) **跨语言整合**
- AOT 编译可以方便地将不同语言编写的模块编译成统一的本地代码，便于跨语言调用。

#### (5) **更容易分发**
- 生成的可执行文件独立于编译器或运行时环境，可以轻松分发和部署。

### 4. **AOT 编译的缺点**
#### (1) **灵活性不足**
- AOT 编译缺乏运行时动态优化的能力，无法基于实际运行情况调整性能。
- 某些优化（如分支预测、逃逸分析）需要运行时信息，AOT 无法完成。

#### (2) **编译时间长**
- 编译过程通常比 JIT 更复杂，生成本地代码需要更多时间和资源。

#### (3) **平台绑定**
- AOT 编译生成的可执行文件与目标平台紧密绑定，跨平台能力不如字节码+JVM 的方案。

#### (4) **文件体积大**
- AOT 编译后的可执行文件可能包含额外的运行时支持代码，文件体积较大。


### 5. **AOT 编译的应用场景**
AOT 编译在以下场景中特别有用：
1. **启动速度敏感的应用**：
   - 微服务、命令行工具、图形用户界面（GUI）程序等需要快速启动的应用。
2. **资源受限设备**：
   - 嵌入式系统、物联网设备和移动设备等内存有限的平台。
3. **无运行时环境的环境**：
   - 部署时无法安装完整的虚拟机或运行时（如 JVM）的场景。
4. **安全性要求高的应用**：
   - 直接编译为本地代码可以减少对运行时的依赖，降低潜在的安全风险。
