<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java学习笔记-AOP | Kelin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java学习笔记-AOP</h1><a id="logo" href="/.">Kelin's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java学习笔记-AOP</h1><div class="post-meta">2024-09-30<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.3k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业务逻辑和横切关注点分离开来，提高代码的可维护性和可扩展性。</p>
<p>这里他举了一个例子，例如每个方法都需要统计运行时间，如果不使用AOP，那么每个方法都需要添加统计时间的代码，这样会导致代码冗余，可维护性差。使用AOP，只需要在一个地方添加统计时间的代码，就可以实现所有方法的统计时间。</p>
<p>这个思想和设计模式中的装饰器模式有点类似，都是在不改变原有代码的情况下，添加新的功能。</p>
<p>假设用装饰器模式来实现，应该怎么实现呢？</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式是面向对象的思想</strong>，它允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是继承关系的一个替代方案。</p>
<ol>
<li>定义 Service 接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>原始实现 ServiceImpl：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 原始任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Performing the task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>定义装饰器类 ServiceDecorator：</li>
</ol>
<p>装饰器类实现了 Service 接口，并组合了一个 Service 实例。我们通过组合模式，将对原始对象的调用进行包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service decoratedService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceDecorator</span><span class="params">(Service decoratedService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedService = decoratedService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用装饰器类：</li>
</ol>
<p>现在，可以使用装饰器模式为 ServiceImpl 添加统计运行时间的功能，而无需修改原始 ServiceImpl 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用装饰器包装原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">decoratedService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceDecorator</span>(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法，自动统计运行时间</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用AOP又该怎么实现呢？</p>
<h2 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h2><p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p>
<p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p>
<p>以上是我搜索到的内容，但是“面向切面编程”确实抽象，难以理解。</p>
<p>如果核心是不侵入原始代码去增加一些功能。</p>
<p>那么这里很容易联想到C++中的函数指针、回调函数以及后面出现的Lambda表达式，这些都是在函数调用时，传递的是函数的地址，而不是函数的返回值。这样就可以在函数调用前后，执行一些操作。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>这里都以Lambda表达式为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lambda传递行为</span></span><br><span class="line">        performTask(() -&gt; System.out.println(<span class="string">&quot;Task executed!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">performTask</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者在形式上没有什么很大的区别。</p>
<p>但在实现上还是有一些区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Java AOC</th>
<th>C++ 函数作为参数传入</th>
</tr>
</thead>
<tbody><tr>
<td>传递方式</td>
<td>通过实现接口或继承类创建匿名类实例</td>
<td>通过函数指针、函数对象、lambda 传递函数</td>
</tr>
<tr>
<td>类型要求</td>
<td>必须实现接口或继承类</td>
<td>直接传递函数，使用函数指针或 lambda</td>
</tr>
<tr>
<td>语法简洁性</td>
<td>Java 8 之前语法较冗长，Java 8 后可用 lambda 简化</td>
<td>Lambda 语法较简洁，函数指针较底层</td>
</tr>
<tr>
<td>捕获上下文</td>
<td>只能捕获 final 或 effectively final 变量</td>
<td>可以捕获任意上下文变量，提供闭包特性</td>
</tr>
<tr>
<td>灵活性</td>
<td>必须依赖接口或类</td>
<td>不需要接口，函数指针和 lambda 都可以使用</td>
</tr>
<tr>
<td>性能</td>
<td>由于会生成匿名内部类的实例，可能开销较大</td>
<td>函数指针直接传递，效率更高</td>
</tr>
</tbody></table>
<p><strong>尽管思想上相似，但两者在实现上有所不同：</strong></p>
<ul>
<li><p>Java 更加面向对象。Java 中，匿名内部类和 Lambda 本质上是依赖接口或者类的实现，体现了 Java 面向对象的特性。即便在 Java 8 之后使用 Lambda，依然是函数式接口的简化语法。这意味着 Java 的行为参数化是通过类或接口来进行的。</p>
</li>
<li><p>C++ 更加底层。C++ 允许更直接地操作函数本身，既可以通过函数指针传递行为，也可以通过 Lambda 捕获上下文变量，并将其作为参数传递。这种设计体现了 C++ 语言的灵活性，不需要依赖面向对象的设计。C++ 中的函数传递更接近于函数式编程的思想</p>
</li>
</ul>
<h2 id="使用AOP来实现开头提到的统计时间功能"><a href="#使用AOP来实现开头提到的统计时间功能" class="headerlink" title="使用AOP来实现开头提到的统计时间功能"></a>使用AOP来实现开头提到的统计时间功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声明这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 让 Spring 容器能够管理这个切面。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点：匹配所有在 com.example.service 包下的类和它们的所有方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印方法执行时间</span></span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匹配所有在 <code>com.example.service</code> 包下的类和它们的所有方法，所以当执行 <code>com.example.service</code> 包下的任意方法时，都会执行 <code>logExecutionTime</code> 方法。</p>
<h2 id="AOP的关键术语"><a href="#AOP的关键术语" class="headerlink" title="AOP的关键术语"></a>AOP的关键术语</h2><ul>
<li><strong>切面（Aspect）</strong>：切面是一个类，它包含了一些横切关注点（例如日志记录、事务管理）。在 Spring AOP 中，切面是通过 <code>@Aspect</code> 注解声明的 Java 类。</li>
<li><strong>连接点（Join Point）</strong>：连接点是在应用执行过程中能够插入切面的点。这些点可以是方法的调用、方法的执行、异常的处理等。在 Spring AOP 中，连接点总是表示方法的执行。</li>
<li><strong>通知（Advice）</strong>：通知是切面在特定连接点（Join Point）执行的动作。在 Spring AOP 中，有以下几种类型的通知：<ul>
<li><strong>前置通知（Before Advice）</strong>：在连接点之前执行的通知。</li>
<li><strong>后置通知（After Advice）</strong>：在连接点之后执行的通知，无论连接点是否正常执行。</li>
<li><strong>返回通知（After Returning Advice）</strong>：在连接点正常执行后执行的通知。</li>
<li><strong>异常通知（After Throwing Advice）</strong>：在连接点抛出异常后执行的通知。</li>
<li><strong>环绕通知（Around Advice）</strong>：在连接点之前和之后执行的通知。</li>
</ul>
</li>
<li><strong>切点（Pointcut）</strong>：切点是一个表达式，它定义了哪些连接点应该被通知。在 Spring AOP 中，切点使用 <code>@Pointcut</code> 注解定义。</li>
<li><strong>目标对象（Target Object）</strong>：被一个或多个切面通知的对象。</li>
<li><strong>代理对象（Proxy Object）</strong>：在 Spring AOP 中，代理对象是 Spring 框架创建的对象，它包含了目标对象的增强方法。</li>
<li><strong>织入（Weaving）</strong>：织入是将切面应用到目标对象并创建代理对象的过程。织入可以发生在编译时、类加载时、运行时。</li>
<li><strong>引入（Introduction）</strong>：引入允许向现有的类添加新方法和属性。Spring AOP 不支持引入。</li>
</ul>
<h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们有一个 <code>UserService</code> 类，它有一个 <code>login</code> 方法，登录时我们希望记录这个方法的执行时间。</p>
<ol>
<li>目标对象 (Target Object):<br>这是我们想要增强的对象，也就是 <code>UserService</code> 类中的 <code>login</code> 方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟登录逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging in.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>切面 (Aspect):我们创建一个切面，用于记录方法执行时间的逻辑。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 切点 (Pointcut) - 指定在哪些方法上应用增强逻辑</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allUserServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 通知 (Advice) - 具体的增强逻辑，这里使用环绕通知来记录执行时间</span></span><br><span class="line">    <span class="meta">@Around(&quot;allUserServiceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + executionTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>当我们调用 login 方法时，增强逻辑（记录执行时间）会自动插入：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">userService.login(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;password123&quot;</span>);</span><br></pre></td></tr></table></figure>
输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User Alice is logging in.</span><br><span class="line">void UserService.login(String, String) executed in 50ms</span><br></pre></td></tr></table></figure></li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/">包管理器相关</a><a class="next" href="/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">Java学习笔记-单元测试</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kelinkong.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/logo.jpg"/></a><p>Kelin is a boring girl, but not always.</p><a class="info-icon" href="https://github.com/kelinkong" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CPP/">CPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLVM/">LLVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Security/">Network Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solutions/">Solutions</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/CMU15-445/" style="font-size: 15px;">CMU15-445</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/note/" style="font-size: 15px;">note</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/">包管理器相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/">Java学习笔记-AOP</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">Java学习笔记-单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/">Java学习笔记-组合、继承、接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/">llvm中的temperature</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/23/one-hot%E7%BC%96%E7%A0%81/">one-hot编码</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/23/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/">提示工程</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/">Java学习笔记-开发实战一</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">Java学习笔记-代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/">Java学习笔记-语法基础篇</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Kelin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js?v=1.0.0"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>