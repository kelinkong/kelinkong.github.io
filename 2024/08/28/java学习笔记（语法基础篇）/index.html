<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Java学习笔记-语法基础篇 | Kelin's blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java学习笔记-语法基础篇</h1><a id="logo" href="/.">Kelin's blog</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java学习笔记-语法基础篇</h1><div class="post-meta">2024-08-28<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.4k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 13</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="post-content"><h3 id="扫盲，Java和C-的一些区别"><a href="#扫盲，Java和C-的一些区别" class="headerlink" title="扫盲，Java和C++的一些区别"></a>扫盲，Java和C++的一些区别</h3><p><strong>Java项目需要编译吗？底层编译原理和C++有什么不同？</strong></p>
<ol>
<li>   编译输出：</li>
</ol>
<ul>
<li>Java：编译输出的是平台无关的字节码文件（.class 文件），这些字节码可以在任何安装了 JVM 的平台上运行。</li>
<li>C++：编译输出的是特定平台的机器码文件（如 .exe 文件），这些文件只能在编译时指定的平台上运行。</li>
</ul>
<ol start="2">
<li>   跨平台性：</li>
</ol>
<ul>
<li>Java：通过 JVM 的跨平台特性，Java 程序可以“一次编写，到处运行”（Write Once, Run Anywhere）。</li>
<li>C++：需要为每个平台分别编译代码才能生成可以执行的文件，不具备 Java 那样的跨平台能力。</li>
</ul>
<ol start="3">
<li>   运行时性能：</li>
</ol>
<ul>
<li>Java：由于字节码需要在运行时通过 JVM 翻译为机器码，可能会在启动时稍慢，但 JIT 编译可以在运行期间优化代码，提高性能。</li>
<li>C++：由于是直接编译为机器码，C++ 程序的启动和运行速度通常会比 Java 程序快，尤其是在性能关键的应用中。</li>
</ul>
<ol start="4">
<li>   编译速度：</li>
</ol>
<ul>
<li>Java 编译通常更快，因为编译器只需将代码编译为字节码，而不需要生成机器码。</li>
<li>C++ 编译通常更慢，尤其是在大型项目中，因为编译器需要生成并优化特定平台的机器码。</li>
</ul>
<p><strong>Java编译是否需要再单独安装编译器？</strong></p>
<p>在编写 Java 程序时，不需要单独安装编译器，因为 Java 编译器是包含在 JDK（Java Development Kit）中</p>
<p><strong>JDK包含了什么？</strong></p>
<p>JDK 是 Java 开发的核心工具包，它包含了一整套开发 Java 应用程序所需的工具和库。JDK 的主要组成部分包括：</p>
<ol>
<li>   Java 编译器 (javac)：</li>
</ol>
<ul>
<li>这是用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）的工具。</li>
<li>javac 是 JDK 中最重要的组件之一，负责将人类可读的 Java 代码转换为 JVM 可执行的字节码。</li>
</ul>
<ol start="2">
<li>   Java 运行时环境 (JRE, Java Runtime Environment)：</li>
</ol>
<ul>
<li>JRE 是运行 Java 程序所需的环境，包括 JVM、Java 类库和其他资源。</li>
<li>JRE 包含了 Java 虚拟机（JVM）、核心类库和支持文件，但不包括编译器和调试工具。</li>
<li>JDK 本身包含了一个完整的 JRE，所以在安装 JDK 时也会获得 JRE。</li>
</ul>
<ol start="3">
<li>   Java 虚拟机 (JVM)：</li>
</ol>
<ul>
<li>JVM 是一个平台独立的虚拟机，负责解释和执行编译后的字节码。</li>
<li>JVM 使得 Java 程序可以在任何支持 JVM 的操作系统上运行。</li>
</ul>
<ol start="4">
<li>   核心类库：</li>
</ol>
<ul>
<li>这是 Java 标准库（API），包含了大量的预定义类和接口，用于执行各种常见的编程任务（如数据结构、网络通信、文件操作、并发处理等）。</li>
<li>核心类库是 Java 程序构建的基础，几乎所有 Java 程序都会使用其中的类和方法。</li>
</ul>
<ol start="5">
<li>   开发工具：</li>
</ol>
<ul>
<li>java：用于启动 Java 应用程序的命令行工具，它调用 JVM 来执行字节码。</li>
<li>javadoc：用于生成 Java 代码文档的工具，可以从源码中的注释生成 API 文档。</li>
<li>jdb：Java 调试工具，允许开发者在运行时调试 Java 应用程序。</li>
<li>jar：用于创建和管理 Java Archive（JAR）文件的工具，这些文件通常用于打包 Java 类库和应用程序。</li>
<li>javap：Java 类文件反汇编工具，用于查看编译后的字节码。</li>
</ul>
<ol start="6">
<li>   其他工具：</li>
</ol>
<ul>
<li>javah：用于生成 C 头文件和源文件，支持 JNI（Java Native Interface）。</li>
<li>jarsigner：用于对 JAR 文件进行签名和验证的工具。</li>
</ul>
<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>在Java中，每个源文件都是一个类，类名必须与文件名相同。Java程序的入口是<code>main</code>方法，格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</span></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个源码文件只能包含一个public类型的类。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Java的数据类型分为两大类：基本数据类型和引用数据类型。</p>
<ol>
<li>   基本数据类型：byte、short、int、long、float、double、char、boolean。<strong>基本类型的变量直接存储值。</strong></li>
<li>   引用数据类型：类、接口、数组、String等。<strong>引用类型变量存储的是对象的内存地址（引用）</strong>。</li>
</ol>
<p>引用类型变量通常通过 <code>new</code> 关键字创建对象（但也有例外，比如字符串常量池），而基本类型变量则直接赋值。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java中的字符串是不可变的，即一旦创建，就不能再修改。字符串的比较要使用<code>equals()</code>方法，而不是<code>==</code>运算符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>字符串拼接</strong>：</p>
<ul>
<li>使用<code>+</code>运算符拼接字符串。</li>
<li>使用<code>StringBuilder</code>类进行字符串拼接，它是可变的字符串，效率更高。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(s); <span class="comment">// Hello, Mr Bob!</span></span><br></pre></td></tr></table></figure>

<p>多行字符串可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SELECT * FROM</span></span><br><span class="line"><span class="string">    users</span></span><br><span class="line"><span class="string">    WHERE id = 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>); <span class="comment">// 输出并换行</span></span><br><span class="line">System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 输出不换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// 格式化输出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 导入某个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>在Java的类中，有构造函数，但是没有析构函数。Java的垃圾回收器会自动回收不再使用的对象。</p>
<p><strong>但是Java同样会有内存泄漏的问题，比如静态变量、集合类等。</strong></p>
<p>在Java的类中，也有一个this关键字，表示当前实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用extends关键字实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>在Java中一个子类只能继承一个父类，子类继承后无法访问父类的私有字段和方法，可以将父类的字段和方法设置为<code>protected</code>。</strong></p>
</li>
<li><p>子类不会继承父类的构造方法，但是可以通过<code>super()</code>调用父类的构造方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和C++一样，在Java中可以使用父类的引用指向子类的实例。</li>
<li>Java中的方法可以被子类覆写，使用<code>@Override</code>注解可以让编译器检查是否正确覆写了父类的方法。</li>
<li>在Java中 ，同样存在抽象类，使用<code>abstract</code>关键字修饰，抽象类不能被实例化，只能被继承。<code>abstract class Person &#123;&#125;</code></li>
</ul>
<p><strong>实例化子类时，会调用父类的构造器，Java是单继承，且所有的类都继承于Object类，那么是这条线上的所有父类、祖父类的构造器都会被调用吗？</strong></p>
<blockquote>
<p>是的，在 Java 中，当实例化一个子类时，父类、祖父类乃至更高层次的所有父类的构造函数都会被依次调用，直到根类 Object 的构造函数。这个过程是通过构造函数链实现的。</p>
</blockquote>
<p><strong>在Java中，继承是一棵树，构造函数的调用是从下往上的，即先调用子类的构造函数，再调用父类的构造函数，直到根类的构造函数。</strong></p>
<p><strong>在C++中，继承是一个图。</strong></p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/oop/basic/interface/index.html">接口-参考文献</a></p>
<p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以把该抽象类改写为接口：interface。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个具体的class去实现一个interface时，需要使用implements关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。</p>
<h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>  在定义class的时候，我们需要在第一行声明这个class属于哪个包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example; <span class="comment">// 定义包名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有Java文件对应的目录层次要和包的层次一致。</p>
<h3 id="和C-作对比："><a href="#和C-作对比：" class="headerlink" title="和C++作对比："></a>和C++作对比：</h3><table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">Java</th>
<th align="right">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">常量</td>
<td align="center">final</td>
<td align="right">const</td>
</tr>
<tr>
<td align="center">自动类型推导</td>
<td align="center">var</td>
<td align="right">auto</td>
</tr>
<tr>
<td align="center">空指针</td>
<td align="center">null</td>
<td align="right">nullptr</td>
</tr>
<tr>
<td align="center">字符串</td>
<td align="center">String</td>
<td align="right">std::string</td>
</tr>
<tr>
<td align="center">静态方法</td>
<td align="center">static</td>
<td align="right">static</td>
</tr>
<tr>
<td align="center">继承</td>
<td align="center">extends</td>
<td align="right">: public</td>
</tr>
<tr>
<td align="center">实现</td>
<td align="center">implements</td>
<td align="right">: public</td>
</tr>
<tr>
<td align="center">抽象类</td>
<td align="center">abstract class</td>
<td align="right">class</td>
</tr>
<tr>
<td align="center">接口</td>
<td align="center">interface</td>
<td align="right">class</td>
</tr>
<tr>
<td align="center">包</td>
<td align="center">package</td>
<td align="right">namespace</td>
</tr>
<tr>
<td align="center">异常处理</td>
<td align="center"><a target="_blank" rel="noopener" href="https://liaoxuefeng.com/books/java/exception/java-exception/index.html">try-catch-finally</a></td>
<td align="right">try-catch</td>
</tr>
<tr>
<td align="center">泛型</td>
<td align="center">List&lt;String&gt;</td>
<td align="right">vector&lt;string&gt; 模版</td>
</tr>
</tbody></table>
<h4 id="Java和C-中的STL容器区别"><a href="#Java和C-中的STL容器区别" class="headerlink" title="Java和C++中的STL容器区别"></a>Java和C++中的STL容器区别</h4><table>
<thead>
<tr>
<th align="center">容器</th>
<th align="center">Java</th>
<th align="right">C++</th>
</tr>
</thead>
<tbody><tr>
<td align="center">动态数组</td>
<td align="center">ArrayList</td>
<td align="right">vector</td>
</tr>
<tr>
<td align="center">链表</td>
<td align="center">LinkedList</td>
<td align="right">list</td>
</tr>
<tr>
<td align="center">栈</td>
<td align="center">Stack</td>
<td align="right">stack</td>
</tr>
<tr>
<td align="center">队列</td>
<td align="center">Queue</td>
<td align="right">queue</td>
</tr>
<tr>
<td align="center">双端队列</td>
<td align="center">Deque</td>
<td align="right">deque</td>
</tr>
<tr>
<td align="center">集合</td>
<td align="center">Set</td>
<td align="right">set</td>
</tr>
<tr>
<td align="center">映射</td>
<td align="center">Map</td>
<td align="right">map</td>
</tr>
<tr>
<td align="center">哈希表</td>
<td align="center">HashMap</td>
<td align="right">unordered_map</td>
</tr>
<tr>
<td align="center">哈希集合</td>
<td align="center">HashSet</td>
<td align="right">unordered_set</td>
</tr>
<tr>
<td align="center">优先队列</td>
<td align="center">PriorityQueue</td>
<td align="right">priority_queue</td>
</tr>
</tbody></table>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>Java的反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法。</p>
<p>如果要实现一个通用的对象<code>拷贝</code>方法，就必须要用反射机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        person.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        copyProperties(person, employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Name: &quot;</span> + employee.name); <span class="comment">// 输出: Employee Name: John</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Age: &quot;</span> + employee.age);   <span class="comment">// 输出: Employee Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取源对象的所有字段</span></span><br><span class="line">        Field[] fields = source.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标对象中同名的字段</span></span><br><span class="line">            Field targetField;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetField = target.getClass().getField(field.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果目标对象中没有这个字段，则跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查字段类型是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (targetField.getType().equals(field.getType())) &#123;</span><br><span class="line">                <span class="comment">// 将值设置到目标对象中</span></span><br><span class="line">                targetField.set(target, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ol>
<li>注解的作用</li>
</ol>
<ul>
<li>标注和说明: 注解通常用来标注或说明代码中的某些元素。例如，@Override注解表明一个方法是重写父类或接口的方法，这是一种对代码的说明。</li>
<li>代码行为的调整: 某些注解会影响代码的行为。例如，@Deprecated注解标注某个方法已经过时，编译器会在使用该方法时发出警告。</li>
<li>与框架和工具的集成: 许多框架（如Spring、Hibernate）和工具（如JUnit、编译器）使用注解来配置和控制代码的行为。例如，@Autowired注解用于在Spring中自动注入依赖。</li>
</ul>
<ol start="2">
<li>注解的使用场景</li>
</ol>
<ul>
<li>编译时处理: 注解可以在编译时被处理，例如生成额外的代码、文档，或进行代码校验。例如，@SuppressWarnings注解可以告诉编译器忽略特定的警告。</li>
<li>运行时反射: 注解可以在运行时通过反射机制读取和使用。例如，JUnit在运行时通过反射读取@Test注解来识别哪些方法是测试方法。</li>
<li>框架配置: 许多Java框架通过注解来配置和管理对象的行为，这种配置方式比传统的XML配置更加直观和简洁。</li>
</ul>
<p><strong>Java的注解和Python的装饰器有什么不同？</strong></p>
<ol>
<li>功能与用途：</li>
</ol>
<ul>
<li>Java注解主要用于提供元数据，标记类、方法、字段等。主要用于配置和框架集成，如依赖注入、ORM映射等。</li>
<li>Python装饰器用于动态改变函数或方法的行为，可以在运行时修改代码逻辑，常用于日志记录、权限控制等。</li>
</ul>
<ol start="2">
<li>   实现方式：</li>
</ol>
<ul>
<li>Java注解是静态的，不能直接改变代码逻辑，通过编译器或框架在编译时或运行时处理。</li>
<li>Python装饰器是高阶函数，可以在运行时动态生成、修改或应用，具有更强的灵活性。</li>
</ul>
<ol start="3">
<li>   使用场景：</li>
</ol>
<ul>
<li>Java注解常见于企业级应用中的配置和元数据标注。</li>
<li>Python装饰器用于简化代码、提高复用性，特别是在Web开发和数据处理领域。</li>
</ul>
<p>两者虽然都是用于增强代码的功能性，但Java注解偏向于静态配置，而Python装饰器偏向于动态行为修改。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">Java学习笔记-代码规范</a><a class="next" href="/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/">常见的网络攻击方式</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://kelinkong.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/logo.jpg"/></a><p>Kelin is a boring girl, but not always.</p><a class="info-icon" href="https://github.com/kelinkong" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CPP/">CPP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/DataBase/">DataBase</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Frontend/">Frontend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLVM/">LLVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network-Security/">Network Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Operating-System/">Operating System</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Solutions/">Solutions</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/frontend/">frontend</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/CMU15-445/" style="font-size: 15px;">CMU15-445</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/note/" style="font-size: 15px;">note</a> <a href="/tags/architecture/" style="font-size: 15px;">architecture</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/">Spring Boot：事务处理</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/">Java学习笔记-MyBatis</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/">Spring Boot：全注解下的IoC</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">llvm学习-人工神经网络</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/">llvm-RAG学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/10/%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/">大模型API封装学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/">Java学习笔记-gradle</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Axios学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/">Java学习笔记-JWT</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/">包管理器相关</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">Kelin's blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/love.js?v=1.0.0"></script><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html><!-- 插入 Dify 大模型助手代码--><script>window.difyChatbotConfig = {
  token: '4gcHypq3JpvHcBxt'
}</script><script src="https://udify.app/embed.min.js" id="4gcHypq3JpvHcBxt" defer></script><style>#dify-chatbot-bubble-button {
  background-color: #1C64F2 !important;
  position: fixed !important;
  bottom: 20px !important;
  left: 20px !important;
}
#dify-chatbot-bubble-window {
  width: 24rem !important;
  height: 40rem !important;
  bottom: 70px !important; /* 确保窗口在按钮上方 */
  left: 20px !important;
}</style>