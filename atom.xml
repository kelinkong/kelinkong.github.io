<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-18T01:52:56.085Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的网络攻击方式</title>
    <link href="http://example.com/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2024-04-03T04:54:28.000Z</published>
    <updated>2024-05-18T01:52:56.085Z</updated>
    
    <content type="html"><![CDATA[<p>学习网站：<a href="https://xss-game.appspot.com/level1">https://xss-game.appspot.com/level1</a></p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>XSS（Cross Site Scripting）跨站脚本攻击，是一种代码注入攻击。攻击者在目标网站植入恶意脚本，当用户访问目标网站时，恶意脚本会被执行，从而达到攻击目的。</p><p>假设有一个简单的网页，用于用户输入评论，然后显示在页面上。如果用户输入的内容没有经过过滤，那么用户可以输入一段恶意脚本，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>评论页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>留言板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;post_comment.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交评论&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端代码没有进行恰当的输入过滤和输出转义，导致用户输入的恶意脚本被执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;评论结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;评论结果&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;您的评论是：<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>]; <span class="meta">?&gt;</span>&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当用户输入如下内容时，就会弹出一个对话框：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果尝试在<code>&lt;script&gt;</code>标签中输入恶意代码失败了，那么可以尝试使用带有JavaScript属性的HTML元素来执行XSS攻击。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span></span><br><span class="line">&#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span>&#x27;</span><br><span class="line">0&#x27;); alert(&#x27;XSS&#x27;); //</span><br></pre></td></tr></table></figure><h4 id="XSS攻击的解决措施"><a href="#XSS攻击的解决措施" class="headerlink" title="XSS攻击的解决措施"></a>XSS攻击的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>输出转义：对用户输入的内容进行转义，确保用户输入的内容不会被当做HTML代码执行。</li><li>HTTP头部设置：设置HTTP头部的Content-Security-Policy字段，限制页面加载的资源。</li><li>Cookie设置：设置Cookie的HttpOnly属性，防止JavaScript读取Cookie。</li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF（Cross Site Request Forgery）跨站请求伪造，是一种利用用户已登录的身份，以用户不知情的情况下，完成非法操作的攻击方式。</p><ul><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问断线都具备一定的有效期，比如1天过期，或者几个小时过气，再次期间权限信息会保留在用户浏览器的cookie中，这本例子中假设用户C刚刚登录了网站A，全新还没有过期。</li><li>攻击者利用正常网站A的CSFR漏洞，构造页面一个恶意网页B，在页面中包含对发往正常网站A的请求，在用户C加载页面B（或者点击某些元素时触发）时，会触发攻击请求，完成攻击。</li><li>由于加载恶意页面B和触发攻击请求都是在用户浏览器端完成的，因为之前用户登录过正常网站，发往正常网站的请求会带有用户授权信息（在cookie中），在授权信息没有过期的情况达到攻击目的。</li></ul><h4 id="CSRF攻击的解决措施"><a href="#CSRF攻击的解决措施" class="headerlink" title="CSRF攻击的解决措施"></a>CSRF攻击的解决措施</h4><ul><li>验证来源站点：在服务器端验证请求的来源站点，只允许来自合法站点的请求。</li><li>验证请求内容：在请求中添加验证信息，确保请求是用户自己发起的。</li><li>防止重复提交：使用Token验证，确保请求只能被执行一次。</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是一种利用Web应用程序中的漏洞，通过在用户提交的数据中插入恶意的SQL语句，从而实现非法操作的攻击方式。</p><p>例如：登陆查询的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果用户输入的<code>$username</code>和<code>$password</code>没有经过过滤，那么用户可以输入一段恶意的SQL语句，比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;archer2017&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样就会返回所有用户的信息，因为<code>OR 1=1</code>永远为真。</p><h4 id="SQL注入的解决措施"><a href="#SQL注入的解决措施" class="headerlink" title="SQL注入的解决措施"></a>SQL注入的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>如果不可避免地使用SQL语句进行拼装，可以对用户输入数据进行转义，确保用户输入的内容不会被当做SQL语句执行。</li></ul><h3 id="上传文件漏洞"><a href="#上传文件漏洞" class="headerlink" title="上传文件漏洞"></a>上传文件漏洞</h3><p>上传文件漏洞也是一种常见的web漏洞，攻击者可以用利用服务器端的上传文件漏洞绕过安全验证将代码提交到服务器端，并想办法让代码文件被执行。一单可执行的代码上传成功，会造成比较严重的安全问题，比如获取服务器权限，为攻击者开后门，或者让服务器超载，破快服务器的可用性，甚至是上传病毒，木马。</p><h4 id="上传文件漏洞的解决措施"><a href="#上传文件漏洞的解决措施" class="headerlink" title="上传文件漏洞的解决措施"></a>上传文件漏洞的解决措施</h4><ul><li>限制上传文件类型：限制上传文件的类型，确保只能上传安全的文件。</li><li>将上传文件和应用程序分开存储</li><li>对上传的图片进行重绘</li><li>对上传文件重命名，最好具有一定的随机性，提高攻击成本</li></ul><h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>DDOS（Distributed Denial of Service）分布式拒绝服务攻击，是一种通过大量合法请求，占用服务器资源，导致服务器无法正常提供服务的攻击方式。</p><p>在了解 DDoS 之前，我们需要先知道什么是 DoS。最基本的 DoS 就是利用合理的客户端请求里占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDoS 攻击便是在传统的 DoS 攻击的基础上产生的一类攻击方式。传统的 DoS攻击一般是一对一的方式，当攻击目标的CPU速度、内存或者网络带宽等各项性能指标不高的情况下，它的效果是明显的，但随着计算机与网络技术的发展，计算机的处理能力显著增加，内存不断增大，这便使得 DoS 攻击逐渐失去了效果。</p><h4 id="DDOS分类"><a href="#DDOS分类" class="headerlink" title="DDOS分类"></a>DDOS分类</h4><p><strong>SYN Flood</strong></p><p>SYN Flood就是利用了 TCP 协议三次握手的过程来达到攻击的目的。攻击者伪造大量的 IP 地址给服务器发送 SYN 报文，因为伪造的 IP 地址不可能存在，也就不可能从客户端得到任何响应，就会一直卡在第三步，服务端就得维护一个非常大的半连接等待列表，并且不断对这个列表中的 IP 地址进行遍历重试，占用了大量的系统资源。而由于服务器资源有限，恶意的连接占满了服务器的等待队列，导致服务器不再接收新的 SYN 请求，使正常的用户无法完成通信。</p><p><strong>DNS Query Flood</strong></p><p>DNS Query Flood 攻击采用的方法是向被攻击的服务器发送海量的域名解析请求。而这部分请求解析的域名一般都是随机生成的，大部分不存在，并且通过伪造端口和客户端IP，防止查询请求被 ACL（访问控制列表）过滤。被攻击的 DNS服务器 在收到域名解析的请求后，首先会在自己的服务器上查找是否该域名的 IP，因为域名的不存在，在自身自然是找不到的，因此DNS 服务器便会向上层的 DNS服务器递归查询域名，直到全球互联网的 13台 根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量级的时候，就会造成 DNS服务器 解析域名超时，使正常的域名都查询不到对应的 IP，达到了攻击的效果。</p><p><strong>HTTP&#x2F;CC Flood</strong></p><p>CC攻击的原理是通过控制大量的 “肉鸡” 或者利用从互联网上搜寻的大量匿名的 HTTP 代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过 CDN 以及分布式缓存来加快服务端的响应，提高网站的吞吐量。而这些恶意的 HTTP 请求会有意的避开这些缓存，需要进行多次 DB 查询操作或者一次请求会返回大量的数据，加速系统资源的消耗，从而拖垮后端的业务处理系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习网站：&lt;a href=&quot;https://xss-game.appspot.com/level1&quot;&gt;https://xss-game.appspot.com/level1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Network Security" scheme="http://example.com/categories/Network-Security/"/>
    
    
  </entry>
  
  <entry>
    <title>API-architecture</title>
    <link href="http://example.com/2024/03/31/API-architecture/"/>
    <id>http://example.com/2024/03/31/API-architecture/</id>
    <published>2024-03-31T07:39:41.000Z</published>
    <updated>2024-03-31T08:43:45.368Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<a href="https://www.youtube.com/watch?v=4vLxWqE94l4">Top 6 Most Popular API Architecture Styles</a></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API（Application Programming Interface）是一组定义了软件应用程序之间如何互相通信的规则的接口。API可以让不同的软件应用程序之间共享数据和功能，从而提高开发效率。</p><p>主要是用于不同系统之间的通信，比如前端和后端之间的通信。</p><p>如果没有定义API，那么不同的系统之间就无法通信。</p><h3 id="常用API架构风格"><a href="#常用API架构风格" class="headerlink" title="常用API架构风格"></a>常用API架构风格</h3><p><img src="/../imgs/image-47.png"></p><h3 id="Highlights"><a href="#Highlights" class="headerlink" title="Highlights"></a>Highlights</h3><ul><li>📜 SOAP是一种成熟、全面且基于XML的API架构风格，尤其适用于金融服务和支付网关等需要安全性和可靠性的场景。</li><li>🌐 RESTful APIs是Internet的骨干，易于实现，使用HTTP方法，适用于大多数日常交互的网络服务。</li><li>📊 GraphQL不仅是一种架构风格，还是一种查询语言，能够高效地提供精确的数据，尤其适用于复杂数据需求的应用程序。</li><li>💻 gRPC是现代高性能的API架构风格，适用于微服务架构，但在处理浏览器客户端时可能存在一些挑战。</li><li>🔄 WebSocket是实时、双向且持久连接的API架构风格，适用于实时聊天和实时游戏等场景。</li><li>🎣 Webhook是基于事件驱动的API架构风格，适用于异步操作，但不适合需要同步通信或立即响应的场景。</li></ul><h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful API"></a>restful API</h3><p>Github的API设计规范学习：<a href="https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api?apiVersion=2022-11-28">Github API</a></p><h4 id="rest架构特征"><a href="#rest架构特征" class="headerlink" title="rest架构特征"></a>rest架构特征</h4><ul><li>以资源为基础：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。</li><li>统一接口：对资源的操作包括获取、创建、修改和删除资源，这些操作分别对应HTTP协议中的GET、POST、PUT、DELETE方法。</li><li>无状态：每次请求必须包含所有的信息，服务器不会保存客户端的状态。</li><li>url指向资源：一个url对应一个资源，通过url获取资源。</li></ul><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>参考学习：<a href="https://juejin.cn/post/6844903475420069902">GraphQL</a></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（Remote Procedure Call）是一种协议，用于在不同的进程之间传递数据。RPC协议允许一个程序调用另一个程序的子程序，而不需要了解底层网络细节。</p><p><strong>rpc是一种思想，广义的rpc是包含http的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;a href=&quot;https://www.youtube.com/watch?v=4vLxWqE94l4&quot;&gt;Top 6 Most Popular API Architecture Styles&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot;</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="architecture" scheme="http://example.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（下）</title>
    <link href="http://example.com/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2024-03-07T07:03:28.000Z</published>
    <updated>2024-03-30T12:56:10.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求整理"><a href="#需求整理" class="headerlink" title="需求整理"></a>需求整理</h2><p><strong>popup.html：</strong></p><ul><li>是否开启划词翻译</li><li>选择划词翻译的默认目标语言</li><li>是否开启输入翻译</li><li>输入框翻译的简介</li><li>项目地址</li></ul><p><strong>popup.js</strong></p><ul><li>从popup界面接收信息，如果用户更新设置，就更新存储在浏览器中的值，同时发送消息给content脚本，让其监听</li><li>监听用户是否点击项目地址</li><li>每次点开popup界面都重新从浏览器中加载存储的设置</li></ul><p><strong>content.js</strong></p><ul><li>从浏览器中获取设置</li><li>监听用户的输入</li><li>监听用户是否复制文本</li><li>将信息发送给background脚本</li><li>显示翻译框</li></ul><p><strong>background.js</strong></p><ul><li>接收content脚本发来的信息</li><li>发送请求给API，同时接收应答信息</li><li>将翻译后的内容发送给content脚本</li></ul><p>翻译展示框：</p><ul><li>上方：左边显示logo，右边显示关闭按钮</li><li>中间显示译文</li><li>当用户点击别的地方时关闭翻译框，同时取消选中</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p>在上一篇有写过popup脚本支持跨域，所以我最初的想法是，在划词翻译这个功能中，content脚本只负责发送、接收信息，并且将信息显示出来，而向百度翻译发送请求由popup脚本完成。</p><p>但是<strong>popup 脚本（popup.js）只在用户点击扩展图标并打开 popup 页面时才会运行。</strong></p><p>所以最终改为popup脚本只负责接收popup界面的信息，并传递给content脚本，与外界的交互还是<br>由background脚本完成，这样子增加了代码复用性，也更符合逻辑。</p><p><strong>需要保存用户的设置，所以当用户点击插件时都需要从storage中获取保存的设置</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>([<span class="string">&#x27;autoTranslate&#x27;</span>, <span class="string">&#x27;targetLanguage&#x27;</span>, <span class="string">&#x27;inputTranslate&#x27;</span>], <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">autoTranslate</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span> = result.<span class="property">targetLanguage</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">inputTranslate</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当用户更新设置时，也需要将设置保存下来，同时发给content脚本。</strong></p><p>这里为什么要发送给content脚本呢？而不是要content脚本自己去获取？</p><p>这里我更想用通知的方法，这样假设用户开启或关闭某一个功能，content脚本可以第一时间得到反馈。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">saveSettings</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> autoTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line"><span class="keyword">let</span> targetLanguage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"><span class="keyword">let</span> inputTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123; <span class="attr">autoTranslate</span>: autoTranslate, <span class="attr">targetLanguage</span>: targetLanguage, <span class="attr">inputTranslate</span>: inputTranslate &#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">sendMessageToContent</span>(autoTranslate, targetLanguage, inputTranslate);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于扩展不支持直接从popup界面跳转链接，所以要在popup脚本去跳转。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;project-link&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">create</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;https://github.com/kelinkong/Input-Translation.git&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>这里真的是折磨我好几个小时，主要是调试弹出的翻译框。</p><p>和popup一样，在每次加载界面时需要从storage中获取用户之前的设置。</p><p>然后就是监听用户是否进行选中文本。这里除了记录选中的文本，还需要记录选中的位置，因为我想要直接在选中文本下方弹出翻译框。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line"><span class="keyword">var</span> selectedText = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 获取位置</span></span><br><span class="line"><span class="keyword">var</span> rect = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">getRangeAt</span>(<span class="number">0</span>).<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure><p>和background交互方式与上一篇相同，此处不再赘述。</p><p>接收到饭回来的译文后，这里可以直接调用<code>panel = document.createElement(&#39;div&#39;);</code>来创建一个视图。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">panel.<span class="property">innerHTML</span> = innerHTMLContent; <span class="comment">// 可以使用内嵌html</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;  <span class="comment">// 可以直接调整样式</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">top</span> = rect.<span class="property">bottom</span> + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">panel.<span class="property">style</span>.<span class="property">left</span> = rect.<span class="property">left</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑，应该是有一个单独的HTML文件来控制翻译框。但是我对前端太不了解，折腾了好久也没有折腾成功，只能将就着写进content脚本中。</p><h4 id="开启和关闭功能的实现"><a href="#开启和关闭功能的实现" class="headerlink" title="开启和关闭功能的实现"></a>开启和关闭功能的实现</h4><p>对于输入翻译来说，<code>if (event.target.tagName.toLowerCase() === &#39;input&#39; &amp;&amp; inputTranslate)</code>，检测到输入且inputTranslate为真才会去分析用户的输入是否含有目标语言前缀。</p><p>对于划词翻译，和输入翻译不同的是，这里还涉及到弹出框的开启与关闭。</p><ul><li>当检测到用户更新设置时，先移除所有的鼠标监听，如果划词翻译被开启，则开始监听鼠标。</li><li>当用户点了弹出框的关闭，或者点击其他地方，关闭翻译框，同时取消选中。</li></ul><p>这里取消选中其实有个坑。一开始我没有设置关闭翻译框后取消选中，结果就是，不断弹出翻译框。</p><p>当我设置了取消选中后，我一开始担心，也许用户选中并不是想要翻译，而是想要复制。所以我又给用户在翻译框下添加了两个选项：复制原文和复制译文。作为一个前端小白，调试界面的过程真的太难了，这些元素我怎么摆放都不好看。好不容易调试好了，我突然发现其实我不需要给用户提供这个功能，因为弹出翻译框并不影响用户的复制。</p><p>所以最终我没有给复制的选项。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>popup脚本—&gt;右键点击插件，选择检查，就可以打开调试控制台<br>content脚本—&gt;打开浏览器开发者面板，就可以看到<br>background脚本—&gt;在插件管理中，点击服务工作进程，可以打开后台的调试控制台</p><h3 id="理解前端"><a href="#理解前端" class="headerlink" title="理解前端"></a>理解前端</h3><p>前端就类似做IDesign设计，由各种框组成，大框套小框，前后层叠关系类似图层的概念。每一对尖括号就是一个框。</p><p>那么<strong>先把所有的框显示出来，就可以看到各个页面的包含关系</strong>。</p><p>同样，在前端调试界面，可以看到每一个框的代码。如果呈现出来的画面不是自己想要的那样，可以去界面上调试，来查看是哪一块的代码出现了问题。</p><h4 id="如何去设计这些框？"><a href="#如何去设计这些框？" class="headerlink" title="如何去设计这些框？"></a>如何去设计这些框？</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 新框<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>属于哪一类<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  class可以被css和js用来访问和操作元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>可以有不同的标签<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;auto-translate&quot;</span> <span class="attr">checked</span>&gt;</span>可以交互</span><br></pre></td></tr></table></figure><p><code>.css</code>文件可以定义框的属性，框内元素的呈现。比如：</p><ul><li>padding：内部元素与框的距离。padding-left</li><li>margin：内部框与外部框的距离。margin-left</li></ul><h4 id="如何与用户交互"><a href="#如何与用户交互" class="headerlink" title="如何与用户交互"></a>如何与用户交互</h4><p>当用户改变前端界面时，发生了什么？</p><p>比如当用户点击了一个复选框，那么这条信息传到哪里？对后台有什么影响？</p><p>这些交互都可以在js脚本中定义。写js脚本和写其他的编程语言更像，都是写一个又一个的函数去实现各种各样的功能。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>整个插件开发的有效工作时间大概是4天，这个过程AI帮我写了大部份代码，我只是在努力debug。之前的开发debug就是打断点，看变量信息，而在浏览器上调试就是用笨办法，在每一个函数入口都输出日志，然后去看是哪里出现了问题。</p><p>整个过程耗费时间的点：</p><ul><li>各个脚本之间的通信</li><li>浏览器API</li><li>界面调试</li></ul><p>在界面调试时，遇到了几个我实在是解决不了的bug，请外援帮忙解决的。易用性和UI上同门们也都给过建议。</p><p>如果觉得有用，可以在GitHub上帮忙点个star。感谢。<a href="https://github.com/kelinkong/Input-Translation.git">https://github.com/kelinkong/Input-Translation.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求整理&quot;&gt;&lt;a href=&quot;#需求整理&quot; class=&quot;headerlink&quot; title=&quot;需求整理&quot;&gt;&lt;/a&gt;需求整理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;popup.html：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否开启划词翻译&lt;/li&gt;
&lt;li&gt;选择</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（上）</title>
    <link href="http://example.com/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2024-03-05T09:07:30.000Z</published>
    <updated>2024-03-30T12:55:52.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。</strong></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在检索内容时，很多时候需要检索英文内容，但是现有的翻译插件都需要先复制中文翻译后再复制回搜索框，要么就是将输入框翻译作为付费项目，于是就想自己开发一款插件来解决这个问题。</p><p>同时在浏览网页时难免会遇到不认识的单词，所以想融入一个划词翻译的功能，就不需要再额外安装插件。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>在输入框中输入检索内容后，加上尾缀可自动翻译为对应语言，目前支持<code>/en /zh /fr /de</code><ul><li>如<code>测试/en ---&gt; test</code></li></ul></li><li>划词翻译（开发中，暂不支持）</li></ul><h3 id="开发教程"><a href="#开发教程" class="headerlink" title="开发教程"></a>开发教程</h3><h4 id="基于MV3的项目结构"><a href="#基于MV3的项目结构" class="headerlink" title="基于MV3的项目结构"></a>基于MV3的项目结构</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">│</span><br><span class="line">├── manifest<span class="selector-class">.json</span>  // 配置文件</span><br><span class="line">│</span><br><span class="line">├── icons/</span><br><span class="line">│   └── icon16<span class="selector-class">.png</span></span><br><span class="line">│</span><br><span class="line">├── scripts/</span><br><span class="line">│   ├── <span class="attribute">content</span><span class="selector-class">.js</span> // 内容脚本，向访问的网页注入js代码的一种方式</span><br><span class="line">│   ├── <span class="attribute">background</span><span class="selector-class">.js</span> // 后台脚本，可以访问浏览器的所有API</span><br><span class="line">│   └── popup<span class="selector-class">.js</span></span><br><span class="line">│</span><br><span class="line">├── pages/</span><br><span class="line">└── └── popup<span class="selector-class">.html</span> // 弹出窗口样式</span><br></pre></td></tr></table></figure><h5 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 这是manifest文件的版本，当前版本是3。</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input Translation&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Translate text input and selected words.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//这里配置一些相关权限，如该脚本在那些网站上可以运行</span></span><br><span class="line"><span class="string">&quot;*://*/*&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义了扩展的浏览器动作，包括默认的弹出窗口和默认的图标。</span></span><br><span class="line"><span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup/popup.html&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 定义了扩展的后台页面，这里使用了一个服务工作线程。</span></span><br><span class="line"><span class="attr">&quot;service_worker&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;content_scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// 定义了扩展的内容脚本，包括要注入的JS文件和匹配的网页URL。</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;js&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">// 如果content.js脚本要引用其他脚本，可以写在这里</span></span><br><span class="line"><span class="string">&quot;scripts/content.js&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;matches&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;&lt;all_urls&gt;&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>各个脚本的权限：</strong></p><p><img src="/../imgs/image-46.png" alt="alt text"></p><p>在调用百度翻译的API时，由于content脚本不支持直接跨域，所以要先将输入框的信息发送到background脚本，再由background脚本发送，所以这里涉及到两个脚本的通信。</p><p>脚本通信的教程参考：</p><p><a href="https://juejin.cn/post/6844903985711677453">background、content、popup的通信 - 掘金 (juejin.cn)</a></p><h4 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h4><p>popup就是点击扩展图标弹出来的框，输入框翻译这个功能并不需要这个，所以留到下篇再写。</p><h4 id="content-js"><a href="#content-js" class="headerlink" title="content.js"></a>content.js</h4><p>这个脚本的功能是：</p><ul><li>监测用户输入框，判断用户是否输入了相关后缀，如果检测到用户输入相关后缀，就将输入的内容和后缀发送至background脚本。</li><li>接收到信息后，替换原本输入框中的内容</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> match = text.<span class="title function_">match</span>(<span class="regexp">/(.*)(\/en|\/zh|\/fr|\/de)$/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (match) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start to translate&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> textToTranslate = match[<span class="number">1</span>]; <span class="comment">// 匹配到的文本，不包括语言代码</span></span><br><span class="line"><span class="keyword">var</span> languageCode = match[<span class="number">2</span>].<span class="title function_">slice</span>(<span class="number">1</span>); <span class="comment">// 匹配到的语言代码</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123; <span class="attr">text</span>: textToTranslate, <span class="attr">lang</span>: languageCode &#125;, <span class="keyword">function</span> (<span class="params">response</span>) &#123; </span><br><span class="line"><span class="keyword">if</span> (chrome.<span class="property">runtime</span>.<span class="property">lastError</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(chrome.<span class="property">runtime</span>.<span class="property">lastError</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">event.<span class="property">target</span>.<span class="property">value</span> = response.<span class="property">data</span>.<span class="property">trans_result</span>[<span class="number">0</span>].<span class="property">dst</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是<code>chrome.runtime.sendMessage</code>通信方式，将输入的文本和语言发送至background脚本。</p><p>另外，单独检测用户输入框，会导致用户正在输入<code>/en</code>时，就会被翻译，此时再按anter键，就会导致翻译后的文本多一个<code>/en</code>，如<br><code>测试/en  ----&gt; test/en</code><br>这很不优雅，所以这里的监听事件设置为<code>keyup</code>，且设置了1s的延迟。<br><code>document.addEventListener(&#39;keyup&#39;, function (event)</code></p><h4 id="background-js"><a href="#background-js" class="headerlink" title="background.js"></a>background.js</h4><p>这个脚本的功能是：接受content脚本发来的信息，调用百度翻译API，将翻译完成的信息发送给content脚本。</p><p>因为百度翻译API接受的内容需要使用md5算法加密，所以这里要引入md5算法。</p><p><strong>但是在mv3版本中，不支持直接在配置文件中引入脚本，所以这里要使用import的方式。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">importScripts(<span class="string">&#x27;scripts/lib/md5.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发送信息回content脚本有一个问题要注意，因为background脚本可能同时会和很多脚本通信，所以要使用tab的方式进行通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">request, sender, sendResponse</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received in content script:&#x27;</span>, request);</span><br><span class="line"><span class="title function_">translateText</span>(request.<span class="property">text</span>, request.<span class="property">lang</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span> &#125;, <span class="keyword">function</span> (<span class="params">tabs</span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, &#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">sendResponse</span>(&#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/kelinkong/input-translate">kelinkong&#x2F;input-translate (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;在检索内容时，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>托管博客源码</title>
    <link href="http://example.com/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/</id>
    <published>2024-01-31T03:14:41.000Z</published>
    <updated>2024-03-30T03:53:01.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，将源码也上传到仓库，方便查看。</p><h2 id="使用多分支管理"><a href="#使用多分支管理" class="headerlink" title="使用多分支管理"></a>使用多分支管理</h2><ol><li><p>在GitHub创建一个hexo分支，并将其设置为默认分支；</p></li><li><p>将其clone到本地，默认clone的是hexo分支内容，此时会包含一个.git文件夹，还有原本仓库中有的编译后的文件；</p></li><li><p>将原本仓库中的内容删除，只保留.git文件夹；</p></li><li><p>将原本的文件除了.deploy_git文件夹复制到本地仓库中；</p></li><li><p>在.gitignore文件中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p><strong>如果clone过主题文件，需要把主题文件夹中的.git文件夹删除，因为不能嵌套clone</strong></p></li><li><p>将clone的文件提交到hexo分支中；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m add_branch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><p><strong>之后网站更新到main分支，源代码更新到hexo分支。</strong></p><h2 id="解决GitHub无法上传问题"><a href="#解决GitHub无法上传问题" class="headerlink" title="解决GitHub无法上传问题"></a>解决GitHub无法上传问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 127.0.0.1 port 7890</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br></pre></td></tr></table></figure><ul><li>使用代理或者不使用都会提示该问题</li><li>之前使用正常</li></ul><p>参考这个问题：<br><a href="https://github.com/orgs/community/discussions/55269">https://github.com/orgs/community/discussions/55269</a></p><p>最终解决方案：<br>在<code>~/.ssh/config</code>中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname 20.200.245.248</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="http://example.com/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-12-05T04:29:14.479Z</published>
    <updated>2024-03-30T03:51:23.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/../imgs/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed --save</code></p><h3 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h3><p>在vscode中预览是有图片的，生成和发布之后无法显示图片。<br><img src="/../imgs/image-4.png"></p><p>因为在源文件的 post 目录下新建了 img 子目录,然后在 markdown 中使用相对路径引用图片。</p><p>这在本地预览时可以正常显示,但是部署后会出错。</p><p>因为 Hexo 在生成时,会将 post 中的 markdown 和资源文件一起复制到 public 目录,相对位置不变。</p><p>但是 img 子目录不会自动复制过去。所以 public 中找不到 img 中的图片,导致无法显示。</p><p><strong>解决方法：</strong> 将img重命名为imgs(因为会和主题的img文件夹命名冲突)，然后将文件夹移动到<code>source</code>目录下，而不是放在<code>_posts</code>目录下，注意粘贴的设置也需要修改为imgs。</p><p><img src="/../imgs/image-6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>前端基础学习</title>
    <link href="http://example.com/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-17T21:54:32.000Z</published>
    <updated>2024-03-30T03:52:47.492Z</updated>
    
    <content type="html"><![CDATA[<ol><li>html定义了网页内容</li><li>css描述了网页的布局</li><li>js控制了网页的行为(通过函数)</li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML:</strong> 超文本标记语言，运行在浏览器上，由浏览器来解析。文件名后缀为<code>.html</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 声明文档类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 头部元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 定义一个大标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 定义一个段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="什么是html？"><a href="#什么是html？" class="headerlink" title="什么是html？"></a>什么是html？</h3><ul><li>html是一种标记语言（标记标签）</li><li>使用标记标签来描述网页</li><li>html文档包含了html标签及文本内容</li></ul><p><strong>html的标签：</strong> </p><ul><li>由尖括号包围的关键词，如<code>&lt;html&gt;</code></li><li>标签通常是成对出现的，如<code>&lt;html&gt;&lt;/html&gt;</code></li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li><li>开始标签和结束标签也被称为开放标签和闭合标签 <code>&lt;标签&gt;内容&lt;/标签&gt;</code></li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 超链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">decoding</span>=<span class="string">&quot;async&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;百度logo&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span>&gt;</span> <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 换行 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol><li>对于中文网页需要使用<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>来指定编码格式，否则会出现乱码。</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>CSS:</strong> 层叠样式表，用于设置HTML元素的样式，如颜色、字体、大小、间距、边框等。文件名后缀为<code>.css</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f3f3f3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>选择器：要改变样式的html元素</li><li>声明块：由<code>&#123;&#125;</code>包围的一条或多条声明，如<code>color: red;</code>，总是以分号结尾，用大括号括起来</li><li>注释：<code>/* */</code>，不会被浏览器读取，可以提高代码可读性</li></ul><h3 id="id和class选择器"><a href="#id和class选择器" class="headerlink" title="id和class选择器"></a>id和class选择器</h3><p><strong>id：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#para1</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个段落不受该样式的影响。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class：</strong><br>class用于描述一组元素的样式，可以在多个元素中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.center</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题居中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>段落居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id选择器用于唯一的元素</li><li>class选择器通常具有重用性</li></ul><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ul><li>id不要以数字开头</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>每个页面使用<code>&lt;link&gt;</code>标签链接到外部样式表，外部样式表通常存储在<code>.css</code>文件中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会从文件<code>mystyle.css</code>中读取样式信息，然后将其应用到当前的文档上。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>参考上面的写法。</p><p>优先级：内联样式 》 内部样式 》 外部样式</p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>不过多赘述，需要时再查阅。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>JavaScript:</strong> 一种轻量级的编程语言，可用于创建动态网页。文件名后缀为<code>.js</code>。</p><p>编程语言语法不做过多赘述，主要关注JavsScript是如何和HTML交互的。</p><h3 id="js能够直接写入html输出流中"><a href="#js能够直接写入html输出流中" class="headerlink" title="js能够直接写入html输出流中"></a>js能够直接写入html输出流中</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js对事件的反应"><a href="#js对事件的反应" class="headerlink" title="js对事件的反应"></a>js对事件的反应</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Welcome!&#x27;)&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="改变html内容"><a href="#改变html内容" class="headerlink" title="改变html内容"></a>改变html内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一段 JavaScript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">JavaScript 能改变 HTML 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">x=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);  <span class="comment">// 找到元素</span></span></span><br><span class="line"><span class="language-javascript">x.<span class="property">innerHTML</span>=<span class="string">&quot;Hello JavaScript!&quot;</span>;    <span class="comment">// 改变内容</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>HTML中的JavaScript代码必须位于<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间。放置到<code>&lt;body&gt;</code>和<code>&lt;head&gt;</code>标签中都可以。</p><p>通常的做法是把函数放入到<code>&lt;head&gt;</code>标签中，然后在<code>&lt;body&gt;</code>标签中调用函数。或者是放置到底部。</p><h4 id="外部的JavaScript"><a href="#外部的JavaScript" class="headerlink" title="外部的JavaScript"></a>外部的JavaScript</h4><p>如果需要使用外部文件，在<code>&lt;script&gt;</code>标签的src属性中设置该文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>输出：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 弹出警告框</span></span><br><span class="line">innerHTML <span class="comment">// 内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() <span class="comment">// 控制台</span></span><br></pre></td></tr></table></figure><p><strong>变量：</strong><br>Number\String\Array\Object\Function</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, length;</span><br><span class="line">x = <span class="number">1.2</span>;</span><br><span class="line">length = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>&#125;;  <span class="comment">// Object 通过对象字面量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;                                <span class="comment">// 返回 a 乘以 b 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些交互示例"><a href="#一些交互示例" class="headerlink" title="一些交互示例"></a>一些交互示例</h3><ul><li>JavaScript可以附加到HTML元素上的事件处理程序，例如点击事件、鼠标移动事件、键- 盘事件等。<br>当事件发生时，与该事件相关的JavaScript代码将被执行，以响应用户的操作。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮被点击了！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以访问和操作文档对象模型（DOM），这是HTML页面的表示。</li><li>通过JavaScript，您可以创建、修改、删除HTML元素，以及改变元素的样式和内容。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    myDiv.<span class="property">innerHTML</span> = <span class="string">&quot;现在我被JavaScript修改了！&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以用于验证表单数据、提交表单、以及处理表单的输入。</li><li>可以使用JavaScript来验证用户输入是否有效，然后根据验证结果采取相应的行动。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (nameInput.<span class="property">value</span> === <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;请输入您的姓名！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单提交</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;html定义了网页内容&lt;/li&gt;
&lt;li&gt;css描述了网页的布局&lt;/li&gt;
&lt;li&gt;js控制了网页的行为(通过函数)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++代码调试</title>
    <link href="http://example.com/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>http://example.com/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</id>
    <published>2023-10-10T00:15:48.000Z</published>
    <updated>2024-03-30T03:51:52.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC-工作流程"><a href="#GCC-工作流程" class="headerlink" title="GCC 工作流程"></a>GCC 工作流程</h2><table><thead><tr><th>说明</th><th>文件后缀</th><th>参数</th></tr></thead><tbody><tr><td>预处理</td><td>.c</td><td>-</td></tr><tr><td>编译</td><td>.i</td><td>-E</td></tr><tr><td>汇编</td><td>.s</td><td>-S</td></tr><tr><td>链接</td><td>.o</td><td>-c</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预处理。 -o 参数是为了指定编译后的文件名</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -S test.i -o test.s </span><br><span class="line"><span class="comment"># 汇编</span></span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>生成调试信息，即可调试</td></tr><tr><td>-D</td><td>指定一个宏</td></tr><tr><td>-l</td><td>指定链接库</td></tr><tr><td>-std</td><td>指定C++版本</td></tr><tr><td>-I</td><td>指定头文件路径</td></tr><tr><td>-Wall</td><td>打开所有警告信息</td></tr></tbody></table><p><strong><code>-D</code>参数应用场景：</strong><br>在发布程序的时候，一般会将所有log输出去掉，如果不去掉会影响程序的执行效率。这时候可以在编译的时候加上<code>-D</code>参数，定义一个宏，然后在程序中使用这个宏，如果是发布程序，就不定义这个宏，这样就可以在编译的时候去掉所有的log输出。</p><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> string.c main.c</span><br></pre></td></tr></table></figure><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p><strong>在编译阶段：</strong></p><ul><li>后缀为.c的文件，gcc会将其当做C语言源文件，g++会将其当做C++语言源文件。</li><li>后缀为.cpp的文件，两者都会将其当做C++语言源文件。</li><li>g++会调用gcc，对于C++代码，两者是等价的，也就是说gcc和g++都可以编译C&#x2F;C++代码</li></ul><p><strong>在链接阶段：</strong></p><ul><li>gcc和g++都可以自动连接到标准C库</li><li>g++会自动连接到标准C++库，gcc如果要链接到标准C++库需要加参数<code>-lstdc++</code></li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><strong>gdb调试的代码必须添加-g参数，-g的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行。</strong></p><p><em>使用CMake编译的，添加<code>-DCMAKE_BUILD_TYPE=Debug</code>参数</em>。</p><h3 id="启动和退出gdb"><a href="#启动和退出gdb" class="headerlink" title="启动和退出gdb"></a>启动和退出gdb</h3><p><strong>gdb进程启动之后，需要被调试的应用程序是没有执行的。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;program&gt; <span class="comment"># 启动</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args &lt;arg1&gt; &lt;arg2&gt; <span class="comment"># 设置参数,启动应用程序之前可能需要传参</span></span><br><span class="line"></span><br><span class="line">show args <span class="comment"># 查看参数</span></span><br></pre></td></tr></table></figure><p><strong>在gdb中启动程序：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">(gdb) start <span class="comment"># 会阻塞到main函数第一行</span></span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>run</td><td>启动程序</td><td></td></tr><tr><td>continue &#x3D; c</td><td>继续执行程序</td><td></td></tr><tr><td>quit &#x3D;&#x3D; q</td><td>退出gdb</td><td></td></tr><tr><td>list &#x3D;&#x3D; l</td><td>列出源代码</td><td>l 行号, l 函数名， l 文件名：行号</td></tr><tr><td>break &#x3D;&#x3D; b</td><td>设置断点</td><td>b 行号, b 函数名， b 文件名：行号， b 行数 if 变量名&#x3D;某个值</td></tr><tr><td>info &#x3D;&#x3D; i</td><td>查看信息</td><td>i breakpoints, i locals, i args</td></tr><tr><td>delete &#x3D; del &#x3D; d</td><td>删除断点</td><td>d 断点号</td></tr><tr><td>disable &#x3D; dis</td><td>禁用断点</td><td>disable 断点号</td></tr><tr><td>enable &#x3D; ena</td><td>启用断点</td><td>enable 断点号</td></tr><tr><td>print &#x3D; p</td><td>打印变量</td><td>p 变量名</td></tr><tr><td>ptype</td><td>打印变量类型</td><td>ptype 变量名</td></tr><tr><td>display</td><td>跟踪查看变量</td><td>display 变量名</td></tr><tr><td>step &#x3D; s</td><td>单步执行，进入函数</td><td></td></tr><tr><td>finish</td><td>执行到当前函数返回为止</td><td></td></tr><tr><td>next &#x3D; n</td><td>单步执行，不进入函数</td><td></td></tr><tr><td>until</td><td>跳出循环</td><td></td></tr><tr><td>set</td><td>修改变量值</td><td>set 变量名&#x3D;值</td></tr></tbody></table><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>参考<a href="https://www.hahack.com/codes/cmake/">Cmake快速入门</a></p><p>cmake的基本语法：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake &lt;<span class="keyword">option</span>&gt; &lt;path&gt;</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table><thead><tr><th>含义</th><th>指令</th></tr></thead><tbody><tr><td>编译</td><td>cmake <code>&lt;path&gt;</code>, 当前目录为<code>.</code>,上一级目录为<code>..</code></td></tr><tr><td>清理cmake缓存</td><td><code>rm -rf CMakeFiles/ CMakeCache.txt cmake_install.cmake Makefile</code></td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每一个层级都需要写CMakeLists.txt文件</li><li>需要在父层级添加子层级的目录</li><li>需要在父层级添加子层级的库&#x2F;子目录包含可执行文件</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>文件结构：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── cmake_notes</span><br><span class="line">│   ├── build</span><br><span class="line">│   └── math</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├── myfunction.h</span><br><span class="line">│       └── myfunction.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.txt</span><br></pre></td></tr></table></figure><p>第一层级的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(Demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否用自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DUSE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否加入MathFunctions库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable(Demo main.cpp print.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="comment"># add_subdirectory(math)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo -lpthread)</span><br></pre></td></tr></table></figure><p><strong>在源代码中使用：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use my math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use system math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// USE_MYMATH</span></span></span><br></pre></td></tr></table></figure><p><strong>子目录的CMakeLists文档，需要add_executable吗?</strong></p><p>子目录包含可执行文件：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp other_source.cpp)</span><br></pre></td></tr></table></figure><p>子目录只包含库代码：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_library</span>(my_library my_source.cpp)</span><br></pre></td></tr></table></figure><p>这将创建一个库目标而不是可执行文件，以便在主目录的CMakeLists.txt文件中或其他子目录中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GCC-工作流程&quot;&gt;&lt;a href=&quot;#GCC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;GCC 工作流程&quot;&gt;&lt;/a&gt;GCC 工作流程&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="CPP" scheme="http://example.com/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程模型</title>
    <link href="http://example.com/2023/10/10/%E3%80%90c++%E3%80%91-threads/"/>
    <id>http://example.com/2023/10/10/%E3%80%90c++%E3%80%91-threads/</id>
    <published>2023-10-09T22:47:41.000Z</published>
    <updated>2024-03-30T03:51:58.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步和线程通信"><a href="#线程同步和线程通信" class="headerlink" title="线程同步和线程通信"></a>线程同步和线程通信</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>互斥锁</li><li>条件变量</li><li>互斥量</li><li>信号量</li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li>条件变量</li><li>队列</li><li>原子操作</li><li>条件变量和定时器</li></ol><h2 id="C-标准库提供了哪些锁？"><a href="#C-标准库提供了哪些锁？" class="headerlink" title="C++标准库提供了哪些锁？"></a>C++标准库提供了哪些锁？</h2><p><code>std::mutex</code>：互斥锁是最基本的锁类型，用于确保一次只有一个线程可以访问共享资源。你可以使用 std::mutex 来创建一个互斥锁对象，然后使用 lock() 和 unlock() 方法来手动锁定和解锁。</p><p><code>std::unique_lock：</code>std::unique_lock 是一个更加灵活的互斥锁包装器，它允许你在需要时手动锁定和解锁，也可以在构造函数和析构函数中自动锁定和解锁。</p><p><code>std::lock_guard：</code>std::lock_guard 是另一个互斥锁包装器，但它只支持自动锁定和解锁。一旦 std::lock_guard 对象被创建，它会自动锁定互斥锁，并在其生命周期结束时自动解锁。</p><p><code>std::recursive_mutex：</code>递归互斥锁允许同一线程多次获得锁。这对于某些特定的情况很有用，但要小心避免死锁。</p><p><code>std::shared_mutex：</code>共享互斥锁（C++17引入）允许多个线程同时读取共享资源，但只有一个线程可以写入资源。这有助于提高并发性能。</p><p><code>std::condition_variable：</code>条件变量用于线程之间的同步和通信。它们允许一个线程等待某个条件成立，然后另一个线程发出信号以通知等待线程。</p><h2 id="实现线程的交替打印："><a href="#实现线程的交替打印：" class="headerlink" title="实现线程的交替打印："></a>实现线程的交替打印：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATTIONS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 锁，用于线程同步</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量，用于线程通信</span></span><br><span class="line"><span class="type">int</span> current_thread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> thread_num, <span class="type">const</span> std::string&amp; messages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITERATTIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取锁，进入临界区</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是当前线程，就等待</span></span><br><span class="line">        <span class="keyword">while</span> (current_thread != thread_num) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 释放锁，允许其他线程进入临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        std::cout &lt;&lt; messages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改当前线程的编号</span></span><br><span class="line">        current_thread = (current_thread + <span class="number">1</span>) % NUM_THREADS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知下一个线程开始打印</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>(); <span class="comment">// 这里并没有释放锁，当前线程仍然持有锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print, i, <span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span> -pthread</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么使用条件变量唤醒的时候要用while而不用if？"><a href="#为什么使用条件变量唤醒的时候要用while而不用if？" class="headerlink" title="为什么使用条件变量唤醒的时候要用while而不用if？"></a>为什么使用条件变量唤醒的时候要用while而不用if？</h3><p>条件变量在等待期间可能会收到虚假唤醒（spurious wakeups），也就是在条件尚未满足时，线程被唤醒。</p><p>虚假唤醒是由于操作系统或底层线程库的实现细节引起的，他们可能会偶尔导致条件变量的信号量被错误唤醒。所以要循环检查，直到条件不满足。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程同步和线程通信&quot;&gt;&lt;a href=&quot;#线程同步和线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程同步和线程通信&quot;&gt;&lt;/a&gt;线程同步和线程通信&lt;/h2&gt;&lt;h3 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CPP" scheme="http://example.com/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CS50课程学习笔记</title>
    <link href="http://example.com/2023/10/08/cs50/"/>
    <id>http://example.com/2023/10/08/cs50/</id>
    <published>2023-10-07T19:26:51.000Z</published>
    <updated>2024-03-30T03:54:37.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h3><ul><li>input –&gt; black box –&gt; output</li><li>binary&#x2F;bit: A bit is a zero or one</li><li>text: using ASCII</li><li>Emojis: Unicode</li><li>RGB: three numbers</li><li>Images, Video and Sound are simply collections of RGB values</li></ul><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ul><li>Problem-solving is central to computer science and computer programming</li></ul><h3 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h3><ul><li>function：pick up</li><li>conditions：if elseif</li><li>Boolean expression</li><li>loops：for&#x2F;while</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p><strong>command line interface</strong>：CLI， send commands to the computer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><em>这里并没有写makefile文件，为什么可以直接编译呢？</em><br><em>make程序默认会根据源代码文件的后缀名，自动生成并使用一个默认的Makefile规则进行编译。对于c语言的源代码，会有一个默认规则，类似如下：</em></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c <span class="comment"># % 是通配符，匹配任意字符串，匹配所有.c结尾的文件，生成以.o结尾的目标文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment"># $(CC) 变量，使用CC编译器。 $(CFLAGS)编译参数， -c表示进行编译而不链接， $&lt; 取出第一个前置文件的名字，即.c文件，-o指定输出目标文件，&amp;@ 取出目标文件的名字，既.o文件</span></span><br></pre></td></tr></table></figure><p>这里提到一个进行编译而不链接。回顾一下c语言编译的过程</p><ol><li>预处理，生成扩展后的.i文件。删除所有注释、#define 宏展开、文件包含 #include&lt;文件名&gt;</li><li>编译，汇编代码文件.s。会进行语法检查</li><li>组装。将汇编文件转化为机器码。生成.o文件</li><li>链接。链接是将库文件包含在我们的程序中的过程。生成可执行文件.out</li></ol><p><strong>静态成员变量是在哪一个阶段被初始化的呢？</strong></p><p><em>我们都知道静态成员变量是在运行<code>main</code>函数前初始化，那么究竟是在编译的哪一个阶段呢？</em></p><ol><li>定义在类内部的静态成员变量,其初始化是在编译期初期完成的。</li><li>定义在类外部的静态成员变量,其初始化是在链接阶段完成的。</li></ol><p>区别在于:</p><p>对于类内部定义的静态成员变量,编译器可以在编译当前类的定义时直接初始化它。</p><p>而对于类外部定义的静态成员变量,需要到链接阶段不同的目标文件合并时,由链接器完成初始化操作。</p><p><strong>预编译阶段，编译器会把#include包含的头文件内容展开Inline，但是对于lib库的引用则不会展开，而是保留该引用。真正使用库里的目标文件是在链接阶段。由链接器解析引用，并从外部库获取目标代码进行连接。</strong></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>linear and binary search</li><li>data structures</li><li>sorting</li><li>recursion</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><strong>内存地址为什么用16进制存放？</strong></p><ol><li>紧凑表示：使用尽可能少的数字来表示较大的内存空间</li><li>与CPU寻址匹配： CPU使用总线地址线表示内存地址，地址线数量是2的指数倍（如8条、16条），这与16进制表示是匹配的</li><li>转换为二进制方便，16进制中的每一个恰好对应2进制中的4位，可以非常方便的转换为二进制数。</li></ol><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>指针的本质就是一个地址变量。指向的是操作系统给模拟出来的虚拟内存空间的地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p是一个指针，(*p)表示获取指针所指向的值，&amp;符合代表取地址</span></span><br></pre></td></tr></table></figure><p>在c语言中<br><code>string</code>类型本质就是一个指针，以<code>&#39;\0&#39;</code>位标识符结尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HI!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">1</span>]); <span class="comment">// I</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">2</span>]); <span class="comment">// !</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">3</span>]); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">4</span>]); <span class="comment">// %</span></span><br></pre></td></tr></table></figure><p>为什么没有提示数组越界呢？</p><p><em>在c语言中数组边界检查并不是强制的。所以这访问越界并没有报错，但是可能会导致其他问题。当访问s[3]之后的值时，读取的是垃圾内存的值。</em></p><h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>valgrind是一个检查是否有内存泄漏的工具，比如使用malloc但是没有使用free。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    x[<span class="number">0</span>] = <span class="number">72</span>;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">73</span>;</span><br><span class="line">    x[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make test</code></p><p><code>valgrind --leak-check=full ./test</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==61782== HEAP SUMMARY:</span><br><span class="line">==61782==     in use at exit: 12 bytes in 1 blocks</span><br><span class="line">==61782==   total heap usage: 1 allocs, 0 frees, 12 bytes allocated</span><br><span class="line">==61782== </span><br><span class="line">==61782== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==61782==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==61782==    by 0x10915E: main (in /home/kelin/cs50/test)</span><br></pre></td></tr></table></figure><p><strong>valgind可以检查哪些类型的错误呢？</strong></p><ol><li>内存管理错误：访问越界、未释放、访问未初始化的内存等</li><li>线程错误：程序未正确join线程、线程同步错误（多个线程争用资源未加锁）</li><li>I&#x2F;O操作错误：文件描述符泄漏、socket使用错误</li><li>未定义行为：访问未初始化的变量</li></ol><h3 id="在c语言中，打开文件是如何实现的？"><a href="#在c语言中，打开文件是如何实现的？" class="headerlink" title="在c语言中，打开文件是如何实现的？"></a>在c语言中，打开文件是如何实现的？</h3><ol><li>open系统调用</li><li>分配文件描述符：文件描述符是内核用来标识这个文件打开状态的整数</li><li>更新文件表：将文件描述符放入进程的文件描述符表，该表维护了进程打开文件的状态</li><li>返回文件描述符：open系统调用返回文件描述符给应用程序</li><li>read&#x2F;write调用</li><li>关闭</li></ol><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p><strong><code>curl</code></strong></p><p>curl用来发送各种HTTP请求，获取或传输数据。</p><table><thead><tr><th>参数</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-X</td><td>指定http请求的方法</td><td>-X GET</td></tr><tr><td>-d</td><td>指定发送的数据体</td><td>-d ‘data&#x3D;test’</td></tr><tr><td>-I</td><td>只显示响应头信息，不显示响应内容</td><td></td></tr><tr><td>-w</td><td>将响应头信息保存到文件</td><td></td></tr><tr><td>-O</td><td>将服务器访问保存为文件</td><td>curl -O example.com&#x2F;file1.zip</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;Computational-Thinking&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Operating System" scheme="http://example.com/categories/Operating-System/"/>
    
    
    <category term="note" scheme="http://example.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>执行一个程序的过程</title>
    <link href="http://example.com/2023/08/25/exec-program/"/>
    <id>http://example.com/2023/08/25/exec-program/</id>
    <published>2023-08-25T02:09:26.000Z</published>
    <updated>2024-03-30T03:54:50.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li></ul><p><img src="/../imgs/image-44.png" alt="图来源于小林coding"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>程序和数据都是存储在内存中，存储的区域是线性的。存储数据的基本单位是<strong>字节（byte）</strong>，一字节等于8位（bit），每一个字节对应着一个内存地址。</p><h3 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h3><p>32位和64位CPU最主要区别在于一次能计算多少字节的数据</p><ul><li>32位一次能计算4个字节，虚拟内存空间大小为$2^{32}$，4G</li><li>64位一次能计算8个字节</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>通用寄存器：用来存放需要进行运算的数据(执行单元)</li><li>程序计数器：用来存储CPU要执行下一条指令所在的内存地址（此时指令仍然在内存中）（控制单元）</li><li>指令寄存器：用来存放正在执行的指令（控制单元）</li></ul><h3 id="存储器接口-Memory-Interface"><a href="#存储器接口-Memory-Interface" class="headerlink" title="存储器接口(Memory Interface)"></a>存储器接口(Memory Interface)</h3><p>与内存交互,读写数据。</p><h4 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h4><p>提取指令、解析指令、产生控制信号。</p><h4 id="执行单元-Execution-Unit"><a href="#执行单元-Execution-Unit" class="headerlink" title="执行单元(Execution Unit)"></a>执行单元(Execution Unit)</h4><p>包含算术逻辑单元ALU和通用寄存器组,执行各种运算和数据处理。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li>地址总线：用于指定CPU将要操作的内存地址</li><li>数据总线：用于读写内存的数据</li><li>控制总线：用于发送和接收信号</li></ul><p>通过地址总线来指定内存内存的地址–&gt;通过控制总线控制是读或写命令–&gt;通过数据总线传输数据。</p><h2 id="程序是如何执行的？"><a href="#程序是如何执行的？" class="headerlink" title="程序是如何执行的？"></a>程序是如何执行的？</h2><p><img src="/../imgs/image-45.png"></p><p>指令：一串二进制数字的机器码，不同的CPU有不同的指令集</p><p><strong>指令是存放在虚拟内存里还是物理内存中？</strong></p><p>虚拟内存为每个进程提供一片连续的虚拟地址空间，各进程的虚拟地址空间是独立的，指令与数据位于不同进程的虚拟地址空间中，因此多个进程共同执行时，他们的指令集不会交叉。</p><p><strong>那么程序计数器加1的时候，是加的虚拟内存还是实际内存？CPU直接操作的是实际内存还是虚拟内存？</strong></p><p>程序计数器加1时,它加的都是虚拟地址。CPU在执行程序时,直接操作和访问的也都是虚拟地址,而不是实际物理地址。</p><ol><li>CPU送出的下一条指令虚拟地址到MMU</li><li>MMU根据页表查找虚拟地址到物理地址的映射</li><li>若对应页不在物理内存，则触发缺页中断，os将其从磁盘换入</li><li>MMU最终将虚拟地址翻译为物理地址，从物理地址中读取指令后，将指令发送至CPU</li><li>CPU执行该指令</li><li>程序计数器中的虚拟地址+1</li></ol><h3 id="对于一个C-程序而言，是如何把代码变成指令集的？"><a href="#对于一个C-程序而言，是如何把代码变成指令集的？" class="headerlink" title="对于一个C++程序而言，是如何把代码变成指令集的？"></a>对于一个C++程序而言，是如何把代码变成指令集的？</h3><h4 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing)"></a>预处理(Preprocessing)</h4><p>预编译器处理头文件包含、宏定义展开等预处理工作,生成扩展后的源代码。<code>#define</code></p><h4 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h4><p>编译器将预处理后的C++源代码编译成汇编语言。这个过程包括词法分析、语法分析、语义分析、中间代码生成、目标代码生成等步骤。内联函数会被直接插入到每一个调用点，省去了函数调用的过程。</p><h4 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h4><p>汇编程序将汇编语言转换成机器语言,生成目标文件。</p><h4 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接(Linking)"></a>链接(Linking)</h4><p>链接器将多个目标文件和系统库链接生成完整的可执行程序。</p><p>在这个过程中,C++源代码经过编译器的编译和汇编程序的汇编,最终被转换成机器指令,这些指令保存在可执行文件的代码段,可以直接被CPU执行。</p><h3 id="编译前和编译后代码是存放在哪里？"><a href="#编译前和编译后代码是存放在哪里？" class="headerlink" title="编译前和编译后代码是存放在哪里？"></a>编译前和编译后代码是存放在哪里？</h3><h4 id="编译前"><a href="#编译前" class="headerlink" title="编译前:"></a>编译前:</h4><p>源代码以文本文件的形式存储在文件系统中,使用高级语言编写,对人更友好。</p><p>源代码包含了数据结构定义、算法流程、程序逻辑等信息。但不能直接被计算机执行。</p><h4 id="编译后："><a href="#编译后：" class="headerlink" title="编译后："></a>编译后：</h4><p>经过编译器编译后,会生成机器代码,存放在可执行文件的代码段中。</p><p>机器代码使用机器指令组成,可以直接被CPU执行。</p><p>举个例子：当我调用<code>new</code>关键字去为一个对象分配内存时，在编译前这仅仅是一个抽象的概念，<strong>内存分配是在运行时发生的</strong>。</p><h3 id="在编译的时候，编译顺序是怎么样的？"><a href="#在编译的时候，编译顺序是怎么样的？" class="headerlink" title="在编译的时候，编译顺序是怎么样的？"></a>在编译的时候，编译顺序是怎么样的？</h3><p>以下面的代码为例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 预处理阶段</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val)&#123;&#125; <span class="comment">// 构造函数和析构函数机器码</span></span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;&#125; <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">sFunc</span><span class="params">()</span></span>; <span class="comment">// 没有this指针，所以只能调用静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_val = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_val = <span class="number">1</span>; <span class="comment">// 所有实例共享，不属于类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Node * node_ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    node.<span class="built_in">func</span>();</span><br><span class="line">    node_ptr.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> node_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main函数执行之前，需要做什么？"><a href="#main函数执行之前，需要做什么？" class="headerlink" title="main函数执行之前，需要做什么？"></a>main函数执行之前，需要做什么？</h3><ol><li>设置栈指针</li><li>初始化静态static变量和global变量。静态类的构造函数在这里被调用</li><li>初始化全局变量，全局对象的构造函数也在main之前被调用</li><li>将main函数所需参数传递给main函数</li></ol><h3 id="在main函数之后，需要执行什么？"><a href="#在main函数之后，需要执行什么？" class="headerlink" title="在main函数之后，需要执行什么？"></a>在main函数之后，需要执行什么？</h3><ol><li>全局对象的析构函数</li><li>可以使用<code>atexit</code>注册一个函数，会在main之后执行</li></ol><h3 id="静态成员函数也是放在代码区的吗？"><a href="#静态成员函数也是放在代码区的吗？" class="headerlink" title="静态成员函数也是放在代码区的吗？"></a>静态成员函数也是放在代码区的吗？</h3><p>是的。编译器会为静态成员函数生成对应的机器代码，不需要实例化类就可以调用，机器代码独立生成，不依赖任何实例。</p><h3 id="函数调用时是如何传递参数的？"><a href="#函数调用时是如何传递参数的？" class="headerlink" title="函数调用时是如何传递参数的？"></a>函数调用时是如何传递参数的？</h3><ol><li>把参数的值从寄存器或内存加载到CPU的通用寄存器中。</li><li>调用指令将程序控制流跳转到函数代码地址。</li><li>在跳转前,调用指令会将返回地址等寄存器信息压入调用栈,用于保留调用环境。</li><li>跳转执行函数代码,函数中的局部变量也可能在栈上分配。</li><li>在函数执行前,根据调用约定从寄存器或栈空间中读取参数值。</li><li>函数执行完后,使用返回指令跳回调用点。</li><li>返回前依照调用约定将返回值写入寄存器或内存。</li><li>返回后,调用栈恢复,继续执行调用代码。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冯诺依曼模型&quot;&gt;&lt;a href=&quot;#冯诺依曼模型&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼模型&quot;&gt;&lt;/a&gt;冯诺依曼模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;</summary>
      
    
    
    
    <category term="Operating System" scheme="http://example.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency Control</title>
    <link href="http://example.com/2023/08/21/Concurrency-Control/"/>
    <id>http://example.com/2023/08/21/Concurrency-Control/</id>
    <published>2023-08-20T20:39:32.000Z</published>
    <updated>2024-03-30T03:53:47.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="project4需要实现的内容"><a href="#project4需要实现的内容" class="headerlink" title="project4需要实现的内容"></a>project4需要实现的内容</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/project4/">project任务链接</a></p><h3 id="Lock-Manager："><a href="#Lock-Manager：" class="headerlink" title="Lock Manager："></a>Lock Manager：</h3><p><code>src/include/concurrency/lock_manager.h</code></p><p><code>concurrency/lock_manager.cpp</code></p><h4 id="Lock-Manager的作用是什么？"><a href="#Lock-Manager的作用是什么？" class="headerlink" title="Lock Manager的作用是什么？"></a>Lock Manager的作用是什么？</h4><p>Lock Manager 的作用是处理事务发送的锁请。事务在被允许访问某个数据项之前,需要先向锁管理器发出锁请求。锁管理器将向调用事务授予锁,阻塞该事务,或者中止它。</p><p>例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。</p><p>整个系统将具有一个全局的锁管理器(类似于缓冲池管理器)。TableHeap和Executor类将使用你实现的锁管理器在事务想访问或修改一个元组记录时获取行锁(通过记录ID RID)。</p><p>这个任务要求实现一个支持三种常见隔离级别的表级锁和行级锁:READ_UNCOMMITTED, READ_COMMITTED和REPEATABLE_READ。锁管理器应该根据事务的隔离级别授予或释放锁。请参考课件复习隔离级别。</p><p>在代码库中,提供了一个Transaction上下文处理(transaction.h),其中包含隔离级别属性和它持有的锁的相关信息。锁管理器需要检查事务的隔离级别并公开在锁请求上的正确行为。任何失败的锁操作都应导致事务进入ABORTED状态(隐式中止)并抛出异常。事务管理器(transaction_manager.h)会进一步捕获这个异常并回滚事务执行的写操作。</p><h4 id="三种隔离级别的实现"><a href="#三种隔离级别的实现" class="headerlink" title="三种隔离级别的实现"></a>三种隔离级别的实现</h4><ul><li>READ_UNCOMMITED只有在需要时上写锁。</li><li>READ_COMMITTED要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。</li><li>REPEATABLE_READ进一步打造可重复读。同一事务读两次数据的中途不想被其他事务的写干扰，这就需要用到巧妙的二段封锁协议（2PL）了：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段(GROWING)只上锁，解锁阶段(SHINKING)只解锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPEATABLE_READ:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   No locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_COMMITTED:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   Only IS, S locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_UNCOMMITTED:</span><br><span class="line">   The transaction is required to take only IX, X locks.</span><br><span class="line">   X, IX locks are allowed in the GROWING state.</span><br><span class="line">   S, IS, SIX locks are never allowed</span><br></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>由于对行添加S&#x2F;X锁时，需要对应的对行所在的表添加IS&#x2F;IX锁，所以需要记录每一个表里有哪些行被加锁。</p><p>这里用一个map来实现对应表id和行集合。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** LockManager: the set of row locks held by this transaction. */</span></span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; s_row_lock_set_;</span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; x_row_lock_set_;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/image-43.png"></p><p><strong>获取表锁</strong></p><ol><li>判断锁请求是否合理(如果当前事务Abort&#x2F;Commit，或者加锁类型与事务隔离级别不符合，抛异常)</li><li>从 <code>table_lock_map_</code> 中获取 table 对应的 <code>lock request queue</code>。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</li><li>判断之前该事务是否对这个表进行加过锁</li><li>如果之前加过锁，升级该锁（级别不能比当前的锁的级别要低且不能有另一个事务也在对这个表进行升级），创建一个新的LockRequest，加入到队列尾部</li><li>尝试获取锁，如果<code>GrantLock()</code>为真，可以获取锁，否则循环等待，这里使用条件变量<code>queue-&gt;cv_.wait(queue-&gt;latch_);</code>, 当这个锁被释放时，会唤醒当前线程，判断是否能获取锁。</li></ol><p><strong>GrantLock()</strong></p><ol><li>判断当前的锁请求是否与所有的<code>granted</code>的请求兼容</li><li>判断优先级</li></ol><p>tips：</p><p>使用条件变量去通知请求队列上等待的线程。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** List of lock requests for the same resource (table or row) */</span></span><br><span class="line">  std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">  <span class="comment">/** For notifying blocked transactions on this rid */</span></span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  <span class="comment">/** txn_id of an upgrading transaction (if any) */</span></span><br><span class="line">  <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="comment">/** coordination */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解表锁：</strong></p><ol><li>判断可以不可以解锁：之前是否加过锁，如果是解锁表锁，要检测该表中有没有行被加过锁</li><li>检查在对应隔离级别下是否要进入Shrinking状态</li><li>删除锁</li></ol><p>行锁与表锁类似，解锁时不需要检查是否有表锁。</p><h3 id="Deadlock-Detection："><a href="#Deadlock-Detection：" class="headerlink" title="Deadlock Detection："></a>Deadlock Detection：</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** Waits-for graph representation. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">txn_id_t</span>, std::vector&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br></pre></td></tr></table></figure><p>并不需要时刻维护wait for图，而是在死锁检测线程被唤醒的时候，根据当前请求队列构建的wait for图，再通过这个图去判断是否存在死锁。</p><ul><li>当检测到有圈时，这里采取的victim策略是找到事务ID最大的返回，因为这个事务是最年轻的。</li><li>默认的检测时间是50ms</li></ul><h3 id="Concurrent-Query-Execution"><a href="#Concurrent-Query-Execution" class="headerlink" title="Concurrent Query Execution"></a>Concurrent Query Execution</h3><p>这里需要修改之前的三个算子，顺序扫描、插入和删除。</p><p>tips：</p><ul><li>添加行锁之前需要对相应的表添加意向锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;project4需要实现的内容&quot;&gt;&lt;a href=&quot;#project4需要实现的内容&quot; class=&quot;headerlink&quot; title=&quot;project4需要实现的内容&quot;&gt;&lt;/a&gt;project4需要实现的内容&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://1</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency study note</title>
    <link href="http://example.com/2023/08/21/concurrency_notes/"/>
    <id>http://example.com/2023/08/21/concurrency_notes/</id>
    <published>2023-08-20T20:39:32.000Z</published>
    <updated>2024-03-30T03:53:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>在做project4之前，最好是先学习课件内容。<br><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf">课件地址</a></p><p>Concurrency Control：avoid losting updates</p><p>Recovery： Durability</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>A transaction is the execution of a sequence of  one or more operations (e.g., SQL queries) on a database to perform some higher-level function.</p><p>Move $100 from Andy’s bank account to his bookie’s account.</p><p>Transaction:</p><ul><li>Check whether Andy has $100.</li><li>Deduct $100 from his account.</li><li>Add $100 to his bookie’s account</li></ul><p>一个事务包含了许多操作，如果是并发执行事务时，就可能会导致很多问题。</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>A new txn starts with the <code>BEGIN</code> command.</p><p>The txn stops with either <code>COMMIT</code> or <code>ABORT</code></p><ul><li>If commit, the DBMS either saves all the txn’s changes<br>or aborts it.</li><li>If abort, all changes are undone so that it’s like as if the<br>txn never executed at all.</li></ul><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性：所有操作要么全部完成，要么全部不完成。undo log(回滚日志)</li><li>隔离性：多个事务并发修改，不会互相干扰。MVCC（多版本并发机制）</li><li>持久性：事务处理结束后，对事务的修改是永久的。redo log（重做日志）</li><li>一致性：事务操作前和操作后，数据库保持一致性</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>脏读：读取到未提交的</li><li>不可重复读：在一个事务内多次读取同一个数据，前后读取的数据不一致</li><li>幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，前后读取的记录数量不一致</li></ul><p><strong>隔离级别：</strong></p><ul><li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；— 解决脏读问题</li><li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； — 解决不可重复读问题</li><li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； — 解决幻读问题</li></ul><p><strong>五种锁：</strong></p><ul><li>意向共享锁(IS):表示事务想要获得共享锁,与其他意向锁兼容,与排它锁冲突。用共享锁锁了里面的某些记录</li><li>意向排它锁(IX):表示事务想要获得排它锁,与其他所有锁模式冲突。用排他锁锁了表里的某些记录</li><li>共享锁(S):允许多个事务同时持有同一资源的共享锁,相互兼容。</li><li>排它锁(X):只允许一个事务持有排它锁,与所有其他锁冲突。</li><li>共享意向排他锁(SIX):表示持有共享锁的同时,想要获得排它锁,与排它锁冲突。用共享锁锁了整个表，用排他锁锁了里面的某些记录</li></ul><h3 id="锁管理器"><a href="#锁管理器" class="headerlink" title="锁管理器"></a>锁管理器</h3><p>管理锁的请求<br><img src="/../imgs/image-30.png" alt="Alt text"></p><p><strong>过程：</strong></p><ol><li>Transactions request locks (or upgrades).</li><li>Lock manager grants or blocks requests.</li><li>Transactions release locks.</li><li>Lock manager updates its internal lock-table.<br> It keeps track of what transactions hold what locks and what transactions are waiting to acquire any locks.</li></ol><h3 id="两阶段锁-2PL"><a href="#两阶段锁-2PL" class="headerlink" title="两阶段锁 2PL"></a>两阶段锁 2PL</h3><h4 id="Growing"><a href="#Growing" class="headerlink" title="Growing"></a>Growing</h4><p>只能加锁</p><h4 id="Shrinking"><a href="#Shrinking" class="headerlink" title="Shrinking"></a>Shrinking</h4><p>只能解锁</p><p>示意图：</p><p><img src="/../imgs/image-32.png"></p><p>但是无法避免接连回滚问题：这里事务一进入Shrinking阶段后，并没有提交，而是ABORT，最终回滚，由于事务二用的是事务一修改后的数据，也需要跟着回滚。</p><p><img src="/../imgs/image-33.png"></p><p>粗暴的解决方法：所有的锁都在commit的时候解锁，能解决脏读问题。</p><p><strong>但是可能出现死锁：</strong></p><p><img src="/../imgs/image-34.png"></p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><p>如果图种产生了环，需要解开环。<br><img src="/../imgs/image-35.png"></p><p>解开环：选择一个事务victim(abort or restart)</p><ul><li>根据执行时间选择（执行时间短的）</li><li>执行的SQL语句的多少</li><li>已经加了多少把锁</li><li>被回滚过多少次</li></ul><p><strong>回滚策略：</strong> victim完全回滚 or 回滚某些语句</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h4><ul><li>独占资源</li><li>不可剥夺</li><li>占用并等待</li><li>循环引用</li></ul><h4 id="破坏其中的某一条"><a href="#破坏其中的某一条" class="headerlink" title="破坏其中的某一条"></a>破坏其中的某一条</h4><p>Assign priorities based on timestamps:</p><ul><li>Older Timestamp &#x3D; Higher Priority (e.g., T1 &gt; T2)</li></ul><p><img src="/../imgs/image-36.png"></p><p>两个事务不会互相等待。</p><p>为了避免饥饿，新的被kill掉之后，时间戳沿用以前的。</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>行锁？表锁？间隙锁？</p><ul><li>更少的锁的数量？粒度大，加锁的开销</li><li>更好的并发？粒度小</li></ul><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>并不是真的锁，只是一个意向。比如表A种某一个tuple被加了锁，此时需要对表A加意向锁，表示比表A粒度更细的内容被加了所，不能再对表A加表锁。</p><p><img src="/../imgs/image-38.png"></p><p>例如：要对Tuple1加S锁，需要先对Table R加IS锁</p><p><img src="/../imgs/image-39.png"> </p><p>两阶段锁是悲观锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/17-timestampordering.pdf">课件地址</a></p><p>根据时间戳排序，如果A的时间戳小与B的时间戳，那么最后执行的效果等于A先执行完B再去执行。</p><p>时间戳来源：</p><ul><li>系统时钟（可能不准确）</li><li>逻辑计数器，比如从1递增，分布式校准难</li><li>Hybrid：结合</li></ul><p>每一个记录X都需要有两个时间戳：</p><ul><li><code>W-TS(x)</code> - 上一次被写的时间戳</li><li><code>R-TS(x)</code> - 上一次被读的时间戳</li></ul><p>基准：<strong>不能操作来自未来的数据</strong></p><p>读数据：</p><p><img src="/../imgs/image-40.png"></p><p>写数据：数据的任何操作都应该发生在过去</p><p><img src="/../imgs/image-41.png"></p><h3 id="THOMAS-WRITE-RULE"><a href="#THOMAS-WRITE-RULE" class="headerlink" title="THOMAS WRITE RULE"></a>THOMAS WRITE RULE</h3><p>如果我们当前要修改的数据A已经被未来的事务所修改，那么我们忽视写这个操作，因为现在写了一定会被未来写的数据所覆盖掉。</p><p><img src="/../imgs/image-42.png"></p><ul><li>乐观锁不存在死锁，因为没有锁也没有等待</li><li>长事务可能会饥饿，因为有可能碰到的所有数据都被未来的事务所修改</li><li>必须要保证所有的修改都是在已经提交的基础上</li></ul><p>可能会读取到别人未提交的。</p><h3 id="乐观的并发"><a href="#乐观的并发" class="headerlink" title="乐观的并发"></a>乐观的并发</h3><p>每一个事务都有一个workspace，所有的修改都在当前这个workspace进行，当事务提交时，DBMS对比workspace写集合，查看是否与其他事务冲突，没有冲突就写入原始数据库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做project4之前，最好是先学习课件内容。&lt;br&gt;&lt;a href=&quot;https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf&quot;&gt;课件地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Concurre</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Query_Execution</title>
    <link href="http://example.com/2023/08/17/Query-Execution/"/>
    <id>http://example.com/2023/08/17/Query-Execution/</id>
    <published>2023-08-16T23:50:33.000Z</published>
    <updated>2024-03-30T03:56:28.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行引擎介绍"><a href="#执行引擎介绍" class="headerlink" title="执行引擎介绍"></a>执行引擎介绍</h2><p><strong>一条SQL语句进入到数据库中后是如何被执行的？</strong></p><p><img src="/../imgs/image-23.png" alt="来源于小林coding"></p><p>前两个project实现的buffer pool和index都是存储引擎的一部分。</p><p>执行计划可以看作一个有向无环图，由source开始到sink结束，中间是一个又一个的算子。这一个project实现的就是这些算子。</p><p>课件地址：<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf</a></p><h2 id="processing-model"><a href="#processing-model" class="headerlink" title="processing model"></a>processing model</h2><p>A DBMS’s processing model defines how the system executes a query plan.</p><p>→ Different trade-offs for different workloads.</p><h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>每个运算符实现一个iterator接口,产生一行输出就调用下个运算符,逐行传递数据。或 Pipeline Model，或火山模型。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。</p><p>即时输出查询结果,不需要存储和载入大量中间状态。<br>易于实现,类似拉模式,但执行效率低。</p><h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个运算符将中间结果完全 Materialize 产生,存储在临时表中。<br>下个运算符从临时表中读取输入数据。<br>效率高,可最大化利用批处理,但需要更多存储空间。</p><h3 id="Vectorized-Batch-Model"><a href="#Vectorized-Batch-Model" class="headerlink" title="Vectorized&#x2F;Batch Model"></a>Vectorized&#x2F;Batch Model</h3><p>运算符以批(向量)为单位处理数据,减少解释器调度开销。<br>输入数据存放在列式存储中,易于向量化操作。<br>并行计算批数据,可利用现代CPU指令集。<br>兼具Iterator和Materialization方法的优点。现在大部分OLAP数据库使用这种方法。</p><p>在bustub中使用的是Iterator Model。</p><p>比如这个join的例子，查询时数据自下而上流动，通过父节点调用子节点的<code>Next()</code>方法。在根节点处得到最终值。</p><p><img src="/../imgs/image-27.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于每一个算子，我们需要补充构造函数、<code>Init()</code>函数和<code>Next()</code>函数，注意<code>Next()</code>函数如果返回值，这里只返回一条，通过传出参数实现，返回<code>Tuple</code>和<code>rid</code>。</p><p><strong>这些信息是如何得到的？</strong></p><p>在顺序扫描算子中，构造函数提供了两个参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqScanExecutor::<span class="built_in">SeqScanExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> SeqScanPlanNode *plan) : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>ExecutorContext和SeqScanPlanNode，首先要搞明白执行上下文都包括什么东西？</p><p><img src="/../imgs/exec_ctx.png"></p><p>最终的原始数据都在<code>Tuple</code>中，也代表着OLTP数据库中的一行数据。</p><p><strong>SeqScanPlanNode</strong>，执行计划的一个结点应该包含哪些东西？</p><p>output_schema是用来表示执行计划结点的输出模式。输出元组包含哪些列, 每列的类型和名称是什么。这为下游运算符解析和处理数据提供信息。</p><p><img src="/../imgs/plannode.png"></p><p>bustub提供了一个迭代器<code>TableIterator</code>，用来遍历<code>TableHeap</code>。根据上面的ctx包含的内容和plan包含的内容可以一层层拆解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_id = plan_-&gt;<span class="built_in">GetTableOid</span>();</span><br><span class="line">table_info = ctx-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(table_id);</span><br><span class="line">table_heap = table_info-&gt;table_.<span class="built_in">get</span>();</span><br><span class="line">table_iter_ = table_heap_-&gt;<span class="built_in">Begin</span>(ctx-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">*table_iter_=tuple;</span><br><span class="line">rid=tuple-&gt;<span class="built_in">GetRid</span>();</span><br></pre></td></tr></table></figure><h2 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h2><h4 id="顺序扫描-src-execution-seq-scan-executor-cpp"><a href="#顺序扫描-src-execution-seq-scan-executor-cpp" class="headerlink" title="顺序扫描 src/execution/seq_scan_executor.cpp"></a>顺序扫描 <code>src/execution/seq_scan_executor.cpp</code></h4><p>在有了前面的铺垫后，顺序扫描的<code>Next()</code>实现就非常简单，只需要返回迭代器指向的<code>Tuple</code>即可。</p><h3 id="插入-src-execution-insert-executor-cpp"><a href="#插入-src-execution-insert-executor-cpp" class="headerlink" title="插入 src/execution/insert_executor.cpp"></a>插入 <code>src/execution/insert_executor.cpp</code></h3><p>insert和delete是唯二的写算子。<br>插入这里多了一个参数<code>child_executor</code>, 右值传入。插入直接将tuple插入到table尾部，然后更新index。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InsertExecutor::<span class="built_in">InsertExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> InsertPlanNode *plan,</span><br><span class="line">                               std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child_executor)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为要更新index，可以通过<code>Catelog-&gt;GetTableIndexes()</code>来获取所有包含这个table的index，这里使用<code>std::vector&lt;IndexInfo *&gt; indexes_;</code> 遍历indexes数组，将每一个index插入B+树即可。<br><code>bpIndex = ... index_.get()</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bpIndex = <span class="keyword">reinterpret_cast</span>&lt;BPlusTreeIndex&lt;GenericKey&lt;<span class="number">8</span>&gt;, RID, GenericComparator&lt;<span class="number">8</span>&gt;&gt; (index-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">bpIndex-&gt;<span class="built_in">InsertEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid, txn); <span class="comment">// insert into B+tree</span></span><br></pre></td></tr></table></figure><p>然后从子计划获取kv, 插入表中 TableHeap, 调用TableHeap中的插入方法即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_heap_-&gt;<span class="built_in">InsertTuple</span>(*tuple, rid, txn);</span><br></pre></td></tr></table></figure><h3 id="删除-src-execution-insert-executor-cpp"><a href="#删除-src-execution-insert-executor-cpp" class="headerlink" title="删除 src/execution/insert_executor.cpp"></a>删除 <code>src/execution/insert_executor.cpp</code></h3><p>删除几乎和插入一样，唯一不同的是把写记录换成删除记录，调用TableHeap中的删除方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">txn-&gt;<span class="built_in">AppendIndexWriteRecord</span>(delete_record);</span><br><span class="line">bpIndex-&gt;<span class="built_in">DeleteEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),*rid, txn);</span><br></pre></td></tr></table></figure><h3 id="索引扫描-src-execution-index-scan-executor-cpp"><a href="#索引扫描-src-execution-index-scan-executor-cpp" class="headerlink" title="索引扫描 src/execution/index_scan_executor.cpp"></a>索引扫描 <code>src/execution/index_scan_executor.cpp</code></h3><p>同样的，bustub封装了<code>IndexIterator</code>指针，用来遍历B+树。指向一个<code>std::pair&lt;KeyType, ValueType&gt;</code>类型。这里的value也就是rid，再通过rid获取tuple。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BPlusTreeIndexForOneIntegerColumn *tree_;</span><br><span class="line">BPlusTreeIndexIteratorForOneIntegerColumn index_iter_;</span><br></pre></td></tr></table></figure><h2 id="Task2-aggr-and-join"><a href="#Task2-aggr-and-join" class="headerlink" title="Task2 aggr and join"></a>Task2 aggr and join</h2><h3 id="聚合-src-execution-aggregation-executor-cpp"><a href="#聚合-src-execution-aggregation-executor-cpp" class="headerlink" title="聚合 src/execution/aggregation_executor.cpp"></a>聚合 <code>src/execution/aggregation_executor.cpp</code></h3><p>在<code>AggregationPlanNode</code>中多了这些参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* Construct a <span class="keyword">new</span> AggregationPlanNode.</span><br><span class="line">   * @param output_schema The output format of <span class="keyword">this</span> plan node</span><br><span class="line">   * @param child The child plan to aggregate data over</span><br><span class="line">   * @param group_bys The group by clause of the aggregation</span><br><span class="line">   * @param aggregates The expressions that we are aggregating</span><br><span class="line">   * @param agg_types The types that we are aggregating</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在聚合执行器中有以下参数</span></span><br><span class="line">  <span class="comment">/** The aggregation plan node */</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  SimpleAggregationHashTable::Iterator aht_iterator_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 构造函数需要改为</span></span><br><span class="line"></span><br><span class="line">AggregationExecutor::<span class="built_in">AggregationExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> AggregationPlanNode *plan,</span><br><span class="line">                                         std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx),</span><br><span class="line">      <span class="built_in">plan_</span>(plan),</span><br><span class="line">      <span class="built_in">child_</span>(std::<span class="built_in">move</span>(child)),</span><br><span class="line">      <span class="built_in">aht_</span>(plan-&gt;<span class="built_in">GetAggregates</span>(), plan-&gt;<span class="built_in">GetAggregateTypes</span>()),</span><br><span class="line">      <span class="built_in">aht_iterator_</span>(aht_.<span class="built_in">Begin</span>())&#123;&#125;</span><br></pre></td></tr></table></figure><p>聚合需要根据<code>group by</code>分组的结果来计算吗，所以这里需要建立一个哈希表用来存储中间结果。和之前每一次只吐一条数据不一样的是，这里必须要在<code>Init()</code>函数中把所有结果计算出来，再在<code> Next()</code> 中一条一条地 emit。所以实际上计算过程是在<code>Init()</code>函数中，通过：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   aht_.<span class="built_in">InsertCombine</span>(<span class="built_in">MakeAggregateKey</span>(&amp;tuple), <span class="built_in">MakeAggregateValue</span>(&amp;tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后注意在<code>Next()</code>函数中，一个tuple可能要返回多个聚集的值，例如查询”SELECT SUM(A), MAX(B), COUNT(C) FROM table”就需要返回一个包含三个聚合结果的元组。所以内部是一个<code>vector</code>。没有返回rid是因为聚集之后产生了新结果，而不是原有的记录。</p><h3 id="inner-join-left-join-src-execution-nested-loop-join-executor-cpp"><a href="#inner-join-left-join-src-execution-nested-loop-join-executor-cpp" class="headerlink" title="inner join &amp; left join src/execution/nested_loop_join_executor.cpp"></a>inner join &amp; left join <code>src/execution/nested_loop_join_executor.cpp</code></h3><p><code>join</code>的时候也是需要建立hash表的，这里是根据join的key来建立哈希表，至于是左表建表还是右表建表，需要看数据库的具体实现。</p><h4 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h4><p>嵌套循环连接是连接算法的一种,它的基本原理是:</p><ul><li>外表和内表,其中外表是驱动表,内表是被驱动表。</li><li>通过外表循环遍历每一行。</li><li>对于外表的每一行,遍历内表找到匹配的行。</li><li>将匹配的外表行和内表行组合,产生连接结果。</li><li>外表的循环嵌套内表的循环,逐行进行连接处理。</li></ul><p>相比其他连接算法如哈希连接和排序合并连接,嵌套循环连接简单直接,但是当表大小不均衡时性能较差。<br>它适用于外表很小而内表较大的情况,或者当连接条件非常复杂时。</p><p>提示： Note for 2022 Fall: You ONLY need to implement left join and inner join.</p><ul><li><p>left join：左表全匹配（没匹配上右表时右表用null填充），右表只匹配join上的</p></li><li><p>inner join： 左表和右表均只匹配能匹配上的</p></li></ul><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>添加成员变量：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The NestedLoopJoin plan node to be executed. */</span></span><br><span class="line"><span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the left side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the right side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;</span><br><span class="line"><span class="comment">/** The output tuple schema. */</span></span><br><span class="line">Schema left_schema_;</span><br><span class="line">Schema right_schema_;</span><br><span class="line"><span class="type">bool</span> is_inner_join_;</span><br><span class="line">std::vector&lt;Value&gt; right_tuples_;</span><br></pre></td></tr></table></figure><p><strong>这里为什么需要把右表的值先全部拿出来呢？</strong><br>假设我们的join逻辑是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> outer_tuple in outer_table:</span><br><span class="line">    <span class="keyword">for</span> inner_tuple in inner_table:</span><br><span class="line">        <span class="keyword">if</span> inner_tuple matched outer_tuple:</span><br><span class="line">            emit</span><br></pre></td></tr></table></figure><p>右表的值会在左表的第一个值做匹配时就完全被消耗掉了。</p><p><strong>left join</strong><br>右值填充空值可以使用 <code>ValueFactory::GetNullValueByType(right_schema_.GetColumn(i).GetType())</code></p><p>比较右表和左表的tuple是否相等可以使用<code>EvaluateJoin(&amp;left_tuple_, &amp;left_schema_, &amp;right_tuple_, &amp;right_schema_);</code></p><h3 id="index-join-src-execution-nested-index-join-executor-cpp"><a href="#index-join-src-execution-nested-index-join-executor-cpp" class="headerlink" title="index join src/execution/nested_index_join_executor.cpp"></a>index join <code>src/execution/nested_index_join_executor.cpp</code></h3><p>索引连接(Index Join)是连接算法的一种优化技术,其主要思想是:</p><p>对于多个表的连接查询,通过在一个表上使用索引来加速连接处理。</p><p>例如对于一个多表连接查询:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id <span class="keyword">JOIN</span> C <span class="keyword">ON</span> B.id <span class="operator">=</span> C.id</span><br></pre></td></tr></table></figure><p>如果在表B的id列上存在索引,可以进行索引连接优化:</p><p>通过扫描表A,获取连接需要的id值。<br>对于表A的每一行,使用表B上的索引直接查找id值,得到B中的匹配行。<br>再扫描表C找到匹配B的行。<br>最终组合A,B,C的匹配行。<br>这样可以利用B表上的索引,避免对B进行全表扫描,从而加速连接查询。</p><p>具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><p>在构造函数中只有一个child_executor，不在是左右孩子的执行器，tuple来源：</p><ul><li>left tuple 来自 child_executor</li><li>right tuple 来自 table</li><li>index scan key 获取 rid, 用rid 获取right tuple</li></ul><h2 id="Task3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task3  Sort + Limit Executors and Top-N Optimization"></a>Task3  Sort + Limit Executors and Top-N Optimization</h2><h3 id="src-execution-sort-executor-cpp"><a href="#src-execution-sort-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;sort_executor.cpp"></a>src&#x2F;execution&#x2F;sort_executor.cpp</h3><p>Sort 也是 pipeline breaker。在 Init() 中读取所有下层算子的 tuple，并按 ORDER BY 的字段升序或降序排序。</p><p>next 函数每次用迭代器返回一个值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt; tuples_; <span class="comment">// 存储所有的值用来排序</span></span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt;::iterator it_;</span><br></pre></td></tr></table></figure><p>根据order by的值来进行升序或者降序排序，这里使用匿名函数自定义排序。然后返回迭代器指向的tuple。</p><h3 id="src-execution-limit-executor-cpp"><a href="#src-execution-limit-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;limit_executor.cpp"></a>src&#x2F;execution&#x2F;limit_executor.cpp</h3><p>使用一个成员变量 <code>limit_</code>来统计输出多少数据即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">limit_ = plan_-&gt;<span class="built_in">GetLimit</span>();</span><br><span class="line"><span class="comment">/// after emit </span></span><br><span class="line">limit_--</span><br></pre></td></tr></table></figure><h3 id="src-execution-topn-execution-cpp"><a href="#src-execution-topn-execution-cpp" class="headerlink" title="src&#x2F;execution&#x2F;topn_execution.cpp"></a>src&#x2F;execution&#x2F;topn_execution.cpp</h3><p>top_n函数：返回最大或者最小的n个tuple</p><p>也是 pipeline breaker，需要在<code>Init()</code>时，使用优先队列。最后每一次调用<code>Next()</code>就从栈中弹出一个。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   pq.<span class="built_in">push</span>(tuple);</span><br><span class="line">   <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>())&#123;</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   stack_.<span class="built_in">push</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">   pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;执行引擎介绍&quot;&gt;&lt;a href=&quot;#执行引擎介绍&quot; class=&quot;headerlink&quot; title=&quot;执行引擎介绍&quot;&gt;&lt;/a&gt;执行引擎介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一条SQL语句进入到数据库中后是如何被执行的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 B+tree</title>
    <link href="http://example.com/2023/08/17/B-tree/"/>
    <id>http://example.com/2023/08/17/B-tree/</id>
    <published>2023-08-16T23:07:54.000Z</published>
    <updated>2024-03-30T03:53:16.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树的介绍（以InnoDB为例）"><a href="#B-树的介绍（以InnoDB为例）" class="headerlink" title="B+树的介绍（以InnoDB为例）"></a>B+树的介绍（以InnoDB为例）</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>B+树只有叶子结点存储数据，内部节点和根结点只存储索引。</p><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><h2 id="bustub"><a href="#bustub" class="headerlink" title="bustub"></a>bustub</h2><p>在这这个实验中只需要实现三个接口：查询、插入和删除。</p><p>需要使用我们在 Project 1 中实现的 buffer pool manager 来获取 page。</p><p>internal page 中，KV 对的 K 是能够比较大小的索引，V 是 page id，用来指向下一层的节点。</p><p>leaf page 和 internal page 的内存布局基本一样，只是 leaf page 多了一个成员变量 <code>next_page_id</code>，指向下一个 leaf page（用于 range scan）</p><p>internal page 中储存 key 和 child page id，那么在拿到 page id 后如何获得对应的 page 指针？用 Project 1 中实现的 buffer pool。</p><p><code>Page *page = buffer_pool_manager_-&gt;FetchPage(page_id);</code></p><p>新建一个结点&#x2F;Page, 示例为新建root</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">page_id_t</span> page_id;</span><br><span class="line">Page *page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;page_id);</span><br><span class="line"><span class="keyword">auto</span> leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">leaf_node-&gt;<span class="built_in">Init</span>(page_id, INVALID_PAGE_ID, leaf_max_size_);</span><br><span class="line">root_page_id_ = page_id;</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page_id, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>找到leaf page，然后二分法找到key，就能够找到对应的record id。</p><p>唯一要注意的问题就是我们在拿到 page id 后，调用 buffer pool 的 FetchPage() 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，无法从 disk 读取其他的 page。比较合适的做法是，在本次操作中，找出 page 最后一次被使用的地方，并在最后一次使用后 unpin。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>假设叶子结点插入值之后满了，要考虑break的问题，要向父节点中插入break之后新的索引，假设父节点也满了，也要break（这是一个递归的过程），注意这里内部节点的第一个位置只存放value，而不存放key</p><p><img src="/../imgs/B+insert.png"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete的时候，如果当前节点小于最小size（Max size&#x2F;2），首先考虑从兄弟结点偷一个过来，如果兄弟结点投不了，就考虑merge。因为是一个向上递归删除的过程，所以merge的时候要区分是叶节点还是内部节点。</p><p>这里注意是先删除再做merge或者偷一个key</p><p><img src="/../imgs/b+delete.png"></p><h3 id="锁的问题："><a href="#锁的问题：" class="headerlink" title="锁的问题："></a>锁的问题：</h3><p>螃蟹式加锁（区分读锁和写锁）</p><p>参考课件:<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf</a></p><p>先给父节点加锁，然后给子节点加锁，如果确认子节点安全（不会发生merge或者break），此时解锁父节点</p><p><img src="/../imgs/image-22.png" alt="Alt text"></p><p>当寻找兄弟结点时，一个指针往前走，假设另一个进程在往后寻找兄弟结点，此时会不会发生死锁？</p><p>不会，因为当子节点需要寻找兄弟节点时，说明此时该节点不安全，所以父节点的锁不会释放，也就意味着另一个子进程拿不到父节点的锁，只会等待。</p><p>如何确定该page有没有被锁住？使用事务管理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树的介绍（以InnoDB为例）&quot;&gt;&lt;a href=&quot;#B-树的介绍（以InnoDB为例）&quot; class=&quot;headerlink&quot; title=&quot;B+树的介绍（以InnoDB为例）&quot;&gt;&lt;/a&gt;B+树的介绍（以InnoDB为例）&lt;/h2&gt;&lt;p&gt;InnoDB 的数据</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 buffer pool manager</title>
    <link href="http://example.com/2023/08/17/bufferpool/"/>
    <id>http://example.com/2023/08/17/bufferpool/</id>
    <published>2023-08-16T22:29:40.000Z</published>
    <updated>2024-03-30T03:53:39.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库中为什么需要buffer-pool？"><a href="#数据库中为什么需要buffer-pool？" class="headerlink" title="数据库中为什么需要buffer pool？"></a>数据库中为什么需要buffer pool？</h3><p>数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p><p>要想提升查询性能，添加缓存。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>通常存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在MySQL中，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页(<code>frame</code>)， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲(<code>free list</code>)的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><h3 id="Buffer-Pool-Manager-需要实现的功能："><a href="#Buffer-Pool-Manager-需要实现的功能：" class="headerlink" title="Buffer Pool Manager 需要实现的功能："></a>Buffer Pool Manager 需要实现的功能：</h3><p><code>auto NewPgImp(page_id_t *page_id) -&gt; Page * override</code><br>返回一个<code>Page</code>（首先检查free list中有没有空闲的Page，如果有从free list返回，如果没有使用LRU_K算法replace一个页面之后返回, 注意这里的<code>page_id</code>是一个传入参数）</p><p><code>auto FetchPgImp(page_id_t page_id) -&gt; Page * override;</code><br>在buffer pool中可能存在这个page_id, 标记为visit之后返回，不存在就和创建新的Page一样操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a>Extendible Hash Table</h3><h4 id="为什么这里需要一个hash表？"><a href="#为什么这里需要一个hash表？" class="headerlink" title="为什么这里需要一个hash表？"></a>为什么这里需要一个hash表？</h4><p>外部使用的参数为<code>page_id</code> , 内部转换为<code>frame_id</code>, 每一个frame对应着一个page。从<code>page_id</code>转换为<code>frame_id</code>通过hash表实现。</p><p><strong>重点在于如何去管理桶，当桶满了再插入时应该如何操作。</strong></p><p>每个桶（bucket）都有一个本地深度（local depth）和一个全局深度（global depth）</p><p>本地深度是指每个桶中存储的键值对的哈希值的前缀长度。例如，如果本地深度为2，则桶中存储的键值对的哈希值的前两位必须相同。</p><p>全局深度是指哈希表中所有桶的本地深度的最大值。它表示哈希表的索引空间的大小。</p><p>如果插入时全局深度等于本地深度，哈希目录扩展为两倍（左移一位）<br>此时针对桶的处理最简单的办法是也新建一倍的桶，每一个桶对应着每个索引，但是这样很浪费空间，当有数据插入的时候再考虑新建桶。<br>扩展目录为double，更新index，将桶中的数据重新插入到新的桶中。</p><p><img src="/../imgs/image-21.png" alt="Alt text"></p><h3 id="LRU-K算法"><a href="#LRU-K算法" class="headerlink" title="LRU_K算法"></a>LRU_K算法</h3><p>和传统的LRU不一样的地方在于，传统的LRU是淘汰最近未使用的，而LRU_K多维护了一个record链表，用于记录访问次数大于等于K的Page，当淘汰时优先淘汰访问次数小于K次的，若所有的Page访问次数都大于K次才从record链表中去淘汰。</p><p><img src="/../imgs/image-20.png" alt="Alt text"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/../imgs/bufferpool.png"></p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li><p>是否是dirty，是在Page内部用变量标识的，在buffer pool中没有使用额外的list管理脏页。</p></li><li><p>在buffer pool中的Page array的作用：<code>pages_</code>用来管理已经在bufferp pool中的Page</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">    pages_[frame_id].pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库中为什么需要buffer-pool？&quot;&gt;&lt;a href=&quot;#数据库中为什么需要buffer-pool？&quot; class=&quot;headerlink&quot; title=&quot;数据库中为什么需要buffer pool？&quot;&gt;&lt;/a&gt;数据库中为什么需要buffer pool？&lt;/</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>malloc是如何和物理地址关联上的？</title>
    <link href="http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/"/>
    <id>http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/</id>
    <published>2023-08-16T09:38:52.000Z</published>
    <updated>2024-03-30T03:55:21.277Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-19.png"></p><ol><li><p>malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。</p></li><li><p>操作系统维护着可用物理内存的信息,知道哪些内存地址 当前未被使用。当收到malloc的请求时,它会从可用物理内存中选择一块未使用的内存,将其标记为已分配,并返回给应用程序。</p></li><li><p>在32位系统中,malloc返回的地址是虚拟地址,需要经过MMU地址转换找到对应的物理地址。64位系统中,malloc的地址空间通常就直接对应物理地址空间。</p><p> a. 在32位系统中,CPU可以寻址的虚拟地址空间比较小,一般为4GB左右。而物理内存可能会超过4GB。为了让进程可以访问超过4GB的物理内存,操作系统会使用虚拟内存技术,将虚拟地址映射到物理地址上。malloc返回的虚拟地址需要通过MMU(内存管理单元)翻译成物理地址,才能真正访问到内存。</p><p> b. 而在64位系统中,虚拟地址空间巨大(16EB),远远大于当前的物理内存大小。所以操作系统可以选择把虚拟地址直接映射到物理地址上,这种称为平坦内存模型。在这种情况下,malloc返回的地址就是物理地址,不需要再做地址转换。应用程序把malloc返回的地址直接作为物理地址使用即可。</p></li></ol><h3 id="平坦内存模型-Flat-Memory-Model"><a href="#平坦内存模型-Flat-Memory-Model" class="headerlink" title="平坦内存模型(Flat Memory Model)"></a>平坦内存模型(Flat Memory Model)</h3><ol><li>在平坦内存模型下,进程的虚拟地址与物理地址是一一对应的。操作系统不会进行地址转换,进程使用的虚拟地址就是对应物理内存的物理地址。</li><li>由于虚拟地址直接对应物理地址,不需要进行地址转换,所以省去了地址转换所带来的性能开销。</li><li>程序直接使用虚拟地址访问物理内存,不需要区分逻辑地址和物理地址,编程模型简单。</li><li>64位系统拥有极其大的虚拟地址空间(16EB),使得直接映射成为可能。虚拟地址空间大于目前的物理内存容量。</li><li>由于省去了内存虚拟化,无法实现弹性调配物理页框,可能会出现较严重的内存碎片。</li><li>很多64位系统不会选择完全平坦的模型,而是在一定范围内做映射,同时配合页表实现虚拟内存。综合利用了平坦模型与传统虚拟内存的优点。</li></ol><h3 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU(Memory Management Unit)"></a>MMU(Memory Management Unit)</h3><p>有些系统MMU集成在CPU中，有些系统是单独芯片实现，通过地址总线和CPU连接。（地址总线、数据总线、控制总线–&gt;传递信号）</p><ol><li>地址转换 MMU负责将CPU产生的虚拟地址转换成物理地址。转换过程需要参考TLB,根据虚拟地址的高位找到对应的页表项,翻译出物理页号,与虚拟地址的低位组合成物理地址。</li><li>页面置换 当访问的页面不在物理内存时,MMU会触发页面置换（<em>页面置换算法通常不是由MMU(内存管理单元)直接实现的,而是由操作系统内核的虚拟内存管理子系统来实现。页表和地址转换是由MMU硬件来完成,但确定哪些页面需要换出、加载,以及页面替换策略则由操作系统内核的虚拟内存管理机制决定。</em>）,将内存中的某一页换出,将需要访问的页换入物理内存。</li><li>存取权限检查 MMU会检查每次地址转换后的物理内存访问权限,例如是否可读、可写、可执行,避免非法访问。</li><li>缓存一致性 MMU会与CPU缓存协同工作,实现缓存一致性,保证内存访问正确。</li><li>地址空间隔离 MMU为每个进程维护一个独立的地址空间,实现进程间的内存隔离。</li><li>中断与异常 若地址非法或者缺页等异常,MMU会触发中断信号,通知CPU进行异常处理。</li><li>硬件缓存 部分MMU集成了TLB等缓存结构,加速地址转换的速度。</li></ol><h3 id="为什么MMU可以解决内存碎片的问题？"><a href="#为什么MMU可以解决内存碎片的问题？" class="headerlink" title="为什么MMU可以解决内存碎片的问题？"></a>为什么MMU可以解决内存碎片的问题？</h3><ol><li>MMU实现了虚拟地址到物理地址的映射,程序只需要一个连续的虚拟地址空间。操作系统可以将不连续的物理内存片段映射到该连续虚拟地址空间上。通过这种映射,即使物理内存分布不连续,程序视图也是一个连续空间,可以任意使用而不会出现碎片。操作系统会负责这些不连续物理页的映射和调度,对上层应用透明。</li><li>当物理内存使用产生外部碎片时,虚拟存储技术可以进行碎片回收,将闲置的小块内存映射给其他程序使用。</li><li>同时,虚拟内存可以将暂时不用的内存页换出到磁盘,腾出物理内存空间供其他程序使用,减少内存碎片。</li><li>进而避免了严重的外部碎片,提高了物理内存的利用效率。</li></ol><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>一个计算系统通常包含多级缓存,任何两个存储层次之间都可能存在数据一致性的问题。</p><ol><li><p>CPU缓存与硬盘缓存</p></li><li><p>多核CPU之间</p></li><li><p>各级系统缓存之间</p><p> MMU与CPU缓存的一致性是通过以下几种方式实现的:<br> a. 缓存一致性协议 CPU和MMU之间通过一定的硬件协议(如Intel的MESI协议)来维持缓存和主存的数据一致性。当缓存数据被修改时,会根据协议规则通知MMU将主存更新。</p><p> b. 缓存锁定 针对一些关键数据,CPU缓存会被锁定,每次访问必须从MMU加载,而不是缓存中的拷贝。保证了这部分数据的一致性。</p><p> c. 地址翻译表同步 地址翻译表如TLB也存放在CPU高速缓存中,MMU会同步更新CPU中的翻译表缓存,保证访问获取的是最新翻译关系。</p><p> d. 缓存行注释 MMU可以向缓存中的缓存行添加标记信息,如是否可缓存、是否已修改等,方便缓存控制。</p></li><li><p>分布式缓存系统</p></li><li><p>存储设备之间</p></li><li><p>客户端缓存</p></li></ol><h3 id="malloc调用时什么时候用sys-mmap-什么时候用brk？"><a href="#malloc调用时什么时候用sys-mmap-什么时候用brk？" class="headerlink" title="malloc调用时什么时候用sys_mmap, 什么时候用brk？"></a>malloc调用时什么时候用sys_mmap, 什么时候用brk？</h3><p>在调用malloc时会产生系统调用，切换到内核态，然后执行系统调用<br>在malloc调用时,是否使用sys_mmap或brk分配内存,主要取决于请求的内存大小:</p><ol><li>对于较小的内存请求,malloc通常会使用brk系统调用去扩展程序的堆区。</li><li>当请求较大内存页(一般超过128KB)时,malloc会使用mmap系统调用去映射匿名内存页。</li></ol><p>mmap相比brk的优势在于:</p><ul><li>可以指定地址对齐,提高效率</li><li>可以随时释放不连续的大内存块</li><li>避免堆区碎片</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-19.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统维护着可用物理内存的信息,知道</summary>
      
    
    
    
    <category term="Operating System" scheme="http://example.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo Cannot GET/</title>
    <link href="http://example.com/2023/08/15/hexo_Cannot_GET/"/>
    <id>http://example.com/2023/08/15/hexo_Cannot_GET/</id>
    <published>2023-08-14T23:33:02.000Z</published>
    <updated>2024-03-30T03:54:56.007Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>在hexo搭建博客的过程中，出现Cannot GET&#x2F;xxx的错误。</p><h3 id="查看是否缺少组件"><a href="#查看是否缺少组件" class="headerlink" title="查看是否缺少组件"></a>查看是否缺少组件</h3><ol><li><p>到public目录下找到xxx文件是否存在，我的错误是<code>Cannot GET/</code>，所以去找<code>index.html</code>是否存在。</p></li><li><p>不存在，执行<code>hexo clean &amp;&amp; hexo g</code>重新生成</p></li><li><p>还是不存在，执行<code>npm audit fix</code>或者是<code>npm ls --depth 0</code>，查看是否缺少组件。通过<code>npm install hexo-xxx-xxx</code>安装</p></li><li><p>执行完毕后发现我并不缺少组件。尝试其他解决办法。</p></li></ol><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p><code>config–&gt;index.js</code>中的 <code>assetsPublicPath: &#39;/&#39;</code>改成<code>assetsPublicPath: ‘./’</code></p><h3 id="没有文件"><a href="#没有文件" class="headerlink" title="没有文件"></a>没有文件</h3><p>在路径<code>\source\_posts\</code>中至少需要存放一篇文档，否则会出现<code>Cannot GET/</code>错误。</p><h3 id="nodejs等级太高"><a href="#nodejs等级太高" class="headerlink" title="nodejs等级太高"></a>nodejs等级太高</h3><p>官方文档参考链接：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><p><img src="/../imgs/image-1.png"></p><h3 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h3><p>将所有markdown文件的名称替换为英文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hexo搭建博客的过程中，出现Cannot GET&amp;#x2F;xxx的错误。&lt;/p&gt;
&lt;h3 id=&quot;查看是否缺少组件&quot;&gt;&lt;a href=&quot;#查看是否缺少组件&quot; class=&quot;headerlink&quot; title=&quot;查</summary>
      
    
    
    
    <category term="Solutions" scheme="http://example.com/categories/Solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解合集</title>
    <link href="http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/</id>
    <published>2022-10-14T23:33:02.000Z</published>
    <updated>2024-03-30T03:55:14.270Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS&#x2F;回溯"></a>DFS&#x2F;回溯</h3><p><strong>以整数拆分为例：</strong><br><img src="/../imgs/image-5.png"></p><p><strong>剪枝条件</strong></p><ul><li>当和为n时，保存结果</li><li>当和大于n时，进行剪枝</li></ul><p>在DFS中，同一排的结点是在同一个函数调用中进行处理，如上图中的第一排，1、2、3、4、这4个结点是在第一次函数调用中进行处理。</p><p><strong>因此使用一个for循环来处理同一排的结点。</strong><br>因为元素可以重复取用，本来for循环的起始位置应该都为1，但是为了避免重复，我们可以假设for循环的起始位置为其父节点的值，这里用变量<code>index</code>表示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="comment">//n表示要拆分的数 index表示当前函数从哪个数开始拆 sum表示当前的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n) &#123;<span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">myPrint</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) <span class="keyword">return</span>;<span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; ++i) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//元素可以重复使用，下一次还是从i开始拆分，拆到n为止</span></span><br><span class="line">        <span class="built_in">split</span>(n, i, sum + i);</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combinations/">77 组合</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">216. 组合总和 III</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">39. 组合总和</a><br><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/c-hui-su-suan-fa-by-sdy-r-6soj/">17. 电话号码的字母组合</a><br><a href="https://leetcode.cn/problems/combination-sum-ii/solution/by-sdy-r-vecj/">40. 组合总和 II</a><br><a href="https://leetcode.cn/problems/subsets-ii/solution/by-sdy-r-nehc/">90. 子集 II</a><br><a href="https://leetcode.cn/problems/permutations-ii/solution/by-sdy-r-fiul/">47. 全排列 II</a><br><a href="https://blog.csdn.net/wenningker/article/details/124399435?spm=1001.2014.3001.5502">679. 24点游戏</a><br><a href="https://leetcode.cn/problems/longest-univalue-path/solution/by-sdy-r-0cz4/">687. 最长同值路径</a></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://www.bilibili.com/video/BV1X741127ZM/?spm_id_from=333.337.search-card.all.click&vd_source=59139a795dc5f3ee3da07683650b7b16">一个超级实用的视频</a><br><strong>状态表示：</strong><br>f 函数代表什么状态？<br>写出状态表示之后我们会有一个f函数的集合，代表递推到f(i)时，有多少种可能的状态。</p><p><strong>动态转移方程</strong><br>把集合中的每一种可能表示出来，对应要求的结果（求最大、最小、求和等）写出动态转移方程。</p><ul><li>状态表示</li><li>状态集，从状态集求出当前状态</li></ul><p><strong>思考当前状态对比前一个状态会有什么变化：</strong></p><ul><li>从前一步加1？</li><li>等于前一步？</li></ul><p><strong>如下图所示</strong><br><img src="/../imgs/image-7.png"></p><p><a href="https://blog.csdn.net/wenningker/article/details/124410311?spm=1001.2014.3001.5502">路径和有关的题目</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/by-sdy-r-6p9s/">714. 买卖股票的最佳时机含手续费</a></p><p><a href="https://leetcode.cn/problems/word-break/solution/by-sdy-r-cj3h/">139. 单词拆分</a></p><p><a href="https://leetcode.cn/problems/integer-break/solution/by-sdy-r-q33e/">343. 整数拆分</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/solution/by-sdy-r-9rnk/">337. 打家劫舍 III</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/by-sdy-r-hrxf/">300. 最长递增子序列</a></p><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/solution/by-sdy-r-atvj/">940. 不同的子序列 II</a></p><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/solution/by-sdy-r-g02s/">646. 最长数对链</a></p><p><a href="https://leetcode.cn/problems/triangle/solution/by-sdy-r-fuap/">120. 三角形最小路径和</a></p><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a></p><p><a href="https://leetcode.cn/problems/wildcard-matching/solution/by-sdy-r-pm4u/">44. 通配符匹配</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/by-sdy-r-boss/">72. 编辑距离</a></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><strong>每次选取局部最优解，得到最终的最优解。</strong><br><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a><br><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/by-sdy-r-3ec9/">406. 根据身高重建队列</a><br><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/by-sdy-r-17wh/">452. 用最少数量的箭引爆气球</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列 小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//降序队列  大顶堆 默认情况</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/meeting-rooms-iii/solution/by-sdy-r-xle0/">2402. 会议室 III</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124468136?spm=1001.2014.3001.5501">23. 合并k个有序链表</a></p><h4 id="数组-链表-哈希"><a href="#数组-链表-哈希" class="headerlink" title="数组&#x2F;链表&#x2F;哈希"></a>数组&#x2F;链表&#x2F;哈希</h4><p><strong>数组：</strong> 查找效率高，插入和删除效率低<br><strong>链表：</strong> 插入删除效率高，查找效率低</p><p><strong>哈希：</strong> </p><ul><li>思想：通过哈希函数得到的键值，使其能够高效查找</li><li>当键值重复时，处理哈希冲突</li><li>在C++中unordered_set 和unordered_map的底层实现时哈希表</li></ul><p><a href="https://leetcode.cn/problems/4sum-ii/solution/by-sdy-r-jlw2/">454. 四数相加 II</a><br><a href="https://leetcode.cn/problems/optimal-partition-of-string/solution/by-sdy-r-uq9h/">2405. 子字符串的最优划分</a><br><a href="https://leetcode.cn/problems/most-popular-video-creator/solution/by-sdy-r-tknt/">6221. 最流行的视频创作者</a></p><h4 id="栈-队列"><a href="#栈-队列" class="headerlink" title="栈&#x2F;队列"></a>栈&#x2F;队列</h4><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a><br><a href="https://leetcode.cn/problems/parsing-a-boolean-expression/solution/c-by-sdy-r-nxof/">1106. 解析布尔表达式</a></p><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。<br><a href="https://leetcode.cn/problems/daily-temperatures/solution/by-sdy-r-7za8/">739. 每日温度</a><br><a href="https://leetcode.cn/problems/next-greater-element-ii/solution/by-sdy-r-t3b7/">503. 下一个更大元素 II</a></p><h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p><a href="https://blog.csdn.net/wenningker/article/details/126799292?spm=1001.2014.3001.5502">前缀树</a></p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>并查集由两个部分构成：</strong></p><ul><li><code>find()</code>函数，发现x的根</li><li><code>Union()</code>函数，合并</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化，最初每个元素的根都是自己</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        parent.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发现x的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfind</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] != x) &#123;</span><br><span class="line">        parent[x] = <span class="built_in">myfind</span>(parent,parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将y的根给x的根，将x和y合并为一堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myunion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    parent[<span class="built_in">myfind</span>(parent,x)] = <span class="built_in">myfind</span>(parent,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wenningker/article/details/124127763?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166597671316800186587518%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166597671316800186587518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-124127763-null-null.nonecase&utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2226.3001.4450">并查集</a></p><p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p><p><a href="https://leetcode.cn/problems/shortest-bridge/solution/by-sdy-r-ao55/">934. 最短的桥</a> BFS+DFS</p><p><a href="https://leetcode.cn/problems/redundant-connection/solutions/2401010/c-bing-cha-ji-tuo-bu-pai-xu-by-sdy-r-48sg/">684. 冗余连接</a> 并查集+拓扑排序</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h3 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针&#x2F;滑动窗口"></a>双指针&#x2F;滑动窗口</h3><p><strong>主要是考虑左指针往右走的条件。</strong><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/solution/by-sdy-r-yayj/">209. 长度最小的子数组</a></p><p><a href="https://leetcode.cn/problems/minimum-window-substring/solution/by-sdy-r-zwx8/">76. 最小覆盖子串</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124530777?spm=1001.2014.3001.5502">90. 水果成蓝</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/longest-nice-subarray/solution/by-sdy-r-glyh/">2401. 最长优雅子数组</a></p><p><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-sdy-r-sm3x/">915. 分割数组</a></p><p><a href="https://leetcode.cn/problems/sort-colors/solution/by-sdy-r-tg7s/">75. 颜色分类</a></p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/kuai-man-zhi-zhen-yi-bian-sao-miao-by-sd-pwps/">19. 删除链表的倒数第 N 个结点</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>对于二叉树来书，考虑遍历方式：</p><ul><li>前序遍历：先处理父节点，再处理孩子节点</li><li>中序遍历：先处理左孩子，再处理父节点，最后处理右孩子</li><li>后序遍历：先处理孩子结点，再处理父节点</li></ul><p><strong>大部分题目都是使用的后序遍历来求解：因为处理父节点时往往需要用到子节点的结果</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/by-sdy-r-307g/">106. 从中序与后序遍历序列构造二叉树</a></p><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/solution/by-sdy-r-6m2z/">98. 验证二叉搜索树</a></p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-sdy-r-n5e3/">236. 二叉树的最近公共祖先</a></p><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/by-sdy-r-vovn/">701. 二叉搜索树中的插入操作</a></p><p><a href="https://leetcode.cn/problems/maximum-binary-tree-ii/solution/by-sdy-r-96ic/">998. 最大二叉树 II</a></p><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/by-sdy-r-x7yd/">538. 把二叉搜索树转换为累加树</a></p><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution/c-by-sdy-r-osdi/">6242. 二叉搜索树最近节点查询</a><br>序列化二叉搜索树</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><table><thead><tr><th>操作</th><th>结果</th><th>特性</th></tr></thead><tbody><tr><td>~</td><td>取反，0变为1，1变为0</td><td></td></tr><tr><td>a&amp;b</td><td>且，ab同时为1时才取1</td><td>a &amp; b &lt;&#x3D; min(a,b)，交换律、结合律，越取越小</td></tr><tr><td>a 或 b</td><td>a和b其中有一个为1，最终结果就是1</td><td>越取越大</td></tr><tr><td>a ^ b</td><td>a和b相同时为1，不同为0</td><td></td></tr><tr><td>&lt;&lt; 和 &gt;&gt;</td><td>左移一位，相当于*2，右移一位，相当于&#x2F;2</td><td></td></tr></tbody></table><p><a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solution/by-sdy-r-6vt8/">2419. 按位与最大的最长子数组</a></p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p><strong>根据题意模拟，主要是代码细节要注意。</strong></p><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/by-sdy-r-g20f/">59. 螺旋矩阵 II</a></p><p><a href="https://leetcode.cn/problems/EXvqDp/solution/by-sdy-r-wlw0/">LCP 63. 弹珠游戏</a></p><p><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/by-sdy-r-yemm/">1441. 用栈操作构建数组</a></p><p><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/by-sdy-r-alxj/">779. 第K个语法符号</a></p><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/solution/by-sdy-r-a32l/">6222. 美丽整数的最小增量</a></p><p><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution/by-sdy-r-lrwi/">1620. 网络信号最好的坐标</a></p><p><a href="https://leetcode.cn/problems/global-and-local-inversions/solution/c-by-sdy-r-8gqu/">775. 全局倒置与局部倒置</a></p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>主要多考虑组合数学</p><p><strong>从起点到终点的所有路径：给定一个$n$和一个$k，n$代表要走的步数，$k$代表终点，从0出发，每次可以选择往左走或者往右走，走到$k$，有多少种路径？</strong></p><ol><li>假设$a$等于往右走的步数，往左走的步数为$k-a$,走到$n$时的步数为$a-(k-a)&#x3D;a$，$a&#x3D;(k+n)&#x2F;2$</li><li>当且仅当$(k+n)$为偶数时有解</li><li>等价于从$k$步里面选$a$步往右走，所以结果是$C^{(k+n)&#x2F;2}_k$</li></ol><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><strong>C++如何计算组合数？</strong></p><p>从<code>n</code>个里面选<code>m</code>个，当前这个选，就变为从<code>n-1</code>个里面选<code>m-1</code>个，当前不选，就变成从<code>n-1</code>个里面选<code>m</code>个。</p><p>根据公式:：$C_n^m&#x3D;C^m_{n-1}+C_{n-1}^{m-1}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span> || m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m] != <span class="number">0</span>)<span class="keyword">return</span> res[n][m];<span class="comment">//保存状态</span></span><br><span class="line">    <span class="keyword">return</span> res[n][m] = <span class="built_in">C</span>(n<span class="number">-1</span>,m)+ <span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);<span class="comment">//赋值给res[n][m]并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">C</span>(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排序不等式：</strong><br>$a_1 \leq a_2 \leq … \leq a_n$<br>$b_1 \leq b_2 \leq … \leq b_n$</p><p>最大值&#x3D; $a_1b_1+a_2b_2+…+a_nb_n$<br>最小值&#x3D; $a_1b_n+a_2b_{n-1}+…+a_nb_1$</p><p><strong>求解最大公约数和最小公倍数</strong></p><ul><li>最大公约数：数组中所有数都能整除的最大数</li><li>最小公倍数：数组中所有数的最小倍数</li></ul><p>$a和b的最小公倍数&#x3D;a*b&#x2F;(a和b的最大公约数)$<br>求解最大公约数使用<code>gcd(a,b)</code>函数</p><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution/-by-sdy-r-z1sc/">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/">6234. 最小公倍数为 K 的子数组数目</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">2447. 最大公因数等于 K 的子数组数目</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DFS-回溯&quot;&gt;&lt;a href=&quot;#DFS-回溯&quot; class=&quot;headerlink&quot; title=&quot;DFS&amp;#x2F;回溯&quot;&gt;&lt;/a&gt;DFS&amp;#x2F;回溯&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;以整数拆分为例：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/../i</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://example.com/categories/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>C++实现一个简单的线程池</title>
    <link href="http://example.com/2022/09/15/%E3%80%90c++%E3%80%91%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/09/15/%E3%80%90c++%E3%80%91%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-09-14T23:33:02.000Z</published>
    <updated>2024-03-30T03:52:10.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-8.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="任务结构体"><a href="#任务结构体" class="headerlink" title="任务结构体"></a>任务结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务结构体</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Task</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Task</span>(callback function,<span class="type">void</span>* arg):</span><br><span class="line">    <span class="built_in">function</span>(function),<span class="built_in">arg</span>(arg)&#123;&#125;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    callback function;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//取出任务</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取当前任务的个数，内联函数不会进行压栈，通过代码替换实现</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">taskNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//添加互斥锁</span></span><br><span class="line">    queue&lt;Task&gt; m_taskQ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//给线程池添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBusyNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLiveNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//工作的线程任务函数</span></span><br><span class="line">    <span class="comment">//静态成员函数定义时就分配地址，普通成员函数只有实例化才有地址</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程任务函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//单个线程退出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQ;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadID;<span class="comment">//工作线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙的线程个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//存活的线程个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;<span class="comment">//锁定整个线程池</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列是否为空</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;<span class="comment">//每次创建线程的数量</span></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是不是要销毁线程池，销毁为1，不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(<span class="built_in">Task</span>(f,arg));</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">if</span>(!m_taskQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t = m_taskQ.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQ.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max)&#123;</span><br><span class="line">        <span class="comment">//实例化任务队列</span></span><br><span class="line">        taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(taskQ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat tackqueue error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        threadID = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line">        <span class="keyword">if</span>(threadID == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat threadpool error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(threadID,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;mutexPool,<span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty,<span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;mutex or condition init fail...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程，参数：线程，线程的属性，线程要执行的函数，该函数传入的参数</span></span><br><span class="line">        <span class="comment">//成功返回0，失败返回非0值</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID,<span class="literal">NULL</span>,manager,<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; minNum;++i)&#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadID[i],<span class="literal">NULL</span>,worker,<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    shutdown = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//回收管理者线程</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(managerID,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//唤醒阻塞的工作线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; liveNum;++i)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程和进程</span></span><br><span class="line">    <span class="keyword">if</span>(threadID) <span class="keyword">delete</span>[]threadID;</span><br><span class="line">    <span class="keyword">if</span>(taskQ) <span class="keyword">delete</span> taskQ;</span><br><span class="line">    <span class="comment">//销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutexPool);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给线程池添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里访问任务队列不需要再加锁，因为再任务队列的添加操作里已经加了锁</span></span><br><span class="line">    <span class="comment">//pthread_mutex_lock(&amp;mutexPool);</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    taskQ-&gt;<span class="built_in">addTask</span>(task);</span><br><span class="line">    <span class="comment">//有任务了唤醒工作线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="comment">//这里不能直接返回，否则会发生死锁</span></span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getLiveNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作的线程任务函数</span></span><br><span class="line"><span class="comment">//这里需要把pool传进来是因为这个函数是静态成员函数，无法访问非静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt; (arg);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//因为每一个线程都需要对这个线程池进行操作，所以这里要对线程池加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//当前任务队列是否为空，且线程池没有被关闭</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="comment">//阻塞工作线程</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">//判断是否要销毁线程(该线程被唤醒之后)</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断线程池是否关闭了</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从任务队列中取出一个任务</span></span><br><span class="line">        Task task = pool-&gt;taskQ-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line">        <span class="comment">//忙的线程数加一</span></span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="comment">//用完解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot;start working...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);</span><br><span class="line">        <span class="comment">//delete task.arg;</span></span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务执行完毕</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)&#123;</span><br><span class="line">        <span class="comment">//每隔三秒检测一次</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//取出线程池中的任务数量和当前线程的数量</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//任务数量</span></span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>();</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        <span class="comment">//取出忙的线程数量</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//添加线程</span></span><br><span class="line">        <span class="comment">//任务的个数大于存活的线程数&amp;&amp;存活的线程数小于最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;maxNum &amp;&amp;</span><br><span class="line">            i &lt; pool-&gt;NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadID[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadID[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁线程</span></span><br><span class="line">        <span class="comment">//忙的线程*2小于存活的线程数&amp;&amp;存活的线程数大于最小线程数</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = pool-&gt;NUMBER;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;NUMBER;++i)&#123;</span><br><span class="line">                <span class="comment">//唤醒线程，然后销毁,因为工作的线程没被阻塞，这里唤醒被阻塞的线程</span></span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单个线程退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程的ID</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; maxNum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(threadID[i] == tid)&#123;</span><br><span class="line">            threadID[i] = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;threadExit() called,&quot;</span>&lt;&lt;tid&lt;&lt;<span class="string">&quot;exiting...\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(arg);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>())&lt;&lt;<span class="string">&quot;working,number=&quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(i + <span class="number">100</span>);</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>(taskFunc,num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-8.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;任务结构体&quot;&gt;&lt;a href=&quot;#任务结构体&quot; c</summary>
      
    
    
    
    <category term="CPP" scheme="http://example.com/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
</feed>
