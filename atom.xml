<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-23T06:31:05.492Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>one-hot编码</title>
    <link href="http://example.com/2024/09/23/one-hot%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2024/09/23/one-hot%E7%BC%96%E7%A0%81/</id>
    <published>2024-09-23T06:22:51.000Z</published>
    <updated>2024-09-23T06:31:05.492Z</updated>
    
    <content type="html"><![CDATA[<p>One-hot 编码是一种将类别数据（比如文本或分类标签）转换为数值表示的方法。它的基本思想是用一个二进制向量来表示每个类别，其中只有一个位置为1，其他位置全为0。</p><p>为什么需要 One-hot 编码？<br>在机器学习中，算法通常无法直接处理文字或类别，需要先将它们转化为数值才能输入模型。而 One-hot 编码就是其中一种常用的数值化方法。</p><h2 id="具体操作步骤："><a href="#具体操作步骤：" class="headerlink" title="具体操作步骤："></a>具体操作步骤：</h2><ol><li>记录每个特征的类别数量<br>在编码时，记录下每个特征有多少类别以及每个类别的顺序。例如：</li></ol><p>颜色特征：有3个类别 -&gt; [“红色”, “绿色”, “蓝色”]</p><p>大小特征：有2个类别 -&gt; [“小”, “大”]</p><ol start="2"><li>确定编码位置<br>在编码时，按照顺序将每个特征的 One-hot 向量拼接起来。根据特征的类别数量，确定每个特征占据向量中的哪些位置。</li></ol><p>例如：</p><p>颜色有3个类别，所以编码的第1到3个位置对应颜色：</p><p>红色 [1, 0, 0]<br>绿色 [0, 1, 0]<br>蓝色 [0, 0, 1]</p><p>大小有2个类别，所以编码的第4到5个位置对应大小：</p><p>小 [1, 0]<br>大 [0, 1]</p><p>因此，对于编码向量 [1, 0, 0, 0, 1]，我们知道：</p><p>前3个元素 [1, 0, 0] 对应颜色特征。<br>后2个元素 [0, 1] 对应大小特征。</p><ol start="3"><li>解码过程<br>根据上面记录的规则和位置，我们可以解码向量：</li></ol><p>前3个位置是 [1, 0, 0]，对应颜色特征 -&gt; 红色。<br>后2个位置是 [0, 1]，对应大小特征 -&gt; 大。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义特征类别</span></span><br><span class="line">color_categories = [<span class="string">&quot;红色&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="string">&quot;蓝色&quot;</span>]</span><br><span class="line">size_categories = [<span class="string">&quot;小&quot;</span>, <span class="string">&quot;大&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_encode</span>(<span class="params">color, size</span>):</span><br><span class="line">    color_one_hot = [<span class="number">1</span> <span class="keyword">if</span> color == c <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> color_categories]</span><br><span class="line">    size_one_hot = [<span class="number">1</span> <span class="keyword">if</span> size == s <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> s <span class="keyword">in</span> size_categories]</span><br><span class="line">    <span class="keyword">return</span> color_one_hot + size_one_hot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_decode</span>(<span class="params">encoded_vector</span>):</span><br><span class="line">    color_encoded = encoded_vector[:<span class="built_in">len</span>(color_categories)]</span><br><span class="line">    size_encoded = encoded_vector[<span class="built_in">len</span>(color_categories):]</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 通过位置找到相应的类别</span></span><br><span class="line">    color = color_categories[color_encoded.index(<span class="number">1</span>)]</span><br><span class="line">    size = size_categories[size_encoded.index(<span class="number">1</span>)]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> color, size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">encoded = one_hot_encode(<span class="string">&quot;红色&quot;</span>, <span class="string">&quot;大&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;编码: <span class="subst">&#123;encoded&#125;</span>&quot;</span>)  <span class="comment"># 输出: [1, 0, 0, 0, 1]</span></span><br><span class="line"></span><br><span class="line">decoded = one_hot_decode(encoded)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;解码: <span class="subst">&#123;decoded&#125;</span>&quot;</span>)  <span class="comment"># 输出: (&#x27;红色&#x27;, &#x27;大&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>简单直观：<ul><li>One-hot 编码非常容易理解和实现，每个类别被表示为独立的二进制向量，清晰明确。</li></ul></li><li>无序关系：<ul><li>One-hot 编码不会引入类别之间的顺序关系或大小关系，这对于类别之间没有天然顺序的特征（如颜色、城市名称等）是非常合适的。</li></ul></li><li>减少分类误差：<ul><li>不同类别之间不会有直接的数值距离。例如，如果用 1, 2, 3 表示不同类别，模型可能会认为“1”和“2”之间的距离比“1”和“3”之间更近，但使用 One-hot 编码就避免了这种误解。</li></ul></li><li>广泛使用：<ul><li>在各种分类算法和神经网络中，One-hot 编码是一种标准的类别处理方法，特别是在 NLP、图像分类等领域。</li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>维度爆炸：<ul><li>高维稀疏性：如果类别特征有很多不同的类别，One-hot 编码会导致非常大的稀疏矩阵。比如有1000个不同的类别，One-hot 编码后每个数据点的向量长度就是1000，这不仅增加了存储开销，还可能导致计算性能下降。</li></ul></li><li>无法捕捉类别之间的相似性：<ul><li>One-hot 编码把每个类别都看作彼此独立，不能表达类别之间的相似性或关联。例如，“猫”和“狗”之间可能比“猫”和“车”更相似，但 One-hot 编码无法反映这种信息。</li></ul></li><li>不适用于高基数特征：<ul><li>如果类别的取值非常多（例如用户ID、商品ID等高基数特征），One-hot 编码会生成过大的编码向量，导致计算资源消耗过高，难以处理。</li></ul></li><li>缺乏信息量：<ul><li>虽然 One-hot 编码能够区分类别，但它不包含类别的任何附加信息。每个类别仅通过单独的位表示，不包括类别的重要性、相关性等信息。</li></ul></li></ul><h3 id="何时使用-One-hot-编码："><a href="#何时使用-One-hot-编码：" class="headerlink" title="何时使用 One-hot 编码："></a>何时使用 One-hot 编码：</h3><ul><li>类别数量较少：如果某个特征的类别数量适中（比如10~100个类别），One-hot 编码通常是很好的选择。</li><li>类别没有顺序关系：当类别之间没有自然的顺序或等级时，One-hot 编码能够避免引入不必要的偏差。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;One-hot 编码是一种将类别数据（比如文本或分类标签）转换为数值表示的方法。它的基本思想是用一个二进制向量来表示每个类别，其中只有一个位置为1，其他位置全为0。&lt;/p&gt;
&lt;p&gt;为什么需要 One-hot 编码？&lt;br&gt;在机器学习中，算法通常无法直接处理文字或类别，需要先</summary>
      
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>提示工程</title>
    <link href="http://example.com/2024/09/23/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/"/>
    <id>http://example.com/2024/09/23/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-09-23T02:24:55.000Z</published>
    <updated>2024-09-23T06:27:09.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h3><p>参考<a href="https://www.promptingguide.ai/zh">提示工程指南</a></p><ul><li>Temperature：准确度和发散程度</li><li>Top_p：准确度和发散程度</li><li>Max Length：回复的最大token数</li><li>Stop Sequences：组织模型生成token</li><li>Frequency Penalty</li><li>Presence Penalty</li></ul><h3 id="提示词格式"><a href="#提示词格式" class="headerlink" title="提示词格式"></a>提示词格式</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><p>提示词可以包含以下任意要素：</p><p>指令：想要模型执行的特定任务或指令。  例如：请将文本分为中性、否定或肯定.</p><p>上下文：包含外部信息或额外的上下文信息，引导语言模型更好地响应。 </p><p>输入数据：用户输入的内容或问题。  例如：我觉得食物还可以。</p><p>输出指示：指定输出的类型或格式。 例如：情绪：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请将文本分为中性、否定或肯定</span><br><span class="line">文本：我觉得食物还可以。</span><br><span class="line">情绪：</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>你可以使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提取以下文本中的地名。</span><br><span class="line"></span><br><span class="line">所需格式：</span><br><span class="line">地点：&lt;逗号分隔的公司名称列表&gt;</span><br><span class="line"></span><br><span class="line">输入：“虽然这些发展对研究人员来说是令人鼓舞的，但仍有许多谜团。里斯本未知的香帕利莫德中心的神经免疫学家 Henrique Veiga-Fernandes 说：“我们经常在大脑和我们在周围看到的效果之间有一个黑匣子。”“如果我们想在治疗背景下使用它，我们实际上需要了解机制。””</span><br></pre></td></tr></table></figure><h4 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h4><ul><li>避免不明确，尽量数字化，如几句话：2～3句话</li><li>避免说不要做什么，而要说要做什么</li></ul><h4 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h4><p>Explain the above in one sentence</p><p>Mention the large language model based product mentioned in the paragraph above:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classify the text into neutral, negative or positive. </span><br><span class="line"></span><br><span class="line">Text: I think the vacation is okay.</span><br><span class="line">Sentiment: neutral </span><br><span class="line"></span><br><span class="line">Text: I think the food was okay. </span><br><span class="line">Sentiment:</span><br></pre></td></tr></table></figure><h3 id="少样本提示"><a href="#少样本提示" class="headerlink" title="少样本提示"></a>少样本提示</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“whatpu”是坦桑尼亚的一种小型毛茸茸的动物。一个使用whatpu这个词的句子的例子是：</span><br><span class="line">我们在非洲旅行时看到了这些非常可爱的whatpus。</span><br><span class="line">“farduddle”是指快速跳上跳下。一个使用farduddle这个词的句子的例子是：</span><br></pre></td></tr></table></figure><p><strong>标签</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这太棒了！// Negative</span><br><span class="line">这太糟糕了！// Positive</span><br><span class="line">哇，那部电影太棒了！// Positive</span><br><span class="line">多么可怕的节目！//</span><br></pre></td></tr></table></figure><h3 id="链式思考"><a href="#链式思考" class="headerlink" title="链式思考"></a>链式思考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这组数中的奇数加起来是偶数：4、8、9、15、12、2、1。</span><br><span class="line">A：将所有奇数相加（9、15、1）得到25。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、10、19、4、8、12、24。</span><br><span class="line">A：将所有奇数相加（17、19）得到36。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：16、11、14、4、8、13、24。</span><br><span class="line">A：将所有奇数相加（11、13）得到24。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、9、10、12、13、4、2。</span><br><span class="line">A：将所有奇数相加（17、9、13）得到39。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：15、32、5、13、82、7、1。</span><br><span class="line">A：</span><br></pre></td></tr></table></figure><p><strong>自动思维链</strong><br>Auto-CoT 主要由两个阶段组成：</p><ul><li>阶段1：问题聚类：将给定问题划分为几个聚类</li><li>阶段2：演示抽样：从每组数组中选择一个具有代表性的问题，并使用带有简单启发式的 Zero-Shot-CoT 生成其推理链</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;模型设置&quot;&gt;&lt;a href=&quot;#模型设置&quot; class=&quot;headerlink&quot; title=&quot;模型设置&quot;&gt;&lt;/a&gt;模型设置&lt;/h</summary>
      
    
    
    
    <category term="LLVM" scheme="http://example.com/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-开发实战一</title>
    <link href="http://example.com/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</id>
    <published>2024-09-05T03:47:07.000Z</published>
    <updated>2024-09-10T13:02:53.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>开发一个通用项目管理项目，前端使用react，后端使用Spring Boot</p><h2 id="开发中遇到的知识点"><a href="#开发中遇到的知识点" class="headerlink" title="开发中遇到的知识点"></a>开发中遇到的知识点</h2><h3 id="Spring-Boot的开发框架"><a href="#Spring-Boot的开发框架" class="headerlink" title="Spring Boot的开发框架"></a>Spring Boot的开发框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">project-root/</span><br><span class="line">│</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/example/project/</span><br><span class="line">│   │   │       ├── controller/ # 存放控制器类,处理HTTP请求</span><br><span class="line">│   │   │       ├── service/ # 存放业务逻辑类</span><br><span class="line">│   │   │       ├── repository/ #  存放数据访问层的接口和实现</span><br><span class="line">│   │   │       ├── model/ # 存放实体类和数据传输对象(DTO)</span><br><span class="line">│   │   │       ├── └── dto/ </span><br><span class="line">│   │   │       └── ProjectApplication.java # Spring Boot的主应用类,包含main()方法</span><br><span class="line">│   │   │</span><br><span class="line">│   │   └── resources/</span><br><span class="line">│   │       ├── static/ # 存放静态资源如CSS、JavaScript、图片等。</span><br><span class="line">│   │       ├── templates/ # 存放模板文件(如Thymeleaf模板)。</span><br><span class="line">│   │       ├── db/ # 存放sql文件，scheme.sql  data.sql</span><br><span class="line">│   │       └── application.properties # 主配置文件,用于设置应用程序属性。</span><br><span class="line">│   │</span><br><span class="line">│   └── test/  # 存放测试代码。</span><br><span class="line">│       └── java/</span><br><span class="line">│           └── com/example/project/</span><br><span class="line">│</span><br><span class="line">├── target/ # Maven构建生成的目录,包含编译后的类文件和可执行JAR</span><br><span class="line">├── pom.xml # Maven项目配置文件,定义项目依赖和构建过程。</span><br><span class="line">└── README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p><a href="https://javabetter.cn/springboot/lombok.html">Spring Boot 整合 Lombok，用注解简化 Java 代码，比如说 getter和setter | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>Lombok可以更方便的生成set、get方法，在Maven管理的Java项目中，需要添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.6&lt;/version&gt;   # 在jdk21以上的版本，需要设置版本为1.18.30以上</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>其中<code> scope=provided</code>，就说明 Lombok 只在编译阶段生效。也就是说，Lombok 会在编译期静悄悄地将带 Lombok 注解的源码文件正确编译为完整的 class 文件。</p><p>SpringBoot 2.1.x 版本后不需要再显式地添加 Lombok 依赖了。之后，还需要为 Intellij IDEA 安装 Lombok 插件，否则 Javabean 的 getter &#x2F; setter 就无法自动编译，也就不能被调用。不过，新版的 Intellij IDEA 也已经内置好了，不需要再安装。</p><h4 id="常用的Lombok注解"><a href="#常用的Lombok注解" class="headerlink" title="常用的Lombok注解"></a>常用的Lombok注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Setter</span> <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>. <span class="comment">// @Data 注解可以生成 getter / setter、equals、hashCode，以及 toString，是个总和的选项。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p><a href="https://javabetter.cn/springboot/jpa.html">Spring Boot 整合 JPA | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>JPA（Java Persistence API）是一种Java对象持久化技术，它提供了一种将Java对象映射到关系数据库表的机制。当我们定义一个实体类时，JPA会根据类上的注解（如@Entity、@Table、@Column等）来生成对应的数据库表结构。</p><p>可以使用JPA创建：</p><ul><li>Entity（User）</li><li>Repository（UserRepository）</li></ul><p>JPA可以通过实体类来生成数据库表（spring.jpa.hibernate.ddl-auto），常见的配置有：（在生成环境中，不建议使用create、create、drop、update）</p><ul><li>create: 每次应用程序启动时，都会删除现有的数据库表，并根据实体类重新创建。</li><li>create-drop: 与create类似，但是在应用程序关闭时会删除所有表。</li><li>update: 每次应用程序启动时，会根据实体类的定义来更新数据库表结构。</li><li>validate: 仅验证数据库表结构与实体类是否匹配，不会做任何修改。</li><li>none：不做任何操作。</li></ul><p>在<code>application.properties</code>中设置：<code>spring.jpa.hibernate.ddl-auto=update</code></p><p><strong>更新数据库表时，不会自动更新实体类</strong></p><p>JPA生成Repository内置了一些方法，但是也可以通过注解的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeamRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Team, Integer&gt;, JpaSpecificationExecutor&lt;Team&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all teams</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t&quot;)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findAllTeams</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a team by its ID</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t WHERE t.id = :id&quot;)</span></span><br><span class="line">    Team <span class="title function_">findTeamById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom SQL query to find teams by name</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM teams WHERE name = :name&quot;, nativeQuery = true)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findTeamsByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Query注解的nativeQuery属性作用：</p><ul><li>nativeQuery&#x3D;false：使用HQL，JPA会根据实体类和关联关系自动生成SQL。</li><li>nativeQuery&#x3D;true：使用原生SQL，JPA直接执行你写的SQL语句</li></ul><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p>在Spring Boot中，<code>@RequestMapping</code> 是一个非常基础且强大的注解，用于将HTTP请求映射到特定的处理方法上。它可以配置请求路径、HTTP方法（GET、POST、PUT、DELETE等）、参数等信息。</p><p>为了简化开发，Spring Boot提供了几个更具体的注解，它们都是<code>@RequestMapping</code>的缩写形式：</p><ul><li><strong>@GetMapping:</strong> 通常用于获取数据，比如查询列表、获取详情等。</li><li><strong>@PostMapping:</strong> 通常用于创建新的资源，比如添加用户、提交表单等。</li><li><strong>@PutMapping:</strong> 通常用于更新整个资源，比如修改用户信息。</li><li><strong>@DeleteMapping:</strong> 通常用于删除资源，比如删除用户。</li><li><strong>@PatchMapping:</strong> 通常用于部分更新资源，比如修改用户的部分信息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/teams&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TeamService teamService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TeamController</span><span class="params">(TeamService teamService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.teamService = teamService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;teamId&#125;/members/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteMember</span><span class="params">(<span class="meta">@PathVariable</span> Integer teamId, <span class="meta">@PathVariable</span> Integer userId)</span> &#123;</span><br><span class="line">    teamService.deleteMember(teamId, userId);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestMapping</code>注解可以接受多个参数，如<code>value</code>、<code>method</code>、<code>params</code>、<code>headers</code>等，用于指定请求路径、HTTP方法、请求参数、请求头等信息。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/api/teams&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Team&gt; <span class="title function_">getTeams</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> teamService.getTeams();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用到的注解"><a href="#用到的注解" class="headerlink" title="用到的注解"></a>用到的注解</h3><h4 id="注解是什么？"><a href="#注解是什么？" class="headerlink" title="注解是什么？"></a>注解是什么？</h4><p>注解（Annotation）是一种提供元数据（metadata）的机制。它可以用于标记类、方法、字段等程序元素，从而为编译器或运行时环境提供额外的信息。注解本身不会影响程序的执行逻辑，但可以被编译器、IDE、框架等工具读取并进行相应的处理。</p><h4 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h4><p>注解本质上是一个接口。当我们定义一个注解时，实际上是在定义一个接口，并且这个接口继承自<code>java.lang.annotation.Annotation</code>接口。</p><ul><li><strong>注解处理器：</strong><ul><li>注解处理器是实现注解功能的关键。它们在编译时或运行时读取注解信息，并根据注解的定义执行相应的操作。</li><li>常用的注解处理器有：<ul><li><strong>编译时注解处理器：</strong> 在编译时处理注解，如APT（Annotation Processing Tool）。</li><li><strong>运行时注解处理器：</strong> 在运行时处理注解，如反射机制。</li></ul></li></ul></li><li><strong>反射机制：</strong><ul><li>通过反射机制，可以在运行时获取类、方法、字段的注解信息，并动态地调用这些元素。</li></ul></li></ul><h4 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h4><p>注解在Java开发中发挥着重要的作用，主要有以下几个方面：</p><ul><li><strong>提供元数据：</strong> 为编译器、IDE、框架等工具提供额外的信息，如：<ul><li><strong>生成代码：</strong> 比如Lombok注解可以自动生成getter、setter、构造方法等。</li><li><strong>配置信息：</strong> 比如Spring框架中的<code>@Autowired</code>注解用于自动装配Bean。</li><li><strong>验证：</strong> 比如Hibernate Validator中的<code>@NotNull</code>注解用于验证字段不能为空。</li></ul></li><li><strong>减少重复代码：</strong> 通过注解可以减少重复的代码编写，提高开发效率。</li><li><strong>提高代码可读性：</strong> 注解可以明确地表达代码的意图，提高代码的可维护性。</li><li><strong>实现AOP：</strong> 注解可以作为AOP切入点，实现横切关注点。</li></ul><h4 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h4><ul><li><strong>内置注解：</strong> Java内置了一些注解，如<code>@Override</code>、<code>@Deprecated</code>等。</li><li><strong>元注解：</strong> 用于定义注解的注解，如<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>等。</li><li><strong>自定义注解：</strong> 开发者可以自定义注解，以满足特定的需求</li></ul><h4 id="用到的注解-1"><a href="#用到的注解-1" class="headerlink" title="用到的注解"></a>用到的注解</h4><ul><li>声明 Bean 的注解<br>@Component：通用注解，可以标注任何类为 Spring 组件。<br>@Repository：专用于数据访问层（DAO）的组件。<br>@Service：专用于业务逻辑层（Service）的组件。<br>@Controller：专用于表现层（Controller）的组件。</li><li>注入 Bean 的注解@Autowired：根据类型自动装配 Bean，可以用于字段、方法参数和构造函数。<br>@Qualifier：配合 @Autowired 使用，根据 Bean 的名称进行注入。<br>@Resource：来自 JSR-250，也可以用于注入 Bean，功能类似于 @Autowired。</li><li>配置类相关的注解<br>@Configuration：声明一个配置类，等同于 XML 配置文件。<br>@ComponentScan：指定 Spring 在创建容器时要扫描的包。<br>@Bean：把方法的返回值作为 Bean 对象存入 Spring 容器。</li><li>切面（AOP）相关的注解<br>@Aspect：声明一个切面。<br>@Before、@After、@Around：定义切面中的增强方法。<br>@Pointcut：声明切点，用于定义拦截规则。</li><li>其他常用注解<br>@Value：注入配置文件中的值。<br>@RequestMapping：用于处理 Web 请求。<br>@ResponseBody：将方法的返回值直接写入 HTTP 响应体。<br>@RequestBody：将 HTTP 请求中的 JSON 数据绑定到 Java 对象。<br>@PathVariable：用于获取路径变量的值。<br>@Transactional：声明事务。</li></ul><h2 id="工具-技巧使用"><a href="#工具-技巧使用" class="headerlink" title="工具&#x2F;技巧使用"></a>工具&#x2F;技巧使用</h2><p>Intellj idea快速创建某个接口的实现类：<code>alt+enter</code></p><h3 id="接口类和实现类的调用"><a href="#接口类和实现类的调用" class="headerlink" title="接口类和实现类的调用"></a>接口类和实现类的调用</h3><p>Java中的接口类类似C++中的抽象类。</p><p>我的tokenServiceImpl是tokenService接口的实现，我在别的class中调用这个服务时，我应该使用tokenService还是tokenServiceImpl？</p><blockquote><p>应该使用tokenService。</p><ul><li><strong>依赖注入（Dependency Injection）：</strong> 当 Spring 容器管理你的 Bean 时，它会将 <code>TokenServiceImpl</code> 的实例注入到需要使用 token 服务的类中，但是注入的变量名通常是接口名 <code>tokenService</code>，而不是实现类名 <code>tokenServiceImpl</code>。</li><li><strong>面向接口编程：</strong> 面向接口编程是一种良好的编程习惯。通过使用接口 <code>tokenService</code>，你的代码与具体的实现类解耦，提高了代码的可维护性、可测试性和扩展性。</li><li><strong>多态：</strong> 由于 Java 的多态特性，当你使用 <code>tokenService</code> 时，实际上调用的是 <code>TokenServiceImpl</code> 中实现的方法。这样，如果你以后想更换 <code>TokenServiceImpl</code> 的实现，只需要修改 Spring 配置，而不需要修改调用代码。</li></ul></blockquote><p><strong>Service的注解应该放到实现类上，而不是接口类。</strong></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>为什么要使用JUnit4、mock和verify？</p><ul><li><strong>JUnit4</strong> 是Java中最流行的单元测试框架，提供了丰富的断言和测试注解。</li><li><strong>mock</strong> （模拟对象）可以让我们在测试中替换掉真实对象，从而隔离被测代码，方便测试。</li><li><strong>verify</strong> 用于验证模拟对象的方法调用情况，确保代码的正确性。</li></ul><p>示例，测试一个简单的<code>UserService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 依赖注入,在单元测试中，使用mock模拟</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建UserDao的模拟对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> mock(UserDao.class);</span><br><span class="line">        <span class="comment">// 创建期望的User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">expectedUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">        <span class="comment">// 设置模拟对象的行为，当userDao调用getUserById(1)时，返回期望的User对象</span></span><br><span class="line">        when(userDao.getUserById(<span class="number">1</span>)).thenReturn(expectedUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UserService实例，这是我们要测试的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(userDao);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用UserService的方法，这是我们要测试的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">actualUser</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证UserDao的getUserById方法被调用了一次</span></span><br><span class="line">        verify(userDao, times(<span class="number">1</span>)).getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言实际的User对象和期望的User对象相等</span></span><br><span class="line">        assertEquals(expectedUser, actualUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"><a href="#在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？" class="headerlink" title="在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"></a>在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？</h3><p>@RequestMapping 注解在 Spring MVC 中起着至关重要的作用，它建立了 HTTP 请求与控制器方法之间的映射关系。当前端发送一个 HTTP 请求时，Spring MVC 框架会根据请求的 URL，去寻找匹配的 @RequestMapping 注解，然后调用对应的控制器方法来处理这个请求。</p><p>整个过程可以简化为以下几步：</p><ol><li><strong>前端发送请求:</strong> 用户在浏览器中输入 URL，浏览器将这个请求发送到服务器。</li><li><strong>Spring MVC 拦截请求:</strong> Spring MVC 作为 Web 框架，会拦截所有的 HTTP 请求。</li><li><strong>匹配 @RequestMapping:</strong> Spring MVC 会根据请求的 URL，去容器中查找所有被<code>@RequestMapping</code> 注解标注的方法，并尝试匹配。</li><li><strong>执行控制器方法:</strong> 如果找到了匹配的方法，Spring MVC 就会调用这个方法，并把请求参数传递给方法。</li><li><strong>返回响应:</strong> 控制器方法执行完成后，会返回一个 ModelAndView 对象，Spring MVC 会将这个对象转换为 HTTP 响应，返回给前端。</li></ol><h3 id="Spring-MVC-与-Socket-的关系"><a href="#Spring-MVC-与-Socket-的关系" class="headerlink" title="Spring MVC 与 Socket 的关系"></a>Spring MVC 与 Socket 的关系</h3><ul><li>Spring MVC 的工作原理： Spring MVC 作为一款基于 Servlet 的 Web 框架，其核心是处理 HTTP 请求。当一个 HTTP 请求到达服务器时，Servlet 容器会将请求封装成 HttpServletRequest 和 HttpServletResponse 对象，然后交给 DispatcherServlet 处理。<ul><li>Servlet 和 Socket： Servlet 本质上是运行在 Servlet 容器中的一个 Java 类，它提供了处理 HTTP 请求和响应的接口。Servlet 容器（如 Tomcat、Jetty）则是基于 Socket 实现的，负责监听网络端口，接收客户端的 HTTP 请求，并将其传递给 Servlet。</li></ul></li><li>Spring MVC 与 Socket 的关系：<ul><li>间接依赖： Spring MVC 依赖于 Servlet 容器，而 Servlet 容器直接基于 Socket 工作。因此，Spring MVC 可以说是间接地利用了 Socket 的功能。</li><li>抽象层级： Spring MVC 提供了一层更高级的抽象，将开发者从底层的 Socket编程细节中解放出来。开发者只需要关注业务逻辑，而不需要关心如何处理网络连接、协议解析等。</li></ul></li><li>Socket 的作用：<ul><li>建立连接： Socket 用于在客户端和服务器之间建立网络连接。</li><li>数据传输： 通过 Socket 进行数据传输，实现客户端和服务器之间的通信。</li><li>协议解析： Socket 负责解析 HTTP 协议，将请求和响应数据进行编码和解码。</li></ul></li></ul><h3 id="当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？"><a href="#当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？" class="headerlink" title="当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？"></a>当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？</h3><p><strong>一般情况下，在 Spring Boot 中，我们不需要手动创建数据库连接池。</strong> Spring Boot 默认集成了 HikariCP 这个高性能的数据库连接池，并提供了自动配置。只需在配置文件（如 application.properties 或 application.yml）中配置数据库连接信息，Spring Boot 就会自动创建并管理连接池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mydatabase</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=yourpassword</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver <span class="comment">// 这个配置项在 Spring Boot 中用于指定连接数据库的 JDBC 驱动类的全限定名。</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-如何处理多个用户请求"><a href="#Spring-Boot-如何处理多个用户请求" class="headerlink" title="Spring Boot 如何处理多个用户请求?"></a>Spring Boot 如何处理多个用户请求?</h3><p>通常情况下，不需要手动创建线程池。 Spring Boot 已经为您内置了许多自动配置，其中就包括线程池的创建和管理。</p><p>Spring Boot 默认的线程池</p><ul><li>Tomcat线程池: 对于传统的 Servlet 容器 Tomcat，Spring Boot 会默认使用 Tomcat 的线程池来处理 HTTP 请求。</li><li>Undertow线程池: 如果您使用的是 Undertow 作为嵌入式 Servlet 容器，那么 Spring Boot 会使用 Undertow 的线程池。</li></ul><p>这些线程池通常已经经过优化，可以满足大多数应用的并发处理需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h2&gt;&lt;p&gt;开发一个通用项目管理项目，前端使用react，后端使用Spring Boot&lt;/p&gt;
&lt;h2 id=&quot;开发中遇到的知识点&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-代码规范</title>
    <link href="http://example.com/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-09-04T01:56:31.000Z</published>
    <updated>2024-09-05T00:37:42.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><table><thead><tr><th align="center">类型</th><th>风格</th><th>示例</th></tr></thead><tbody><tr><td align="center">变量名</td><td>驼峰</td><td>localValue</td></tr><tr><td align="center">方法名</td><td>驼峰</td><td>getValue</td></tr><tr><td align="center">类名</td><td>首字母大写</td><td>JavaServer</td></tr><tr><td align="center">包名</td><td>小写，分隔符之间有且仅有一个自然语义的单词</td><td>com.excample.demo</td></tr><tr><td align="center">枚举类型&#x2F;常量</td><td>全大写，单词间用下划线隔开</td><td>MAX_STOCK_COUNT</td></tr></tbody></table><p><strong>禁止的命名：</strong></p><ul><li>不能以下划线&#x2F;&amp;开始或结束</li><li>禁止中英文混合</li><li>布尔类型不要加is前缀<ul><li>统一使用 xxx&#x2F;setXxx&#x2F;getXxx</li></ul></li></ul><h3 id="推荐的代码风格"><a href="#推荐的代码风格" class="headerlink" title="推荐的代码风格"></a>推荐的代码风格</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ol><li>如果变量值仅在一个固定范围内变化，使用enum类型来定义。如SRTING、SUMMER、AUTUMN、WINTER</li><li>如果大括号内为空，简洁地写成{},无需换行和空格，如果是非空代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getUserID</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>小括号和字符间不留空格，与保留字需要有空格（if&#x2F;while&#x2F;for）</li><li>锁进为4个空格、注释的双斜线和内容之间有且仅有一个空格</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>类、类属性、类方法注释使用Javadoc的规范，使用<code>/* xxx */</code></li><li>所有抽象方法（包括接口）都必须要用Javadoc注释，除了返回值、参数、异常说明外，还必须指出什么方法做什么事情</li><li>枚举类型需要注释</li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li>每行最多包含一条语句</li><li>当switch括号内的变量类型为String时，必须先进行null判断</li><li>在高并发场景中，避免使用等于作为中断或退出的条件，应该用大于等于或者小于等于</li><li>不要在表达式中插入赋值语句</li><li>避免使用取反逻辑运算符</li></ol><h2 id="高级编码规范"><a href="#高级编码规范" class="headerlink" title="高级编码规范"></a>高级编码规范</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>使用类名直接引用<strong>静态</strong>类型和<strong>静态方法</strong></li><li>避免使用构造函数创建字符串对象</li><li>所有的覆写方法都必须要加<code>@Override</code>注解</li><li>尽量不使用可变参数编程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h2&gt;&lt;h3 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-语法基础篇</title>
    <link href="http://example.com/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2024-08-28T06:13:28.000Z</published>
    <updated>2024-08-30T00:37:41.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扫盲，Java和C-的一些区别"><a href="#扫盲，Java和C-的一些区别" class="headerlink" title="扫盲，Java和C++的一些区别"></a>扫盲，Java和C++的一些区别</h3><p><strong>Java项目需要编译吗？底层编译原理和C++有什么不同？</strong></p><ol><li>   编译输出：</li></ol><ul><li>Java：编译输出的是平台无关的字节码文件（.class 文件），这些字节码可以在任何安装了 JVM 的平台上运行。</li><li>C++：编译输出的是特定平台的机器码文件（如 .exe 文件），这些文件只能在编译时指定的平台上运行。</li></ul><ol start="2"><li>   跨平台性：</li></ol><ul><li>Java：通过 JVM 的跨平台特性，Java 程序可以“一次编写，到处运行”（Write Once, Run Anywhere）。</li><li>C++：需要为每个平台分别编译代码才能生成可以执行的文件，不具备 Java 那样的跨平台能力。</li></ul><ol start="3"><li>   运行时性能：</li></ol><ul><li>Java：由于字节码需要在运行时通过 JVM 翻译为机器码，可能会在启动时稍慢，但 JIT 编译可以在运行期间优化代码，提高性能。</li><li>C++：由于是直接编译为机器码，C++ 程序的启动和运行速度通常会比 Java 程序快，尤其是在性能关键的应用中。</li></ul><ol start="4"><li>   编译速度：</li></ol><ul><li>Java 编译通常更快，因为编译器只需将代码编译为字节码，而不需要生成机器码。</li><li>C++ 编译通常更慢，尤其是在大型项目中，因为编译器需要生成并优化特定平台的机器码。</li></ul><p><strong>Java编译是否需要再单独安装编译器？</strong></p><p>在编写 Java 程序时，不需要单独安装编译器，因为 Java 编译器是包含在 JDK（Java Development Kit）中</p><p><strong>JDK包含了什么？</strong></p><p>JDK 是 Java 开发的核心工具包，它包含了一整套开发 Java 应用程序所需的工具和库。JDK 的主要组成部分包括：</p><ol><li>   Java 编译器 (javac)：</li></ol><ul><li>这是用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）的工具。</li><li>javac 是 JDK 中最重要的组件之一，负责将人类可读的 Java 代码转换为 JVM 可执行的字节码。</li></ul><ol start="2"><li>   Java 运行时环境 (JRE, Java Runtime Environment)：</li></ol><ul><li>JRE 是运行 Java 程序所需的环境，包括 JVM、Java 类库和其他资源。</li><li>JRE 包含了 Java 虚拟机（JVM）、核心类库和支持文件，但不包括编译器和调试工具。</li><li>JDK 本身包含了一个完整的 JRE，所以在安装 JDK 时也会获得 JRE。</li></ul><ol start="3"><li>   Java 虚拟机 (JVM)：</li></ol><ul><li>JVM 是一个平台独立的虚拟机，负责解释和执行编译后的字节码。</li><li>JVM 使得 Java 程序可以在任何支持 JVM 的操作系统上运行。</li></ul><ol start="4"><li>   核心类库：</li></ol><ul><li>这是 Java 标准库（API），包含了大量的预定义类和接口，用于执行各种常见的编程任务（如数据结构、网络通信、文件操作、并发处理等）。</li><li>核心类库是 Java 程序构建的基础，几乎所有 Java 程序都会使用其中的类和方法。</li></ul><ol start="5"><li>   开发工具：</li></ol><ul><li>java：用于启动 Java 应用程序的命令行工具，它调用 JVM 来执行字节码。</li><li>javadoc：用于生成 Java 代码文档的工具，可以从源码中的注释生成 API 文档。</li><li>jdb：Java 调试工具，允许开发者在运行时调试 Java 应用程序。</li><li>jar：用于创建和管理 Java Archive（JAR）文件的工具，这些文件通常用于打包 Java 类库和应用程序。</li><li>javap：Java 类文件反汇编工具，用于查看编译后的字节码。</li></ul><ol start="6"><li>   其他工具：</li></ol><ul><li>javah：用于生成 C 头文件和源文件，支持 JNI（Java Native Interface）。</li><li>jarsigner：用于对 JAR 文件进行签名和验证的工具。</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>在Java中，每个源文件都是一个类，类名必须与文件名相同。Java程序的入口是<code>main</code>方法，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</span></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个源码文件只能包含一个public类型的类。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Java的数据类型分为两大类：基本数据类型和引用数据类型。</p><ol><li>   基本数据类型：byte、short、int、long、float、double、char、boolean。<strong>基本类型的变量直接存储值。</strong></li><li>   引用数据类型：类、接口、数组、String等。<strong>引用类型变量存储的是对象的内存地址（引用）</strong>。</li></ol><p>引用类型变量通常通过 <code>new</code> 关键字创建对象（但也有例外，比如字符串常量池），而基本类型变量则直接赋值。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java中的字符串是不可变的，即一旦创建，就不能再修改。字符串的比较要使用<code>equals()</code>方法，而不是<code>==</code>运算符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong>：</p><ul><li>使用<code>+</code>运算符拼接字符串。</li><li>使用<code>StringBuilder</code>类进行字符串拼接，它是可变的字符串，效率更高。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(s); <span class="comment">// Hello, Mr Bob!</span></span><br></pre></td></tr></table></figure><p>多行字符串可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SELECT * FROM</span></span><br><span class="line"><span class="string">    users</span></span><br><span class="line"><span class="string">    WHERE id = 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>); <span class="comment">// 输出并换行</span></span><br><span class="line">System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 输出不换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// 格式化输出</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 导入某个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>在Java的类中，有构造函数，但是没有析构函数。Java的垃圾回收器会自动回收不再使用的对象。</p><p>在Java的类中，也有一个this关键字，表示当前实例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用extends关键字实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>在Java中一个子类只能继承一个父类，子类继承后无法访问父类的私有字段和方法，可以将父类的字段和方法设置为<code>protected</code>。</strong></p></li><li><p>子类不会继承父类的构造方法，但是可以通过<code>super()</code>调用父类的构造方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和C++一样，在Java中可以使用父类的引用指向子类的实例。</li><li>Java中的方法可以被子类覆写，使用<code>@Override</code>注解可以让编译器检查是否正确覆写了父类的方法。</li><li>在Java中 ，同样存在抽象类，使用<code>abstract</code>关键字修饰，抽象类不能被实例化，只能被继承。<code>abstract class Person &#123;&#125;</code></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://liaoxuefeng.com/books/java/oop/basic/interface/index.html">接口-参考文献</a></p><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：interface。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的class去实现一个interface时，需要使用implements关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>  在定义class的时候，我们需要在第一行声明这个class属于哪个包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example; <span class="comment">// 定义包名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有Java文件对应的目录层次要和包的层次一致。</p><h3 id="和C-作对比："><a href="#和C-作对比：" class="headerlink" title="和C++作对比："></a>和C++作对比：</h3><table><thead><tr><th align="center">关键字</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">常量</td><td align="center">final</td><td align="right">const</td></tr><tr><td align="center">自动类型推导</td><td align="center">var</td><td align="right">auto</td></tr><tr><td align="center">空指针</td><td align="center">null</td><td align="right">nullptr</td></tr><tr><td align="center">字符串</td><td align="center">String</td><td align="right">std::string</td></tr><tr><td align="center">静态方法</td><td align="center">static</td><td align="right">static</td></tr><tr><td align="center">继承</td><td align="center">extends</td><td align="right">: public</td></tr><tr><td align="center">实现</td><td align="center">implements</td><td align="right">: public</td></tr><tr><td align="center">抽象类</td><td align="center">abstract class</td><td align="right">class</td></tr><tr><td align="center">接口</td><td align="center">interface</td><td align="right">class</td></tr><tr><td align="center">包</td><td align="center">package</td><td align="right">namespace</td></tr><tr><td align="center">异常处理</td><td align="center"><a href="https://liaoxuefeng.com/books/java/exception/java-exception/index.html">try-catch-finally</a></td><td align="right">try-catch</td></tr></tbody></table><h4 id="Java和C-中的STL容器区别"><a href="#Java和C-中的STL容器区别" class="headerlink" title="Java和C++中的STL容器区别"></a>Java和C++中的STL容器区别</h4><table><thead><tr><th align="center">容器</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">动态数组</td><td align="center">ArrayList</td><td align="right">vector</td></tr><tr><td align="center">链表</td><td align="center">LinkedList</td><td align="right">list</td></tr><tr><td align="center">栈</td><td align="center">Stack</td><td align="right">stack</td></tr><tr><td align="center">队列</td><td align="center">Queue</td><td align="right">queue</td></tr><tr><td align="center">双端队列</td><td align="center">Deque</td><td align="right">deque</td></tr><tr><td align="center">集合</td><td align="center">Set</td><td align="right">set</td></tr><tr><td align="center">映射</td><td align="center">Map</td><td align="right">map</td></tr><tr><td align="center">哈希表</td><td align="center">HashMap</td><td align="right">unordered_map</td></tr><tr><td align="center">哈希集合</td><td align="center">HashSet</td><td align="right">unordered_set</td></tr><tr><td align="center">优先队列</td><td align="center">PriorityQueue</td><td align="right">priority_queue</td></tr></tbody></table><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>Java的反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法。</p><p>如果要实现一个通用的对象<code>拷贝</code>方法，就必须要用反射机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        person.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        copyProperties(person, employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Name: &quot;</span> + employee.name); <span class="comment">// 输出: Employee Name: John</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Age: &quot;</span> + employee.age);   <span class="comment">// 输出: Employee Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取源对象的所有字段</span></span><br><span class="line">        Field[] fields = source.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标对象中同名的字段</span></span><br><span class="line">            Field targetField;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetField = target.getClass().getField(field.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果目标对象中没有这个字段，则跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查字段类型是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (targetField.getType().equals(field.getType())) &#123;</span><br><span class="line">                <span class="comment">// 将值设置到目标对象中</span></span><br><span class="line">                targetField.set(target, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ol><li>注解的作用</li></ol><ul><li>标注和说明: 注解通常用来标注或说明代码中的某些元素。例如，@Override注解表明一个方法是重写父类或接口的方法，这是一种对代码的说明。</li><li>代码行为的调整: 某些注解会影响代码的行为。例如，@Deprecated注解标注某个方法已经过时，编译器会在使用该方法时发出警告。</li><li>与框架和工具的集成: 许多框架（如Spring、Hibernate）和工具（如JUnit、编译器）使用注解来配置和控制代码的行为。例如，@Autowired注解用于在Spring中自动注入依赖。</li></ul><ol start="2"><li>注解的使用场景</li></ol><ul><li>编译时处理: 注解可以在编译时被处理，例如生成额外的代码、文档，或进行代码校验。例如，@SuppressWarnings注解可以告诉编译器忽略特定的警告。</li><li>运行时反射: 注解可以在运行时通过反射机制读取和使用。例如，JUnit在运行时通过反射读取@Test注解来识别哪些方法是测试方法。</li><li>框架配置: 许多Java框架通过注解来配置和管理对象的行为，这种配置方式比传统的XML配置更加直观和简洁。</li></ul><p><strong>Java的注解和Python的装饰器有什么不同？</strong></p><ol><li>功能与用途：</li></ol><ul><li>Java注解主要用于提供元数据，标记类、方法、字段等。主要用于配置和框架集成，如依赖注入、ORM映射等。</li><li>Python装饰器用于动态改变函数或方法的行为，可以在运行时修改代码逻辑，常用于日志记录、权限控制等。</li></ul><ol start="2"><li>   实现方式：</li></ol><ul><li>Java注解是静态的，不能直接改变代码逻辑，通过编译器或框架在编译时或运行时处理。</li><li>Python装饰器是高阶函数，可以在运行时动态生成、修改或应用，具有更强的灵活性。</li></ul><ol start="3"><li>   使用场景：</li></ol><ul><li>Java注解常见于企业级应用中的配置和元数据标注。</li><li>Python装饰器用于简化代码、提高复用性，特别是在Web开发和数据处理领域。</li><li>两者虽然都是用于增强代码的功能性，但Java注解偏向于静态配置，而Python装饰器偏向于动态行为修改。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;扫盲，Java和C-的一些区别&quot;&gt;&lt;a href=&quot;#扫盲，Java和C-的一些区别&quot; class=&quot;headerlink&quot; title=&quot;扫盲，Java和C++的一些区别&quot;&gt;&lt;/a&gt;扫盲，Java和C++的一些区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Java项目需要</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的网络攻击方式</title>
    <link href="http://example.com/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>http://example.com/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2024-04-03T04:54:28.000Z</published>
    <updated>2024-05-18T01:53:38.853Z</updated>
    
    <content type="html"><![CDATA[<p>学习网站：<a href="https://xss-game.appspot.com/level1">https://xss-game.appspot.com/level1</a></p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>XSS（Cross Site Scripting）跨站脚本攻击，是一种代码注入攻击。攻击者在目标网站植入恶意脚本，当用户访问目标网站时，恶意脚本会被执行，从而达到攻击目的。</p><p>假设有一个简单的网页，用于用户输入评论，然后显示在页面上。如果用户输入的内容没有经过过滤，那么用户可以输入一段恶意脚本，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>评论页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>留言板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;post_comment.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交评论&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端代码没有进行恰当的输入过滤和输出转义，导致用户输入的恶意脚本被执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;评论结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;评论结果&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;您的评论是：<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>]; <span class="meta">?&gt;</span>&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当用户输入如下内容时，就会弹出一个对话框：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果尝试在<code>&lt;script&gt;</code>标签中输入恶意代码失败了，那么可以尝试使用带有JavaScript属性的HTML元素来执行XSS攻击。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span></span><br><span class="line">&#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span>&#x27;</span><br><span class="line">0&#x27;); alert(&#x27;XSS&#x27;); //</span><br></pre></td></tr></table></figure><h4 id="XSS攻击的解决措施"><a href="#XSS攻击的解决措施" class="headerlink" title="XSS攻击的解决措施"></a>XSS攻击的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>输出转义：对用户输入的内容进行转义，确保用户输入的内容不会被当做HTML代码执行。</li><li>HTTP头部设置：设置HTTP头部的Content-Security-Policy字段，限制页面加载的资源。</li><li>Cookie设置：设置Cookie的HttpOnly属性，防止JavaScript读取Cookie。</li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF（Cross Site Request Forgery）跨站请求伪造，是一种利用用户已登录的身份，以用户不知情的情况下，完成非法操作的攻击方式。</p><ul><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问断线都具备一定的有效期，比如1天过期，或者几个小时过气，再次期间权限信息会保留在用户浏览器的cookie中，这本例子中假设用户C刚刚登录了网站A，全新还没有过期。</li><li>攻击者利用正常网站A的CSFR漏洞，构造页面一个恶意网页B，在页面中包含对发往正常网站A的请求，在用户C加载页面B（或者点击某些元素时触发）时，会触发攻击请求，完成攻击。</li><li>由于加载恶意页面B和触发攻击请求都是在用户浏览器端完成的，因为之前用户登录过正常网站，发往正常网站的请求会带有用户授权信息（在cookie中），在授权信息没有过期的情况达到攻击目的。</li></ul><h4 id="CSRF攻击的解决措施"><a href="#CSRF攻击的解决措施" class="headerlink" title="CSRF攻击的解决措施"></a>CSRF攻击的解决措施</h4><ul><li>验证来源站点：在服务器端验证请求的来源站点，只允许来自合法站点的请求。</li><li>验证请求内容：在请求中添加验证信息，确保请求是用户自己发起的。</li><li>防止重复提交：使用Token验证，确保请求只能被执行一次。</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是一种利用Web应用程序中的漏洞，通过在用户提交的数据中插入恶意的SQL语句，从而实现非法操作的攻击方式。</p><p>例如：登陆查询的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果用户输入的<code>$username</code>和<code>$password</code>没有经过过滤，那么用户可以输入一段恶意的SQL语句，比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;archer2017&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样就会返回所有用户的信息，因为<code>OR 1=1</code>永远为真。</p><h4 id="SQL注入的解决措施"><a href="#SQL注入的解决措施" class="headerlink" title="SQL注入的解决措施"></a>SQL注入的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>如果不可避免地使用SQL语句进行拼装，可以对用户输入数据进行转义，确保用户输入的内容不会被当做SQL语句执行。</li></ul><h3 id="上传文件漏洞"><a href="#上传文件漏洞" class="headerlink" title="上传文件漏洞"></a>上传文件漏洞</h3><p>上传文件漏洞也是一种常见的web漏洞，攻击者可以用利用服务器端的上传文件漏洞绕过安全验证将代码提交到服务器端，并想办法让代码文件被执行。一单可执行的代码上传成功，会造成比较严重的安全问题，比如获取服务器权限，为攻击者开后门，或者让服务器超载，破快服务器的可用性，甚至是上传病毒，木马。</p><h4 id="上传文件漏洞的解决措施"><a href="#上传文件漏洞的解决措施" class="headerlink" title="上传文件漏洞的解决措施"></a>上传文件漏洞的解决措施</h4><ul><li>限制上传文件类型：限制上传文件的类型，确保只能上传安全的文件。</li><li>将上传文件和应用程序分开存储</li><li>对上传的图片进行重绘</li><li>对上传文件重命名，最好具有一定的随机性，提高攻击成本</li></ul><h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>DDOS（Distributed Denial of Service）分布式拒绝服务攻击，是一种通过大量合法请求，占用服务器资源，导致服务器无法正常提供服务的攻击方式。</p><p>在了解 DDoS 之前，我们需要先知道什么是 DoS。最基本的 DoS 就是利用合理的客户端请求里占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDoS 攻击便是在传统的 DoS 攻击的基础上产生的一类攻击方式。传统的 DoS攻击一般是一对一的方式，当攻击目标的CPU速度、内存或者网络带宽等各项性能指标不高的情况下，它的效果是明显的，但随着计算机与网络技术的发展，计算机的处理能力显著增加，内存不断增大，这便使得 DoS 攻击逐渐失去了效果。</p><h4 id="DDOS分类"><a href="#DDOS分类" class="headerlink" title="DDOS分类"></a>DDOS分类</h4><p><strong>SYN Flood</strong></p><p>SYN Flood就是利用了 TCP 协议三次握手的过程来达到攻击的目的。攻击者伪造大量的 IP 地址给服务器发送 SYN 报文，因为伪造的 IP 地址不可能存在，也就不可能从客户端得到任何响应，就会一直卡在第三步，服务端就得维护一个非常大的半连接等待列表，并且不断对这个列表中的 IP 地址进行遍历重试，占用了大量的系统资源。而由于服务器资源有限，恶意的连接占满了服务器的等待队列，导致服务器不再接收新的 SYN 请求，使正常的用户无法完成通信。</p><p><strong>DNS Query Flood</strong></p><p>DNS Query Flood 攻击采用的方法是向被攻击的服务器发送海量的域名解析请求。而这部分请求解析的域名一般都是随机生成的，大部分不存在，并且通过伪造端口和客户端IP，防止查询请求被 ACL（访问控制列表）过滤。被攻击的 DNS服务器 在收到域名解析的请求后，首先会在自己的服务器上查找是否该域名的 IP，因为域名的不存在，在自身自然是找不到的，因此DNS 服务器便会向上层的 DNS服务器递归查询域名，直到全球互联网的 13台 根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量级的时候，就会造成 DNS服务器 解析域名超时，使正常的域名都查询不到对应的 IP，达到了攻击的效果。</p><p><strong>HTTP&#x2F;CC Flood</strong></p><p>CC攻击的原理是通过控制大量的 “肉鸡” 或者利用从互联网上搜寻的大量匿名的 HTTP 代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过 CDN 以及分布式缓存来加快服务端的响应，提高网站的吞吐量。而这些恶意的 HTTP 请求会有意的避开这些缓存，需要进行多次 DB 查询操作或者一次请求会返回大量的数据，加速系统资源的消耗，从而拖垮后端的业务处理系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习网站：&lt;a href=&quot;https://xss-game.appspot.com/level1&quot;&gt;https://xss-game.appspot.com/level1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Network Security" scheme="http://example.com/categories/Network-Security/"/>
    
    
  </entry>
  
  <entry>
    <title>API-architecture</title>
    <link href="http://example.com/2024/03/31/API-architecture/"/>
    <id>http://example.com/2024/03/31/API-architecture/</id>
    <published>2024-03-31T07:39:41.000Z</published>
    <updated>2024-03-31T08:43:45.368Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<a href="https://www.youtube.com/watch?v=4vLxWqE94l4">Top 6 Most Popular API Architecture Styles</a></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API（Application Programming Interface）是一组定义了软件应用程序之间如何互相通信的规则的接口。API可以让不同的软件应用程序之间共享数据和功能，从而提高开发效率。</p><p>主要是用于不同系统之间的通信，比如前端和后端之间的通信。</p><p>如果没有定义API，那么不同的系统之间就无法通信。</p><h3 id="常用API架构风格"><a href="#常用API架构风格" class="headerlink" title="常用API架构风格"></a>常用API架构风格</h3><p><img src="/../imgs/image-47.png"></p><h3 id="Highlights"><a href="#Highlights" class="headerlink" title="Highlights"></a>Highlights</h3><ul><li>📜 SOAP是一种成熟、全面且基于XML的API架构风格，尤其适用于金融服务和支付网关等需要安全性和可靠性的场景。</li><li>🌐 RESTful APIs是Internet的骨干，易于实现，使用HTTP方法，适用于大多数日常交互的网络服务。</li><li>📊 GraphQL不仅是一种架构风格，还是一种查询语言，能够高效地提供精确的数据，尤其适用于复杂数据需求的应用程序。</li><li>💻 gRPC是现代高性能的API架构风格，适用于微服务架构，但在处理浏览器客户端时可能存在一些挑战。</li><li>🔄 WebSocket是实时、双向且持久连接的API架构风格，适用于实时聊天和实时游戏等场景。</li><li>🎣 Webhook是基于事件驱动的API架构风格，适用于异步操作，但不适合需要同步通信或立即响应的场景。</li></ul><h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful API"></a>restful API</h3><p>Github的API设计规范学习：<a href="https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api?apiVersion=2022-11-28">Github API</a></p><h4 id="rest架构特征"><a href="#rest架构特征" class="headerlink" title="rest架构特征"></a>rest架构特征</h4><ul><li>以资源为基础：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。</li><li>统一接口：对资源的操作包括获取、创建、修改和删除资源，这些操作分别对应HTTP协议中的GET、POST、PUT、DELETE方法。</li><li>无状态：每次请求必须包含所有的信息，服务器不会保存客户端的状态。</li><li>url指向资源：一个url对应一个资源，通过url获取资源。</li></ul><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>参考学习：<a href="https://juejin.cn/post/6844903475420069902">GraphQL</a></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（Remote Procedure Call）是一种协议，用于在不同的进程之间传递数据。RPC协议允许一个程序调用另一个程序的子程序，而不需要了解底层网络细节。</p><p><strong>rpc是一种思想，广义的rpc是包含http的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;a href=&quot;https://www.youtube.com/watch?v=4vLxWqE94l4&quot;&gt;Top 6 Most Popular API Architecture Styles&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot;</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="architecture" scheme="http://example.com/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（下）</title>
    <link href="http://example.com/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2024-03-07T07:03:28.000Z</published>
    <updated>2024-03-30T12:56:10.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求整理"><a href="#需求整理" class="headerlink" title="需求整理"></a>需求整理</h2><p><strong>popup.html：</strong></p><ul><li>是否开启划词翻译</li><li>选择划词翻译的默认目标语言</li><li>是否开启输入翻译</li><li>输入框翻译的简介</li><li>项目地址</li></ul><p><strong>popup.js</strong></p><ul><li>从popup界面接收信息，如果用户更新设置，就更新存储在浏览器中的值，同时发送消息给content脚本，让其监听</li><li>监听用户是否点击项目地址</li><li>每次点开popup界面都重新从浏览器中加载存储的设置</li></ul><p><strong>content.js</strong></p><ul><li>从浏览器中获取设置</li><li>监听用户的输入</li><li>监听用户是否复制文本</li><li>将信息发送给background脚本</li><li>显示翻译框</li></ul><p><strong>background.js</strong></p><ul><li>接收content脚本发来的信息</li><li>发送请求给API，同时接收应答信息</li><li>将翻译后的内容发送给content脚本</li></ul><p>翻译展示框：</p><ul><li>上方：左边显示logo，右边显示关闭按钮</li><li>中间显示译文</li><li>当用户点击别的地方时关闭翻译框，同时取消选中</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p>在上一篇有写过popup脚本支持跨域，所以我最初的想法是，在划词翻译这个功能中，content脚本只负责发送、接收信息，并且将信息显示出来，而向百度翻译发送请求由popup脚本完成。</p><p>但是<strong>popup 脚本（popup.js）只在用户点击扩展图标并打开 popup 页面时才会运行。</strong></p><p>所以最终改为popup脚本只负责接收popup界面的信息，并传递给content脚本，与外界的交互还是<br>由background脚本完成，这样子增加了代码复用性，也更符合逻辑。</p><p><strong>需要保存用户的设置，所以当用户点击插件时都需要从storage中获取保存的设置</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>([<span class="string">&#x27;autoTranslate&#x27;</span>, <span class="string">&#x27;targetLanguage&#x27;</span>, <span class="string">&#x27;inputTranslate&#x27;</span>], <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">autoTranslate</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span> = result.<span class="property">targetLanguage</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">inputTranslate</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当用户更新设置时，也需要将设置保存下来，同时发给content脚本。</strong></p><p>这里为什么要发送给content脚本呢？而不是要content脚本自己去获取？</p><p>这里我更想用通知的方法，这样假设用户开启或关闭某一个功能，content脚本可以第一时间得到反馈。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">saveSettings</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> autoTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line"><span class="keyword">let</span> targetLanguage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"><span class="keyword">let</span> inputTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123; <span class="attr">autoTranslate</span>: autoTranslate, <span class="attr">targetLanguage</span>: targetLanguage, <span class="attr">inputTranslate</span>: inputTranslate &#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">sendMessageToContent</span>(autoTranslate, targetLanguage, inputTranslate);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于扩展不支持直接从popup界面跳转链接，所以要在popup脚本去跳转。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;project-link&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">create</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;https://github.com/kelinkong/Input-Translation.git&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>这里真的是折磨我好几个小时，主要是调试弹出的翻译框。</p><p>和popup一样，在每次加载界面时需要从storage中获取用户之前的设置。</p><p>然后就是监听用户是否进行选中文本。这里除了记录选中的文本，还需要记录选中的位置，因为我想要直接在选中文本下方弹出翻译框。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line"><span class="keyword">var</span> selectedText = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 获取位置</span></span><br><span class="line"><span class="keyword">var</span> rect = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">getRangeAt</span>(<span class="number">0</span>).<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure><p>和background交互方式与上一篇相同，此处不再赘述。</p><p>接收到饭回来的译文后，这里可以直接调用<code>panel = document.createElement(&#39;div&#39;);</code>来创建一个视图。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">panel.<span class="property">innerHTML</span> = innerHTMLContent; <span class="comment">// 可以使用内嵌html</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;  <span class="comment">// 可以直接调整样式</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">top</span> = rect.<span class="property">bottom</span> + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">panel.<span class="property">style</span>.<span class="property">left</span> = rect.<span class="property">left</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑，应该是有一个单独的HTML文件来控制翻译框。但是我对前端太不了解，折腾了好久也没有折腾成功，只能将就着写进content脚本中。</p><h4 id="开启和关闭功能的实现"><a href="#开启和关闭功能的实现" class="headerlink" title="开启和关闭功能的实现"></a>开启和关闭功能的实现</h4><p>对于输入翻译来说，<code>if (event.target.tagName.toLowerCase() === &#39;input&#39; &amp;&amp; inputTranslate)</code>，检测到输入且inputTranslate为真才会去分析用户的输入是否含有目标语言前缀。</p><p>对于划词翻译，和输入翻译不同的是，这里还涉及到弹出框的开启与关闭。</p><ul><li>当检测到用户更新设置时，先移除所有的鼠标监听，如果划词翻译被开启，则开始监听鼠标。</li><li>当用户点了弹出框的关闭，或者点击其他地方，关闭翻译框，同时取消选中。</li></ul><p>这里取消选中其实有个坑。一开始我没有设置关闭翻译框后取消选中，结果就是，不断弹出翻译框。</p><p>当我设置了取消选中后，我一开始担心，也许用户选中并不是想要翻译，而是想要复制。所以我又给用户在翻译框下添加了两个选项：复制原文和复制译文。作为一个前端小白，调试界面的过程真的太难了，这些元素我怎么摆放都不好看。好不容易调试好了，我突然发现其实我不需要给用户提供这个功能，因为弹出翻译框并不影响用户的复制。</p><p>所以最终我没有给复制的选项。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>popup脚本—&gt;右键点击插件，选择检查，就可以打开调试控制台<br>content脚本—&gt;打开浏览器开发者面板，就可以看到<br>background脚本—&gt;在插件管理中，点击服务工作进程，可以打开后台的调试控制台</p><h3 id="理解前端"><a href="#理解前端" class="headerlink" title="理解前端"></a>理解前端</h3><p>前端就类似做IDesign设计，由各种框组成，大框套小框，前后层叠关系类似图层的概念。每一对尖括号就是一个框。</p><p>那么<strong>先把所有的框显示出来，就可以看到各个页面的包含关系</strong>。</p><p>同样，在前端调试界面，可以看到每一个框的代码。如果呈现出来的画面不是自己想要的那样，可以去界面上调试，来查看是哪一块的代码出现了问题。</p><h4 id="如何去设计这些框？"><a href="#如何去设计这些框？" class="headerlink" title="如何去设计这些框？"></a>如何去设计这些框？</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 新框<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>属于哪一类<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  class可以被css和js用来访问和操作元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>可以有不同的标签<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;auto-translate&quot;</span> <span class="attr">checked</span>&gt;</span>可以交互</span><br></pre></td></tr></table></figure><p><code>.css</code>文件可以定义框的属性，框内元素的呈现。比如：</p><ul><li>padding：内部元素与框的距离。padding-left</li><li>margin：内部框与外部框的距离。margin-left</li></ul><h4 id="如何与用户交互"><a href="#如何与用户交互" class="headerlink" title="如何与用户交互"></a>如何与用户交互</h4><p>当用户改变前端界面时，发生了什么？</p><p>比如当用户点击了一个复选框，那么这条信息传到哪里？对后台有什么影响？</p><p>这些交互都可以在js脚本中定义。写js脚本和写其他的编程语言更像，都是写一个又一个的函数去实现各种各样的功能。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>整个插件开发的有效工作时间大概是4天，这个过程AI帮我写了大部份代码，我只是在努力debug。之前的开发debug就是打断点，看变量信息，而在浏览器上调试就是用笨办法，在每一个函数入口都输出日志，然后去看是哪里出现了问题。</p><p>整个过程耗费时间的点：</p><ul><li>各个脚本之间的通信</li><li>浏览器API</li><li>界面调试</li></ul><p>在界面调试时，遇到了几个我实在是解决不了的bug，请外援帮忙解决的。易用性和UI上同门们也都给过建议。</p><p>如果觉得有用，可以在GitHub上帮忙点个star。感谢。<a href="https://github.com/kelinkong/Input-Translation.git">https://github.com/kelinkong/Input-Translation.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求整理&quot;&gt;&lt;a href=&quot;#需求整理&quot; class=&quot;headerlink&quot; title=&quot;需求整理&quot;&gt;&lt;/a&gt;需求整理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;popup.html：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否开启划词翻译&lt;/li&gt;
&lt;li&gt;选择</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（上）</title>
    <link href="http://example.com/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2024-03-05T09:07:30.000Z</published>
    <updated>2024-03-30T12:55:52.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。</strong></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在检索内容时，很多时候需要检索英文内容，但是现有的翻译插件都需要先复制中文翻译后再复制回搜索框，要么就是将输入框翻译作为付费项目，于是就想自己开发一款插件来解决这个问题。</p><p>同时在浏览网页时难免会遇到不认识的单词，所以想融入一个划词翻译的功能，就不需要再额外安装插件。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>在输入框中输入检索内容后，加上尾缀可自动翻译为对应语言，目前支持<code>/en /zh /fr /de</code><ul><li>如<code>测试/en ---&gt; test</code></li></ul></li><li>划词翻译（开发中，暂不支持）</li></ul><h3 id="开发教程"><a href="#开发教程" class="headerlink" title="开发教程"></a>开发教程</h3><h4 id="基于MV3的项目结构"><a href="#基于MV3的项目结构" class="headerlink" title="基于MV3的项目结构"></a>基于MV3的项目结构</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">│</span><br><span class="line">├── manifest<span class="selector-class">.json</span>  // 配置文件</span><br><span class="line">│</span><br><span class="line">├── icons/</span><br><span class="line">│   └── icon16<span class="selector-class">.png</span></span><br><span class="line">│</span><br><span class="line">├── scripts/</span><br><span class="line">│   ├── <span class="attribute">content</span><span class="selector-class">.js</span> // 内容脚本，向访问的网页注入js代码的一种方式</span><br><span class="line">│   ├── <span class="attribute">background</span><span class="selector-class">.js</span> // 后台脚本，可以访问浏览器的所有API</span><br><span class="line">│   └── popup<span class="selector-class">.js</span></span><br><span class="line">│</span><br><span class="line">├── pages/</span><br><span class="line">└── └── popup<span class="selector-class">.html</span> // 弹出窗口样式</span><br></pre></td></tr></table></figure><h5 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 这是manifest文件的版本，当前版本是3。</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input Translation&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Translate text input and selected words.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//这里配置一些相关权限，如该脚本在那些网站上可以运行</span></span><br><span class="line"><span class="string">&quot;*://*/*&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义了扩展的浏览器动作，包括默认的弹出窗口和默认的图标。</span></span><br><span class="line"><span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup/popup.html&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 定义了扩展的后台页面，这里使用了一个服务工作线程。</span></span><br><span class="line"><span class="attr">&quot;service_worker&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;content_scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// 定义了扩展的内容脚本，包括要注入的JS文件和匹配的网页URL。</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;js&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">// 如果content.js脚本要引用其他脚本，可以写在这里</span></span><br><span class="line"><span class="string">&quot;scripts/content.js&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;matches&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;&lt;all_urls&gt;&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>各个脚本的权限：</strong></p><p><img src="/../imgs/image-46.png" alt="alt text"></p><p>在调用百度翻译的API时，由于content脚本不支持直接跨域，所以要先将输入框的信息发送到background脚本，再由background脚本发送，所以这里涉及到两个脚本的通信。</p><p>脚本通信的教程参考：</p><p><a href="https://juejin.cn/post/6844903985711677453">background、content、popup的通信 - 掘金 (juejin.cn)</a></p><h4 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h4><p>popup就是点击扩展图标弹出来的框，输入框翻译这个功能并不需要这个，所以留到下篇再写。</p><h4 id="content-js"><a href="#content-js" class="headerlink" title="content.js"></a>content.js</h4><p>这个脚本的功能是：</p><ul><li>监测用户输入框，判断用户是否输入了相关后缀，如果检测到用户输入相关后缀，就将输入的内容和后缀发送至background脚本。</li><li>接收到信息后，替换原本输入框中的内容</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> match = text.<span class="title function_">match</span>(<span class="regexp">/(.*)(\/en|\/zh|\/fr|\/de)$/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (match) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start to translate&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> textToTranslate = match[<span class="number">1</span>]; <span class="comment">// 匹配到的文本，不包括语言代码</span></span><br><span class="line"><span class="keyword">var</span> languageCode = match[<span class="number">2</span>].<span class="title function_">slice</span>(<span class="number">1</span>); <span class="comment">// 匹配到的语言代码</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123; <span class="attr">text</span>: textToTranslate, <span class="attr">lang</span>: languageCode &#125;, <span class="keyword">function</span> (<span class="params">response</span>) &#123; </span><br><span class="line"><span class="keyword">if</span> (chrome.<span class="property">runtime</span>.<span class="property">lastError</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(chrome.<span class="property">runtime</span>.<span class="property">lastError</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">event.<span class="property">target</span>.<span class="property">value</span> = response.<span class="property">data</span>.<span class="property">trans_result</span>[<span class="number">0</span>].<span class="property">dst</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是<code>chrome.runtime.sendMessage</code>通信方式，将输入的文本和语言发送至background脚本。</p><p>另外，单独检测用户输入框，会导致用户正在输入<code>/en</code>时，就会被翻译，此时再按anter键，就会导致翻译后的文本多一个<code>/en</code>，如<br><code>测试/en  ----&gt; test/en</code><br>这很不优雅，所以这里的监听事件设置为<code>keyup</code>，且设置了1s的延迟。<br><code>document.addEventListener(&#39;keyup&#39;, function (event)</code></p><h4 id="background-js"><a href="#background-js" class="headerlink" title="background.js"></a>background.js</h4><p>这个脚本的功能是：接受content脚本发来的信息，调用百度翻译API，将翻译完成的信息发送给content脚本。</p><p>因为百度翻译API接受的内容需要使用md5算法加密，所以这里要引入md5算法。</p><p><strong>但是在mv3版本中，不支持直接在配置文件中引入脚本，所以这里要使用import的方式。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">importScripts(<span class="string">&#x27;scripts/lib/md5.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发送信息回content脚本有一个问题要注意，因为background脚本可能同时会和很多脚本通信，所以要使用tab的方式进行通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">request, sender, sendResponse</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received in content script:&#x27;</span>, request);</span><br><span class="line"><span class="title function_">translateText</span>(request.<span class="property">text</span>, request.<span class="property">lang</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span> &#125;, <span class="keyword">function</span> (<span class="params">tabs</span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, &#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">sendResponse</span>(&#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/kelinkong/input-translate">kelinkong&#x2F;input-translate (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;在检索内容时，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>托管博客源码</title>
    <link href="http://example.com/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/</id>
    <published>2024-01-31T03:14:41.000Z</published>
    <updated>2024-03-30T03:53:01.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，将源码也上传到仓库，方便查看。</p><h2 id="使用多分支管理"><a href="#使用多分支管理" class="headerlink" title="使用多分支管理"></a>使用多分支管理</h2><ol><li><p>在GitHub创建一个hexo分支，并将其设置为默认分支；</p></li><li><p>将其clone到本地，默认clone的是hexo分支内容，此时会包含一个.git文件夹，还有原本仓库中有的编译后的文件；</p></li><li><p>将原本仓库中的内容删除，只保留.git文件夹；</p></li><li><p>将原本的文件除了.deploy_git文件夹复制到本地仓库中；</p></li><li><p>在.gitignore文件中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p><strong>如果clone过主题文件，需要把主题文件夹中的.git文件夹删除，因为不能嵌套clone</strong></p></li><li><p>将clone的文件提交到hexo分支中；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m add_branch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><p><strong>之后网站更新到main分支，源代码更新到hexo分支。</strong></p><h2 id="解决GitHub无法上传问题"><a href="#解决GitHub无法上传问题" class="headerlink" title="解决GitHub无法上传问题"></a>解决GitHub无法上传问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 127.0.0.1 port 7890</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br></pre></td></tr></table></figure><ul><li>使用代理或者不使用都会提示该问题</li><li>之前使用正常</li></ul><p>参考这个问题：<br><a href="https://github.com/orgs/community/discussions/55269">https://github.com/orgs/community/discussions/55269</a></p><p>最终解决方案：<br>在<code>~/.ssh/config</code>中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname 20.200.245.248</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="http://example.com/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-12-05T04:29:14.479Z</published>
    <updated>2024-03-30T03:51:23.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/../imgs/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed --save</code></p><h3 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h3><p>在vscode中预览是有图片的，生成和发布之后无法显示图片。<br><img src="/../imgs/image-4.png"></p><p>因为在源文件的 post 目录下新建了 img 子目录,然后在 markdown 中使用相对路径引用图片。</p><p>这在本地预览时可以正常显示,但是部署后会出错。</p><p>因为 Hexo 在生成时,会将 post 中的 markdown 和资源文件一起复制到 public 目录,相对位置不变。</p><p>但是 img 子目录不会自动复制过去。所以 public 中找不到 img 中的图片,导致无法显示。</p><p><strong>解决方法：</strong> 将img重命名为imgs(因为会和主题的img文件夹命名冲突)，然后将文件夹移动到<code>source</code>目录下，而不是放在<code>_posts</code>目录下，注意粘贴的设置也需要修改为imgs。</p><p><img src="/../imgs/image-6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="Frontend" scheme="http://example.com/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>前端基础学习</title>
    <link href="http://example.com/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-17T21:54:32.000Z</published>
    <updated>2024-03-30T03:52:47.492Z</updated>
    
    <content type="html"><![CDATA[<ol><li>html定义了网页内容</li><li>css描述了网页的布局</li><li>js控制了网页的行为(通过函数)</li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML:</strong> 超文本标记语言，运行在浏览器上，由浏览器来解析。文件名后缀为<code>.html</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 声明文档类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 头部元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 定义一个大标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 定义一个段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="什么是html？"><a href="#什么是html？" class="headerlink" title="什么是html？"></a>什么是html？</h3><ul><li>html是一种标记语言（标记标签）</li><li>使用标记标签来描述网页</li><li>html文档包含了html标签及文本内容</li></ul><p><strong>html的标签：</strong> </p><ul><li>由尖括号包围的关键词，如<code>&lt;html&gt;</code></li><li>标签通常是成对出现的，如<code>&lt;html&gt;&lt;/html&gt;</code></li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li><li>开始标签和结束标签也被称为开放标签和闭合标签 <code>&lt;标签&gt;内容&lt;/标签&gt;</code></li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 超链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">decoding</span>=<span class="string">&quot;async&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;百度logo&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span>&gt;</span> <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 换行 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol><li>对于中文网页需要使用<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>来指定编码格式，否则会出现乱码。</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>CSS:</strong> 层叠样式表，用于设置HTML元素的样式，如颜色、字体、大小、间距、边框等。文件名后缀为<code>.css</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f3f3f3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>选择器：要改变样式的html元素</li><li>声明块：由<code>&#123;&#125;</code>包围的一条或多条声明，如<code>color: red;</code>，总是以分号结尾，用大括号括起来</li><li>注释：<code>/* */</code>，不会被浏览器读取，可以提高代码可读性</li></ul><h3 id="id和class选择器"><a href="#id和class选择器" class="headerlink" title="id和class选择器"></a>id和class选择器</h3><p><strong>id：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#para1</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个段落不受该样式的影响。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class：</strong><br>class用于描述一组元素的样式，可以在多个元素中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.center</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题居中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>段落居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id选择器用于唯一的元素</li><li>class选择器通常具有重用性</li></ul><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ul><li>id不要以数字开头</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>每个页面使用<code>&lt;link&gt;</code>标签链接到外部样式表，外部样式表通常存储在<code>.css</code>文件中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会从文件<code>mystyle.css</code>中读取样式信息，然后将其应用到当前的文档上。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>参考上面的写法。</p><p>优先级：内联样式 》 内部样式 》 外部样式</p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>不过多赘述，需要时再查阅。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>JavaScript:</strong> 一种轻量级的编程语言，可用于创建动态网页。文件名后缀为<code>.js</code>。</p><p>编程语言语法不做过多赘述，主要关注JavsScript是如何和HTML交互的。</p><h3 id="js能够直接写入html输出流中"><a href="#js能够直接写入html输出流中" class="headerlink" title="js能够直接写入html输出流中"></a>js能够直接写入html输出流中</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js对事件的反应"><a href="#js对事件的反应" class="headerlink" title="js对事件的反应"></a>js对事件的反应</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Welcome!&#x27;)&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="改变html内容"><a href="#改变html内容" class="headerlink" title="改变html内容"></a>改变html内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一段 JavaScript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">JavaScript 能改变 HTML 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">x=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);  <span class="comment">// 找到元素</span></span></span><br><span class="line"><span class="language-javascript">x.<span class="property">innerHTML</span>=<span class="string">&quot;Hello JavaScript!&quot;</span>;    <span class="comment">// 改变内容</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>HTML中的JavaScript代码必须位于<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间。放置到<code>&lt;body&gt;</code>和<code>&lt;head&gt;</code>标签中都可以。</p><p>通常的做法是把函数放入到<code>&lt;head&gt;</code>标签中，然后在<code>&lt;body&gt;</code>标签中调用函数。或者是放置到底部。</p><h4 id="外部的JavaScript"><a href="#外部的JavaScript" class="headerlink" title="外部的JavaScript"></a>外部的JavaScript</h4><p>如果需要使用外部文件，在<code>&lt;script&gt;</code>标签的src属性中设置该文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>输出：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 弹出警告框</span></span><br><span class="line">innerHTML <span class="comment">// 内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() <span class="comment">// 控制台</span></span><br></pre></td></tr></table></figure><p><strong>变量：</strong><br>Number\String\Array\Object\Function</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, length;</span><br><span class="line">x = <span class="number">1.2</span>;</span><br><span class="line">length = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>&#125;;  <span class="comment">// Object 通过对象字面量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;                                <span class="comment">// 返回 a 乘以 b 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些交互示例"><a href="#一些交互示例" class="headerlink" title="一些交互示例"></a>一些交互示例</h3><ul><li>JavaScript可以附加到HTML元素上的事件处理程序，例如点击事件、鼠标移动事件、键- 盘事件等。<br>当事件发生时，与该事件相关的JavaScript代码将被执行，以响应用户的操作。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮被点击了！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以访问和操作文档对象模型（DOM），这是HTML页面的表示。</li><li>通过JavaScript，您可以创建、修改、删除HTML元素，以及改变元素的样式和内容。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    myDiv.<span class="property">innerHTML</span> = <span class="string">&quot;现在我被JavaScript修改了！&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以用于验证表单数据、提交表单、以及处理表单的输入。</li><li>可以使用JavaScript来验证用户输入是否有效，然后根据验证结果采取相应的行动。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (nameInput.<span class="property">value</span> === <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;请输入您的姓名！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单提交</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;html定义了网页内容&lt;/li&gt;
&lt;li&gt;css描述了网页的布局&lt;/li&gt;
&lt;li&gt;js控制了网页的行为(通过函数)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++代码调试</title>
    <link href="http://example.com/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>http://example.com/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</id>
    <published>2023-10-10T00:15:48.000Z</published>
    <updated>2024-03-30T03:51:52.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC-工作流程"><a href="#GCC-工作流程" class="headerlink" title="GCC 工作流程"></a>GCC 工作流程</h2><table><thead><tr><th>说明</th><th>文件后缀</th><th>参数</th></tr></thead><tbody><tr><td>预处理</td><td>.c</td><td>-</td></tr><tr><td>编译</td><td>.i</td><td>-E</td></tr><tr><td>汇编</td><td>.s</td><td>-S</td></tr><tr><td>链接</td><td>.o</td><td>-c</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预处理。 -o 参数是为了指定编译后的文件名</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -S test.i -o test.s </span><br><span class="line"><span class="comment"># 汇编</span></span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>生成调试信息，即可调试</td></tr><tr><td>-D</td><td>指定一个宏</td></tr><tr><td>-l</td><td>指定链接库</td></tr><tr><td>-std</td><td>指定C++版本</td></tr><tr><td>-I</td><td>指定头文件路径</td></tr><tr><td>-Wall</td><td>打开所有警告信息</td></tr></tbody></table><p><strong><code>-D</code>参数应用场景：</strong><br>在发布程序的时候，一般会将所有log输出去掉，如果不去掉会影响程序的执行效率。这时候可以在编译的时候加上<code>-D</code>参数，定义一个宏，然后在程序中使用这个宏，如果是发布程序，就不定义这个宏，这样就可以在编译的时候去掉所有的log输出。</p><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> string.c main.c</span><br></pre></td></tr></table></figure><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p><strong>在编译阶段：</strong></p><ul><li>后缀为.c的文件，gcc会将其当做C语言源文件，g++会将其当做C++语言源文件。</li><li>后缀为.cpp的文件，两者都会将其当做C++语言源文件。</li><li>g++会调用gcc，对于C++代码，两者是等价的，也就是说gcc和g++都可以编译C&#x2F;C++代码</li></ul><p><strong>在链接阶段：</strong></p><ul><li>gcc和g++都可以自动连接到标准C库</li><li>g++会自动连接到标准C++库，gcc如果要链接到标准C++库需要加参数<code>-lstdc++</code></li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><strong>gdb调试的代码必须添加-g参数，-g的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行。</strong></p><p><em>使用CMake编译的，添加<code>-DCMAKE_BUILD_TYPE=Debug</code>参数</em>。</p><h3 id="启动和退出gdb"><a href="#启动和退出gdb" class="headerlink" title="启动和退出gdb"></a>启动和退出gdb</h3><p><strong>gdb进程启动之后，需要被调试的应用程序是没有执行的。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;program&gt; <span class="comment"># 启动</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args &lt;arg1&gt; &lt;arg2&gt; <span class="comment"># 设置参数,启动应用程序之前可能需要传参</span></span><br><span class="line"></span><br><span class="line">show args <span class="comment"># 查看参数</span></span><br></pre></td></tr></table></figure><p><strong>在gdb中启动程序：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">(gdb) start <span class="comment"># 会阻塞到main函数第一行</span></span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>run</td><td>启动程序</td><td></td></tr><tr><td>continue &#x3D; c</td><td>继续执行程序</td><td></td></tr><tr><td>quit &#x3D;&#x3D; q</td><td>退出gdb</td><td></td></tr><tr><td>list &#x3D;&#x3D; l</td><td>列出源代码</td><td>l 行号, l 函数名， l 文件名：行号</td></tr><tr><td>break &#x3D;&#x3D; b</td><td>设置断点</td><td>b 行号, b 函数名， b 文件名：行号， b 行数 if 变量名&#x3D;某个值</td></tr><tr><td>info &#x3D;&#x3D; i</td><td>查看信息</td><td>i breakpoints, i locals, i args</td></tr><tr><td>delete &#x3D; del &#x3D; d</td><td>删除断点</td><td>d 断点号</td></tr><tr><td>disable &#x3D; dis</td><td>禁用断点</td><td>disable 断点号</td></tr><tr><td>enable &#x3D; ena</td><td>启用断点</td><td>enable 断点号</td></tr><tr><td>print &#x3D; p</td><td>打印变量</td><td>p 变量名</td></tr><tr><td>ptype</td><td>打印变量类型</td><td>ptype 变量名</td></tr><tr><td>display</td><td>跟踪查看变量</td><td>display 变量名</td></tr><tr><td>step &#x3D; s</td><td>单步执行，进入函数</td><td></td></tr><tr><td>finish</td><td>执行到当前函数返回为止</td><td></td></tr><tr><td>next &#x3D; n</td><td>单步执行，不进入函数</td><td></td></tr><tr><td>until</td><td>跳出循环</td><td></td></tr><tr><td>set</td><td>修改变量值</td><td>set 变量名&#x3D;值</td></tr></tbody></table><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>参考<a href="https://www.hahack.com/codes/cmake/">Cmake快速入门</a></p><p>cmake的基本语法：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake &lt;<span class="keyword">option</span>&gt; &lt;path&gt;</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table><thead><tr><th>含义</th><th>指令</th></tr></thead><tbody><tr><td>编译</td><td>cmake <code>&lt;path&gt;</code>, 当前目录为<code>.</code>,上一级目录为<code>..</code></td></tr><tr><td>清理cmake缓存</td><td><code>rm -rf CMakeFiles/ CMakeCache.txt cmake_install.cmake Makefile</code></td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每一个层级都需要写CMakeLists.txt文件</li><li>需要在父层级添加子层级的目录</li><li>需要在父层级添加子层级的库&#x2F;子目录包含可执行文件</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>文件结构：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── cmake_notes</span><br><span class="line">│   ├── build</span><br><span class="line">│   └── math</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├── myfunction.h</span><br><span class="line">│       └── myfunction.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.txt</span><br></pre></td></tr></table></figure><p>第一层级的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(Demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否用自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DUSE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否加入MathFunctions库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable(Demo main.cpp print.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="comment"># add_subdirectory(math)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo -lpthread)</span><br></pre></td></tr></table></figure><p><strong>在源代码中使用：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use my math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use system math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// USE_MYMATH</span></span></span><br></pre></td></tr></table></figure><p><strong>子目录的CMakeLists文档，需要add_executable吗?</strong></p><p>子目录包含可执行文件：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp other_source.cpp)</span><br></pre></td></tr></table></figure><p>子目录只包含库代码：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_library</span>(my_library my_source.cpp)</span><br></pre></td></tr></table></figure><p>这将创建一个库目标而不是可执行文件，以便在主目录的CMakeLists.txt文件中或其他子目录中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GCC-工作流程&quot;&gt;&lt;a href=&quot;#GCC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;GCC 工作流程&quot;&gt;&lt;/a&gt;GCC 工作流程&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="CPP" scheme="http://example.com/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程模型</title>
    <link href="http://example.com/2023/10/10/%E3%80%90c++%E3%80%91-threads/"/>
    <id>http://example.com/2023/10/10/%E3%80%90c++%E3%80%91-threads/</id>
    <published>2023-10-09T22:47:41.000Z</published>
    <updated>2024-03-30T03:51:58.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步和线程通信"><a href="#线程同步和线程通信" class="headerlink" title="线程同步和线程通信"></a>线程同步和线程通信</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>互斥锁</li><li>条件变量</li><li>互斥量</li><li>信号量</li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li>条件变量</li><li>队列</li><li>原子操作</li><li>条件变量和定时器</li></ol><h2 id="C-标准库提供了哪些锁？"><a href="#C-标准库提供了哪些锁？" class="headerlink" title="C++标准库提供了哪些锁？"></a>C++标准库提供了哪些锁？</h2><p><code>std::mutex</code>：互斥锁是最基本的锁类型，用于确保一次只有一个线程可以访问共享资源。你可以使用 std::mutex 来创建一个互斥锁对象，然后使用 lock() 和 unlock() 方法来手动锁定和解锁。</p><p><code>std::unique_lock：</code>std::unique_lock 是一个更加灵活的互斥锁包装器，它允许你在需要时手动锁定和解锁，也可以在构造函数和析构函数中自动锁定和解锁。</p><p><code>std::lock_guard：</code>std::lock_guard 是另一个互斥锁包装器，但它只支持自动锁定和解锁。一旦 std::lock_guard 对象被创建，它会自动锁定互斥锁，并在其生命周期结束时自动解锁。</p><p><code>std::recursive_mutex：</code>递归互斥锁允许同一线程多次获得锁。这对于某些特定的情况很有用，但要小心避免死锁。</p><p><code>std::shared_mutex：</code>共享互斥锁（C++17引入）允许多个线程同时读取共享资源，但只有一个线程可以写入资源。这有助于提高并发性能。</p><p><code>std::condition_variable：</code>条件变量用于线程之间的同步和通信。它们允许一个线程等待某个条件成立，然后另一个线程发出信号以通知等待线程。</p><h2 id="实现线程的交替打印："><a href="#实现线程的交替打印：" class="headerlink" title="实现线程的交替打印："></a>实现线程的交替打印：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATTIONS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 锁，用于线程同步</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量，用于线程通信</span></span><br><span class="line"><span class="type">int</span> current_thread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> thread_num, <span class="type">const</span> std::string&amp; messages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITERATTIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取锁，进入临界区</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是当前线程，就等待</span></span><br><span class="line">        <span class="keyword">while</span> (current_thread != thread_num) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 释放锁，允许其他线程进入临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        std::cout &lt;&lt; messages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改当前线程的编号</span></span><br><span class="line">        current_thread = (current_thread + <span class="number">1</span>) % NUM_THREADS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知下一个线程开始打印</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>(); <span class="comment">// 这里并没有释放锁，当前线程仍然持有锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print, i, <span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span> -pthread</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么使用条件变量唤醒的时候要用while而不用if？"><a href="#为什么使用条件变量唤醒的时候要用while而不用if？" class="headerlink" title="为什么使用条件变量唤醒的时候要用while而不用if？"></a>为什么使用条件变量唤醒的时候要用while而不用if？</h3><p>条件变量在等待期间可能会收到虚假唤醒（spurious wakeups），也就是在条件尚未满足时，线程被唤醒。</p><p>虚假唤醒是由于操作系统或底层线程库的实现细节引起的，他们可能会偶尔导致条件变量的信号量被错误唤醒。所以要循环检查，直到条件不满足。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程同步和线程通信&quot;&gt;&lt;a href=&quot;#线程同步和线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程同步和线程通信&quot;&gt;&lt;/a&gt;线程同步和线程通信&lt;/h2&gt;&lt;h3 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CPP" scheme="http://example.com/categories/CPP/"/>
    
    
    <category term="CPP" scheme="http://example.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CS50课程学习笔记</title>
    <link href="http://example.com/2023/10/08/cs50/"/>
    <id>http://example.com/2023/10/08/cs50/</id>
    <published>2023-10-07T19:26:51.000Z</published>
    <updated>2024-03-30T03:54:37.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h3><ul><li>input –&gt; black box –&gt; output</li><li>binary&#x2F;bit: A bit is a zero or one</li><li>text: using ASCII</li><li>Emojis: Unicode</li><li>RGB: three numbers</li><li>Images, Video and Sound are simply collections of RGB values</li></ul><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ul><li>Problem-solving is central to computer science and computer programming</li></ul><h3 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h3><ul><li>function：pick up</li><li>conditions：if elseif</li><li>Boolean expression</li><li>loops：for&#x2F;while</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p><strong>command line interface</strong>：CLI， send commands to the computer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><em>这里并没有写makefile文件，为什么可以直接编译呢？</em><br><em>make程序默认会根据源代码文件的后缀名，自动生成并使用一个默认的Makefile规则进行编译。对于c语言的源代码，会有一个默认规则，类似如下：</em></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c <span class="comment"># % 是通配符，匹配任意字符串，匹配所有.c结尾的文件，生成以.o结尾的目标文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment"># $(CC) 变量，使用CC编译器。 $(CFLAGS)编译参数， -c表示进行编译而不链接， $&lt; 取出第一个前置文件的名字，即.c文件，-o指定输出目标文件，&amp;@ 取出目标文件的名字，既.o文件</span></span><br></pre></td></tr></table></figure><p>这里提到一个进行编译而不链接。回顾一下c语言编译的过程</p><ol><li>预处理，生成扩展后的.i文件。删除所有注释、#define 宏展开、文件包含 #include&lt;文件名&gt;</li><li>编译，汇编代码文件.s。会进行语法检查</li><li>组装。将汇编文件转化为机器码。生成.o文件</li><li>链接。链接是将库文件包含在我们的程序中的过程。生成可执行文件.out</li></ol><p><strong>静态成员变量是在哪一个阶段被初始化的呢？</strong></p><p><em>我们都知道静态成员变量是在运行<code>main</code>函数前初始化，那么究竟是在编译的哪一个阶段呢？</em></p><ol><li>定义在类内部的静态成员变量,其初始化是在编译期初期完成的。</li><li>定义在类外部的静态成员变量,其初始化是在链接阶段完成的。</li></ol><p>区别在于:</p><p>对于类内部定义的静态成员变量,编译器可以在编译当前类的定义时直接初始化它。</p><p>而对于类外部定义的静态成员变量,需要到链接阶段不同的目标文件合并时,由链接器完成初始化操作。</p><p><strong>预编译阶段，编译器会把#include包含的头文件内容展开Inline，但是对于lib库的引用则不会展开，而是保留该引用。真正使用库里的目标文件是在链接阶段。由链接器解析引用，并从外部库获取目标代码进行连接。</strong></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>linear and binary search</li><li>data structures</li><li>sorting</li><li>recursion</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><strong>内存地址为什么用16进制存放？</strong></p><ol><li>紧凑表示：使用尽可能少的数字来表示较大的内存空间</li><li>与CPU寻址匹配： CPU使用总线地址线表示内存地址，地址线数量是2的指数倍（如8条、16条），这与16进制表示是匹配的</li><li>转换为二进制方便，16进制中的每一个恰好对应2进制中的4位，可以非常方便的转换为二进制数。</li></ol><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>指针的本质就是一个地址变量。指向的是操作系统给模拟出来的虚拟内存空间的地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p是一个指针，(*p)表示获取指针所指向的值，&amp;符合代表取地址</span></span><br></pre></td></tr></table></figure><p>在c语言中<br><code>string</code>类型本质就是一个指针，以<code>&#39;\0&#39;</code>位标识符结尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HI!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">1</span>]); <span class="comment">// I</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">2</span>]); <span class="comment">// !</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">3</span>]); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">4</span>]); <span class="comment">// %</span></span><br></pre></td></tr></table></figure><p>为什么没有提示数组越界呢？</p><p><em>在c语言中数组边界检查并不是强制的。所以这访问越界并没有报错，但是可能会导致其他问题。当访问s[3]之后的值时，读取的是垃圾内存的值。</em></p><h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>valgrind是一个检查是否有内存泄漏的工具，比如使用malloc但是没有使用free。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    x[<span class="number">0</span>] = <span class="number">72</span>;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">73</span>;</span><br><span class="line">    x[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make test</code></p><p><code>valgrind --leak-check=full ./test</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==61782== HEAP SUMMARY:</span><br><span class="line">==61782==     in use at exit: 12 bytes in 1 blocks</span><br><span class="line">==61782==   total heap usage: 1 allocs, 0 frees, 12 bytes allocated</span><br><span class="line">==61782== </span><br><span class="line">==61782== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==61782==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==61782==    by 0x10915E: main (in /home/kelin/cs50/test)</span><br></pre></td></tr></table></figure><p><strong>valgind可以检查哪些类型的错误呢？</strong></p><ol><li>内存管理错误：访问越界、未释放、访问未初始化的内存等</li><li>线程错误：程序未正确join线程、线程同步错误（多个线程争用资源未加锁）</li><li>I&#x2F;O操作错误：文件描述符泄漏、socket使用错误</li><li>未定义行为：访问未初始化的变量</li></ol><h3 id="在c语言中，打开文件是如何实现的？"><a href="#在c语言中，打开文件是如何实现的？" class="headerlink" title="在c语言中，打开文件是如何实现的？"></a>在c语言中，打开文件是如何实现的？</h3><ol><li>open系统调用</li><li>分配文件描述符：文件描述符是内核用来标识这个文件打开状态的整数</li><li>更新文件表：将文件描述符放入进程的文件描述符表，该表维护了进程打开文件的状态</li><li>返回文件描述符：open系统调用返回文件描述符给应用程序</li><li>read&#x2F;write调用</li><li>关闭</li></ol><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p><strong><code>curl</code></strong></p><p>curl用来发送各种HTTP请求，获取或传输数据。</p><table><thead><tr><th>参数</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-X</td><td>指定http请求的方法</td><td>-X GET</td></tr><tr><td>-d</td><td>指定发送的数据体</td><td>-d ‘data&#x3D;test’</td></tr><tr><td>-I</td><td>只显示响应头信息，不显示响应内容</td><td></td></tr><tr><td>-w</td><td>将响应头信息保存到文件</td><td></td></tr><tr><td>-O</td><td>将服务器访问保存为文件</td><td>curl -O example.com&#x2F;file1.zip</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;Computational-Thinking&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Operating System" scheme="http://example.com/categories/Operating-System/"/>
    
    
    <category term="note" scheme="http://example.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>执行一个程序的过程</title>
    <link href="http://example.com/2023/08/25/exec-program/"/>
    <id>http://example.com/2023/08/25/exec-program/</id>
    <published>2023-08-25T02:09:26.000Z</published>
    <updated>2024-03-30T03:54:50.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li></ul><p><img src="/../imgs/image-44.png" alt="图来源于小林coding"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>程序和数据都是存储在内存中，存储的区域是线性的。存储数据的基本单位是<strong>字节（byte）</strong>，一字节等于8位（bit），每一个字节对应着一个内存地址。</p><h3 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h3><p>32位和64位CPU最主要区别在于一次能计算多少字节的数据</p><ul><li>32位一次能计算4个字节，虚拟内存空间大小为$2^{32}$，4G</li><li>64位一次能计算8个字节</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>通用寄存器：用来存放需要进行运算的数据(执行单元)</li><li>程序计数器：用来存储CPU要执行下一条指令所在的内存地址（此时指令仍然在内存中）（控制单元）</li><li>指令寄存器：用来存放正在执行的指令（控制单元）</li></ul><h3 id="存储器接口-Memory-Interface"><a href="#存储器接口-Memory-Interface" class="headerlink" title="存储器接口(Memory Interface)"></a>存储器接口(Memory Interface)</h3><p>与内存交互,读写数据。</p><h4 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h4><p>提取指令、解析指令、产生控制信号。</p><h4 id="执行单元-Execution-Unit"><a href="#执行单元-Execution-Unit" class="headerlink" title="执行单元(Execution Unit)"></a>执行单元(Execution Unit)</h4><p>包含算术逻辑单元ALU和通用寄存器组,执行各种运算和数据处理。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li>地址总线：用于指定CPU将要操作的内存地址</li><li>数据总线：用于读写内存的数据</li><li>控制总线：用于发送和接收信号</li></ul><p>通过地址总线来指定内存内存的地址–&gt;通过控制总线控制是读或写命令–&gt;通过数据总线传输数据。</p><h2 id="程序是如何执行的？"><a href="#程序是如何执行的？" class="headerlink" title="程序是如何执行的？"></a>程序是如何执行的？</h2><p><img src="/../imgs/image-45.png"></p><p>指令：一串二进制数字的机器码，不同的CPU有不同的指令集</p><p><strong>指令是存放在虚拟内存里还是物理内存中？</strong></p><p>虚拟内存为每个进程提供一片连续的虚拟地址空间，各进程的虚拟地址空间是独立的，指令与数据位于不同进程的虚拟地址空间中，因此多个进程共同执行时，他们的指令集不会交叉。</p><p><strong>那么程序计数器加1的时候，是加的虚拟内存还是实际内存？CPU直接操作的是实际内存还是虚拟内存？</strong></p><p>程序计数器加1时,它加的都是虚拟地址。CPU在执行程序时,直接操作和访问的也都是虚拟地址,而不是实际物理地址。</p><ol><li>CPU送出的下一条指令虚拟地址到MMU</li><li>MMU根据页表查找虚拟地址到物理地址的映射</li><li>若对应页不在物理内存，则触发缺页中断，os将其从磁盘换入</li><li>MMU最终将虚拟地址翻译为物理地址，从物理地址中读取指令后，将指令发送至CPU</li><li>CPU执行该指令</li><li>程序计数器中的虚拟地址+1</li></ol><h3 id="对于一个C-程序而言，是如何把代码变成指令集的？"><a href="#对于一个C-程序而言，是如何把代码变成指令集的？" class="headerlink" title="对于一个C++程序而言，是如何把代码变成指令集的？"></a>对于一个C++程序而言，是如何把代码变成指令集的？</h3><h4 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing)"></a>预处理(Preprocessing)</h4><p>预编译器处理头文件包含、宏定义展开等预处理工作,生成扩展后的源代码。<code>#define</code></p><h4 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h4><p>编译器将预处理后的C++源代码编译成汇编语言。这个过程包括词法分析、语法分析、语义分析、中间代码生成、目标代码生成等步骤。内联函数会被直接插入到每一个调用点，省去了函数调用的过程。</p><h4 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h4><p>汇编程序将汇编语言转换成机器语言,生成目标文件。</p><h4 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接(Linking)"></a>链接(Linking)</h4><p>链接器将多个目标文件和系统库链接生成完整的可执行程序。</p><p>在这个过程中,C++源代码经过编译器的编译和汇编程序的汇编,最终被转换成机器指令,这些指令保存在可执行文件的代码段,可以直接被CPU执行。</p><h3 id="编译前和编译后代码是存放在哪里？"><a href="#编译前和编译后代码是存放在哪里？" class="headerlink" title="编译前和编译后代码是存放在哪里？"></a>编译前和编译后代码是存放在哪里？</h3><h4 id="编译前"><a href="#编译前" class="headerlink" title="编译前:"></a>编译前:</h4><p>源代码以文本文件的形式存储在文件系统中,使用高级语言编写,对人更友好。</p><p>源代码包含了数据结构定义、算法流程、程序逻辑等信息。但不能直接被计算机执行。</p><h4 id="编译后："><a href="#编译后：" class="headerlink" title="编译后："></a>编译后：</h4><p>经过编译器编译后,会生成机器代码,存放在可执行文件的代码段中。</p><p>机器代码使用机器指令组成,可以直接被CPU执行。</p><p>举个例子：当我调用<code>new</code>关键字去为一个对象分配内存时，在编译前这仅仅是一个抽象的概念，<strong>内存分配是在运行时发生的</strong>。</p><h3 id="在编译的时候，编译顺序是怎么样的？"><a href="#在编译的时候，编译顺序是怎么样的？" class="headerlink" title="在编译的时候，编译顺序是怎么样的？"></a>在编译的时候，编译顺序是怎么样的？</h3><p>以下面的代码为例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 预处理阶段</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val)&#123;&#125; <span class="comment">// 构造函数和析构函数机器码</span></span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;&#125; <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">sFunc</span><span class="params">()</span></span>; <span class="comment">// 没有this指针，所以只能调用静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_val = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_val = <span class="number">1</span>; <span class="comment">// 所有实例共享，不属于类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Node * node_ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    node.<span class="built_in">func</span>();</span><br><span class="line">    node_ptr.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> node_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main函数执行之前，需要做什么？"><a href="#main函数执行之前，需要做什么？" class="headerlink" title="main函数执行之前，需要做什么？"></a>main函数执行之前，需要做什么？</h3><ol><li>设置栈指针</li><li>初始化静态static变量和global变量。静态类的构造函数在这里被调用</li><li>初始化全局变量，全局对象的构造函数也在main之前被调用</li><li>将main函数所需参数传递给main函数</li></ol><h3 id="在main函数之后，需要执行什么？"><a href="#在main函数之后，需要执行什么？" class="headerlink" title="在main函数之后，需要执行什么？"></a>在main函数之后，需要执行什么？</h3><ol><li>全局对象的析构函数</li><li>可以使用<code>atexit</code>注册一个函数，会在main之后执行</li></ol><h3 id="静态成员函数也是放在代码区的吗？"><a href="#静态成员函数也是放在代码区的吗？" class="headerlink" title="静态成员函数也是放在代码区的吗？"></a>静态成员函数也是放在代码区的吗？</h3><p>是的。编译器会为静态成员函数生成对应的机器代码，不需要实例化类就可以调用，机器代码独立生成，不依赖任何实例。</p><h3 id="函数调用时是如何传递参数的？"><a href="#函数调用时是如何传递参数的？" class="headerlink" title="函数调用时是如何传递参数的？"></a>函数调用时是如何传递参数的？</h3><ol><li>把参数的值从寄存器或内存加载到CPU的通用寄存器中。</li><li>调用指令将程序控制流跳转到函数代码地址。</li><li>在跳转前,调用指令会将返回地址等寄存器信息压入调用栈,用于保留调用环境。</li><li>跳转执行函数代码,函数中的局部变量也可能在栈上分配。</li><li>在函数执行前,根据调用约定从寄存器或栈空间中读取参数值。</li><li>函数执行完后,使用返回指令跳回调用点。</li><li>返回前依照调用约定将返回值写入寄存器或内存。</li><li>返回后,调用栈恢复,继续执行调用代码。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冯诺依曼模型&quot;&gt;&lt;a href=&quot;#冯诺依曼模型&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼模型&quot;&gt;&lt;/a&gt;冯诺依曼模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;</summary>
      
    
    
    
    <category term="Operating System" scheme="http://example.com/categories/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency Control</title>
    <link href="http://example.com/2023/08/21/Concurrency-Control/"/>
    <id>http://example.com/2023/08/21/Concurrency-Control/</id>
    <published>2023-08-20T20:39:32.000Z</published>
    <updated>2024-03-30T03:53:47.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="project4需要实现的内容"><a href="#project4需要实现的内容" class="headerlink" title="project4需要实现的内容"></a>project4需要实现的内容</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/project4/">project任务链接</a></p><h3 id="Lock-Manager："><a href="#Lock-Manager：" class="headerlink" title="Lock Manager："></a>Lock Manager：</h3><p><code>src/include/concurrency/lock_manager.h</code></p><p><code>concurrency/lock_manager.cpp</code></p><h4 id="Lock-Manager的作用是什么？"><a href="#Lock-Manager的作用是什么？" class="headerlink" title="Lock Manager的作用是什么？"></a>Lock Manager的作用是什么？</h4><p>Lock Manager 的作用是处理事务发送的锁请。事务在被允许访问某个数据项之前,需要先向锁管理器发出锁请求。锁管理器将向调用事务授予锁,阻塞该事务,或者中止它。</p><p>例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。</p><p>整个系统将具有一个全局的锁管理器(类似于缓冲池管理器)。TableHeap和Executor类将使用你实现的锁管理器在事务想访问或修改一个元组记录时获取行锁(通过记录ID RID)。</p><p>这个任务要求实现一个支持三种常见隔离级别的表级锁和行级锁:READ_UNCOMMITTED, READ_COMMITTED和REPEATABLE_READ。锁管理器应该根据事务的隔离级别授予或释放锁。请参考课件复习隔离级别。</p><p>在代码库中,提供了一个Transaction上下文处理(transaction.h),其中包含隔离级别属性和它持有的锁的相关信息。锁管理器需要检查事务的隔离级别并公开在锁请求上的正确行为。任何失败的锁操作都应导致事务进入ABORTED状态(隐式中止)并抛出异常。事务管理器(transaction_manager.h)会进一步捕获这个异常并回滚事务执行的写操作。</p><h4 id="三种隔离级别的实现"><a href="#三种隔离级别的实现" class="headerlink" title="三种隔离级别的实现"></a>三种隔离级别的实现</h4><ul><li>READ_UNCOMMITED只有在需要时上写锁。</li><li>READ_COMMITTED要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。</li><li>REPEATABLE_READ进一步打造可重复读。同一事务读两次数据的中途不想被其他事务的写干扰，这就需要用到巧妙的二段封锁协议（2PL）了：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段(GROWING)只上锁，解锁阶段(SHINKING)只解锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPEATABLE_READ:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   No locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_COMMITTED:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   Only IS, S locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_UNCOMMITTED:</span><br><span class="line">   The transaction is required to take only IX, X locks.</span><br><span class="line">   X, IX locks are allowed in the GROWING state.</span><br><span class="line">   S, IS, SIX locks are never allowed</span><br></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>由于对行添加S&#x2F;X锁时，需要对应的对行所在的表添加IS&#x2F;IX锁，所以需要记录每一个表里有哪些行被加锁。</p><p>这里用一个map来实现对应表id和行集合。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** LockManager: the set of row locks held by this transaction. */</span></span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; s_row_lock_set_;</span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; x_row_lock_set_;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/image-43.png"></p><p><strong>获取表锁</strong></p><ol><li>判断锁请求是否合理(如果当前事务Abort&#x2F;Commit，或者加锁类型与事务隔离级别不符合，抛异常)</li><li>从 <code>table_lock_map_</code> 中获取 table 对应的 <code>lock request queue</code>。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</li><li>判断之前该事务是否对这个表进行加过锁</li><li>如果之前加过锁，升级该锁（级别不能比当前的锁的级别要低且不能有另一个事务也在对这个表进行升级），创建一个新的LockRequest，加入到队列尾部</li><li>尝试获取锁，如果<code>GrantLock()</code>为真，可以获取锁，否则循环等待，这里使用条件变量<code>queue-&gt;cv_.wait(queue-&gt;latch_);</code>, 当这个锁被释放时，会唤醒当前线程，判断是否能获取锁。</li></ol><p><strong>GrantLock()</strong></p><ol><li>判断当前的锁请求是否与所有的<code>granted</code>的请求兼容</li><li>判断优先级</li></ol><p>tips：</p><p>使用条件变量去通知请求队列上等待的线程。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** List of lock requests for the same resource (table or row) */</span></span><br><span class="line">  std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">  <span class="comment">/** For notifying blocked transactions on this rid */</span></span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  <span class="comment">/** txn_id of an upgrading transaction (if any) */</span></span><br><span class="line">  <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="comment">/** coordination */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解表锁：</strong></p><ol><li>判断可以不可以解锁：之前是否加过锁，如果是解锁表锁，要检测该表中有没有行被加过锁</li><li>检查在对应隔离级别下是否要进入Shrinking状态</li><li>删除锁</li></ol><p>行锁与表锁类似，解锁时不需要检查是否有表锁。</p><h3 id="Deadlock-Detection："><a href="#Deadlock-Detection：" class="headerlink" title="Deadlock Detection："></a>Deadlock Detection：</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** Waits-for graph representation. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">txn_id_t</span>, std::vector&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br></pre></td></tr></table></figure><p>并不需要时刻维护wait for图，而是在死锁检测线程被唤醒的时候，根据当前请求队列构建的wait for图，再通过这个图去判断是否存在死锁。</p><ul><li>当检测到有圈时，这里采取的victim策略是找到事务ID最大的返回，因为这个事务是最年轻的。</li><li>默认的检测时间是50ms</li></ul><h3 id="Concurrent-Query-Execution"><a href="#Concurrent-Query-Execution" class="headerlink" title="Concurrent Query Execution"></a>Concurrent Query Execution</h3><p>这里需要修改之前的三个算子，顺序扫描、插入和删除。</p><p>tips：</p><ul><li>添加行锁之前需要对相应的表添加意向锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;project4需要实现的内容&quot;&gt;&lt;a href=&quot;#project4需要实现的内容&quot; class=&quot;headerlink&quot; title=&quot;project4需要实现的内容&quot;&gt;&lt;/a&gt;project4需要实现的内容&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://1</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency study note</title>
    <link href="http://example.com/2023/08/21/concurrency_notes/"/>
    <id>http://example.com/2023/08/21/concurrency_notes/</id>
    <published>2023-08-20T20:39:32.000Z</published>
    <updated>2024-03-30T03:53:43.410Z</updated>
    
    <content type="html"><![CDATA[<p>在做project4之前，最好是先学习课件内容。<br><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf">课件地址</a></p><p>Concurrency Control：avoid losting updates</p><p>Recovery： Durability</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>A transaction is the execution of a sequence of  one or more operations (e.g., SQL queries) on a database to perform some higher-level function.</p><p>Move $100 from Andy’s bank account to his bookie’s account.</p><p>Transaction:</p><ul><li>Check whether Andy has $100.</li><li>Deduct $100 from his account.</li><li>Add $100 to his bookie’s account</li></ul><p>一个事务包含了许多操作，如果是并发执行事务时，就可能会导致很多问题。</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>A new txn starts with the <code>BEGIN</code> command.</p><p>The txn stops with either <code>COMMIT</code> or <code>ABORT</code></p><ul><li>If commit, the DBMS either saves all the txn’s changes<br>or aborts it.</li><li>If abort, all changes are undone so that it’s like as if the<br>txn never executed at all.</li></ul><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性：所有操作要么全部完成，要么全部不完成。undo log(回滚日志)</li><li>隔离性：多个事务并发修改，不会互相干扰。MVCC（多版本并发机制）</li><li>持久性：事务处理结束后，对事务的修改是永久的。redo log（重做日志）</li><li>一致性：事务操作前和操作后，数据库保持一致性</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>脏读：读取到未提交的</li><li>不可重复读：在一个事务内多次读取同一个数据，前后读取的数据不一致</li><li>幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，前后读取的记录数量不一致</li></ul><p><strong>隔离级别：</strong></p><ul><li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；— 解决脏读问题</li><li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； — 解决不可重复读问题</li><li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； — 解决幻读问题</li></ul><p><strong>五种锁：</strong></p><ul><li>意向共享锁(IS):表示事务想要获得共享锁,与其他意向锁兼容,与排它锁冲突。用共享锁锁了里面的某些记录</li><li>意向排它锁(IX):表示事务想要获得排它锁,与其他所有锁模式冲突。用排他锁锁了表里的某些记录</li><li>共享锁(S):允许多个事务同时持有同一资源的共享锁,相互兼容。</li><li>排它锁(X):只允许一个事务持有排它锁,与所有其他锁冲突。</li><li>共享意向排他锁(SIX):表示持有共享锁的同时,想要获得排它锁,与排它锁冲突。用共享锁锁了整个表，用排他锁锁了里面的某些记录</li></ul><h3 id="锁管理器"><a href="#锁管理器" class="headerlink" title="锁管理器"></a>锁管理器</h3><p>管理锁的请求<br><img src="/../imgs/image-30.png" alt="Alt text"></p><p><strong>过程：</strong></p><ol><li>Transactions request locks (or upgrades).</li><li>Lock manager grants or blocks requests.</li><li>Transactions release locks.</li><li>Lock manager updates its internal lock-table.<br> It keeps track of what transactions hold what locks and what transactions are waiting to acquire any locks.</li></ol><h3 id="两阶段锁-2PL"><a href="#两阶段锁-2PL" class="headerlink" title="两阶段锁 2PL"></a>两阶段锁 2PL</h3><h4 id="Growing"><a href="#Growing" class="headerlink" title="Growing"></a>Growing</h4><p>只能加锁</p><h4 id="Shrinking"><a href="#Shrinking" class="headerlink" title="Shrinking"></a>Shrinking</h4><p>只能解锁</p><p>示意图：</p><p><img src="/../imgs/image-32.png"></p><p>但是无法避免接连回滚问题：这里事务一进入Shrinking阶段后，并没有提交，而是ABORT，最终回滚，由于事务二用的是事务一修改后的数据，也需要跟着回滚。</p><p><img src="/../imgs/image-33.png"></p><p>粗暴的解决方法：所有的锁都在commit的时候解锁，能解决脏读问题。</p><p><strong>但是可能出现死锁：</strong></p><p><img src="/../imgs/image-34.png"></p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><p>如果图种产生了环，需要解开环。<br><img src="/../imgs/image-35.png"></p><p>解开环：选择一个事务victim(abort or restart)</p><ul><li>根据执行时间选择（执行时间短的）</li><li>执行的SQL语句的多少</li><li>已经加了多少把锁</li><li>被回滚过多少次</li></ul><p><strong>回滚策略：</strong> victim完全回滚 or 回滚某些语句</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h4><ul><li>独占资源</li><li>不可剥夺</li><li>占用并等待</li><li>循环引用</li></ul><h4 id="破坏其中的某一条"><a href="#破坏其中的某一条" class="headerlink" title="破坏其中的某一条"></a>破坏其中的某一条</h4><p>Assign priorities based on timestamps:</p><ul><li>Older Timestamp &#x3D; Higher Priority (e.g., T1 &gt; T2)</li></ul><p><img src="/../imgs/image-36.png"></p><p>两个事务不会互相等待。</p><p>为了避免饥饿，新的被kill掉之后，时间戳沿用以前的。</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>行锁？表锁？间隙锁？</p><ul><li>更少的锁的数量？粒度大，加锁的开销</li><li>更好的并发？粒度小</li></ul><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>并不是真的锁，只是一个意向。比如表A种某一个tuple被加了锁，此时需要对表A加意向锁，表示比表A粒度更细的内容被加了所，不能再对表A加表锁。</p><p><img src="/../imgs/image-38.png"></p><p>例如：要对Tuple1加S锁，需要先对Table R加IS锁</p><p><img src="/../imgs/image-39.png"> </p><p>两阶段锁是悲观锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/17-timestampordering.pdf">课件地址</a></p><p>根据时间戳排序，如果A的时间戳小与B的时间戳，那么最后执行的效果等于A先执行完B再去执行。</p><p>时间戳来源：</p><ul><li>系统时钟（可能不准确）</li><li>逻辑计数器，比如从1递增，分布式校准难</li><li>Hybrid：结合</li></ul><p>每一个记录X都需要有两个时间戳：</p><ul><li><code>W-TS(x)</code> - 上一次被写的时间戳</li><li><code>R-TS(x)</code> - 上一次被读的时间戳</li></ul><p>基准：<strong>不能操作来自未来的数据</strong></p><p>读数据：</p><p><img src="/../imgs/image-40.png"></p><p>写数据：数据的任何操作都应该发生在过去</p><p><img src="/../imgs/image-41.png"></p><h3 id="THOMAS-WRITE-RULE"><a href="#THOMAS-WRITE-RULE" class="headerlink" title="THOMAS WRITE RULE"></a>THOMAS WRITE RULE</h3><p>如果我们当前要修改的数据A已经被未来的事务所修改，那么我们忽视写这个操作，因为现在写了一定会被未来写的数据所覆盖掉。</p><p><img src="/../imgs/image-42.png"></p><ul><li>乐观锁不存在死锁，因为没有锁也没有等待</li><li>长事务可能会饥饿，因为有可能碰到的所有数据都被未来的事务所修改</li><li>必须要保证所有的修改都是在已经提交的基础上</li></ul><p>可能会读取到别人未提交的。</p><h3 id="乐观的并发"><a href="#乐观的并发" class="headerlink" title="乐观的并发"></a>乐观的并发</h3><p>每一个事务都有一个workspace，所有的修改都在当前这个workspace进行，当事务提交时，DBMS对比workspace写集合，查看是否与其他事务冲突，没有冲突就写入原始数据库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做project4之前，最好是先学习课件内容。&lt;br&gt;&lt;a href=&quot;https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf&quot;&gt;课件地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Concurre</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Query_Execution</title>
    <link href="http://example.com/2023/08/17/Query-Execution/"/>
    <id>http://example.com/2023/08/17/Query-Execution/</id>
    <published>2023-08-16T23:50:33.000Z</published>
    <updated>2024-03-30T03:56:28.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行引擎介绍"><a href="#执行引擎介绍" class="headerlink" title="执行引擎介绍"></a>执行引擎介绍</h2><p><strong>一条SQL语句进入到数据库中后是如何被执行的？</strong></p><p><img src="/../imgs/image-23.png" alt="来源于小林coding"></p><p>前两个project实现的buffer pool和index都是存储引擎的一部分。</p><p>执行计划可以看作一个有向无环图，由source开始到sink结束，中间是一个又一个的算子。这一个project实现的就是这些算子。</p><p>课件地址：<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf</a></p><h2 id="processing-model"><a href="#processing-model" class="headerlink" title="processing model"></a>processing model</h2><p>A DBMS’s processing model defines how the system executes a query plan.</p><p>→ Different trade-offs for different workloads.</p><h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>每个运算符实现一个iterator接口,产生一行输出就调用下个运算符,逐行传递数据。或 Pipeline Model，或火山模型。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。</p><p>即时输出查询结果,不需要存储和载入大量中间状态。<br>易于实现,类似拉模式,但执行效率低。</p><h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个运算符将中间结果完全 Materialize 产生,存储在临时表中。<br>下个运算符从临时表中读取输入数据。<br>效率高,可最大化利用批处理,但需要更多存储空间。</p><h3 id="Vectorized-Batch-Model"><a href="#Vectorized-Batch-Model" class="headerlink" title="Vectorized&#x2F;Batch Model"></a>Vectorized&#x2F;Batch Model</h3><p>运算符以批(向量)为单位处理数据,减少解释器调度开销。<br>输入数据存放在列式存储中,易于向量化操作。<br>并行计算批数据,可利用现代CPU指令集。<br>兼具Iterator和Materialization方法的优点。现在大部分OLAP数据库使用这种方法。</p><p>在bustub中使用的是Iterator Model。</p><p>比如这个join的例子，查询时数据自下而上流动，通过父节点调用子节点的<code>Next()</code>方法。在根节点处得到最终值。</p><p><img src="/../imgs/image-27.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于每一个算子，我们需要补充构造函数、<code>Init()</code>函数和<code>Next()</code>函数，注意<code>Next()</code>函数如果返回值，这里只返回一条，通过传出参数实现，返回<code>Tuple</code>和<code>rid</code>。</p><p><strong>这些信息是如何得到的？</strong></p><p>在顺序扫描算子中，构造函数提供了两个参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqScanExecutor::<span class="built_in">SeqScanExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> SeqScanPlanNode *plan) : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>ExecutorContext和SeqScanPlanNode，首先要搞明白执行上下文都包括什么东西？</p><p><img src="/../imgs/exec_ctx.png"></p><p>最终的原始数据都在<code>Tuple</code>中，也代表着OLTP数据库中的一行数据。</p><p><strong>SeqScanPlanNode</strong>，执行计划的一个结点应该包含哪些东西？</p><p>output_schema是用来表示执行计划结点的输出模式。输出元组包含哪些列, 每列的类型和名称是什么。这为下游运算符解析和处理数据提供信息。</p><p><img src="/../imgs/plannode.png"></p><p>bustub提供了一个迭代器<code>TableIterator</code>，用来遍历<code>TableHeap</code>。根据上面的ctx包含的内容和plan包含的内容可以一层层拆解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_id = plan_-&gt;<span class="built_in">GetTableOid</span>();</span><br><span class="line">table_info = ctx-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(table_id);</span><br><span class="line">table_heap = table_info-&gt;table_.<span class="built_in">get</span>();</span><br><span class="line">table_iter_ = table_heap_-&gt;<span class="built_in">Begin</span>(ctx-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">*table_iter_=tuple;</span><br><span class="line">rid=tuple-&gt;<span class="built_in">GetRid</span>();</span><br></pre></td></tr></table></figure><h2 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h2><h4 id="顺序扫描-src-execution-seq-scan-executor-cpp"><a href="#顺序扫描-src-execution-seq-scan-executor-cpp" class="headerlink" title="顺序扫描 src/execution/seq_scan_executor.cpp"></a>顺序扫描 <code>src/execution/seq_scan_executor.cpp</code></h4><p>在有了前面的铺垫后，顺序扫描的<code>Next()</code>实现就非常简单，只需要返回迭代器指向的<code>Tuple</code>即可。</p><h3 id="插入-src-execution-insert-executor-cpp"><a href="#插入-src-execution-insert-executor-cpp" class="headerlink" title="插入 src/execution/insert_executor.cpp"></a>插入 <code>src/execution/insert_executor.cpp</code></h3><p>insert和delete是唯二的写算子。<br>插入这里多了一个参数<code>child_executor</code>, 右值传入。插入直接将tuple插入到table尾部，然后更新index。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InsertExecutor::<span class="built_in">InsertExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> InsertPlanNode *plan,</span><br><span class="line">                               std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child_executor)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为要更新index，可以通过<code>Catelog-&gt;GetTableIndexes()</code>来获取所有包含这个table的index，这里使用<code>std::vector&lt;IndexInfo *&gt; indexes_;</code> 遍历indexes数组，将每一个index插入B+树即可。<br><code>bpIndex = ... index_.get()</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bpIndex = <span class="keyword">reinterpret_cast</span>&lt;BPlusTreeIndex&lt;GenericKey&lt;<span class="number">8</span>&gt;, RID, GenericComparator&lt;<span class="number">8</span>&gt;&gt; (index-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">bpIndex-&gt;<span class="built_in">InsertEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid, txn); <span class="comment">// insert into B+tree</span></span><br></pre></td></tr></table></figure><p>然后从子计划获取kv, 插入表中 TableHeap, 调用TableHeap中的插入方法即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_heap_-&gt;<span class="built_in">InsertTuple</span>(*tuple, rid, txn);</span><br></pre></td></tr></table></figure><h3 id="删除-src-execution-insert-executor-cpp"><a href="#删除-src-execution-insert-executor-cpp" class="headerlink" title="删除 src/execution/insert_executor.cpp"></a>删除 <code>src/execution/insert_executor.cpp</code></h3><p>删除几乎和插入一样，唯一不同的是把写记录换成删除记录，调用TableHeap中的删除方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">txn-&gt;<span class="built_in">AppendIndexWriteRecord</span>(delete_record);</span><br><span class="line">bpIndex-&gt;<span class="built_in">DeleteEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),*rid, txn);</span><br></pre></td></tr></table></figure><h3 id="索引扫描-src-execution-index-scan-executor-cpp"><a href="#索引扫描-src-execution-index-scan-executor-cpp" class="headerlink" title="索引扫描 src/execution/index_scan_executor.cpp"></a>索引扫描 <code>src/execution/index_scan_executor.cpp</code></h3><p>同样的，bustub封装了<code>IndexIterator</code>指针，用来遍历B+树。指向一个<code>std::pair&lt;KeyType, ValueType&gt;</code>类型。这里的value也就是rid，再通过rid获取tuple。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BPlusTreeIndexForOneIntegerColumn *tree_;</span><br><span class="line">BPlusTreeIndexIteratorForOneIntegerColumn index_iter_;</span><br></pre></td></tr></table></figure><h2 id="Task2-aggr-and-join"><a href="#Task2-aggr-and-join" class="headerlink" title="Task2 aggr and join"></a>Task2 aggr and join</h2><h3 id="聚合-src-execution-aggregation-executor-cpp"><a href="#聚合-src-execution-aggregation-executor-cpp" class="headerlink" title="聚合 src/execution/aggregation_executor.cpp"></a>聚合 <code>src/execution/aggregation_executor.cpp</code></h3><p>在<code>AggregationPlanNode</code>中多了这些参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* Construct a <span class="keyword">new</span> AggregationPlanNode.</span><br><span class="line">   * @param output_schema The output format of <span class="keyword">this</span> plan node</span><br><span class="line">   * @param child The child plan to aggregate data over</span><br><span class="line">   * @param group_bys The group by clause of the aggregation</span><br><span class="line">   * @param aggregates The expressions that we are aggregating</span><br><span class="line">   * @param agg_types The types that we are aggregating</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在聚合执行器中有以下参数</span></span><br><span class="line">  <span class="comment">/** The aggregation plan node */</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  SimpleAggregationHashTable::Iterator aht_iterator_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 构造函数需要改为</span></span><br><span class="line"></span><br><span class="line">AggregationExecutor::<span class="built_in">AggregationExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> AggregationPlanNode *plan,</span><br><span class="line">                                         std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx),</span><br><span class="line">      <span class="built_in">plan_</span>(plan),</span><br><span class="line">      <span class="built_in">child_</span>(std::<span class="built_in">move</span>(child)),</span><br><span class="line">      <span class="built_in">aht_</span>(plan-&gt;<span class="built_in">GetAggregates</span>(), plan-&gt;<span class="built_in">GetAggregateTypes</span>()),</span><br><span class="line">      <span class="built_in">aht_iterator_</span>(aht_.<span class="built_in">Begin</span>())&#123;&#125;</span><br></pre></td></tr></table></figure><p>聚合需要根据<code>group by</code>分组的结果来计算吗，所以这里需要建立一个哈希表用来存储中间结果。和之前每一次只吐一条数据不一样的是，这里必须要在<code>Init()</code>函数中把所有结果计算出来，再在<code> Next()</code> 中一条一条地 emit。所以实际上计算过程是在<code>Init()</code>函数中，通过：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   aht_.<span class="built_in">InsertCombine</span>(<span class="built_in">MakeAggregateKey</span>(&amp;tuple), <span class="built_in">MakeAggregateValue</span>(&amp;tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后注意在<code>Next()</code>函数中，一个tuple可能要返回多个聚集的值，例如查询”SELECT SUM(A), MAX(B), COUNT(C) FROM table”就需要返回一个包含三个聚合结果的元组。所以内部是一个<code>vector</code>。没有返回rid是因为聚集之后产生了新结果，而不是原有的记录。</p><h3 id="inner-join-left-join-src-execution-nested-loop-join-executor-cpp"><a href="#inner-join-left-join-src-execution-nested-loop-join-executor-cpp" class="headerlink" title="inner join &amp; left join src/execution/nested_loop_join_executor.cpp"></a>inner join &amp; left join <code>src/execution/nested_loop_join_executor.cpp</code></h3><p><code>join</code>的时候也是需要建立hash表的，这里是根据join的key来建立哈希表，至于是左表建表还是右表建表，需要看数据库的具体实现。</p><h4 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h4><p>嵌套循环连接是连接算法的一种,它的基本原理是:</p><ul><li>外表和内表,其中外表是驱动表,内表是被驱动表。</li><li>通过外表循环遍历每一行。</li><li>对于外表的每一行,遍历内表找到匹配的行。</li><li>将匹配的外表行和内表行组合,产生连接结果。</li><li>外表的循环嵌套内表的循环,逐行进行连接处理。</li></ul><p>相比其他连接算法如哈希连接和排序合并连接,嵌套循环连接简单直接,但是当表大小不均衡时性能较差。<br>它适用于外表很小而内表较大的情况,或者当连接条件非常复杂时。</p><p>提示： Note for 2022 Fall: You ONLY need to implement left join and inner join.</p><ul><li><p>left join：左表全匹配（没匹配上右表时右表用null填充），右表只匹配join上的</p></li><li><p>inner join： 左表和右表均只匹配能匹配上的</p></li></ul><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>添加成员变量：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The NestedLoopJoin plan node to be executed. */</span></span><br><span class="line"><span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the left side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the right side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;</span><br><span class="line"><span class="comment">/** The output tuple schema. */</span></span><br><span class="line">Schema left_schema_;</span><br><span class="line">Schema right_schema_;</span><br><span class="line"><span class="type">bool</span> is_inner_join_;</span><br><span class="line">std::vector&lt;Value&gt; right_tuples_;</span><br></pre></td></tr></table></figure><p><strong>这里为什么需要把右表的值先全部拿出来呢？</strong><br>假设我们的join逻辑是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> outer_tuple in outer_table:</span><br><span class="line">    <span class="keyword">for</span> inner_tuple in inner_table:</span><br><span class="line">        <span class="keyword">if</span> inner_tuple matched outer_tuple:</span><br><span class="line">            emit</span><br></pre></td></tr></table></figure><p>右表的值会在左表的第一个值做匹配时就完全被消耗掉了。</p><p><strong>left join</strong><br>右值填充空值可以使用 <code>ValueFactory::GetNullValueByType(right_schema_.GetColumn(i).GetType())</code></p><p>比较右表和左表的tuple是否相等可以使用<code>EvaluateJoin(&amp;left_tuple_, &amp;left_schema_, &amp;right_tuple_, &amp;right_schema_);</code></p><h3 id="index-join-src-execution-nested-index-join-executor-cpp"><a href="#index-join-src-execution-nested-index-join-executor-cpp" class="headerlink" title="index join src/execution/nested_index_join_executor.cpp"></a>index join <code>src/execution/nested_index_join_executor.cpp</code></h3><p>索引连接(Index Join)是连接算法的一种优化技术,其主要思想是:</p><p>对于多个表的连接查询,通过在一个表上使用索引来加速连接处理。</p><p>例如对于一个多表连接查询:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id <span class="keyword">JOIN</span> C <span class="keyword">ON</span> B.id <span class="operator">=</span> C.id</span><br></pre></td></tr></table></figure><p>如果在表B的id列上存在索引,可以进行索引连接优化:</p><p>通过扫描表A,获取连接需要的id值。<br>对于表A的每一行,使用表B上的索引直接查找id值,得到B中的匹配行。<br>再扫描表C找到匹配B的行。<br>最终组合A,B,C的匹配行。<br>这样可以利用B表上的索引,避免对B进行全表扫描,从而加速连接查询。</p><p>具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><p>在构造函数中只有一个child_executor，不在是左右孩子的执行器，tuple来源：</p><ul><li>left tuple 来自 child_executor</li><li>right tuple 来自 table</li><li>index scan key 获取 rid, 用rid 获取right tuple</li></ul><h2 id="Task3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task3  Sort + Limit Executors and Top-N Optimization"></a>Task3  Sort + Limit Executors and Top-N Optimization</h2><h3 id="src-execution-sort-executor-cpp"><a href="#src-execution-sort-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;sort_executor.cpp"></a>src&#x2F;execution&#x2F;sort_executor.cpp</h3><p>Sort 也是 pipeline breaker。在 Init() 中读取所有下层算子的 tuple，并按 ORDER BY 的字段升序或降序排序。</p><p>next 函数每次用迭代器返回一个值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt; tuples_; <span class="comment">// 存储所有的值用来排序</span></span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt;::iterator it_;</span><br></pre></td></tr></table></figure><p>根据order by的值来进行升序或者降序排序，这里使用匿名函数自定义排序。然后返回迭代器指向的tuple。</p><h3 id="src-execution-limit-executor-cpp"><a href="#src-execution-limit-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;limit_executor.cpp"></a>src&#x2F;execution&#x2F;limit_executor.cpp</h3><p>使用一个成员变量 <code>limit_</code>来统计输出多少数据即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">limit_ = plan_-&gt;<span class="built_in">GetLimit</span>();</span><br><span class="line"><span class="comment">/// after emit </span></span><br><span class="line">limit_--</span><br></pre></td></tr></table></figure><h3 id="src-execution-topn-execution-cpp"><a href="#src-execution-topn-execution-cpp" class="headerlink" title="src&#x2F;execution&#x2F;topn_execution.cpp"></a>src&#x2F;execution&#x2F;topn_execution.cpp</h3><p>top_n函数：返回最大或者最小的n个tuple</p><p>也是 pipeline breaker，需要在<code>Init()</code>时，使用优先队列。最后每一次调用<code>Next()</code>就从栈中弹出一个。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   pq.<span class="built_in">push</span>(tuple);</span><br><span class="line">   <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>())&#123;</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   stack_.<span class="built_in">push</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">   pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;执行引擎介绍&quot;&gt;&lt;a href=&quot;#执行引擎介绍&quot; class=&quot;headerlink&quot; title=&quot;执行引擎介绍&quot;&gt;&lt;/a&gt;执行引擎介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一条SQL语句进入到数据库中后是如何被执行的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 B+tree</title>
    <link href="http://example.com/2023/08/17/B-tree/"/>
    <id>http://example.com/2023/08/17/B-tree/</id>
    <published>2023-08-16T23:07:54.000Z</published>
    <updated>2024-03-30T03:53:16.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树的介绍（以InnoDB为例）"><a href="#B-树的介绍（以InnoDB为例）" class="headerlink" title="B+树的介绍（以InnoDB为例）"></a>B+树的介绍（以InnoDB为例）</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>B+树只有叶子结点存储数据，内部节点和根结点只存储索引。</p><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><h2 id="bustub"><a href="#bustub" class="headerlink" title="bustub"></a>bustub</h2><p>在这这个实验中只需要实现三个接口：查询、插入和删除。</p><p>需要使用我们在 Project 1 中实现的 buffer pool manager 来获取 page。</p><p>internal page 中，KV 对的 K 是能够比较大小的索引，V 是 page id，用来指向下一层的节点。</p><p>leaf page 和 internal page 的内存布局基本一样，只是 leaf page 多了一个成员变量 <code>next_page_id</code>，指向下一个 leaf page（用于 range scan）</p><p>internal page 中储存 key 和 child page id，那么在拿到 page id 后如何获得对应的 page 指针？用 Project 1 中实现的 buffer pool。</p><p><code>Page *page = buffer_pool_manager_-&gt;FetchPage(page_id);</code></p><p>新建一个结点&#x2F;Page, 示例为新建root</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">page_id_t</span> page_id;</span><br><span class="line">Page *page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;page_id);</span><br><span class="line"><span class="keyword">auto</span> leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">leaf_node-&gt;<span class="built_in">Init</span>(page_id, INVALID_PAGE_ID, leaf_max_size_);</span><br><span class="line">root_page_id_ = page_id;</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page_id, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>找到leaf page，然后二分法找到key，就能够找到对应的record id。</p><p>唯一要注意的问题就是我们在拿到 page id 后，调用 buffer pool 的 FetchPage() 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，无法从 disk 读取其他的 page。比较合适的做法是，在本次操作中，找出 page 最后一次被使用的地方，并在最后一次使用后 unpin。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>假设叶子结点插入值之后满了，要考虑break的问题，要向父节点中插入break之后新的索引，假设父节点也满了，也要break（这是一个递归的过程），注意这里内部节点的第一个位置只存放value，而不存放key</p><p><img src="/../imgs/B+insert.png"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete的时候，如果当前节点小于最小size（Max size&#x2F;2），首先考虑从兄弟结点偷一个过来，如果兄弟结点投不了，就考虑merge。因为是一个向上递归删除的过程，所以merge的时候要区分是叶节点还是内部节点。</p><p>这里注意是先删除再做merge或者偷一个key</p><p><img src="/../imgs/b+delete.png"></p><h3 id="锁的问题："><a href="#锁的问题：" class="headerlink" title="锁的问题："></a>锁的问题：</h3><p>螃蟹式加锁（区分读锁和写锁）</p><p>参考课件:<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf</a></p><p>先给父节点加锁，然后给子节点加锁，如果确认子节点安全（不会发生merge或者break），此时解锁父节点</p><p><img src="/../imgs/image-22.png" alt="Alt text"></p><p>当寻找兄弟结点时，一个指针往前走，假设另一个进程在往后寻找兄弟结点，此时会不会发生死锁？</p><p>不会，因为当子节点需要寻找兄弟节点时，说明此时该节点不安全，所以父节点的锁不会释放，也就意味着另一个子进程拿不到父节点的锁，只会等待。</p><p>如何确定该page有没有被锁住？使用事务管理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树的介绍（以InnoDB为例）&quot;&gt;&lt;a href=&quot;#B-树的介绍（以InnoDB为例）&quot; class=&quot;headerlink&quot; title=&quot;B+树的介绍（以InnoDB为例）&quot;&gt;&lt;/a&gt;B+树的介绍（以InnoDB为例）&lt;/h2&gt;&lt;p&gt;InnoDB 的数据</summary>
      
    
    
    
    <category term="DataBase" scheme="http://example.com/categories/DataBase/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
</feed>
