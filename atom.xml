<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2024-12-20T07:27:33.748Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AI-GraphRAG</title>
    <link href="https://kelinkong.github.io/2024/12/20/AI-GraphRAG/"/>
    <id>https://kelinkong.github.io/2024/12/20/AI-GraphRAG/</id>
    <published>2024-12-20T02:38:54.000Z</published>
    <updated>2024-12-20T07:27:33.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphRAG"><a href="#GraphRAG" class="headerlink" title="GraphRAG"></a>GraphRAG</h2><p>仓库地址：<a href="https://github.com/microsoft/graphrag">GraphRAG</a></p><p>GraphRAG（Graph-based Retrieval Augmented Generation，基于图的检索增强生成）是一种利用图结构来增强大型语言模型（LLM）检索能力的先进方法。它旨在解决传统 RAG 方法在处理复杂关系、全局性问题和多跳推理方面的局限性。以下是 GraphRAG 的一些实现原理和技术要点：</p><p><strong>核心思想：</strong></p><p>GraphRAG 的核心是将文本数据转化为知识图谱，利用图的结构化信息来指导检索过程，从而更有效地为 LLM 提供上下文信息。与传统的基于向量相似度的检索方法不同，GraphRAG 侧重于实体之间的关系和整个数据集的结构，这使得它能够回答需要综合理解和推理的问题。</p><p><strong>实现原理：</strong></p><ol><li><p><strong>文本分块与信息抽取：</strong> 首先将原始文本分割成较小的块（chunk），然后从每个文本块中提取实体、关系和属性等信息。这通常使用命名实体识别（NER）、关系抽取等 NLP 技术。</p></li><li><p><strong>构建知识图谱：</strong> 将提取出的实体作为图的节点，实体之间的关系作为图的边，构建知识图谱。这个图谱可以包含多种类型的关系，例如“属于”、“位于”、“是…的作者”等等。</p></li><li><p><strong>图社区检测：</strong> 使用图算法（例如 Louvain 算法、PageRank 算法）检测图中的社区或子图。这些社区通常代表了文本中相关的概念或主题。</p></li><li><p><strong>社区摘要：</strong> 为每个检测到的社区生成摘要，概述该社区的主要内容和关键信息。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询时，GraphRAG 首先将查询转化为图查询，例如查找与某个实体相关的其他实体或关系。然后，在知识图谱上执行图查询，检索相关的社区或子图。</p></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的社区摘要或子图信息作为上下文提供给 LLM，让 LLM 基于这些上下文生成最终的回答。</p></li></ol><p><strong>技术要点：</strong></p><ul><li><p><strong>知识图谱构建：</strong></p><ul><li><strong>信息抽取质量：</strong> 实体和关系的准确提取至关重要，直接影响图谱的质量和检索效果。</li><li><strong>图谱规模和稀疏性：</strong> 如何有效地处理大规模图谱和图谱中的稀疏性是一个挑战。</li><li><strong>图谱的动态更新：</strong> 如何随着新数据的加入动态更新图谱，保持其时效性。</li></ul></li><li><p><strong>图算法选择：</strong></p><ul><li><strong>社区检测算法：</strong> 选择合适的社区检测算法，以有效地发现图谱中的相关主题。</li><li><strong>图查询算法：</strong> 如何高效地在图谱上执行查询，检索相关信息。</li></ul></li><li><p><strong>上下文选择和融合：</strong></p><ul><li><strong>上下文的相关性：</strong> 如何选择与查询最相关的上下文信息。</li><li><strong>上下文的长度和格式：</strong> 如何将图结构的信息有效地融入到 LLM 的输入中。</li></ul></li><li><p><strong>与传统 RAG 的结合：</strong></p><ul><li><strong>混合检索策略：</strong> 将图检索和向量检索结合起来，充分利用两者的优势。</li><li><strong>多阶段检索：</strong> 先使用图检索缩小检索范围，再使用向量检索进行精细化检索。</li></ul></li></ul><p><strong>GraphRAG 的优势：</strong></p><ul><li><strong>处理复杂关系：</strong> 能够更好地理解和处理实体之间的复杂关系，例如多跳关系。</li><li><strong>回答全局性问题：</strong> 能够基于整个数据集的结构进行推理和总结，回答需要全局视野的问题。</li><li><strong>提高检索效率：</strong> 通过图结构的引导，可以更有效地检索相关信息，减少不必要的计算。</li></ul><p><strong>GraphRAG 的挑战：</strong></p><ul><li><strong>知识图谱构建的复杂性：</strong> 构建高质量的知识图谱需要大量的工程和技术投入。</li><li><strong>图算法的选择和优化：</strong> 选择合适的图算法并进行优化需要一定的专业知识。</li><li><strong>与 LLM 的有效集成：</strong> 如何将图结构的信息有效地传递给 LLM，并让 LLM 充分利用这些信息。</li></ul><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>为了帮助你更好地理解 GraphRAG，我将举一个具体的例子，并结合实际应用场景进行说明。</p><p><strong>场景：</strong> 假设我们有一个关于电影的数据库，其中包含电影的各种信息，例如电影名称、导演、演员、类型、上映日期、剧情简介等。我们希望构建一个问答系统，用户可以提出关于电影的各种问题，例如“克里斯托弗·诺兰导演的科幻电影有哪些？”或者“《盗梦空间》的主演是谁？”。</p><p><strong>传统 RAG 方法的局限性：</strong> 如果使用传统的 RAG 方法，我们可能会将电影信息分割成文本块，并使用向量相似度来检索与用户查询相关的文本块。这种方法在回答简单的问题时可能有效，但在回答需要多跳推理或全局信息的问题时就显得力不从心。例如，如果用户问“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”，传统 RAG 方法可能难以有效地回答，因为它需要检索多个电影的信息，并进行关联和统计。</p><p><strong>使用 GraphRAG 的解决方案：</strong></p><ol><li><p><strong>构建知识图谱：</strong></p><ul><li><strong>实体：</strong> 电影名称、导演、演员、类型等。</li><li><strong>关系：</strong> “导演”、“主演”、“属于类型”、“上映于”等。</li></ul><p>例如，《盗梦空间》可以表示为一个节点，“克里斯托弗·诺兰”和“莱昂纳多·迪卡普里奥”也分别表示为节点。“克里斯托弗·诺兰”和《盗梦空间》之间存在“导演”关系，《莱昂纳多·迪卡普里奥》和《盗梦空间》之间存在“主演”关系。</p></li><li><p><strong>图社区检测（可选）：</strong> 可以使用社区检测算法将相关的电影、导演和演员聚类成不同的社区。例如，可以将克里斯托弗·诺兰导演的电影聚类成一个社区，将某个类型的电影聚类成另一个社区。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 的处理步骤如下：</p><ul><li>将查询转化为图查询：查找与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计每个“导演”节点与“莱昂纳多·迪卡普里奥”节点之间边的数量（即合作次数）。</li><li>在知识图谱上执行图查询：遍历图谱，找到所有与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计它们之间的连接次数。</li><li>返回结果：返回合作次数超过两次的导演列表，例如“马丁·斯科塞斯”。</li></ul></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的导演列表以及相关的电影信息（例如电影名称、上映日期等）作为上下文提供给 LLM。LLM 基于这些上下文生成最终的回答，例如“莱昂纳多·迪卡普里奥与马丁·斯科塞斯合作过多次，包括《华尔街之狼》、《禁闭岛》等电影。”。</p></li></ol><p><strong>具体例子图示：</strong></p><p>假设我们的知识图谱包含以下信息：</p><ul><li>《盗梦空间》- 导演：克里斯托弗·诺兰</li><li>《盗梦空间》- 主演：莱昂纳多·迪卡普里奥</li><li>《禁闭岛》- 导演：马丁·斯科塞斯</li><li>《禁闭岛》- 主演：莱昂纳多·迪卡普里奥</li><li>《华尔街之狼》- 导演：马丁·斯科塞斯</li><li>《华尔街之狼》- 主演：莱昂纳多·迪卡普里奥</li></ul><p>当用户查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 会在图谱上找到以下路径：</p><ul><li>莱昂纳多·迪卡普里奥 -&gt; 《盗梦空间》-&gt; 克里斯托弗·诺兰</li><li>莱昂纳多·迪卡普里奥 -&gt; 《禁闭岛》-&gt; 马丁·斯科塞斯</li><li>莱昂纳多·迪卡普里奥 -&gt; 《华尔街之狼》-&gt; 马丁·斯科塞斯</li></ul><p>通过统计，发现马丁·斯科塞斯与莱昂纳多·迪卡普里奥合作了两次以上，因此将其返回。</p><p><strong>总结：</strong></p><p>通过这个例子可以看出，GraphRAG 利用知识图谱的结构化信息，能够有效地处理需要多跳推理和全局信息的问题，相比传统的 RAG 方法具有明显的优势。它将文本信息转化为图结构，使得 LLM 能够更好地理解和利用这些信息，从而生成更准确、更全面的回答。</p><p>希望这个例子能够帮助你更好地理解 GraphRAG 的实施原理和优势。如果你还有其他问题，欢迎继续提问。</p><h2 id="什么样的场景适合构建知识图谱？"><a href="#什么样的场景适合构建知识图谱？" class="headerlink" title="什么样的场景适合构建知识图谱？"></a>什么样的场景适合构建知识图谱？</h2><p>构建知识图谱并非适用于所有场景。它是一种强大的工具，但也有其特定的适用范围。以下是一些适合构建知识图谱的场景，以及一些不适合的场景：</p><p><strong>适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据之间存在复杂关联：</strong> 如果数据之间存在大量的关系和连接，并且这些关系对于理解数据至关重要，那么知识图谱就非常适用。例如：</p><ul><li><strong>社交网络：</strong> 人与人之间的朋友关系、关注关系、共同参与的活动等。</li><li><strong>生物医药：</strong> 基因、蛋白质、疾病、药物之间的相互作用和关联。</li><li><strong>金融领域：</strong> 公司、股东、投资、交易等之间的关系。</li></ul></li><li><p><strong>需要进行推理和分析：</strong> 如果需要基于数据进行推理、分析和预测，知识图谱可以提供强大的支持。例如：</p><ul><li><strong>智能问答系统：</strong> 回答需要多步推理的问题，例如“与某人合作过两次以上的导演有哪些？”。</li><li><strong>风险评估：</strong> 分析金融交易中的潜在风险，例如欺诈检测。</li><li><strong>推荐系统：</strong> 基于用户的历史行为和兴趣，推荐相关的产品或服务。</li></ul></li><li><p><strong>数据来源多样且异构：</strong> 如果数据来自不同的来源，并且格式各异，知识图谱可以提供一种统一的表示方式，方便数据的整合和利用。例如：</p><ul><li><strong>企业级数据整合：</strong> 将来自不同部门、不同系统的数据整合到一个统一的知识图谱中。</li><li><strong>跨领域数据融合：</strong> 将来自不同领域的数据融合到一起，例如将医疗数据和社交数据结合起来进行健康管理。</li></ul></li><li><p><strong>需要可视化和探索：</strong> 知识图谱以图形化的方式呈现数据，方便用户进行可视化和探索，发现数据中隐藏的模式和规律。例如：</p><ul><li><strong>情报分析：</strong> 分析犯罪网络、恐怖组织等。</li><li><strong>科研探索：</strong> 探索科学研究中的新发现和新联系。</li></ul></li><li><p><strong>需要支持语义搜索：</strong> 传统的关键词搜索只能找到包含关键词的文档，而知识图谱可以支持基于语义的搜索，找到与用户查询相关的概念和实体。例如：</p><ul><li><strong>电商搜索：</strong> 用户搜索“适合跑步的鞋子”，可以返回各种类型的跑鞋，而不仅仅是包含“跑步”和“鞋子”这两个词的商品。</li></ul></li></ol><p><strong>不适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据结构简单且关系单一：</strong> 如果数据结构非常简单，并且数据之间只有简单的线性关系，那么使用传统的数据库或表格就足够了，不需要构建知识图谱。</p></li><li><p><strong>数据量小且变化频繁：</strong> 如果数据量非常小，并且变化非常频繁，那么维护知识图谱的成本可能会高于其带来的收益。</p></li><li><p><strong>对推理和分析的需求不高：</strong> 如果应用场景主要关注数据的存储和检索，而不需要进行复杂的推理和分析，那么使用传统的数据库就足够了。</p></li></ol><p><strong>总结：</strong></p><p>以下是一些判断是否适合构建知识图谱的关键因素：</p><ul><li><strong>数据之间的关联程度：</strong> 关联越复杂，越适合使用知识图谱。</li><li><strong>对推理和分析的需求：</strong> 需求越高，越适合使用知识图谱。</li><li><strong>数据来源的多样性和异构性：</strong> 来源越多，越适合使用知识图谱进行整合。</li><li><strong>对可视化和探索的需求：</strong> 需求越高，越适合使用知识图谱。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphRAG&quot;&gt;&lt;a href=&quot;#GraphRAG&quot; class=&quot;headerlink&quot; title=&quot;GraphRAG&quot;&gt;&lt;/a&gt;GraphRAG&lt;/h2&gt;&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/microsoft/gra</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-神经网络中的三个基本概念：梯度下降、反向传播、损失函数</title>
    <link href="https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</id>
    <published>2024-12-19T02:05:45.000Z</published>
    <updated>2024-12-20T08:18:52.148Z</updated>
    
    <content type="html"><![CDATA[<!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><p>文章参考：<a href="https://github.com/microsoft/ai-edu/blob/master/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC1%E6%AD%A5%20-%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/02.0-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.md">神经网络中的三个基本概念</a></p><h2 id="2-0-通俗地理解三大概念"><a href="#2-0-通俗地理解三大概念" class="headerlink" title="2.0 通俗地理解三大概念"></a>2.0 通俗地理解三大概念</h2><p>这三大概念是：反向传播，梯度下降，损失函数。</p><p>神经网络训练的最基本的思想就是：先“猜”一个结果，称为预测结果 $a$，看看这个预测结果和事先标记好的训练集中的真实结果 $y$ 之间的差距，然后调整策略，再试一次，这一次就不是“猜”了，而是有依据地向正确的方向靠近。如此反复多次，一直到预测结果和真实结果之间相差无几，亦即 $|a-y|\rightarrow 0$，就结束训练。</p><p>在神经网络训练中，我们把“猜”叫做初始化，可以随机，也可以根据以前的经验给定初始值。即使是“猜”，也是有技术含量的。</p><p>下面我们举几个例子来直观的说明下这三个概念。</p><h3 id="2-0-1-例一：猜数"><a href="#2-0-1-例一：猜数" class="headerlink" title="2.0.1 例一：猜数"></a>2.0.1 例一：猜数</h3><p>甲乙两个人玩儿猜数的游戏，数字的范围是 $[1,50]$：</p><p>甲：我猜5</p><p>乙：太小了</p><p>甲：50</p><p>乙：有点儿大</p><p>甲：30</p><p>乙：小了</p><p>……</p><p>在这个游戏里：</p><ul><li>目的：猜到乙心中的数字；</li><li>初始化：甲猜5；</li><li>前向计算：甲每次猜的新数字；</li><li>损失函数：乙在根据甲猜的数来和自己心中想的数做比较，得出“大了”或“小了”的结论；</li><li>反向传播：乙告诉甲“小了”、“大了”；</li><li>梯度下降：甲根据乙的反馈中的含义自行调整下一轮的猜测值。</li></ul><p>这里的损失函数是什么呢？就是“太小了”，“有点儿大”，很不精确！这个“所谓的”损失函数给出了两个信息：</p><ol><li>方向：大了或小了</li><li>程度：“太”，“有点儿”，但是很模糊</li></ol><h3 id="2-0-2-例二：黑盒子"><a href="#2-0-2-例二：黑盒子" class="headerlink" title="2.0.2 例二：黑盒子"></a>2.0.2 例二：黑盒子</h3><p>假设有一个黑盒子：</p><p>我们只能看到输入和输出的数值，看不到里面的样子，当输入1时，输出2.334，然后黑盒子有个信息显示：我需要输出值是4。然后我们试了试输入2，结果输出5.332，一下子比4大了很多。那么我们第一次的损失值是 $2.334-4&#x3D;-1.666$，而二次的损失值是 $5.332-4&#x3D;1.332$。</p><p>这里，我们的损失函数就是一个简单的减法，用实际值减去目标值，但是它可以告诉你两个信息：1）方向，是大了还是小了；2）差值，是0.1还是1.1。这样就给了我们下一次猜的依据。</p><ul><li>目的：猜到一个输入值，使得黑盒子的输出是4；</li><li>初始化：输入1；</li><li>前向计算：黑盒子内部的数学逻辑；</li><li>损失函数：在输出端，用输出值减4；</li><li>反向传播：告诉猜数的人差值，包括正负号和值；</li><li>梯度下降：在输入端，根据正负号和值，确定下一次的猜测值。</li></ul><h3 id="2-0-3-例三：打靶"><a href="#2-0-3-例三：打靶" class="headerlink" title="2.0.3 例三：打靶"></a>2.0.3 例三：打靶</h3><p>小明拿了一支步枪，射击100米外的靶子。这支步枪没有准星，或者是准星有问题，或者是小明眼神儿不好看不清靶子，或者是雾很大，或者风很大，或者由于木星的影响而侧向引力场异常……反正就是遇到各种干扰因素。</p><p>第一次试枪后，拉回靶子一看，弹着点偏左了，于是在第二次试枪时，小明就会有意识地向右侧偏几毫米，再看靶子上的弹着点，如此反复几次，小明就会掌握这支步枪的脾气了。图2-2显示了小明的5次试枪过程。</p><p><img src="/../imgs/image-72.png" alt="图2-2 打靶的弹着点记录"></p><p>在有监督的学习中，需要衡量神经网络输出和所预期的输出之间的差异大小。这种误差函数需要能够反映出当前网络输出和实际结果之间一种量化之后的不一致程度，也就是说函数值越大，反映出模型预测的结果越不准确。</p><p>这个例子中，小明预期的目标是全部命中靶子的中心，最外圈是1分，之后越向靶子中心分数是2，3，4分，正中靶心可以得10分。</p><ul><li>每次试枪弹着点和靶心之间的差距就叫做误差，可以用一个误差函数来表示，比如差距的绝对值，如图中的红色线。</li><li>一共试枪5次，就是迭代&#x2F;训练了5次的过程 。</li><li>每次试枪后，把靶子拉回来看弹着点，然后调整下一次的射击角度的过程，叫做反向传播。注意，把靶子拉回来看和跑到靶子前面去看有本质的区别，后者容易有生命危险，因为还有别的射击者。一个不恰当的比喻是，在数学概念中，人跑到靶子前面去看，叫做正向微分；把靶子拉回来看，叫做反向微分。</li><li>每次调整角度的数值和方向，叫做梯度。比如向右侧调整1毫米，或者向左下方调整2毫米。如图中的绿色矢量线。</li></ul><p>上图是每次单发点射，所以每次训练样本的个数是1。在实际的神经网络训练中，通常需要多个样本，做批量训练，以避免单个样本本身采样时带来的误差。在本例中，多个样本可以描述为连发射击，假设一次可以连打3发子弹，每次的离散程度都类似，如图2-3所示。<br><img src="/../imgs/image-73.png" alt="图2-3 连发弹着点记录"></p><ul><li>如果每次3发子弹连发，这3发子弹的弹着点和靶心之间的差距之和再除以3，叫做损失，可以用损失函数来表示。</li></ul><p>那小明每次射击结果和目标之间的差距是多少呢？在这个例子里面，用得分来衡量的话，就是说小明得到的反馈结果从差9分，到差8分，到差2分，到差1分，到差0分，这就是用一种量化的结果来表示小明的射击结果和目标之间差距的方式。也就是误差函数的作用。因为是一次只有一个样本，所以这里采用的是误差函数的称呼。如果一次有多个样本，就要叫做损失函数了。</p><p>其实射击还不这么简单，如果是远距离狙击，还要考虑空气阻力和风速，在神经网络里，空气阻力和风速可以对应到隐藏层的概念上。</p><p>在这个例子中：</p><ul><li>目的：打中靶心；</li><li>初始化：随便打一枪，能上靶就行，但是要记住当时的步枪的姿态；</li><li>前向计算：让子弹飞一会儿，击中靶子；</li><li>损失函数：环数，偏离角度；</li><li>反向传播：把靶子拉回来看；</li><li>梯度下降：根据本次的偏差，调整步枪的射击角度。</li></ul><p>损失函数的描述是这样的：</p><ol><li>1环，偏左上45度；</li><li>6环，偏左上15度；</li><li>7环，偏左；</li><li>8环，偏左下15度；</li><li>10环。</li></ol><p>这里的损失函数也有两个信息：</p><ol><li>距离；</li><li>方向。</li></ol><p><strong>所以，梯度，是个矢量！</strong> 它应该即告诉我们方向，又告诉我们数值。</p><h3 id="2-0-4-黑盒子的真正玩法"><a href="#2-0-4-黑盒子的真正玩法" class="headerlink" title="2.0.4 黑盒子的真正玩法"></a>2.0.4 黑盒子的真正玩法</h3><p>以上三个例子比较简单，容易理解，我们把黑盒子再请出来：黑盒子这件事真正的意义并不是猜测当输入是多少时输出会是4。它的实际意义是：我们要破解这个黑盒子！于是，我们会有如下破解流程：</p><ol><li>记录下所有输入值和输出值，如表2-1。</li></ol><p>表2-1 样本数据表</p><table><thead><tr><th align="center">样本ID</th><th>输入(特征值)</th><th>输出(标签)</th></tr></thead><tbody><tr><td align="center">1</td><td>1</td><td>2.21</td></tr><tr><td align="center">2</td><td>1.1</td><td>2.431</td></tr><tr><td align="center">3</td><td>1.2</td><td>2.652</td></tr><tr><td align="center">4</td><td>2</td><td>4.42</td></tr></tbody></table><ol start="2"><li>搭建一个神经网络，给出初始权重值，我们先假设这个黑盒子的逻辑是：$z&#x3D;x + x^2$；</li><li>输入1，根据 $z&#x3D;x + x^2$ 得到输出为2，而实际的输出值是2.21，则误差值为 $2-2.21&#x3D;-0.21$，小了；</li><li>调整权重值，比如 $z&#x3D;1.5x+x^2$，再输入1.1，得到的输出为2.86，实际输出为2.431，则误差值为 $2.86-2.431&#x3D;0.429$，大了；</li><li>调整权重值，比如 $z&#x3D;1.2x+x^2$，再输入1.2……</li><li>调整权重值，再输入2……</li><li>所有样本遍历一遍，计算平均的损失函数值；</li><li>依此类推，重复3，4，5，6过程，直到损失函数值小于一个指标，比如 $0.001$，我们就可以认为网络训练完毕，黑盒子“破解”了，实际是被复制了，因为神经网络并不能得到黑盒子里的真实函数体，而只是近似模拟。</li></ol><p>从上面的过程可以看出，如果误差值是正数，我们就把权重降低一些；如果误差值为负数，则升高权重。</p><h3 id="2-0-5-总结"><a href="#2-0-5-总结" class="headerlink" title="2.0.5 总结"></a>2.0.5 总结</h3><p>简单总结一下反向传播与梯度下降的基本工作原理：</p><ol><li>初始化；</li><li>正向计算；</li><li>损失函数为我们提供了计算损失的方法；</li><li>梯度下降是在损失函数基础上向着损失最小的点靠近而指引了网络权重调整的方向；</li><li>反向传播把损失值反向传给神经网络的每一层，让每一层都根据损失值反向调整权重；</li><li>Go to 2，直到精度足够好（比如损失函数值小于 $0.001$）。</li></ol><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-1-线性反向传播"><a href="#2-1-线性反向传播" class="headerlink" title="2.1 线性反向传播"></a>2.1 线性反向传播</h2><h3 id="2-1-1-正向计算的实例"><a href="#2-1-1-正向计算的实例" class="headerlink" title="2.1.1 正向计算的实例"></a>2.1.1 正向计算的实例</h3><p>假设有一个函数：</p><p>$$z &#x3D; x \cdot y \tag{1}$$</p><p>其中:</p><p>$$x &#x3D; 2w + 3b \tag{2}$$</p><p>$$y &#x3D; 2b + 1 \tag{3}$$</p><p>计算图如图2-4。</p><p><img src="/../imgs/image-74.png" alt="图2-4 简单线性计算的计算图"></p><p>注意这里 $x,y,z$ 不是变量，只是中间计算结果；$w,b$ 才是变量。因为在后面要学习的神经网络中，要最终求解的目标是 $w$ 和 $b$ 的值，所以在这里先预热一下。</p><p>当 $w &#x3D; 3, b &#x3D; 4$ 时，会得到图2-5的结果。</p><p><img src="/../imgs/image-75.png" alt="图2-5 计算结果"></p><p>最终的 $z$ 值，受到了前面很多因素的影响：变量 $w$，变量 $b$，计算式 $x$，计算式 $y$。</p><h3 id="2-1-2-反向传播求解-w"><a href="#2-1-2-反向传播求解-w" class="headerlink" title="2.1.2 反向传播求解 $w$"></a>2.1.2 反向传播求解 $w$</h3><h4 id="求-w-的偏导"><a href="#求-w-的偏导" class="headerlink" title="求 $w$ 的偏导"></a>求 $w$ 的偏导</h4><p>目前 $z&#x3D;162$，如果想让 $z$ 变小一些，比如目标是 $z&#x3D;150$，$w$ 应该如何变化呢？为了简化问题，先只考虑改变 $w$ 的值，而令 $b$ 值固定为 $4$。</p><p>如果想解决这个问题，最笨的办法是可以在输入端一点一点的试，把 $w$ 变成 $3.5$ 试试，再变成 $3$ 试试……直到满意为止。现在我们将要学习一个更好的解决办法：反向传播。</p><p>从 $z$ 开始一层一层向回看，图中各节点关于变量 $w$ 的偏导计算结果如下：</p><p>因为 $z &#x3D; x \cdot y$，其中 $x &#x3D; 2w + 3b, y &#x3D; 2b + 1$</p><p>所以：</p><p>$$<br>\frac{\partial{z}}{\partial{w}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}&#x3D;y \cdot 2&#x3D;18 \tag{4}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}&#x3D;\frac{\partial{}}{\partial{x}}(x \cdot y)&#x3D;y&#x3D;9<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{w}}&#x3D;\frac{\partial{}}{\partial{w}}(2w+3b)&#x3D;2<br>$$</p><p><img src="/../imgs/image-76.png" alt="图2-6 对 $w$ 的偏导求解过程"></p><p>图2-6其实就是链式法则的具体表现，$z$ 的误差通过中间的 $x$ 传递到 $w$。如果不是用链式法则，而是直接用 $z$ 的表达式计算对 $w$ 的偏导数，会怎么样呢？我们来试验一下。</p><p>根据公式1、2、3，我们有：</p><p>$$<br>z&#x3D;x \cdot y&#x3D;(2w+3b)(2b+1)&#x3D;4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求 $w$ 的偏导：</p><p>$$<br>\frac{\partial z}{\partial w}&#x3D;4b+2&#x3D;4 \cdot 4 + 2&#x3D;18 \tag{6}<br>$$</p><p>公式4和公式6的结果完全一致！所以，请大家相信链式法则的科学性。</p><h4 id="求-w-的具体变化值"><a href="#求-w-的具体变化值" class="headerlink" title="求 $w$ 的具体变化值"></a>求 $w$ 的具体变化值</h4><p><strong>公式4和公式6的含义是：当 $w$ 变化一点点时，$z$ 会产生 $w$ 的变化值18倍的变化</strong>。记住我们的目标是让 $z&#x3D;150$，目前在初始状态时是 $z&#x3D;162$，所以，问题转化为：当需要 $z$ 从 $162$ 变到 $150$ 时，$w$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z &#x3D; 18 \cdot \Delta w<br>$$</p><p>则：</p><p>$$<br>\Delta w &#x3D; {\Delta z \over 18}&#x3D;\frac{162-150}{18}&#x3D; 0.6667<br>$$</p><p>所以：</p><p>$$<br>w &#x3D; w - 0.6667&#x3D;2.3333<br>$$</p><p>$$<br>x&#x3D;2w+3b&#x3D;16.6667<br>$$</p><p>$$<br>z&#x3D;x \cdot y&#x3D;16.6667 \times 9&#x3D;150.0003<br>$$</p><p>我们一下子就成功地让 $z$ 值变成了 $150.0003$，与 $150$ 的目标非常地接近，这就是偏导数的威力所在。</p><h4 id="【课堂练习】推导-z-对-b-的偏导数，结果在下一小节中使用"><a href="#【课堂练习】推导-z-对-b-的偏导数，结果在下一小节中使用" class="headerlink" title="【课堂练习】推导 $z$ 对 $b$ 的偏导数，结果在下一小节中使用"></a>【课堂练习】推导 $z$ 对 $b$ 的偏导数，结果在下一小节中使用</h4><h3 id="2-1-3-反向传播求解-b"><a href="#2-1-3-反向传播求解-b" class="headerlink" title="2.1.3 反向传播求解 $b$"></a>2.1.3 反向传播求解 $b$</h3><h4 id="求-b-的偏导"><a href="#求-b-的偏导" class="headerlink" title="求 $b$ 的偏导"></a>求 $b$ 的偏导</h4><p>这次我们令 $w$ 的值固定为 $3$，变化 $b$ 的值，目标还是让 $z&#x3D;150$。同上一小节一样，先求 $b$ 的偏导数。</p><p>注意，在上一小节中，求 $w$ 的导数只经过了一条路：从 $z$ 到 $x$ 到 $w$。但是求 $b$ 的导数时要经过两条路，如图2-7所示：</p><ol><li>从 $z$ 到 $x$ 到 $b$；</li><li>从 $z$ 到 $y$ 到 $b$。</li></ol><p><img src="/../imgs/image-77.png" alt="图2-7 对b的偏导求解过程"></p><p>从复合导数公式来看，这两者应该是相加的关系，所以有：</p><p>$$<br>\frac{\partial{z}}{\partial{b}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}&#x3D;y \cdot 3+x \cdot 2&#x3D;63 \tag{7}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}&#x3D;\frac{\partial{}}{\partial{x}}(x \cdot y)&#x3D;y&#x3D;9<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{y}}&#x3D;\frac{\partial{}}{\partial{y}}(x \cdot y)&#x3D;x&#x3D;18<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{b}}&#x3D;\frac{\partial{}}{\partial{b}}(2w+3b)&#x3D;3<br>$$</p><p>$$<br>\frac{\partial{y}}{\partial{b}}&#x3D;\frac{\partial{}}{\partial{b}}(2b+1)&#x3D;2<br>$$</p><p>我们不妨再验证一下链式求导的正确性。把公式5再拿过来：</p><p>$$<br>z&#x3D;x \cdot y&#x3D;(2w+3b)(2b+1)&#x3D;4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求b的偏导：</p><p>$$<br>\frac{\partial z}{\partial b}&#x3D;4w+12b+3&#x3D;12+48+3&#x3D;63 \tag{8}<br>$$</p><p>结果和公式7的链式法则一样。</p><h4 id="求-b-的具体变化值"><a href="#求-b-的具体变化值" class="headerlink" title="求 $b$ 的具体变化值"></a>求 $b$ 的具体变化值</h4><p>公式7和公式8的含义是：当 $b$ 变化一点点时，$z$ 会发生 $b$ 的变化值 $63$ 倍的变化。记住我们的目标是让 $z&#x3D;150$，目前在初始状态时是 $162$，所以，问题转化为：当我们需要 $z$ 从 $162$ 变到 $150$ 时，$b$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z &#x3D; 63 \cdot \Delta b<br>$$</p><p>则：</p><p>$$<br>\Delta b &#x3D; \frac{\Delta z}{63}&#x3D;\frac{162-150}{63}&#x3D;0.1905<br>$$</p><p>所以：<br>$$<br>b&#x3D;b-0.1905&#x3D;3.8095<br>$$</p><p>$$<br>x&#x3D;2w+3b&#x3D;17.4285<br>$$</p><p>$$<br>y&#x3D;2b+1&#x3D;8.619<br>$$</p><p>$$<br>z&#x3D;x \cdot y&#x3D;17.4285 \times 8.619&#x3D;150.2162<br>$$</p><p>这个结果也是与 $150$ 很接近了，但是精度还不够。再迭代几次，直到误差不大于 <code>1e-4</code> 时，我们就可以结束迭代了，对于计算机来说，这些运算的执行速度很快。</p><h4 id="【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？"><a href="#【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？" class="headerlink" title="【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？"></a>【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？</h4><p>这个问题用数学公式倒推求解一个二次方程，就能直接得到准确的b值吗？是的！但是我们是要说明机器学习的方法，机器并不会解二次方程，而且很多时候不是用二次方程就能解决实际问题的。而上例所示，是用机器所擅长的迭代计算的方法来不断逼近真实解，这就是机器学习的真谛！而且这种方法是普遍适用的。</p><h3 id="2-1-4-同时求解-w-和-b-的变化值"><a href="#2-1-4-同时求解-w-和-b-的变化值" class="headerlink" title="2.1.4 同时求解 $w$ 和 $b$ 的变化值"></a>2.1.4 同时求解 $w$ 和 $b$ 的变化值</h3><p>这次我们要同时改变 $w$ 和 $b$，到达最终结果为 $z&#x3D;150$ 的目的。</p><p>已知 $\Delta z&#x3D;12$，我们不妨把这个误差的一半算在 $w$ 的账上，另外一半算在 $b$ 的账上：</p><p>$$<br>\Delta b&#x3D;\frac{\Delta z &#x2F; 2}{63} &#x3D; \frac{12&#x2F;2}{63}&#x3D;0.095<br>$$</p><p>$$<br>\Delta w&#x3D;\frac{\Delta z &#x2F; 2}{18} &#x3D; \frac{12&#x2F;2}{18}&#x3D;0.333<br>$$</p><ul><li>$w &#x3D; w-\Delta w&#x3D;3-0.333&#x3D;2.667$</li><li>$b &#x3D; b - \Delta b&#x3D;4-0.095&#x3D;3.905$</li><li>$x&#x3D;2w+3b&#x3D;2 \times 2.667+3 \times 3.905&#x3D;17.049$</li><li>$y&#x3D;2b+1&#x3D;2 \times 3.905+1&#x3D;8.81$</li><li>$z&#x3D;x \times y&#x3D;17.049 \times 8.81&#x3D;150.2$</li></ul><h4 id="【课堂练习】用Python代码实现以上双变量的反向传播计算过程"><a href="#【课堂练习】用Python代码实现以上双变量的反向传播计算过程" class="headerlink" title="【课堂练习】用Python代码实现以上双变量的反向传播计算过程"></a>【课堂练习】用Python代码实现以上双变量的反向传播计算过程</h4><p>容易出现的问题：</p><ol><li>在检查 $\Delta z$ 时的值时，注意要用绝对值，因为有可能是个负数</li><li>在计算 $\Delta b$ 和 $\Delta w$ 时，第一次时，它们对 $z$ 的贡献值分别是 $1&#x2F;63$ 和 $1&#x2F;18$，但是第二次时，由于 $b,w$ 值的变化，对 $z$ 的贡献值也会有微小变化，所以要重新计算。具体解释如下：</li></ol><p>$$<br>\frac{\partial{z}}{\partial{b}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}&#x3D;y \cdot 3+x \cdot 2&#x3D;3y+2x<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{w}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{w}}&#x3D;y \cdot 2+x \cdot 0 &#x3D; 2y<br>$$<br>所以，在每次迭代中，要重新计算下面两个值：<br>$$<br>\Delta b&#x3D;\frac{\Delta z}{3y+2x}<br>$$</p><p>$$<br>\Delta w&#x3D;\frac{\Delta z}{2y}<br>$$</p><p>以下是程序的运行结果。</p><p>没有在迭代中重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">003455</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">806068</span>,z=<span class="number">150</span>.<span class="number">007970</span>,delta_z=<span class="number">0</span>.<span class="number">007970</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000127</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805942</span>,z=<span class="number">150</span>.<span class="number">000294</span>,delta_z=<span class="number">0</span>.<span class="number">000294</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000011</span>,delta_z=<span class="number">0</span>.<span class="number">000011</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable new: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">714286</span>, delta_b=<span class="number">0</span>.<span class="number">003585</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805938</span>,z=<span class="number">150</span>.<span class="number">000077</span>,delta_z=<span class="number">0</span>.<span class="number">000077</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">671261</span>, delta_b=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>从以上两个结果对比中，可以看到三点：</p><ol><li><code>factor_b</code>第一次是<code>63</code>，以后每次都会略微降低一些</li><li>第二个函数迭代了3次就结束了，而第一个函数迭代了5次，效率不一样</li><li>最后得到的结果是一样的，因为这个问题只有一个解</li></ol><p>对于双变量的迭代，有同样的问题：</p><p>没有在迭代中重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都保持<code>63</code>和<code>18</code>)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">001440</span>, delta_w=<span class="number">0</span>.<span class="number">005039</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661628</span>,b=<span class="number">3</span>.<span class="number">903322</span>,z=<span class="number">150</span>.<span class="number">005526</span>,delta_z=<span class="number">0</span>.<span class="number">005526</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000044</span>, delta_w=<span class="number">0</span>.<span class="number">000154</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661474</span>,b=<span class="number">3</span>.<span class="number">903278</span>,z=<span class="number">150</span>.<span class="number">000170</span>,delta_z=<span class="number">0</span>.<span class="number">000170</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000001</span>, delta_w=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661469</span>,b=<span class="number">3</span>.<span class="number">903277</span>,z=<span class="number">150</span>.<span class="number">000005</span>,delta_z=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903277</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661469</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都变化)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable new: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, factor_w=<span class="number">18</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">523810</span>, factor_w=<span class="number">17</span>.<span class="number">619048</span>, delta_b=<span class="number">0</span>.<span class="number">001499</span>, delta_w=<span class="number">0</span>.<span class="number">005148</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661519</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000044</span>,delta_z=<span class="number">0</span>.<span class="number">000044</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">485234</span>, factor_w=<span class="number">17</span>.<span class="number">613053</span>, delta_b=<span class="number">0</span>.<span class="number">000000</span>, delta_w=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661517</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903263</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661517</span></span><br></pre></td></tr></table></figure><p>这个与第一个单变量迭代不同的地方是：这个问题可以有多个解，所以两种方式都可以得到各自的正确解，但是第二种方式效率高，而且满足梯度下降的概念。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://colah.github.io/posts/2015-08-Backprop/">http://colah.github.io/posts/2015-08-Backprop/</a></p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-2-非线性反向传播"><a href="#2-2-非线性反向传播" class="headerlink" title="2.2 非线性反向传播"></a>2.2 非线性反向传播</h2><h3 id="2-2-1-提出问题"><a href="#2-2-1-提出问题" class="headerlink" title="2.2.1 提出问题"></a>2.2.1 提出问题</h3><p>在上面的线性例子中，我们可以发现，误差一次性地传递给了初始值 $w$ 和 $b$，即，只经过一步，直接修改 $w$ 和 $b$ 的值，就能做到误差校正。因为从它的计算图看，无论中间计算过程有多么复杂，它都是线性的，所以可以一次传到底。缺点是这种线性的组合最多只能解决线性问题，不能解决更复杂的问题。这个我们在神经网络基本原理中已经阐述过了，需要有激活函数连接两个线性单元。</p><p>下面我们看一个非线性的例子，如图2-8所示。</p><p><img src="/../imgs/image-78.png" alt="图2-8 非线性的反向传播"></p><p>其中$1&lt;x&lt;&#x3D;10,0&lt;y&lt;2.15$。假设有5个人分别代表 $x,a,b,c,y$：</p><h4 id="正向过程"><a href="#正向过程" class="headerlink" title="正向过程"></a>正向过程</h4><ol><li>第1个人，输入层，随机输入第一个 $x$ 值，$x$ 的取值范围 $(1,10]$，假设第一个数是 $2$；</li><li>第2个人，第一层网络计算，接收第1个人传入 $x$ 的值，计算：$a&#x3D;x^2$；</li><li>第3个人，第二层网络计算，接收第2个人传入 $a$ 的值，计算：$b&#x3D;\ln (a)$；</li><li>第4个人，第三层网络计算，接收第3个人传入 $b$ 的值，计算：$c&#x3D;\sqrt{b}$；</li><li>第5个人，输出层，接收第4个人传入 $c$ 的值</li></ol><h4 id="反向过程"><a href="#反向过程" class="headerlink" title="反向过程"></a>反向过程</h4><ol start="6"><li>第5个人，计算 $y$ 与 $c$ 的差值：$\Delta c &#x3D; c - y$，传回给第4个人</li><li>第4个人，接收第5个人传回$\Delta c$，计算 $\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}$</li><li>第3个人，接收第4个人传回$\Delta b$，计算 $\Delta a &#x3D; \Delta b \cdot a$</li><li>第2个人，接收第3个人传回$\Delta a$，计算 $\Delta x &#x3D; \frac{\Delta}{2x}$</li><li>第1个人，接收第2个人传回$\Delta x$，更新 $x \leftarrow x - \Delta x$，回到第1步</li></ol><p>提出问题：假设我们想最后得到 $c&#x3D;2.13$ 的值，$x$ 应该是多少？（误差小于 $0.001$ 即可）</p><h3 id="2-2-2-数学解析解"><a href="#2-2-2-数学解析解" class="headerlink" title="2.2.2 数学解析解"></a>2.2.2 数学解析解</h3><p>$$<br>c&#x3D;\sqrt{b}&#x3D;\sqrt{\ln(a)}&#x3D;\sqrt{\ln(x^2)}&#x3D;2.13<br>$$</p><p>$$<br>x &#x3D; 9.6653<br>$$</p><h3 id="2-2-3-梯度迭代解"><a href="#2-2-3-梯度迭代解" class="headerlink" title="2.2.3 梯度迭代解"></a>2.2.3 梯度迭代解</h3><p>$$<br>\frac{da}{dx}&#x3D;\frac{d(x^2)}{dx}&#x3D;2x&#x3D;\frac{\Delta a}{\Delta x} \tag{1}<br>$$</p><p>$$<br>\frac{db}{da} &#x3D;\frac{d(\ln{a})}{da} &#x3D;\frac{1}{a} &#x3D; \frac{\Delta b}{\Delta a} \tag{2}<br>$$</p><p>$$<br>\frac{dc}{db}&#x3D;\frac{d(\sqrt{b})}{db}&#x3D;\frac{1}{2\sqrt{b}}&#x3D;\frac{\Delta c}{\Delta b} \tag{3}<br>$$</p><p>因此得到如下一组公式，可以把最后一层 $\Delta c$ 的误差一直反向传播给最前面的 $\Delta x$，从而更新 $x$ 值：</p><p>$$<br>\Delta c &#x3D; c - y \tag{4}<br>$$</p><p>根据式3</p><p>$$<br>\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}<br>$$</p><p>根据式2</p><p>$$<br>\Delta a &#x3D; \Delta b \cdot a<br>$$</p><p>根据式1</p><p>$$<br>\Delta x &#x3D; \Delta a &#x2F; 2x<br>$$</p><p>我们给定初始值 $x&#x3D;2$，$\Delta x&#x3D;0$，依次计算结果如表2-2。</p><p>表2-2 正向与反向的迭代计算</p><table><thead><tr><th>方向</th><th>公式</th><th>迭代1</th><th>迭代2</th><th>迭代3</th><th>迭代4</th><th>迭代5</th></tr></thead><tbody><tr><td>正向</td><td>$x&#x3D;x-\Delta x$</td><td>2</td><td>4.243</td><td>7.344</td><td>9.295</td><td>9.665</td></tr><tr><td>正向</td><td>$a&#x3D;x^2$</td><td>4</td><td>18.005</td><td>53.934</td><td>86.404</td><td>93.233</td></tr><tr><td>正向</td><td>$b&#x3D;\ln(a)$</td><td>1.386</td><td>2.891</td><td>3.988</td><td>4.459</td><td>4.535</td></tr><tr><td>正向</td><td>$c&#x3D;\sqrt{b}$</td><td>1.177</td><td>1.700</td><td>1.997</td><td>2.112</td><td>2.129</td></tr><tr><td></td><td>标签值y</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td></tr><tr><td>反向</td><td>$\Delta c &#x3D; c - y$</td><td>-0.953</td><td>-0.430</td><td>-0.133</td><td>-0.018</td><td></td></tr><tr><td>反向</td><td>$\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}$</td><td>-2.243</td><td>-1.462</td><td>-0.531</td><td>-0.078</td><td></td></tr><tr><td>反向</td><td>$\Delta a &#x3D; \Delta b \cdot a$</td><td>-8.973</td><td>-26.317</td><td>-28.662</td><td>-6.698</td><td></td></tr><tr><td>反向</td><td>$\Delta x &#x3D; \Delta a &#x2F; 2x$</td><td>-2.243</td><td>-3.101</td><td>-1.951</td><td>-0.360</td><td></td></tr></tbody></table><p>表2-2，先看“迭代-1”列，从上到下是一个完整的正向+反向的过程，最后一行是 $-2.243$，回到“迭代-2”列的第一行，$2-(-2.243)&#x3D;4.243$，然后继续向下。到第5轮时，正向计算得到的 $c&#x3D;2.129$，非常接近 $2.13$ 了，迭代结束。</p><p>运行示例代码可以得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">how <span class="keyword">to</span> play: 1) input x, 2) calculate c, 3) input target number but <span class="keyword">not</span> faraway <span class="keyword">from</span> c</span><br><span class="line">input x as initial number(1.2,10), you can try 1.3:</span><br><span class="line">2</span><br><span class="line"><span class="attribute">c</span>=1.177410</span><br><span class="line">input y as target number(0.5,2), you can try 1.8:</span><br><span class="line">2.13</span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=2.000000,a=4.000000,b=1.386294,c=1.177410</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">delta_c</span>=-0.952590, <span class="attribute">delta_b</span>=-2.243178, <span class="attribute">delta_a</span>=-8.972712, <span class="attribute">delta_x</span>=-2.243178</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=9.655706,a=93.232666,b=4.535098,c=2.129577</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line">done!</span><br></pre></td></tr></table></figure><p>为节省篇幅只列出了第一步和最后一步（第5步）的结果，第一步时<code>c=1.177410</code>，最后一步时<code>c=2.129577</code>，停止迭代。</p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-3-梯度下降"><a href="#2-3-梯度下降" class="headerlink" title="2.3 梯度下降"></a>2.3 梯度下降</h2><h3 id="2-3-1-从自然现象中理解梯度下降"><a href="#2-3-1-从自然现象中理解梯度下降" class="headerlink" title="2.3.1 从自然现象中理解梯度下降"></a>2.3.1 从自然现象中理解梯度下降</h3><p>在大多数文章中，都以“一个人被困在山上，需要迅速下到谷底”来举例，这个人会“寻找当前所处位置最陡峭的地方向下走”。这个例子中忽略了安全因素，这个人不可能沿着最陡峭的方向走，要考虑坡度。</p><p>在自然界中，梯度下降的最好例子，就是泉水下山的过程：</p><ol><li>水受重力影响，会在当前位置，沿着最陡峭的方向流动，有时会形成瀑布（梯度下降）；</li><li>水流下山的路径不是唯一的，在同一个地点，有可能有多个位置具有同样的陡峭程度，而造成了分流（可以得到多个解）；</li><li>遇到坑洼地区，有可能形成湖泊，而终止下山过程（不能得到全局最优解，而是局部最优解）。</li></ol><h3 id="2-3-2-梯度下降的数学理解"><a href="#2-3-2-梯度下降的数学理解" class="headerlink" title="2.3.2 梯度下降的数学理解"></a>2.3.2 梯度下降的数学理解</h3><p>梯度下降的数学公式：</p><p>$$\theta_{n+1} &#x3D; \theta_{n} - \eta \cdot \nabla J(\theta) \tag{1}$$</p><p>其中：</p><ul><li>$\theta_{n+1}$：下一个值；</li><li>$\theta_n$：当前值；</li><li>$-$：减号，梯度的反向；</li><li>$\eta$：学习率或步长，控制每一步走的距离，不要太快以免错过了最佳景点，不要太慢以免时间太长；</li><li>$\nabla$：梯度，函数当前位置的最快上升点；</li><li>$J(\theta)$：函数。</li></ul><h4 id="梯度下降的三要素"><a href="#梯度下降的三要素" class="headerlink" title="梯度下降的三要素"></a>梯度下降的三要素</h4><ol><li>当前点；</li><li>方向；</li><li>步长。</li></ol><h4 id="为什么说是“梯度下降”？"><a href="#为什么说是“梯度下降”？" class="headerlink" title="为什么说是“梯度下降”？"></a>为什么说是“梯度下降”？</h4><p>“梯度下降”包含了两层含义：</p><ol><li>梯度：函数当前位置的最快上升点；</li><li>下降：与导数相反的方向，用数学语言描述就是那个减号。</li></ol><p>亦即与上升相反的方向运动，就是下降。</p><p><img src="/../imgs/image-79.png" alt="图2-9 梯度下降的步骤"></p><p>图2-9解释了在函数极值点的两侧做梯度下降的计算过程，梯度下降的目的就是使得x值向极值点逼近。</p><h3 id="2-3-3-单变量函数的梯度下降"><a href="#2-3-3-单变量函数的梯度下降" class="headerlink" title="2.3.3 单变量函数的梯度下降"></a>2.3.3 单变量函数的梯度下降</h3><p>假设一个单变量函数：</p><p>$$J(x) &#x3D; x ^2$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$$J’(x) &#x3D; 2x$$</p><p>假设初始位置为：</p><p>$$x_0&#x3D;1.2$$</p><p>假设学习率：</p><p>$$\eta &#x3D; 0.3$$</p><p>根据公式(1)，迭代公式：</p><p>$$x_{n+1} &#x3D; x_{n} - \eta \cdot \nabla J(x)&#x3D; x_{n} - \eta \cdot 2x$$</p><p>假设终止条件为 $J(x)&lt;0.01$，迭代过程是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">480000</span>, y=<span class="number">0</span>.<span class="number">230400</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">192000</span>, y=<span class="number">0</span>.<span class="number">036864</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">076800</span>, y=<span class="number">0</span>.<span class="number">005898</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">030720</span>, y=<span class="number">0</span>.<span class="number">000944</span></span><br></pre></td></tr></table></figure><p>上面的过程如图2-10所示。</p><p><img src="/../imgs/image-80.png" alt="图2-10 使用梯度下降法迭代的过程"></p><h3 id="2-3-4-双变量的梯度下降"><a href="#2-3-4-双变量的梯度下降" class="headerlink" title="2.3.4 双变量的梯度下降"></a>2.3.4 双变量的梯度下降</h3><p>假设一个双变量函数：</p><p>$$J(x,y) &#x3D; x^2 + \sin^2(y)$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$${\partial{J(x,y)} \over \partial{x}} &#x3D; 2x$$<br>$${\partial{J(x,y)} \over \partial{y}} &#x3D; 2 \sin y \cos y$$</p><p>假设初始位置为：</p><p>$$(x_0,y_0)&#x3D;(3,1)$$</p><p>假设学习率：</p><p>$$\eta &#x3D; 0.1$$</p><p>根据公式(1)，迭代过程是的计算公式：</p><p>$$<br>(x_{n+1},y_{n+1}) &#x3D; (x_n,y_n) - \eta \cdot \nabla J(x,y)<br>$$</p><p>$$<br> &#x3D; (x_n,y_n) - \eta \cdot (2x,2 \cdot \sin y \cdot \cos y) \tag{1}<br>$$</p><p>根据公式(1)，假设终止条件为 $J(x,y)&lt;0.01$，迭代过程如表2-3所示。</p><p>表2-3 双变量梯度下降的迭代过程</p><table><thead><tr><th>迭代次数</th><th>x</th><th>y</th><th>J(x,y)</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>1</td><td>9.708073</td></tr><tr><td>2</td><td>2.4</td><td>0.909070</td><td>6.382415</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>15</td><td>0.105553</td><td>0.063481</td><td>0.015166</td></tr><tr><td>16</td><td>0.084442</td><td>0.050819</td><td>0.009711</td></tr></tbody></table><p>迭代16次后，$J(x,y)$ 的值为 $0.009711$，满足小于 $0.01$ 的条件，停止迭代。</p><p>上面的过程如表2-4所示，由于是双变量，所以需要用三维图来解释。请注意看两张图中间那条隐隐的黑色线，表示梯度下降的过程，从红色的高地一直沿着坡度向下走，直到蓝色的洼地。</p><p>表2-4 在三维空间内的梯度下降过程</p><p><img src="/../imgs/image-81.png"></p><h3 id="2-3-5-学习率η的选择"><a href="#2-3-5-学习率η的选择" class="headerlink" title="2.3.5 学习率η的选择"></a>2.3.5 学习率η的选择</h3><p>在公式表达时，学习率被表示为$\eta$。在代码里，我们把学习率定义为<code>learning_rate</code>，或者<code>eta</code>。针对上面的例子，试验不同的学习率对迭代情况的影响，如表2-5所示。</p><p>表2-5 不同学习率对迭代情况的影响</p><p><img src="/../imgs/image-83.png"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Neural Network class</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, eta</span>):</span><br><span class="line">        self.eta = eta</span><br><span class="line">        self.w = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = self.w * x + self.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__backward</span>(<span class="params">self, x, y, z</span>):</span><br><span class="line">        dz = z - y  <span class="comment"># dz 表示预测值 z 和真实值 y 之间的误差</span></span><br><span class="line">        db = dz <span class="comment"># 因为偏置项 b 对于每个输入样本 x 都是相同的，所以误差 dz 直接反映了偏置项 b 的更新量。因此，db = dz 表示偏置项 b 的梯度（即偏导数）等于误差 dz。</span></span><br><span class="line">        dw = x * dz <span class="comment"># 损失函数对w求梯度（偏导数），损失函数为均方误差，所以损失函数对w求导，即dw = x * dz</span></span><br><span class="line">        <span class="keyword">return</span> dw, db</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度更新</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__update</span>(<span class="params">self, dw, db</span>):</span><br><span class="line">        self.w = self.w - self.eta * dw</span><br><span class="line">        self.b = self.b - self.eta * db</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, dataReader</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dataReader.num_train_data):</span><br><span class="line">            x, y = dataReader.get_train_data(i)  <span class="comment"># 获取第i个训练样本</span></span><br><span class="line">            z = self.__forward(x)  <span class="comment"># 前向计算得到z</span></span><br><span class="line">            dw, db = self.__backward(x, y, z) <span class="comment"># 反向传播得到dw和db</span></span><br><span class="line">            self.__update(dw, db) <span class="comment"># 更新参数w和b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__forward(x)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!--Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-异步接口调用</title>
    <link href="https://kelinkong.github.io/2024/12/17/Java-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/12/17/Java-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</id>
    <published>2024-12-17T11:16:30.000Z</published>
    <updated>2024-12-23T03:14:30.875Z</updated>
    
    <content type="html"><![CDATA[<p>当<strong>异步方法</strong>提供服务时，调用方通常需要一种机制来<strong>知道异步方法什么时候返回结果</strong>以及<strong>是否执行成功</strong>。在 <strong>Spring Boot</strong> 中，这可以通过返回 <code>Future</code>、<code>CompletableFuture</code> 或使用回调机制来实现。</p><h2 id="1-使用-Future-接口"><a href="#1-使用-Future-接口" class="headerlink" title="1. 使用 Future 接口"></a><strong>1. 使用 <code>Future</code> 接口</strong></h2><p><code>@Async</code> 方法可以返回一个 <code>Future</code> 对象，调用方可以通过 <code>Future</code> 的方法查询执行状态和结果。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">asyncMethodWithFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.failedFuture(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例"><a href="#调用方示例" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testAsync&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;String&gt; result = myService.asyncMethodWithFuture();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!result.isDone()) &#123; <span class="comment">// 轮询检查是否完成</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;异步方法未完成...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.get(); <span class="comment">// 获取结果，阻塞直到异步任务完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;异步调用失败：&quot;</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ol><li><code>Future</code> 提供方法如：<ul><li><code>isDone()</code>：检查任务是否完成。</li><li><code>get()</code>：获取结果（会阻塞当前线程，直到任务完成）。</li></ul></li><li>调用方可以轮询 <code>isDone()</code> 判断异步方法的状态。</li></ol><p><strong>缺点</strong>：轮询消耗资源，且 <code>get()</code> 方法是<strong>阻塞</strong>的，不够高效。</p><hr><h2 id="2-使用-CompletableFuture"><a href="#2-使用-CompletableFuture" class="headerlink" title="2. 使用 CompletableFuture"></a><strong>2. 使用 <code>CompletableFuture</code></strong></h2><p><code>CompletableFuture</code> 提供更灵活的非阻塞异步处理，支持链式操作和回调。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">asyncMethodWithCompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.failedFuture(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例-1"><a href="#调用方示例-1" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testCompletableFuture&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">testCompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myService.asyncMethodWithCompletableFuture()</span><br><span class="line">                .thenApply(result -&gt; <span class="string">&quot;异步任务返回结果：&quot;</span> + result)</span><br><span class="line">                .exceptionally(ex -&gt; <span class="string">&quot;异步任务失败：&quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ol><li><strong>非阻塞</strong>：调用方无需等待，可以直接返回 <code>CompletableFuture</code> 供调用方使用。</li><li><code>thenApply</code>：任务成功时执行的回调操作。</li><li><code>exceptionally</code>：任务失败时的回调处理。</li></ol><p><strong>优点</strong>：</p><ul><li>支持链式调用，代码清晰。</li><li>无需主动轮询，任务完成时自动触发回调。</li></ul><hr><h2 id="3-使用回调机制"><a href="#3-使用回调机制" class="headerlink" title="3. 使用回调机制"></a><strong>3. 使用回调机制</strong></h2><p>如果你不想依赖 <code>Future</code> 或 <code>CompletableFuture</code>，可以手动实现回调逻辑，通过 <strong>自定义回调接口</strong> 来通知调用方。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethodWithCallback</span><span class="params">(Callback callback)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            callback.onSuccess(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            callback.onFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例-2"><a href="#调用方示例-2" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testCallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testCallback</span><span class="params">()</span> &#123;</span><br><span class="line">        myService.asyncMethodWithCallback(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;回调成功：&quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;回调失败：&quot;</span> + t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;异步方法已触发，等待回调结果...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ul><li><code>Callback</code> 接口定义了成功和失败时的回调方法。</li><li>异步任务执行后，通过回调接口通知调用方结果。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>方法</th><th>特点</th><th>是否阻塞</th><th>适用场景</th></tr></thead><tbody><tr><td><code>Future</code></td><td>简单轮询和阻塞获取结果</td><td>阻塞</td><td>小型任务，简单异步</td></tr><tr><td><code>CompletableFuture</code></td><td>支持链式调用、非阻塞和回调</td><td>非阻塞</td><td>高性能异步处理</td></tr><tr><td>自定义回调接口</td><td>完全自定义回调逻辑</td><td>非阻塞</td><td>灵活控制回调和通知</td></tr></tbody></table><p><strong>推荐</strong>：使用 **<code>CompletableFuture</code>**，它功能强大、非阻塞，并且易于维护和扩展。</p><h2 id="异步编程-多并发示例"><a href="#异步编程-多并发示例" class="headerlink" title="异步编程+多并发示例"></a>异步编程+多并发示例</h2><p>为了确保外系统调用接口 A 时不会因接口 B 的处理耗时而超时，可以设计接口 A 为 <strong>异步返回机制</strong>，即外系统调用接口 A 时，接口 A 立即返回一个请求 ID，随后在后台完成调用接口 B 的多次处理任务，外系统可以通过请求 ID 查询最终结果。</p><p>假设我现在有一个接口A，调用了接口B，但是接口B每次需要耗时20s左右才能处理完成，且我需要多次调用接口B，但是我又不能大规模并发的调用接口B（有并发数限制），我的接口A和B都是一个微应用接口，现在我需要把微应用接口A暴露给外系统调用，我要如何高效实现？</p><p>以下是基于已有线程池的实现方案：</p><hr><h3 id="解决方案：立即响应，异步处理"><a href="#解决方案：立即响应，异步处理" class="headerlink" title="解决方案：立即响应，异步处理"></a><strong>解决方案：立即响应，异步处理</strong></h3><ol><li><p><strong>外部接口 A 的处理逻辑：</strong></p><ul><li>接收外部请求。</li><li>立即生成一个唯一请求 ID，并存储初始状态。</li><li>使用线程池异步处理任务。</li><li>立即返回请求 ID。</li></ul></li><li><p><strong>后台任务逻辑：</strong></p><ul><li>在线程池中分解任务。</li><li>按并发限制逐个调用接口 B。</li><li>将结果存储到缓存或数据库中。</li></ul></li><li><p><strong>结果查询接口：</strong></p><ul><li>外系统通过查询接口，使用请求 ID 检索处理结果。</li></ul></li></ol><hr><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><h4 id="1-定义接口-A"><a href="#1-定义接口-A" class="headerlink" title="1. 定义接口 A"></a><strong>1. 定义接口 A</strong></h4><p>通过线程池异步处理任务，立即返回请求 ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceAController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService; <span class="comment">// 现有线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; results = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); <span class="comment">// 模拟存储结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InterfaceAController</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">processRequest</span><span class="params">(<span class="meta">@RequestBody</span> RequestData requestData)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString(); <span class="comment">// 生成唯一请求 ID</span></span><br><span class="line">        results.put(requestId, <span class="string">&quot;Processing&quot;</span>); <span class="comment">// 初始化状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步处理任务</span></span><br><span class="line">        executorService.submit(() -&gt; handleRequest(requestId, requestData));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 立即返回请求 ID</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String requestId, RequestData requestData)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; tasks = requestData.getSubTasks(); <span class="comment">// 分解请求</span></span><br><span class="line">            List&lt;String&gt; taskResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String task : tasks) &#123;</span><br><span class="line">                semaphore.acquire(); <span class="comment">// 控制并发数</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> callInterfaceB(task); <span class="comment">// 调用接口 B</span></span><br><span class="line">                    taskResults.add(result);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并结果并存储</span></span><br><span class="line">            results.put(requestId, String.join(<span class="string">&quot;, &quot;</span>, taskResults));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            results.put(requestId, <span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">callInterfaceB</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟接口 B 的调用</span></span><br><span class="line">        Thread.sleep(<span class="number">20000</span>); <span class="comment">// 假设接口 B 耗时 20 秒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Processed &quot;</span> + task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/result/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">getResult</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> results.get(id);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(<span class="string">&quot;Result not found&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Processing&quot;</span>.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.PROCESSING).body(<span class="string">&quot;Still processing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-外系统调用流程"><a href="#2-外系统调用流程" class="headerlink" title="2. 外系统调用流程"></a><strong>2. 外系统调用流程</strong></h3><ol><li><p>调用 <code>/api/process</code>：</p><ul><li><strong>请求：</strong>发送业务数据。</li><li><strong>响应：</strong>立即返回一个唯一的请求 ID。</li></ul></li><li><p>调用 <code>/api/result/&#123;id&#125;</code>：</p><ul><li><strong>请求：</strong>查询对应请求 ID 的处理结果。</li><li><strong>响应：</strong><ul><li>如果结果尚未处理完成，返回状态码 <code>HTTP 102 Processing</code>。</li><li>如果处理完成，返回最终结果。</li></ul></li></ul></li></ol><hr><h3 id="3-优化与增强"><a href="#3-优化与增强" class="headerlink" title="3. 优化与增强"></a><strong>3. 优化与增强</strong></h3><h4 id="结果存储"><a href="#结果存储" class="headerlink" title="结果存储"></a><strong>结果存储</strong></h4><ul><li>如果任务结果较大，建议存储到 Redis 或数据库中，以减少内存压力。</li></ul><h4 id="结果通知"><a href="#结果通知" class="headerlink" title="结果通知"></a><strong>结果通知</strong></h4><ul><li>除轮询机制外，可以提供<strong>回调机制</strong>，通知外系统任务完成。</li><li>例如，外系统调用接口 A 时提供回调 URL，任务完成后主动通知：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyExternalSystem</span><span class="params">(String callbackUrl, String result)</span> &#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    restTemplate.postForEntity(callbackUrl, result, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="超时监控"><a href="#超时监控" class="headerlink" title="超时监控"></a><strong>超时监控</strong></h4><ul><li>为每个任务设置超时时间，确保长时间未完成的任务能正确标记为失败。</li></ul><h4 id="负载调控"><a href="#负载调控" class="headerlink" title="负载调控"></a><strong>负载调控</strong></h4><ul><li>如果任务量较大，可结合消息队列（如 Kafka）进一步解耦任务提交和处理。</li></ul><hr><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ol><li><strong>外系统不超时：</strong>接口 A 立即响应，外系统只需查询结果或接收回调。</li><li><strong>高效调用接口 B：</strong>通过线程池和信号量控制并发，避免超出接口 B 的限制。</li><li><strong>扩展性好：</strong>可通过增加线程池大小或优化队列管理提升性能。</li></ol><hr><h3 id="完整调用示例"><a href="#完整调用示例" class="headerlink" title="完整调用示例"></a><strong>完整调用示例</strong></h3><ol><li><p>外系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;subTasks&quot;: [&quot;task1&quot;, &quot;task2&quot;]&#125;&#x27;</span> http://localhost:8080/api/process</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;requestId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abcd1234&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/api/result/abcd1234</span><br></pre></td></tr></table></figure><ul><li>如果正在处理中：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Processing&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果处理完成：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Completed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Processed task1, Processed task2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当&lt;strong&gt;异步方法&lt;/strong&gt;提供服务时，调用方通常需要一种机制来&lt;strong&gt;知道异步方法什么时候返回结果&lt;/strong&gt;以及&lt;strong&gt;是否执行成功&lt;/strong&gt;。在 &lt;strong&gt;Spring Boot&lt;/strong&gt; 中，这可以通过返回</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>前端-expo</title>
    <link href="https://kelinkong.github.io/2024/11/22/%E5%89%8D%E7%AB%AF-expo/"/>
    <id>https://kelinkong.github.io/2024/11/22/%E5%89%8D%E7%AB%AF-expo/</id>
    <published>2024-11-22T03:38:47.000Z</published>
    <updated>2024-11-22T06:17:31.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="expo是什么？"><a href="#expo是什么？" class="headerlink" title="expo是什么？"></a>expo是什么？</h2><p>Expo 是一个用于构建原生应用的工具集合，它提供了一组工具和框架，用于开发跨平台应用。Expo 提供了简化原生应用的开发过程的工具，如自动构建和发布，以及集成各种第三方库。</p><h3 id="Expo-的介绍"><a href="#Expo-的介绍" class="headerlink" title="Expo 的介绍"></a><strong>Expo 的介绍</strong></h3><p>Expo 是一个用于构建 React Native 应用的工具链，提供了一种快速搭建、开发、测试和发布移动应用的方法。它简化了 React Native 开发流程，使开发者可以更专注于业务逻辑，而无需担心底层的原生配置。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><strong>易用性</strong>：快速启动，无需配置复杂的环境。</li><li><strong>跨平台支持</strong>：一次开发，适配 iOS 和 Android。</li><li><strong>丰富的 API</strong>：内置支持摄像头、位置、通知等原生功能。</li><li><strong>强大的工具链</strong>：<ul><li><strong>Expo Go</strong>：一个移动应用，用于实时查看开发中的项目。</li><li><strong>Expo CLI</strong>：命令行工具，管理项目的开发、打包和部署。</li></ul></li><li><strong>托管服务</strong>：提供打包、发布和更新服务。</li></ol><hr><h3 id="Expo-的安装"><a href="#Expo-的安装" class="headerlink" title="Expo 的安装"></a><strong>Expo 的安装</strong></h3><p>Expo 的安装分为工具安装和项目初始化。</p><h4 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a><strong>前置要求</strong></h4><ol><li><strong>Node.js</strong>：安装最新的 LTS 版本（推荐使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 管理 Node.js）。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v    <span class="comment"># 检查 Node.js 版本</span></span><br></pre></td></tr></table></figure></li><li><strong>npm 或 yarn</strong>：Node.js 安装后会自带 <code>npm</code>，也可以选择安装 <code>yarn</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v     <span class="comment"># 检查 npm 版本</span></span><br><span class="line">yarn -v    <span class="comment"># 如果使用 yarn，检查其版本</span></span><br></pre></td></tr></table></figure></li></ol><p>现在推荐通过 <code>npx expo</code> 直接执行命令，而不是全局安装 <code>expo-cli</code>。这是为了减少全局依赖，确保使用的是最新版本的 Expo 命令行工具。</p><hr><h3 id="使用-npx-expo-的流程"><a href="#使用-npx-expo-的流程" class="headerlink" title="使用 npx expo 的流程"></a><strong>使用 npx expo 的流程</strong></h3><h4 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a><strong>1. 初始化项目</strong></h4><p>你可以直接通过 <code>npx expo</code> 命令初始化一个新的 Expo 项目：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx expo init my-new-project</span><br></pre></td></tr></table></figure><ul><li><p><strong>选择模板</strong>：执行命令后，你可以选择以下模板之一：</p><ul><li><strong>blank</strong>：空白项目。</li><li>**blank (TypeScript)**：支持 TypeScript 的空白项目。</li><li>**tabs (TypeScript)**：带底部导航栏的 TypeScript 项目。</li></ul></li><li><p><strong>进入项目目录</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-new-project</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-启动开发服务器"><a href="#2-启动开发服务器" class="headerlink" title="2. 启动开发服务器"></a><strong>2. 启动开发服务器</strong></h4><p>在项目目录中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx expo start</span><br></pre></td></tr></table></figure><ul><li>打开浏览器后，你会看到一个开发面板：<ul><li><strong>二维码</strong>：可以用手机上的 <strong>Expo Go</strong> 应用扫描来查看项目。</li><li><strong>选择平台</strong>：可以选择在 iOS 模拟器、Android 模拟器或 Web 浏览器中运行。</li></ul></li></ul><hr><h4 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a><strong>3. 安装依赖</strong></h4><p>Expo 提供了一个专用的 <code>expo install</code> 命令，用来安装与当前 Expo SDK 版本兼容的依赖。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx expo install expo-camera expo-location</span><br></pre></td></tr></table></figure><hr><h4 id="4-构建和发布应用"><a href="#4-构建和发布应用" class="headerlink" title="4. 构建和发布应用"></a><strong>4. 构建和发布应用</strong></h4><ul><li><p><strong>构建应用</strong>：</p><ul><li>使用 <code>EAS Build</code>（推荐）来构建应用：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx expo install eas-cli</span><br><span class="line">npx eas build</span><br></pre></td></tr></table></figure></li><li>Expo 已不再推荐直接使用 <code>expo build</code>，因为 EAS 提供了更现代的构建方式，支持自定义原生代码。</li></ul></li><li><p><strong>发布应用</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx expo publish</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="为什么推荐-npx？"><a href="#为什么推荐-npx？" class="headerlink" title="为什么推荐 npx？"></a><strong>为什么推荐 npx？</strong></h3><ol><li><strong>确保使用最新版本</strong>：通过 <code>npx expo</code>，每次执行时都会自动下载最新的命令行工具。</li><li><strong>减少全局安装依赖</strong>：无需全局安装 <code>expo-cli</code>，避免版本冲突。</li><li><strong>简单易用</strong>：直接通过项目本地的工具执行命令，无需额外配置。</li></ol><hr><h3 id="常用-npx-expo-命令"><a href="#常用-npx-expo-命令" class="headerlink" title="常用 npx expo 命令"></a><strong>常用 npx expo 命令</strong></h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>npx expo init</code></td><td>初始化一个新的 Expo 项目</td></tr><tr><td><code>npx expo start</code></td><td>启动开发服务器，支持 Web 和移动设备测试</td></tr><tr><td><code>npx expo install</code></td><td>安装兼容 Expo 的依赖包</td></tr><tr><td><code>npx expo upgrade</code></td><td>升级 Expo 项目到最新版本</td></tr><tr><td><code>npx eas build</code></td><td>构建 iOS 和 Android 的生产版本</td></tr><tr><td><code>npx expo export:web</code></td><td>导出为静态 Web 应用</td></tr></tbody></table><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li>使用 <code>npx expo</code> 是当前最推荐的方式。</li><li>无需全局安装 <code>expo-cli</code>，保持工具链轻量化。</li><li>支持快速开发、调试和构建跨平台应用。</li></ul><p>如果需要详细指导，比如环境配置或特定功能开发，可以继续告诉我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;expo是什么？&quot;&gt;&lt;a href=&quot;#expo是什么？&quot; class=&quot;headerlink&quot; title=&quot;expo是什么？&quot;&gt;&lt;/a&gt;expo是什么？&lt;/h2&gt;&lt;p&gt;Expo 是一个用于构建原生应用的工具集合，它提供了一组工具和框架，用于开发跨平台应用。Ex</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud: 断路器</title>
    <link href="https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    <id>https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/</id>
    <published>2024-11-19T01:07:12.000Z</published>
    <updated>2024-11-19T02:15:39.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="断路器（Circuit-Breaker）简介"><a href="#断路器（Circuit-Breaker）简介" class="headerlink" title="断路器（Circuit Breaker）简介"></a>断路器（Circuit Breaker）简介</h3><p><strong>断路器</strong>是一种用于防止分布式系统中的故障扩散的机制。它借鉴了电路中的断路器原理，当某个服务出现故障或响应异常时，断路器会主动中断请求链路，避免故障传播到整个系统，保护系统的可用性和稳定性。</p><p>断路器通常在微服务架构中使用，结合服务治理框架（如 Spring Cloud Hystrix、Resilience4j 等）实现。</p><hr><h3 id="断路器的核心概念"><a href="#断路器的核心概念" class="headerlink" title="断路器的核心概念"></a>断路器的核心概念</h3><p>断路器有三种状态：<strong>关闭（Closed）</strong>、<strong>打开（Open）</strong> 和 <strong>半开（Half-Open）</strong>。</p><ol><li><p><strong>关闭状态（Closed）</strong>：</p><ul><li>默认状态，服务正常时断路器处于关闭状态。</li><li>请求直接转发到目标服务。</li><li>如果在一定时间内连续发生错误（如超时、异常等）超过预设阈值，断路器会进入<strong>打开状态</strong>。</li></ul></li><li><p><strong>打开状态（Open）</strong>：</p><ul><li>当断路器打开时，请求不再转发到目标服务，而是直接失败或返回预设的降级结果。</li><li>断路器会在打开状态维持一段时间（冷却时间），然后进入<strong>半开状态</strong>。</li></ul></li><li><p><strong>半开状态（Half-Open）</strong>：</p><ul><li>冷却时间结束后，断路器会允许少量请求通过，测试目标服务是否恢复。</li><li>如果测试请求成功率达到预期，断路器会切换回关闭状态。</li><li>如果测试请求仍然失败，则断路器重新进入打开状态。</li></ul></li></ol><hr><h3 id="断路器的作用"><a href="#断路器的作用" class="headerlink" title="断路器的作用"></a>断路器的作用</h3><ol><li><p><strong>避免级联故障</strong>：<br>当某个服务发生故障时，断路器能够切断请求，防止故障扩散到其他服务，保护系统的整体稳定性。</p></li><li><p><strong>快速失败</strong>：<br>在目标服务不可用时，断路器立即返回失败结果或降级响应，避免用户长时间等待，提高用户体验。</p></li><li><p><strong>系统保护</strong>：<br>减少对故障服务的访问压力，避免因请求积压导致服务雪崩。</p></li></ol><hr><h3 id="断路器的关键指标"><a href="#断路器的关键指标" class="headerlink" title="断路器的关键指标"></a>断路器的关键指标</h3><ol><li><p><strong>失败率</strong>：<br>一段时间内的失败请求占比。如果失败率超过阈值，断路器进入打开状态。</p></li><li><p><strong>请求数量</strong>：<br>设置触发断路器的最小请求数，确保断路器在足够的请求量下判断服务是否故障。</p></li><li><p><strong>熔断时间（冷却时间）</strong>：<br>指断路器打开后保持不再发送请求的时间，熔断时间过后进入半开状态。</p></li><li><p><strong>恢复检测</strong>：<br>在半开状态下，通过少量请求测试服务是否恢复，避免因误判直接恢复全部流量。</p></li></ol><hr><h3 id="常见断路器框架"><a href="#常见断路器框架" class="headerlink" title="常见断路器框架"></a>常见断路器框架</h3><ol><li><p><strong>Hystrix（已停止维护）</strong>：</p><ul><li>Netflix 开发，支持熔断器、线程隔离、请求缓存、请求合并等功能。</li><li>使用广泛，但因功能复杂导致性能损耗高，现已被 Resilience4j 替代。</li></ul></li><li><p><strong>Resilience4j</strong>：</p><ul><li>轻量级 Java 熔断器库，支持断路器、限流、重试、超时等功能。</li><li>性能优于 Hystrix，更适合现代微服务架构。</li></ul></li><li><p><strong>Spring Cloud Circuit Breaker</strong>：</p><ul><li>Spring 官方的断路器抽象层，支持多种断路器实现，如 Resilience4j 和 Sentinel。</li></ul></li></ol><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>微服务调用失败</strong>：<br>处理服务超时、响应错误等异常情况，防止用户请求被无限制地转发到失败服务。</p></li><li><p><strong>高并发场景</strong>：<br>在流量激增时对服务降级，保护系统核心功能。</p></li><li><p><strong>依赖外部资源</strong>：<br>调用第三方接口或外部服务时，避免对其过度依赖导致自身系统故障。</p></li></ol><hr><h3 id="断路器的优缺点"><a href="#断路器的优缺点" class="headerlink" title="断路器的优缺点"></a>断路器的优缺点</h3><p><strong>优点</strong>：</p><ul><li>防止服务雪崩。</li><li>提升系统稳定性。</li><li>提高用户体验，避免长时间等待。</li></ul><p><strong>缺点</strong>：</p><ul><li>增加系统复杂度。</li><li>需要合理设置阈值，否则可能引发误判。</li><li>引入额外的延迟（如熔断检测）。</li></ul><hr><h3 id="实现示例（使用-Resilience4j）"><a href="#实现示例（使用-Resilience4j）" class="headerlink" title="实现示例（使用 Resilience4j）"></a>实现示例（使用 Resilience4j）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;paymentFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用目标服务</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://payment-service/pay&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFallback</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Payment service is currently unavailable. Please try again later.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @CircuitBreaker 注解指定断路器名称和降级方法，当目标服务出现异常时返回降级响应。</p><hr><p>通过断路器，分布式系统可以更好地处理服务故障和性能问题，确保高可用性和用户体验。</p><p>参考文档：<a href="https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/index.md">Resilience4j</a></p><h2 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h2><p><img src="/../imgs/image-68.png"></p><p>配置断路器</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">circuitbreaker:</span> <span class="comment"># 降级熔断</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">50</span> <span class="comment"># 调用失败达到50%后打开断路器</span></span><br><span class="line">        <span class="attr">sliding-window-type:</span> <span class="string">count_based</span> <span class="comment"># 滑动窗口类型</span></span><br><span class="line">        <span class="attr">sliding-window-size:</span> <span class="number">6</span> <span class="comment"># 滑动窗口大小 count_based6个请求 time_base6秒</span></span><br><span class="line">        <span class="attr">minimum-number-of-calls:</span> <span class="number">6</span> <span class="comment"># 每个滑动窗口的周期</span></span><br><span class="line">        <span class="attr">automatic-transition-from-open-to-half-open-enabled:</span> <span class="literal">true</span> <span class="comment"># 开始过度到半开状态</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="string">5s</span> <span class="comment"># 从开启到半开启需要5s</span></span><br><span class="line">        <span class="attr">permitted-number-of-calls-in-half-open-state:</span> <span class="number">2</span> <span class="comment">#半开状态允许通过的最大请求数</span></span><br><span class="line">        <span class="attr">record-exceptions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">java.lang.Exception</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">base-config:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;断路器（Circuit-Breaker）简介&quot;&gt;&lt;a href=&quot;#断路器（Circuit-Breaker）简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud: OpenFeign</title>
    <link href="https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/"/>
    <id>https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/</id>
    <published>2024-11-14T10:18:20.000Z</published>
    <updated>2024-11-19T01:00:01.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenFeign介绍"><a href="#OpenFeign介绍" class="headerlink" title="OpenFeign介绍"></a>OpenFeign介绍</h2><p>OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 Netflix Feign，支持与 Spring Cloud 一起使用。它简化了 HTTP 服务调用的过程，可以通过定义接口来调用远程服务，而不需要手写复杂的 HTTP 请求代码。开发者只需定义接口并使用注解来配置 HTTP 请求的细节。</p><p>在 Spring Cloud 中，OpenFeign 作为微服务间通信的一个常用工具，尤其适合构建基于 REST 的微服务应用。</p><h3 id="OpenFeign-相对-RestTemplate-LoadBalanced-的优势"><a href="#OpenFeign-相对-RestTemplate-LoadBalanced-的优势" class="headerlink" title="OpenFeign 相对 RestTemplate + @LoadBalanced 的优势"></a>OpenFeign 相对 RestTemplate + @LoadBalanced 的优势</h3><p>即便 <code>RestTemplate</code> 可以通过 <code>@LoadBalanced</code> 实现负载均衡，OpenFeign 仍然在以下方面具备优势：</p><ol><li><p><strong>声明式语法简洁性</strong>：OpenFeign 使用接口和注解定义请求，可以省去大量手动编写 URL 和方法的代码，特别是在大型项目中，显著减少重复代码。</p></li><li><p><strong>熔断与容错支持</strong>：OpenFeign 默认集成了 Hystrix 等容错机制，可以在微服务调用中轻松实现熔断功能。而在 <code>RestTemplate</code> 中实现熔断需要手动配置，例如结合 <code>CircuitBreaker</code> 进行实现，稍显繁琐。</p></li><li><p><strong>可扩展性</strong>：OpenFeign 提供了更强的扩展支持，如全局请求拦截器（<code>RequestInterceptor</code>）、超时设置等，可通过注解或配置文件集中管理。而 <code>RestTemplate</code> 则需要通过 <code>ClientHttpRequestInterceptor</code> 来手动添加拦截器，配置相对复杂。</p></li><li><p><strong>可维护性和测试性</strong>：OpenFeign 将远程服务抽象为接口，使得服务之间的依赖关系更清晰，测试时可以轻松进行 Mock，不需要关心实现细节。而在 <code>RestTemplate</code> 中进行类似的 Mock 测试时，需要为每个请求配置更多细节。</p></li></ol><h2 id="使用-OpenFeign"><a href="#使用-OpenFeign" class="headerlink" title="使用 OpenFeign"></a>使用 OpenFeign</h2><p>首先，我们需要在 pom.xml 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们可以在 Spring Boot 项目中定义一个接口，该接口将定义远程服务的 API。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;cloud-provider-payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/pay/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 <code>@FeignClient</code> 注解定义了一个 Feign 客户端，<code>name</code> 属性指定了服务提供者的服务名，<code>@GetMapping</code> 注解定义了一个 GET 请求，<code>@PathVariable</code> 注解用于获取请求参数。</p><p>最后，我们可以在 Controller 中注入该接口，并调用远程服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们注入了 <code>PaymentFeignService</code> 接口，并调用了 <code>getPaymentById</code> 方法，实现了远程服务的调用。</p><p><strong>OpenFeign天然支持负载均衡</strong>，只需要在配置文件中配置服务提供者的服务名即可，无需关心具体的 IP 和端口。</p><h2 id="配置超时时间"><a href="#配置超时时间" class="headerlink" title="配置超时时间"></a>配置超时时间</h2><p>调用服务的超时时间是一个重要的配置，可以避免因为网络延迟导致的性能问题。</p><p>在 OpenFeign 中，我们可以通过配置文件来设置超时时间，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">        <span class="attr">client:</span></span><br><span class="line">            <span class="attr">config:</span></span><br><span class="line">            <span class="attr">default:</span> <span class="comment"># 全局配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">            <span class="attr">my-service:</span> <span class="comment"># 指定服务配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们设置了默认的超时时间为 5 秒。</p><p>openFeign的默认超时时间是60s。</p><h2 id="配置重试机制"><a href="#配置重试机制" class="headerlink" title="配置重试机制"></a>配置重试机制</h2><p>在 OpenFeign 中，可以设置重试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenFeignConfig.java</span></span><br><span class="line"><span class="keyword">public</span> OpenFeignConfig&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重试机制</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Retryer <span class="title function_">myRetryer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retryer</span>.Default(<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志记录级别</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 更换默认的client</span><br><span class="line">在 OpenFeign 中，我们可以通过配置文件来更换默认的 client，例如：</span><br><span class="line">```yaml</span><br><span class="line">cloud:</span><br><span class="line">    openfeign:</span><br><span class="line">        httpclient:</span><br><span class="line">            hc5:</span><br><span class="line">                enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们通过 <code>cloud.openfeign.httpclient.hc5.enabled</code> 属性来启用 HttpClient 5.x 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenFeign介绍&quot;&gt;&lt;a href=&quot;#OpenFeign介绍&quot; class=&quot;headerlink&quot; title=&quot;OpenFeign介绍&quot;&gt;&lt;/a&gt;OpenFeign介绍&lt;/h2&gt;&lt;p&gt;OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 N</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud：base工程</title>
    <link href="https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/"/>
    <id>https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-11-13T07:31:35.000Z</published>
    <updated>2024-11-14T02:34:21.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h2><p>使用Idea做为编译器，创建一个新的Spring Cloud项目。</p><p>版本选择：</p><p><img src="/../imgs/image-67.png"></p><h3 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start mysql</span><br></pre></td></tr></table></figure><p><strong>查看mysql版本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select VERSION();</span><br><span class="line">+-----------+</span><br><span class="line">| VERSION() |</span><br><span class="line">+-----------+</span><br><span class="line">| 9.0.1     |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database db2024;</span><br></pre></td></tr></table></figure><p><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_pay</span><br><span class="line">(</span><br><span class="line">    id          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    pay_no      VARCHAR(50) NOT NULL COMMENT &#x27;支付流水号&#x27;,</span><br><span class="line">    order_no    VARCHAR(50) NOT NULL COMMENT &#x27;订单流水号&#x27;,</span><br><span class="line">    user_id     INT DEFAULT 1 NULL COMMENT &#x27;用户账号ID&#x27;,</span><br><span class="line">    amount      DECIMAL(8, 2) DEFAULT 9.90 NOT NULL COMMENT &#x27;交易金额&#x27;,</span><br><span class="line">    deleted     TINYINT UNSIGNED DEFAULT &#x27;0&#x27; NOT NULL COMMENT &#x27;删除标志, 默认0不删除,1删除&#x27;,</span><br><span class="line">    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;</span><br><span class="line">)</span><br><span class="line">COMMENT &#x27;支付交易表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自动生成mapper和实体类"><a href="#自动生成mapper和实体类" class="headerlink" title="自动生成mapper和实体类"></a>自动生成mapper和实体类</h2><p>创建一个mybatis-generator模块，自动生成mapper和实体类。</p><p>使用<code>mybatis-generator-maven-plugin</code>插件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在maven中，双击<code>mybatis-generator:generate</code>即可生成。</p><p>配置文件在<code>src/main/resources/generator/generatorConfig.xml</code>。</p><h2 id="新建一个微服务流程"><a href="#新建一个微服务流程" class="headerlink" title="新建一个微服务流程"></a>新建一个微服务流程</h2><ol><li>新建一个模块，例如：pay-service。</li><li>更改pom.xml文件，添加依赖。</li><li>写yml配置文件。</li><li>编写启动类。</li><li>编写业务代码。</li></ol><h2 id="Swager3"><a href="#Swager3" class="headerlink" title="Swager3"></a>Swager3</h2><p>Swager是一个API文档生成工具，可以通过注解生成API文档。</p><p>常用注解：</p><ul><li><code>@Tag</code>：用在类上，说明该类的作用。</li><li><code>@Operation</code>：用在方法上，说明方法的作用。</li><li><code>@Parameter</code>：用在方法参数上，说明参数的作用。</li><li><code>Schema</code>：用在实体类上，说明实体类的作用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController()</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pay&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;支付微服务模块&quot;, description = &quot;支付crud操作&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PayService payService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增&quot;, description = &quot;新增支付流水, 参数是JSON字符串&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> PayDTO payDTO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payService.add(payDTO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写配置类，配置Swagger3。</p><p>进入地址：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p><p>在网页上可以看到生成的API文档。点击try it out可以测试接口。</p><h2 id="时间格式问题"><a href="#时间格式问题" class="headerlink" title="时间格式问题"></a>时间格式问题</h2><h3 id="使用-JsonFormat注解"><a href="#使用-JsonFormat注解" class="headerlink" title="使用@JsonFormat注解"></a>使用<code>@JsonFormat</code>注解</h3><p>在实体类中添加注解，指定时间格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure><h3 id="在application-yml中配置"><a href="#在application-yml中配置" class="headerlink" title="在application.yml中配置"></a>在application.yml中配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">        <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">        <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure><h2 id="统一返回值"><a href="#统一返回值" class="headerlink" title="统一返回值"></a>统一返回值</h2><p>现在主流的返回值需要包括：</p><ul><li>code：状态码</li><li>data：数据</li><li>message：消息</li><li>timestamp：时间戳（调用接口的时间）</li></ul><p>状态码一般是枚举类型。</p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>编写枚举类的技巧：举值-构造-遍历。</p><h2 id="全局异常处理和返回"><a href="#全局异常处理和返回" class="headerlink" title="全局异常处理和返回"></a>全局异常处理和返回</h2><p>定义一个全局异常处理类，继承<code>ResponseEntityExceptionHandler</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> <span class="keyword">extends</span> <span class="title class_">ResponseEntityExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;全局异常处理：&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生异常时，会调用<code>handleException</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开发前准备&quot;&gt;&lt;a href=&quot;#开发前准备&quot; class=&quot;headerlink&quot; title=&quot;开发前准备&quot;&gt;&lt;/a&gt;开发前准备&lt;/h2&gt;&lt;p&gt;使用Idea做为编译器，创建一个新的Spring Cloud项目。&lt;/p&gt;
&lt;p&gt;版本选择：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-配置文件</title>
    <link href="https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-13T01:50:41.000Z</published>
    <updated>2024-11-13T02:14:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>基于SpringBoot的Java学习笔记-配置文件</p><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-1-config.html">配置文件</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot的默认配置文件在：<code>src/main/resources/application.properties</code></p><p>关于Spring Boot应用的配置内容都可以集中在该文件中了，根据我们引入的不同Starter模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。比如，我们需要自定义web模块的服务端口号，可以在<code>application.properties</code>中添加<code>server.port=8888</code>来指定服务端口为8888，也可以通过<code>spring.application.name=hello</code>来指定应用名（该名字在Spring Cloud应用中会被注册为服务名）。</p><p>也可以使用yaml文件来配置。</p><p>如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">  <span class="attr">context-path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">shutdown:</span></span><br><span class="line">    <span class="attr">graceful:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8889</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><p>对应的application.properties文件：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="attr">server.context-path</span>=<span class="string">/hello</span></span><br><span class="line"><span class="attr">server.shutdown.graceful</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.port</span>=<span class="string">8889</span></span><br><span class="line"><span class="attr">server.shutdown.timeout</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">server.shutdown.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.path</span>=<span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>在配置文件中可以定义一些自定义参数，如</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">book.name</span>=<span class="string">Spring Boot 2.x</span></span><br></pre></td></tr></table></figure><p>在Java代码中可以通过<code>@Value</code>注解来获取配置文件中的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bookName;</span><br></pre></td></tr></table></figure><p>还可以使用随机数</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在启动应用时，可以通过命令行参数来覆盖配置文件中的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar myapp.jar --server.port=8888</span><br></pre></td></tr></table></figure><p><code>--</code>后面的参数会覆盖配置文件中的参数。</p><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>在Spring Boot中多环境配置文件名需要满足<code>application-&#123;profile&#125;.properties</code>的格式，其中<code>&#123;profile&#125;</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li><li><code>application.properties</code>：默认环境</li></ul><p>在<code>application.properties</code>中通过<code>spring.profiles.active</code>来指定当前环境，如：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h3><p>Spring Boot会按照如下顺序加载配置文件：</p><ul><li>命令行中传入的参数。</li><li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容。</li><li>java:comp&#x2F;env中的JNDI属性。</li><li>Java的系统属性，可以通过System.getProperties()获得的内容。</li><li>操作系统的环境变量</li><li>通过random.*配置的随机属性</li><li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之外的application.properties和YAML配置内容</li><li>位于当前应用jar包之内的application.properties和YAML配置内容</li><li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li></ul><h2 id="加密敏感信息"><a href="#加密敏感信息" class="headerlink" title="加密敏感信息"></a>加密敏感信息</h2><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-5-jasypt.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E5%AF%86">Spring Boot 2.x敏感信息加密</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于SpringBoot的Java学习笔记-配置文件&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.didispace.com/spring-boot-2/2-1-config.html&quot;&gt;配置文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-使用langchain-chatchat和ollama构建大模型</title>
    <link href="https://kelinkong.github.io/2024/11/07/AI-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/07/AI-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-07T11:14:13.000Z</published>
    <updated>2024-12-20T07:25:48.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>github地址：</strong></p><p>langchina-chatchat地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></p><p>ollama地址：<a href="https://github.com/ollama/ollama">ollama</a></p><h2 id="使用langchain-chatchat和ollama构建大模型"><a href="#使用langchain-chatchat和ollama构建大模型" class="headerlink" title="使用langchain-chatchat和ollama构建大模型"></a>使用langchain-chatchat和ollama构建大模型</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>langchain-chatchat</strong></p><p>langchain-chatchat在0.3版本之后支持使用pip安装，这里推荐创建一个新的虚拟环境来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create -n langchain python=3.10</span><br><span class="line">conda activate langchain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install langchain-chatchat -U</span><br></pre></td></tr></table></figure><p><strong>ollama</strong></p><p>ollama的安装比较简单，只需要使用pip安装即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ollama</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>langchain-chatchat</strong></p><p><strong>初始化</strong>，建议创建一个空的文件夹来进行初始化。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat init</span><br></pre></td></tr></table></figure><p>该命令会执行以下操作：</p><ul><li>创建所有需要的数据目录</li><li>复制 samples 知识库内容</li><li>生成默认 yaml 配置文件</li></ul><p><strong>修改配置文件</strong></p><p>具体每个配置文件的作用可以到github仓库查看，这里只列出需要修改的配置文件。</p><p>在文件<code>model_settings.yaml</code>中，修改:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">platform_name:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">platform_type:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">api_base_url:</span> <span class="string">http://127.0.0.1:11434/v1</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">EMPTY</span></span><br><span class="line">  <span class="attr">api_proxy:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">api_concurrencies:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">auto_detect_model:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">llm_models:</span> <span class="comment"># 本地部署的模型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwen2</span></span><br><span class="line">  <span class="attr">embed_models:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">quentinz/bge-large-zh-v1.5</span> <span class="comment"># 嵌入模型</span></span><br><span class="line">  <span class="attr">text2image_models:</span> []</span><br><span class="line">  <span class="attr">image2text_models:</span> []</span><br><span class="line">  <span class="attr">rerank_models:</span> []</span><br><span class="line">  <span class="attr">speech2text_models:</span> []</span><br><span class="line">  <span class="attr">text2speech_models:</span> []</span><br></pre></td></tr></table></figure><p>前面的默认模型可以不修改，开启自动检测后，会自动检测ollama中的模型。</p><p><strong>ollama</strong></p><p>加载大语言模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run qwen2</span><br></pre></td></tr></table></figure><p>如果本地没有部署，会自动下载模型。打开浏览器查看是否正确启动：<a href="http://localhost:11434/">http://localhost:11434</a></p><p>加载嵌入模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama pull quentinz/bge-large-zh-v1.5:latest</span><br></pre></td></tr></table></figure><p>嵌入模型不需要运行，只需要下载即可。</p><blockquote><p>嵌入模型（例如 quentinz&#x2F;bge-large-zh-v1.5）的主要作用是将文本转换成向量表示，这种向量表示也叫做“嵌入” (embedding)。这些嵌入可以捕捉到文本的语义信息，以便在不同的 NLP 任务中进行高效的相似度计算和语义搜索。</p><p>quentinz&#x2F;bge-large-zh-v1.5 可以用于生成中文文本的嵌入。例如，当输入一句中文文本时，该模型会输出一个向量（embedding），我们可以利用这个向量来完成以下操作</p></blockquote><h3 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h3><p>在生成知识库之前，要先确保ollama已经正确启动，使用默认的向量数据库，需要下载驱动，在pycharm中点击info.db，根据提示下载驱动即可。</p><p>使用<code>chatchat</code>命令生成知识库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat kb -r</span><br></pre></td></tr></table></figure><p>这里可能会遇到各种bug，自行到社区issue中查找解决方案。如果没有解决方案，可以给社区提issue。</p><p>出现以下提示表示生成成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">知识库名称      ：samples</span><br><span class="line">知识库类型      ：faiss</span><br><span class="line">向量模型：      ：bge-large-zh-v1.5</span><br><span class="line">知识库路径      ：/root/anaconda3/envs/chatchat/lib/python3.11/site-packages/chatchat/data/knowledge_base/samples</span><br><span class="line">文件总数量      ：47</span><br><span class="line">入库文件数      ：42</span><br><span class="line">知识条目数      ：740</span><br><span class="line">用时            ：0:02:29.701002</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">总计用时        ：0:02:33.414425</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat start -a</span><br></pre></td></tr></table></figure><p>运行成功之后，可以在网页上进行知识库配置、对话等。</p><p>其余功能有待摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;langchina-chatchat地址：&lt;a href=&quot;https:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AI-大模型有关的一些工具链</title>
    <link href="https://kelinkong.github.io/2024/11/07/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>https://kelinkong.github.io/2024/11/07/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-11-07T02:36:51.000Z</published>
    <updated>2024-12-20T07:30:12.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大模型的汇总仓库"><a href="#大模型的汇总仓库" class="headerlink" title="大模型的汇总仓库"></a>大模型的汇总仓库</h2><p><a href="https://github.com/ikaijua/Awesome-AITools/blob/main/README-CN.md">awesome AI</a></p><h2 id="使用大模型做具体场景助手"><a href="#使用大模型做具体场景助手" class="headerlink" title="使用大模型做具体场景助手"></a>使用大模型做具体场景助手</h2><p>使用开源工具来实现具体场景下的 AI 助手，流程可以简化如下：</p><ol><li><p>Prompt 工程</p><ul><li>流程：设计并优化 prompt，让大模型生成符合需求的答案，进行 prompt 测试和调整。</li><li>工具：可以使用 OpenAI API（如 GPT-3 开源替代品）结合 LangChain 或 LlamaIndex（前称 GPT Index）来管理和优化 prompt。</li></ul></li><li><p>构建知识库</p><ul><li>流程：收集和清洗数据，将信息分块后存入知识库，并生成索引以便高效检索。</li><li>工具：<ul><li>Elasticsearch 或 FAISS：用于分块后的数据存储和快速检索。</li><li>Haystack 或 LlamaIndex：可用于索引管理，便于与生成模型集成。</li></ul></li></ul></li><li><p>检索增强生成（RAG）</p><ul><li>流程：通过检索模块先找到相关信息片段，再输入生成模型生成回答，增强内容准确性。</li><li>工具：Haystack 或 LangChain，集成检索与生成，提供基于上下文的回答。</li></ul></li><li><p>大模型微调</p><ul><li>流程：将场景相关数据准备好后对大模型进行微调，使其适应具体领域或场景。</li><li>工具：<ul><li>Hugging Face Transformers：用于加载和微调模型。</li><li>Hugging Face Datasets：用于管理和预处理训练数据。</li></ul></li></ul></li><li><p>模型量化</p><ul><li>流程：在部署前对模型进行量化，以减小模型体积并加快推理速度。</li><li>工具：BitsAndBytes（4&#x2F;8 位量化）、ONNX Runtime（支持量化优化）。</li></ul></li><li><p>部署</p><ul><li>流程：将微调和量化后的模型部署在服务器或云端。</li><li>工具：<ul><li>FastAPI 或 Flask：用于搭建 API 服务。</li><li>Docker：用于容器化部署，保证环境一致性。</li><li>Hugging Face Inference（如使用推理服务器）或 ONNX Runtime（加速推理）。</li></ul></li></ul></li></ol><p>简化流程示例</p><p>设计 prompt → 构建知识库 → RAG 检索 → 大模型微调 → 模型量化 → 部署</p><p>这些步骤结合开源工具能够实现高效的 AI 助手。</p><h2 id="ollama"><a href="#ollama" class="headerlink" title="ollama"></a>ollama</h2><h3 id="ollama简介"><a href="#ollama简介" class="headerlink" title="ollama简介"></a>ollama简介</h3><p>ollama用来部署和运行大型语言模型，它提供了一个简单的命令行工具，可以用来运行模型、查看模型列表、下载模型等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计 prompt → 构建知识库 → RAG 检索 → Ollama 微调 → Ollama 量化 → Ollama 部署</span><br></pre></td></tr></table></figure><p>官网地址：<a href="https://ollama.com/">ollama</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行一个模型，如果本地不存在该模型，会自动到仓库下载，仓库地址：<br><a href="https://ollama.com/library">ollama模型仓库</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run llama3-8b-8192</span><br></pre></td></tr></table></figure><p>一些指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看模型列表</span></span><br><span class="line">ollama list</span><br><span class="line"><span class="comment"># 查看当前运行的模型</span></span><br><span class="line">ollama ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># -h 查看帮助</span></span><br><span class="line">serve       Start ollama</span><br><span class="line">create      Create a model from a Modelfile</span><br><span class="line">show        Show information <span class="keyword">for</span> a model</span><br><span class="line">run         Run a model</span><br><span class="line">stop        Stop a running model</span><br><span class="line">pull        Pull a model from a registry</span><br><span class="line">push        Push a model to a registry</span><br><span class="line">list        List models</span><br><span class="line">ps          List running models</span><br><span class="line"><span class="built_in">cp</span>          Copy a model</span><br><span class="line"><span class="built_in">rm</span>          Remove a model</span><br><span class="line"><span class="built_in">help</span>        Help about any <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>查看ollama是否正确启动：<a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a></p><h2 id="open-webui"><a href="#open-webui" class="headerlink" title="open-webui"></a>open-webui</h2><p>open-webui提供了一个简单的web界面，可以用来查看模型列表、运行模型等。</p><p>仓库地址：<a href="https://github.com/open-webui/open-webui">open-webui</a></p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install open-webui</span><br><span class="line">open-webui serve</span><br></pre></td></tr></table></figure><h2 id="modelscope"><a href="#modelscope" class="headerlink" title="modelscope"></a>modelscope</h2><p>官网地址：<a href="https://modelscope.ai/">modelscope</a></p><p>github地址：<a href="https://github.com/modelscope/modelscope/tree/master">modelscope</a></p><h3 id="modelscope简介"><a href="#modelscope简介" class="headerlink" title="modelscope简介"></a>modelscope简介</h3><p>modelscope是一个 “模型即服务”(MaaS) 平台，旨在汇集来自 AI 社区的最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。ModelScope 库使开发人员能够通过丰富的 API 设计执行推理、训练和评估，从而促进跨不同 AI 领域的最先进模型的统一体验。</p><p>ModelScope Library 为模型贡献者提供了必要的分层 API，以便将来自 CV、NLP、语音、多模态以及科学计算的模型集成到 ModelScope 生态系统中。所有这些不同模型的实现都以一种简单统一访问的方式进行封装，用户只需几行代码即可完成模型推理、微调和评估。同时，灵活的模块化设计使得在必要时也可以自定义模型训练推理过程中的不同组件。</p><h3 id="安装和使用-1"><a href="#安装和使用-1" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>在ModelScope Hub 中有很多可以训练的模型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n modelscope python=3.10</span><br><span class="line">conda activate modelscope</span><br></pre></td></tr></table></figure><p>模型下载需要先配置好Git LFS。</p><blockquote><p>git lfs 是一个 Git 的扩展，它用来存储大文件。它的设计目标是让 Git 能够更好地管理大文件，而不是让 Git 成为一个文件存储系统。Git LFS 通过将大文件存储在远程服务器上，而不是存储在 Git 仓库中，来解决 Git 仓库过大的问题。</p></blockquote><p>之后就可以下载用来训练的模型，和github上的代码一样，可以直接使用git clone。</p><p>训练好的模型（微调）在部署时，通常还需要量化，这样才能在较小的设备上运行。</p><h2 id="langchain和langchain-chatchat"><a href="#langchain和langchain-chatchat" class="headerlink" title="langchain和langchain-chatchat"></a>langchain和langchain-chatchat</h2><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>这里有一个简单的教程:<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">langchain</a>，可以用来构建一个简单的LLM（Large Language Model）应用。</p><p>核心就是构建链，链可以包含各种处理步骤，例如模型、解析器和提示。</p><h3 id="langchain-chatchat"><a href="#langchain-chatchat" class="headerlink" title="langchain-chatchat"></a>langchain-chatchat</h3><p>仓库地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-files">langchain-chatchat</a></p><p>一种利用 langchain 思想实现的基于本地知识库的问答应用，目标期望建立一套对中文场景与开源模型支持友好、可离线运行的知识库问答解决方案。</p><p><strong>原理：</strong><br><img src="/../imgs/image-65.png"><br><img src="/../imgs/image-66.png"></p><p>在这个项目中，并不涉及模型的微调。模型微调参考：<a href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/">llvm-微调大模型</a></p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>官网地址：<a href="https://www.dify.ai/">Dify</a></p><p>github地址：<a href="https://github.com/langgenius/dify">Dify</a></p><p>官方文档：<a href="https://docs.dify.ai/">Dify文档</a></p><p>Dify 是一款开源的大语言模型(LLM) 应用开发平台。它融合了后端即服务（Backend as Service）和 LLMOps 的理念，使开发者可以快速搭建生产级的生成式 AI 应用。即使你是非技术人员，也能参与到 AI 应用的定义和数据运营过程中。</p><p>由于 Dify 内置了构建 LLM 应用所需的关键技术栈，包括对数百个模型的支持、直观的 Prompt 编排界面、高质量的 RAG 引擎、稳健的 Agent 框架、灵活的流程编排，并同时提供了一套易用的界面和 API。这为开发者节省了许多重复造轮子的时间，使其可以专注在创新和业务需求上。</p><p>dify支持ollama，可以直接使用本地部署的模型。</p><h2 id="Groqcloud"><a href="#Groqcloud" class="headerlink" title="Groqcloud"></a>Groqcloud</h2><p>官网地址：<a href="https://console.groq.com/playground">Groqcloud</a></p><p>GroqCloud 是由 Groq 公司提供的云服务，专注于快速 AI 推理。它利用 Groq 的语言处理单元（LPU）硬件和相关软件，推理速度很快，而且API便宜。</p><h2 id="向量知识库"><a href="#向量知识库" class="headerlink" title="向量知识库"></a>向量知识库</h2><ul><li>第一类是开源的专用向量数据库，如 Chroma、Vespa、LanceDB、Marqo、Qdrant 和 Milvus，这些数据库专门设计用于处理向量数据。</li><li>第二类是支持向量搜索的开源数据库，如 OpenSearch、PostgreSQL、ClickHouse 和 Cassandra，它们是常规数据库，但支持向量搜索功能。</li><li>第三类是商用的专用向量数据库，如 Weaviate 和 Pinecone，它们专门用于处理向量数据，但属于商业产品或通过商业许可获得源码。</li><li>第四类是支持向量搜索的商用数据库，如 Elasticsearch、Redis、Rockset 和 SingleStore，这些常规数据库支持向量搜索功能，同时属于商业产品或可通过商业许可获得源码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大模型的汇总仓库&quot;&gt;&lt;a href=&quot;#大模型的汇总仓库&quot; class=&quot;headerlink&quot; title=&quot;大模型的汇总仓库&quot;&gt;&lt;/a&gt;大模型的汇总仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ikaijua/Awesome-AI</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-使用 LCEL 构建一个简单的 LLM 应用</title>
    <link href="https://kelinkong.github.io/2024/11/06/AI-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/11/06/AI-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/</id>
    <published>2024-11-06T01:43:04.000Z</published>
    <updated>2024-12-20T07:28:17.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h2><p>教程来源于：<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">LangChain</a></p><h2 id="使用-LCEL-构建一个简单的-LLM-应用"><a href="#使用-LCEL-构建一个简单的-LLM-应用" class="headerlink" title="使用 LCEL 构建一个简单的 LLM 应用"></a>使用 LCEL 构建一个简单的 LLM 应用</h2><p>langchain的简单使用。</p><h3 id="什么是LangChain？"><a href="#什么是LangChain？" class="headerlink" title="什么是LangChain？"></a>什么是LangChain？</h3><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>在本教程中，会创建一个简单的LLM（Large Language Model）应用。</p><p>主要分为：prompt、model、parser</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langserve <span class="keyword">import</span> add_routes</span><br><span class="line"><span class="keyword">from</span> langchain_groq <span class="keyword">import</span> ChatGroq</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_TRACING_V2&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line">os.environ[<span class="string">&quot;GROQ_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create prompt template</span></span><br><span class="line">system_template = <span class="string">&quot;Translate the following into &#123;language&#125;:&quot;</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    <span class="string">&quot;system&quot;</span>, system_template,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create model</span></span><br><span class="line">model = ChatGroq(model=<span class="string">&quot;llama3-8b-8192&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create output parser</span></span><br><span class="line">parser = StrOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create chain</span></span><br><span class="line">chain = prompt_template | model | parser</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create FastAPI app</span></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&quot;LangChain OpenAI API&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A FastAPI app that uses LangChain and OpenAI to translate text.&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add routes</span></span><br><span class="line">add_routes(</span><br><span class="line">    app,</span><br><span class="line">    chain,</span><br><span class="line">    path=<span class="string">&quot;/chain&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the LangChain OpenAI API&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run FastAPI app</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单教程&quot;&gt;&lt;a href=&quot;#简单教程&quot; class=&quot;headerlink&quot; title=&quot;简单教程&quot;&gt;&lt;/a&gt;简单教程&lt;/h2&gt;&lt;p&gt;教程来源于：&lt;a href=&quot;https://www.langchain.com.cn/docs/tutorials/llm</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-微调大模型</title>
    <link href="https://kelinkong.github.io/2024/11/01/AI-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/01/AI-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-01T06:35:34.000Z</published>
    <updated>2024-12-20T07:27:44.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h2><p>源代码来自:<a href="https://www.cnblogs.com/obullxl/p/18312594/NTopic2024071801">老牛同学</a></p><p>使用开源大模型 Qwen2-0.5B 的示例，实现了一个基于微调和 RAG（Retrieval-Augmented Generation）的文本分类助手。以下是各部分的详细解释：</p><h3 id="1-引入必要库"><a href="#1-引入必要库" class="headerlink" title="1. 引入必要库"></a>1. 引入必要库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> swanlab.integration.huggingface <span class="keyword">import</span> SwanLabCallback</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, TaskType, get_peft_model</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, TrainingArguments, Trainer, DataCollatorForSeq2Seq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> swanlab</span><br></pre></td></tr></table></figure><p>这部分代码引入了主要用于微调、训练和生成文本的库，包括 <code>transformers</code>、<code>peft</code>（主要用于 LoRA 微调）、<code>datasets</code>（用于处理数据集），以及 <code>swanlab</code> 用于回调和日志记录。</p><h3 id="2-设置路径和设备"><a href="#2-设置路径和设备" class="headerlink" title="2. 设置路径和设备"></a>2. 设置路径和设备</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_DIR = <span class="string">&#x27;D:\\ModelSpace\\Qwen2&#x27;</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><p>设置模型的根目录和设备名称。设备名称判断系统是否支持 CUDA（GPU 加速），如果不支持则使用 CPU。</p><p>在mac中使用mps加速</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-数据集格式转换函数"><a href="#3-数据集格式转换函数" class="headerlink" title="3. 数据集格式转换函数"></a>3. 数据集格式转换函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dataset_jsonl_transfer</span>(<span class="params">origin_path, new_path</span>):</span><br><span class="line">    messages = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            data = json.loads(line)</span><br><span class="line">            text = data[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">            catagory = data[<span class="string">&quot;category&quot;</span>]</span><br><span class="line">            output = data[<span class="string">&quot;output&quot;</span>]</span><br><span class="line">            message = &#123;</span><br><span class="line">                <span class="string">&quot;input&quot;</span>: <span class="string">f&quot;文本:<span class="subst">&#123;text&#125;</span>,分类选项列表:<span class="subst">&#123;catagory&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="string">&quot;output&quot;</span>: output,</span><br><span class="line">            &#125;</span><br><span class="line">            messages.append(message)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(new_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> messages:</span><br><span class="line">            file.write(json.dumps(message, ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>dataset_jsonl_transfer</code> 函数用于将原始 JSON 数据转换成微调所需的数据格式。原始文件的每行包含一个 JSON 对象，函数将其读取、重构并保存成新的 JSONL 格式文件，每行包含一个示例数据。</p><h3 id="4-数据预处理函数"><a href="#4-数据预处理函数" class="headerlink" title="4. 数据预处理函数"></a>4. 数据预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_func</span>(<span class="params">example</span>):</span><br><span class="line">    MAX_LENGTH = <span class="number">384</span></span><br><span class="line">    instruction = tokenizer(<span class="string">f&quot;&lt;|im_start|&gt;system\n你是一个文本分类领域的专家...<span class="subst">&#123;example[<span class="string">&#x27;input&#x27;</span>]&#125;</span>&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    response = tokenizer(<span class="string">f&quot;<span class="subst">&#123;example[<span class="string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    input_ids = instruction[<span class="string">&quot;input_ids&quot;</span>] + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    attention_mask = instruction[<span class="string">&quot;attention_mask&quot;</span>] + response[<span class="string">&quot;attention_mask&quot;</span>] + [<span class="number">1</span>]</span><br><span class="line">    labels = [-<span class="number">100</span>] * <span class="built_in">len</span>(instruction[<span class="string">&quot;input_ids&quot;</span>]) + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_ids) &gt; MAX_LENGTH:</span><br><span class="line">        input_ids, attention_mask, labels = input_ids[:MAX_LENGTH], attention_mask[:MAX_LENGTH], labels[:MAX_LENGTH]</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;input_ids&quot;</span>: input_ids, <span class="string">&quot;attention_mask&quot;</span>: attention_mask, <span class="string">&quot;labels&quot;</span>: labels&#125;</span><br></pre></td></tr></table></figure><p><code>process_func</code> 函数将数据处理成大模型可以接受的格式，包含 <code>input_ids</code>、<code>attention_mask</code> 和 <code>labels</code>。这里模拟了一个对话输入，用户提问，助手返回分类输出。如果序列长度超出最大限制 <code>MAX_LENGTH</code>，进行截断。</p><h3 id="5-加载模型和分词器"><a href="#5-加载模型和分词器" class="headerlink" title="5. 加载模型和分词器"></a>5. 加载模型和分词器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_dir = os.path.join(BASE_DIR, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_dir, use_fast=<span class="literal">False</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_dir, device_map=device, torch_dtype=torch.bfloat16)</span><br><span class="line">model.enable_input_require_grads()</span><br></pre></td></tr></table></figure><p>加载模型和分词器，将 <code>bfloat16</code> 用于精度，以减少 GPU 占用量。<code>model.enable_input_require_grads()</code> 开启梯度检查点支持，以节省内存。</p><h3 id="6-加载和处理数据集"><a href="#6-加载和处理数据集" class="headerlink" title="6. 加载和处理数据集"></a>6. 加载和处理数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;train.jsonl&#x27;</span>)</span><br><span class="line">test_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;test.jsonl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(train_dataset_path, train_jsonl_new_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(test_dataset_path, test_jsonl_new_path)</span><br><span class="line"></span><br><span class="line">train_df = pd.read_json(train_jsonl_new_path, lines=<span class="literal">True</span>)</span><br><span class="line">train_ds = Dataset.from_pandas(train_df)</span><br><span class="line">train_dataset = train_ds.<span class="built_in">map</span>(process_func, remove_columns=train_ds.column_names)</span><br></pre></td></tr></table></figure><p>检查并转换数据集，将其加载为 <code>Dataset</code> 格式，并通过 <code>process_func</code> 处理成可用于训练的数据格式。</p><h3 id="7-LoRA-配置与应用"><a href="#7-LoRA-配置与应用" class="headerlink" title="7. LoRA 配置与应用"></a>7. LoRA 配置与应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = LoraConfig(</span><br><span class="line">    task_type=TaskType.CAUSAL_LM,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, ...],</span><br><span class="line">    inference_mode=<span class="literal">False</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    lora_alpha=<span class="number">32</span>,</span><br><span class="line">    lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = get_peft_model(model, config)</span><br></pre></td></tr></table></figure><p>设置并应用 LoRA（Low-Rank Adaptation）配置，用于高效微调。<code>LoRA</code> 能通过添加低秩矩阵在不改变原模型参数的情况下更新模型，适合大模型的微调。</p><h3 id="8-训练参数与-Trainer-初始化"><a href="#8-训练参数与-Trainer-初始化" class="headerlink" title="8. 训练参数与 Trainer 初始化"></a>8. 训练参数与 Trainer 初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = TrainingArguments(</span><br><span class="line">    output_dir=os.path.join(BASE_DIR, <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>),</span><br><span class="line">    per_device_train_batch_size=<span class="number">4</span>,</span><br><span class="line">    gradient_accumulation_steps=<span class="number">4</span>,</span><br><span class="line">    logging_steps=<span class="number">10</span>,</span><br><span class="line">    num_train_epochs=<span class="number">2</span>,</span><br><span class="line">    save_steps=<span class="number">100</span>,</span><br><span class="line">    learning_rate=<span class="number">1e-4</span>,</span><br><span class="line">    save_on_each_node=<span class="literal">True</span>,</span><br><span class="line">    gradient_checkpointing=<span class="literal">True</span>,</span><br><span class="line">    report_to=<span class="string">&quot;none&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">swanlab_callback = SwanLabCallback(project=<span class="string">&quot;Qwen2-FineTuning&quot;</span>, experiment_name=<span class="string">&quot;Qwen2-0.5B&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainer = Trainer(</span><br><span class="line">    model=model,</span><br><span class="line">    args=args,</span><br><span class="line">    train_dataset=train_dataset,</span><br><span class="line">    data_collator=DataCollatorForSeq2Seq(tokenizer=tokenizer, padding=<span class="literal">True</span>),</span><br><span class="line">    callbacks=[swanlab_callback],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置训练参数并创建 <code>Trainer</code> 实例，指定保存路径、batch 大小、梯度累积步数、日志记录频率、学习率等。<code>SwanLabCallback</code> 用于将训练过程发送至 <code>SwanLab</code> 进行实时监控。</p><h3 id="9-训练模型"><a href="#9-训练模型" class="headerlink" title="9. 训练模型"></a>9. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainer.train()</span><br></pre></td></tr></table></figure><p>调用 <code>.train()</code> 开始训练。</p><h3 id="10-模型推理与评估"><a href="#10-模型推理与评估" class="headerlink" title="10. 模型推理与评估"></a>10. 模型推理与评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">messages, model, tokenizer</span>):</span><br><span class="line">    text = tokenizer.apply_chat_template(messages, tokenize=<span class="literal">False</span>, add_generation_prompt=<span class="literal">True</span>)</span><br><span class="line">    model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(device)</span><br><span class="line">    generated_ids = model.generate(model_inputs.input_ids, max_new_tokens=<span class="number">512</span>)</span><br><span class="line">    generated_ids = [output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)]</span><br><span class="line">    <span class="keyword">return</span> tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>predict</code> 函数实现了模型推理功能，将输入转成模型格式后生成输出文本。</p><h3 id="11-测试集上的推理"><a href="#11-测试集上的推理" class="headerlink" title="11. 测试集上的推理"></a>11. 测试集上的推理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_json(test_jsonl_new_path, lines=<span class="literal">True</span>)[:<span class="number">10</span>]</span><br><span class="line">test_text_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> test_df.iterrows():</span><br><span class="line">    instruction = row[<span class="string">&#x27;你是一个文本分类领域的专家，你会接收到一段文本和几个潜在的分类选项列表，请输出文本内容的正确分类&#x27;</span>]</span><br><span class="line">    input_value = row[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;instruction&#125;</span>&quot;</span>&#125;, &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;input_value&#125;</span>&quot;</span>&#125;]</span><br><span class="line">    response = predict(messages, model, tokenizer)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;response&#125;</span>&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    result_text = <span class="string">f&quot;<span class="subst">&#123;messages[<span class="number">0</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">1</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">    test_text_list.append(swanlab.Text(result_text, caption=response))</span><br><span class="line"></span><br><span class="line">swanlab.log(&#123;<span class="string">&quot;Prediction&quot;</span>: test_text_list&#125;)</span><br><span class="line">swanlab.finish()</span><br></pre></td></tr></table></figure><p>在测试集上对模型进行评估，将预测结果和输入对比，并将输出文本记录到 <code>SwanLab</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微调大模型&quot;&gt;&lt;a href=&quot;#微调大模型&quot; class=&quot;headerlink&quot; title=&quot;微调大模型&quot;&gt;&lt;/a&gt;微调大模型&lt;/h2&gt;&lt;p&gt;源代码来自:&lt;a href=&quot;https://www.cnblogs.com/obullxl/p/18312594/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AI-机器学习基础</title>
    <link href="https://kelinkong.github.io/2024/10/29/AI-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://kelinkong.github.io/2024/10/29/AI-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-29T10:55:08.000Z</published>
    <updated>2024-12-20T07:29:06.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>什么是一个线性回归问题？</strong></p><p>如果把线性回归模型看作一个函数，用最简单的话说，这个函数的作用就是预测。</p><p>线性回归模型的预测过程是这样的：给定一个输入特征向量，通过线性组合得到一个预测值。</p><p>举个例子：</p><p>假设有数据集：这里我们想知道工资、年龄和贷款额度之间的关系。</p><table><thead><tr><th>工资</th><th>年龄</th><th>贷款额度</th></tr></thead><tbody><tr><td>1000</td><td>25</td><td>1000</td></tr><tr><td>2000</td><td>30</td><td>2000</td></tr><tr><td>3000</td><td>35</td><td>3000</td></tr></tbody></table><p>我们可以用线性回归模型来预测工资，假设我们的模型是这样的：<br>$y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2$</p><p>其中，$y$ 是贷款额度，$x_1$ 是工资，$x_2$ 是年龄。</p><p>我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。</p><p>这个函数就是一个线性函数，也就是线性回归模型。</p><p>$$<br>y &#x3D; w_0 + w_1 \cdot x_1 + w_2 \cdot x_2<br>  &#x3D; \sum_{i&#x3D;0}^{n} w_i \cdot x_i<br>$$</p><p>这里$w_0$是偏置项，用来调整模型的预测值。$x_0$是一个常数项，通常为1。</p><h3 id="误差值"><a href="#误差值" class="headerlink" title="误差值"></a>误差值</h3><p>误差值是指预测值与真实值之间的差距。</p><p><img src="/../imgs/image-62.png"></p><ul><li>误差与误差之间是独立的，不会相互影响。</li><li>误差的分布是正态分布，均值为0。</li></ul><p>预测与误差：</p><p>$$<br>y^i &#x3D; W^T \cdot x^i + \epsilon^i<br>$$</p><p>其中，$y^i$ 是预测值，$W^T$ 是权重向量，$x^i$ 是输入特征向量，$\epsilon^i$ 是误差。</p><p>误差服从正态分布：</p><p>$$<br>p(\epsilon^i) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(\epsilon^i)^2}{2\sigma^2})<br>$$</p><p>将误差代入预测值：</p><p>$$<br>p(y^i|x^i;W) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>$x^i;W$组合之后的概率密度函数，就是我们的模型。我们希望$x^i;W$组合之后与$y^i$越接近越好。所以希望最大化这个概率密度函数。</p><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>似然函数为什么要使用连乘？因为前面说过，误差是独立的，所以我们可以将每个样本的概率密度函数连乘起来。</p><p>$$<br>L(W) &#x3D; \prod_{i&#x3D;1}^{m} p(y^i|x^i;W)&#x3D; \prod_{i&#x3D;1}^{m} \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>对似然函数取对数，可以将连乘转换为连加：</p><p>$$<br>\log L(W) &#x3D; \sum_{i&#x3D;1}^{m} \log p(y^i|x^i;W)&#x3D; \sum_{i&#x3D;1}^{m} \log \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>展开化简：</p><p>$$<br>\log L(W) &#x3D; \frac{m}{2} \log(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><p>我们最终的目标是最大化似然函数，也就是最小化误差。前一项是常数，所以希望后一项越小越好。即：</p><p>$$<br>\min_W \frac{1}{2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><strong>什么是损失函数？</strong></p><p>损失函数也叫目标函数，是用来衡量模型预测值与真实值之间的差距的函数。</p><p>上面那个例子，我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。损失函数可以定义为：</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (y_i - \hat{y_i})^2<br>$$</p><p>使用目标值和预测值之间的平方误差作为损失函数，这个损失函数叫做均方误差（Mean Squared Error，MSE）。</p><p>其中，$m$ 是样本数量，$y_i$ 是真实值，$\hat{y_i}$ 是预测值。</p><p>对于机器学习的大部分任务，我们都是通过最小化损失函数来优化模型的参数。</p><p>如何求解损失函数？</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (W^T \cdot x^i - \hat{y_i})^2 &#x3D; \frac{1}{2m} (X \cdot W - Y)^T \cdot (X \cdot W - Y)<br>$$</p><p>其中，$X$ 是输入特征矩阵，$Y$ 是真实值矩阵。</p><p>我们的目标是找到一个合适的 $W$，使得损失函数最小化。</p><p>因此，对损失函数求导，然后令导数为0，可以得到最优解。</p><p>$$<br>\frac{\partial L(W)}{\partial W} &#x3D; \frac{1}{m} X^T \cdot (X \cdot W - Y) &#x3D; 0<br>$$</p><p>解方程，得到最优解：<br>$$<br>W &#x3D; (X^T \cdot X)^{-1} \cdot X^T \cdot Y<br>$$</p><p>但是，这个方法有一个问题，就是计算量太大。当数据量很大时，计算矩阵的逆是非常耗时的。而且，矩阵的逆不一定存在。</p><p>因此，我们通常使用梯度下降法来求解损失函数的最小值。</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p><strong>什么是梯度下降法？</strong></p><p>梯度下降法是一种常用的优化算法，用来求解损失函数的最小值。</p><p>梯度下降法的思想是：沿着梯度的反方向，不断迭代更新参数，直到损失函数的值收敛。</p><p><strong>目标函数</strong></p><p>$$<br>J(\theta_0, \theta_1) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i)^2<br>$$</p><p>其中，$h_\theta(x^i) &#x3D; \theta_0 + \theta_1 \cdot x^i$ 是模型的预测值。</p><p><strong>如何寻找合适的方向？</strong></p><p>梯度下降法的核心是求解目标函数的梯度。</p><p>分别对 $\theta_0$ 和 $\theta_1$ 求偏导数：</p><p>$$<br>\frac{\partial J(\theta_0, \theta_1)}{\partial \theta_1} &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_1<br>$$</p><p>使得梯度为0，得到最优解。因为切线方向是函数值下降最快的方向，此时梯度为0。梯度其实就是函数的导数。</p><p>注意，这里等式中的两个$\theta_j$表示两个不同的$\theta_j$，一个是当前的$\theta_j$，一个是更新后的$\theta_j$。</p><p>$$<br>\theta_j &#x3D;  \theta_j - \alpha  \frac{\partial J(\theta_j)}{\partial \theta_j}&#x3D;<br> \theta_j - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_j<br>$$</p><p>其中，$\alpha$ 是学习率，用来控制参数更新的步长，$x^i_j$表示第$i$个样本的第$j$个特征。</p><p>如果将所有的参数更新写成矩阵形式，可以得到：</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} X^T \cdot (X \cdot \theta - Y)<br>$$</p><p>这就是梯度下降法中的批量梯度下降（Batch Gradient Descent）。但是，批量梯度下降的计算量很大，因为每次迭代都要计算所有样本的梯度。</p><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降（Stochastic Gradient Descent，SGD）是梯度下降法的一种变种，它每次迭代只使用一个样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$x^i$ 是第$i$个样本的特征向量，$y^i$ 是第$i$个样本的真实值。</p><p>随机梯度下降的优点是计算速度快，但缺点是收敛速度慢，因为每次迭代的方向不一定是最优的。</p><h3 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h3><p>小批量梯度下降（Mini-batch Gradient Descent）是批量梯度下降和随机梯度下降的折中方案，每次迭代使用一小部分样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$m$ 是小批量的大小。batch size的选择对模型的训练速度有很大影响。当batch size较小时，模型的训练速度较慢；当batch size较大时，模型的训练速度较快。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>给一个代码实现：</p><p>对应上面的公式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, learning_rate=<span class="number">0.01</span>, num_iterations=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用梯度下降法训练线性回归模型</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cost_history = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">        self.theta = self.predict_step(learning_rate)</span><br><span class="line">        cost_history.append(self.compute_cost())</span><br><span class="line">        logger.info(<span class="string">&quot;第&#123;&#125;次迭代，损失值为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(_, cost_history[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回训练后的参数和损失值</span></span><br><span class="line">    <span class="keyword">return</span> self.theta, cost_history</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict_step</span>(<span class="params">self, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    每一步迭代计算梯度并更新参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 计算预测值</span></span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    <span class="comment"># 计算误差</span></span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    <span class="comment"># 计算梯度并更新参数</span></span><br><span class="line">    theta = self.theta - learning_rate * (<span class="number">1</span> / num_examples) * np.dot(self.data.T, error)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hypothesis</span>(<span class="params">data, theta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算预测值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(data, theta)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算损失, 这里使用均方误差</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    cost = (<span class="number">1</span> / (<span class="number">2</span> * num_examples)) * np.dot(error.T, error)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是一个线性回归问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把线性回归模型看作一个函数，用最简单的话说，这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：Spring MVC</title>
    <link href="https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/"/>
    <id>https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/</id>
    <published>2024-10-23T00:41:51.000Z</published>
    <updated>2024-10-23T03:40:23.783Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot第九章，Spring MVC。</p><h2 id="Spring-MVC-示意图"><a href="#Spring-MVC-示意图" class="headerlink" title="Spring MVC 示意图"></a>Spring MVC 示意图</h2><p><img src="/../imgs/image-60.png"></p><p><img src="/../imgs/image-61.png"></p><p>如果 Web 工程使用了 Spring MVC ， 那么它在启动阶段就会将注解<br><code>@RequestMapping</code> 所配置的内容保存到处理器映射（ <code>HandlerMapping</code> ）机制中去，然后等待请求的到来 ，通过拦截请求信息与<code>HandlerMapping</code>进行匹配，找到对应的处理器（它包含控制器的逻辑），并将处理器及其拦截器保存到 <code>HandlerExecution Chain</code> 对象中，返回给 <code>DispatcherServlet</code> ，这样<code>DispatcherServlet</code> 就可以运行它们了。</p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code> 是 Spring MVC 的核心组件，负责将客户端的请求分发给相应的处理器（Controller），并协调请求处理过程。它的主要职责是接收 HTTP 请求，委托给合适的处理组件，并将结果返回给客户端。<code>DispatcherServlet</code> 是前后端分离架构和传统 MVC 架构中的重要部分。</p><h3 id="DispatcherServlet-的工作原理"><a href="#DispatcherServlet-的工作原理" class="headerlink" title="DispatcherServlet 的工作原理"></a><code>DispatcherServlet</code> 的工作原理</h3><ol><li><p><strong>客户端请求到达 DispatcherServlet</strong>：</p><ul><li>当用户通过浏览器发送 HTTP 请求时，请求首先到达 <code>DispatcherServlet</code>。<code>DispatcherServlet</code> 是一个前端控制器（Front Controller），负责接收所有的请求。</li></ul></li><li><p><strong>HandlerMapping 映射请求</strong>：</p><ul><li><code>DispatcherServlet</code> 接收到请求后，开始通过 <strong>HandlerMapping</strong> 查找对应的处理器（Controller）。它根据请求的 URL 路径去匹配合适的处理器，这一步决定了应该调用哪个控制器来处理这个请求。</li></ul></li><li><p><strong>调用 HandlerAdapter</strong>：</p><ul><li>找到处理器后，<code>DispatcherServlet</code> 会通过 <strong>HandlerAdapter</strong> 调用实际的控制器方法。<code>HandlerAdapter</code> 的职责是适配处理器方法，使得它们能够被调用。不同类型的控制器方法（如注解方式的、简单映射方式的）可能需要不同的适配器。</li></ul></li><li><p><strong>Controller 处理请求</strong>：</p><ul><li>处理器（Controller）接收请求并处理业务逻辑，可能需要调用服务层、数据库等操作，最终返回一个 <code>ModelAndView</code> 对象或直接返回数据（如 JSON）。</li></ul></li><li><p>**视图解析器 (ViewResolver)**：</p><ul><li>如果处理器返回的是一个视图名，<code>DispatcherServlet</code> 会通过 <strong>ViewResolver</strong> 解析视图的名称，将其转换为具体的视图对象（如 JSP、Thymeleaf 等）。视图解析器负责确定返回页面的位置。</li></ul></li><li><p><strong>返回响应给客户端</strong>：</p><ul><li>最终，<code>DispatcherServlet</code> 将处理的结果（视图页面或数据）响应给客户端。如果返回的是视图，<code>DispatcherServlet</code> 将把数据填充到视图中，并将生成的 HTML 返回给客户端；如果是 JSON 数据，则直接响应 JSON。</li></ul></li></ol><h3 id="DispatcherServlet-的处理流程图"><a href="#DispatcherServlet-的处理流程图" class="headerlink" title="DispatcherServlet 的处理流程图"></a><code>DispatcherServlet</code> 的处理流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client Request --&gt; DispatcherServlet --&gt; HandlerMapping --&gt; Handler (Controller)</span><br><span class="line">                  --&gt; HandlerAdapter --&gt; ModelAndView --&gt; ViewResolver --&gt; Response (HTML/JSON)</span><br></pre></td></tr></table></figure><h3 id="详细的步骤"><a href="#详细的步骤" class="headerlink" title="详细的步骤"></a>详细的步骤</h3><ol><li><p><strong>初始化 DispatcherServlet</strong>：</p><ul><li>当 Spring 容器启动时，<code>DispatcherServlet</code> 作为前端控制器被初始化，它会加载配置文件，并初始化一些关键的组件，比如 <code>HandlerMapping</code> 和 <code>HandlerAdapter</code>。</li></ul></li><li><p><strong>处理请求</strong>：</p><ul><li>用户发出 HTTP 请求时，<code>DispatcherServlet</code> 会接管请求的控制权。</li></ul></li><li><p><strong>查找处理器</strong>：</p><ul><li><code>DispatcherServlet</code> 根据 <code>HandlerMapping</code> 的配置，确定哪个控制器将会处理这个请求。</li></ul></li><li><p><strong>调用控制器</strong>：</p><ul><li><code>DispatcherServlet</code> 通过 <code>HandlerAdapter</code> 来调用处理器的具体方法，处理业务逻辑。</li></ul></li><li><p><strong>返回视图或数据</strong>：</p><ul><li>控制器执行完业务逻辑后，返回视图名或数据，<code>DispatcherServlet</code> 会通过 <code>ViewResolver</code> 来解析视图，或直接返回 JSON 数据。</li></ul></li><li><p><strong>生成响应</strong>：</p><ul><li>最后，<code>DispatcherServlet</code> 将视图或数据返回给客户端。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库获取用户数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userDetail&quot;</span>;  <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DispatcherServlet</code> 会：</p><ol><li>接收到对 <code>/users/&#123;id&#125;</code> 的请求。</li><li>通过 <code>HandlerMapping</code> 映射到 <code>UserController</code> 的 <code>getUserById</code> 方法。</li><li>返回视图名 <code>userDetail</code>，然后通过 <code>ViewResolver</code> 找到实际的视图并渲染。</li></ol><h2 id="在前后端分离的项目中，Spring-MVC-是如何工作的"><a href="#在前后端分离的项目中，Spring-MVC-是如何工作的" class="headerlink" title="在前后端分离的项目中，Spring MVC 是如何工作的"></a>在前后端分离的项目中，Spring MVC 是如何工作的</h2><p>在前后端分离的项目中，Spring MVC 主要用作 <strong>后端 API</strong> 服务，专注于处理业务逻辑、数据库交互，并通过 RESTful API 接口向前端提供数据。前端和后端通过 HTTP 请求（如 <code>GET</code>、<code>POST</code> 等）进行通信，前端不再依赖于服务器渲染 HTML 页面，而是通过调用 API 获取 JSON 数据。</p><h3 id="Spring-MVC-在前后端分离中的工作流程"><a href="#Spring-MVC-在前后端分离中的工作流程" class="headerlink" title="Spring MVC 在前后端分离中的工作流程"></a>Spring MVC 在前后端分离中的工作流程</h3><ol><li><strong>前端发送请求</strong>：用户在前端应用（如基于 React、Vue、Angular 的应用）中进行操作，前端应用通过 HTTP 向后端发送请求。</li><li><strong>后端控制器接收请求</strong>：Spring MVC 的控制器接收前端请求，并调用业务逻辑或数据库，处理请求。</li><li><strong>返回 JSON 数据</strong>：后端处理完请求后，返回 JSON 格式的数据响应给前端。</li><li><strong>前端显示数据</strong>：前端应用根据后端返回的数据更新页面内容。</li></ol><h3 id="使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例"><a href="#使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例" class="headerlink" title="使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例"></a>使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例</h3><h4 id="1-Maven-依赖"><a href="#1-Maven-依赖" class="headerlink" title="1. Maven 依赖"></a>1. <strong>Maven 依赖</strong></h4><p>首先，确保 <code>pom.xml</code> 中包含以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Web Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot DevTools --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JSON 处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-控制器类"><a href="#2-控制器类" class="headerlink" title="2. 控制器类"></a>2. <strong>控制器类</strong></h4><p>在前后端分离的项目中，控制器负责接收前端的 API 请求，处理业务逻辑，并返回 JSON 响应。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设从数据库获取用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟创建用户的逻辑，通常会调用服务层</span></span><br><span class="line">        user.setId(<span class="number">1</span>);  <span class="comment">// 模拟数据库生成的用户ID</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟更新用户信息</span></span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟删除用户的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3. 模型类"></a>3. <strong>模型类</strong></h4><p>模型类用于定义实体，例如 <code>User</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-跨域配置（CORS）"><a href="#4-跨域配置（CORS）" class="headerlink" title="4. 跨域配置（CORS）"></a>4. <strong>跨域配置（CORS）</strong></h4><p>前后端分离时，通常前端和后端不在同一个域名下，因此需要处理跨域请求。我们可以通过配置 <code>CorsConfiguration</code> 来允许跨域请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)  <span class="comment">// 允许前端地址</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-前端调用示例"><a href="#5-前端调用示例" class="headerlink" title="5. 前端调用示例"></a>5. <strong>前端调用示例</strong></h4><p>假设前端使用了 Vue.js，前端可以通过 <code>axios</code> 调用 Spring MVC 提供的 RESTful API。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Info<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;&#123; user.id &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fetchUser&quot;</span>&gt;</span>Fetch User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">user</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">fetchUser</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8080/api/users/1&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">user</span> = response.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;There was an error!&quot;</span>, error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-启动后端服务"><a href="#6-启动后端服务" class="headerlink" title="6. 启动后端服务"></a>6. <strong>启动后端服务</strong></h4><p>在 Spring Boot 中，后端项目运行后将会监听 <code>http://localhost:8080</code>，可以通过调用后端的 API 接口获取用户信息，如 <code>http://localhost:8080/api/users/1</code>。</p><h4 id="7-前端调用后端接口"><a href="#7-前端调用后端接口" class="headerlink" title="7. 前端调用后端接口"></a>7. <strong>前端调用后端接口</strong></h4><p>前端（例如 <code>localhost:3000</code>）向后端发起 <code>GET</code> 请求，Spring MVC 接收到请求并调用相应的控制器方法，返回 JSON 数据，前端根据这些数据进行页面更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot第九章，Spring MVC。&lt;/p&gt;
&lt;h2 id=&quot;Spring-MVC-示意图&quot;&gt;&lt;a href=&quot;#Spring-MVC-示意图&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 示意图&quot;&gt;&lt;/a&gt;Spring</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：事务处理</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2024-10-22T07:09:09.000Z</published>
    <updated>2024-12-17T12:19:36.159Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>@Transactional</code>注解，Spring就会知道在哪里启动事务。其约定流程如图：<br><img src="/../imgs/image-58.png"></p><p>@Transactional注解的一些配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = true,                          // 是否只读</span></span><br><span class="line"><span class="meta">        timeout = 30,                             // 超时时间</span></span><br><span class="line"><span class="meta">        isolation = Isolation.READ_COMMITTED,      // 隔离级别</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED,        // 传播行为</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;SQLException.class&#125;,        // 指定回滚异常</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;IllegalStateException.class&#125;  // 指定不回滚异常</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先引入事务的隔离级别：</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务的隔离级别（Transaction Isolation Level）用于定义并发事务之间的相互影响，避免因并发执行而引发数据不一致的问题。数据库中的隔离级别定义了一个事务在执行时可以看到其他事务的修改情况，常见的隔离级别有以下四种，按隔离强度从低到高排列：</p><h3 id="1-READ-UNCOMMITTED（读未提交）"><a href="#1-READ-UNCOMMITTED（读未提交）" class="headerlink" title="1. READ UNCOMMITTED（读未提交）"></a>1. <strong>READ UNCOMMITTED（读未提交）</strong></h3><ul><li><strong>描述</strong>：在此隔离级别下，事务可以读取到其他事务尚未提交的数据（脏数据）。</li><li><strong>问题</strong>：<ul><li><strong>脏读</strong>（Dirty Read）：一个事务可以读到其他事务尚未提交的数据。如果这个事务回滚了，那么读到的数据就是无效的。</li><li><strong>不可重复读</strong>（Non-repeatable Read）：同一事务在不同时间读取相同数据时，可能得到不同结果。</li><li><strong>幻读</strong>（Phantom Read）：一个事务多次查询时可能会发现新的数据插入。</li></ul></li><li><strong>适用场景</strong>：对数据一致性要求极低的场景（很少使用）。</li></ul><h3 id="2-READ-COMMITTED（读已提交）"><a href="#2-READ-COMMITTED（读已提交）" class="headerlink" title="2. READ COMMITTED（读已提交）"></a>2. <strong>READ COMMITTED（读已提交）</strong></h3><ul><li><strong>描述</strong>：一个事务只能读取到其他事务已经提交的数据，避免脏读。</li><li><strong>问题</strong>：<ul><li><strong>不可重复读</strong>：同一事务在不同时间读取相同数据时，可能得到不同的结果。如果另一个事务在两次读取之间修改了数据，就会出现这种现象。</li><li><strong>幻读</strong>：如果一个事务在读取时，另一个事务插入了新的行，第一次查询时看不到这些行，下一次查询时就看到了。</li></ul></li><li><strong>适用场景</strong>：多数数据库（如 SQL Server 和 Oracle）默认的隔离级别，适用于读一致性要求不高但需要避免脏读的场景。</li></ul><h3 id="3-REPEATABLE-READ（可重复读）"><a href="#3-REPEATABLE-READ（可重复读）" class="headerlink" title="3. REPEATABLE READ（可重复读）"></a>3. <strong>REPEATABLE READ（可重复读）</strong></h3><ul><li><strong>描述</strong>：在整个事务期间，无论其他事务是否提交，当前事务的所有读操作都能保证是相同的数据。避免了脏读和不可重复读的问题。</li><li><strong>问题</strong>：<ul><li><strong>幻读</strong>：在同一事务中，如果另一个事务插入了新行，这些行可能会在事务的后续查询中出现。</li></ul></li><li><strong>适用场景</strong>：MySQL 默认的隔离级别，适合需要确保数据在一个事务中多次读取一致性的场景。</li></ul><h3 id="4-SERIALIZABLE（可串行化）"><a href="#4-SERIALIZABLE（可串行化）" class="headerlink" title="4. SERIALIZABLE（可串行化）"></a>4. <strong>SERIALIZABLE（可串行化）</strong></h3><ul><li><strong>描述</strong>：最高的隔离级别，强制事务串行化执行，即一个事务必须等其他事务完成后才能执行，避免了所有并发问题，包括脏读、不可重复读和幻读。</li><li><strong>问题</strong>：<ul><li>并发性能最差，多个事务几乎不能并发执行，适合数据一致性要求极高但并发量较低的场景。</li></ul></li><li><strong>适用场景</strong>：极端情况下使用，适合金融交易等需要绝对数据一致性的场景。</li></ul><h3 id="事务隔离级别总结："><a href="#事务隔离级别总结：" class="headerlink" title="事务隔离级别总结："></a>事务隔离级别总结：</h3><ul><li><strong>脏读（Dirty Read）</strong>：读取到了其他未提交事务修改的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：同一事务中，前后两次读取相同数据得到不同的结果，通常是由于其他事务更新了数据。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，如果其他事务插入了新行，这些行在事务后续查询中可能会出现。</li></ul><h3 id="四种隔离级别对问题的防护表："><a href="#四种隔离级别对问题的防护表：" class="headerlink" title="四种隔离级别对问题的防护表："></a>四种隔离级别对问题的防护表：</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>否</td><td>是</td><td>是</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>否</td><td>否</td><td>是</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>注意</strong>：隔离级别越高，事务之间的并发性越差，但数据一致性更强。选择合适的隔离级别需要权衡并发性能和数据一致性。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>假设有批量任务在处理时，如果其中一个任务出现异常，是否需要回滚整个批量任务？这就需要用到事务的传播行为。<br>通常我们只希望回滚出现异常的错误任务，而不是回滚整个批量任务。<br><img src="/../imgs/image-59.png"></p><p>事务的传播行为（Transaction Propagation Behavior）决定了当一个事务方法调用另一个事务方法时，如何处理新旧事务之间的关系。Spring 提供了多种事务传播机制，允许开发人员根据业务需求选择适当的事务行为。主要的传播行为有以下几种：</p><h3 id="1-REQUIRED"><a href="#1-REQUIRED" class="headerlink" title="1. REQUIRED"></a>1. <strong>REQUIRED</strong></h3><ul><li><p><strong>描述</strong>：如果当前已经存在事务，则加入到这个事务中。如果当前没有事务，则新建一个事务。</p></li><li><p><strong>场景</strong>：默认的传播行为，适合大部分业务场景。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 调用methodA，将在同一个事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodB()</code>调用<code>methodA()</code>时，它们共享同一个事务。如果事务成功，则一起提交；如果抛出异常，则一起回滚。</p><h3 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <strong>REQUIRES_NEW</strong></h3><ul><li><p><strong>描述</strong>：总是新建一个事务。如果当前有事务，先挂起当前事务，等新事务执行完再恢复。</p></li><li><p><strong>场景</strong>：适用于需要在事务中执行独立的操作，无论外部事务的状态如何，该事务都要独立提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将开启新事务，不依赖methodB的事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>将启动一个新的事务，与<code>methodB()</code>的事务独立。如果<code>methodB()</code>回滚，<code>methodA()</code>的事务依然可以成功提交。</p><h3 id="3-SUPPORTS"><a href="#3-SUPPORTS" class="headerlink" title="3. SUPPORTS"></a>3. <strong>SUPPORTS</strong></h3><ul><li><p><strong>描述</strong>：支持当前事务。如果当前有事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p></li><li><p><strong>场景</strong>：适用于需要根据调用者上下文决定是否在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>被<code>methodB()</code>调用时，存在事务，它将加入事务；否则，它将以非事务方式执行。</p><h3 id="4-NOT-SUPPORTED"><a href="#4-NOT-SUPPORTED" class="headerlink" title="4. NOT_SUPPORTED"></a>4. <strong>NOT_SUPPORTED</strong></h3><ul><li><p><strong>描述</strong>：总是以非事务方式执行。如果当前有事务，则将其挂起。</p></li><li><p><strong>场景</strong>：适用于某些操作不需要事务，甚至不能在事务中执行。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将以非事务方式执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>会以非事务方式执行，且不受<code>methodB()</code>事务的影响。</p><h3 id="5-MANDATORY"><a href="#5-MANDATORY" class="headerlink" title="5. MANDATORY"></a>5. <strong>MANDATORY</strong></h3><ul><li><p><strong>描述</strong>：强制要求当前存在事务。如果没有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于必须在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 必须在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>只能在已有事务的上下文中执行。如果直接调用<code>methodA()</code>时没有事务，会抛出异常。</p><h3 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. <strong>NEVER</strong></h3><ul><li><p><strong>描述</strong>：强制不允许存在事务。如果有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于不允许事务存在的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 将抛出异常，因为methodB有事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>在事务中执行，则会抛出异常。</p><h3 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. <strong>NESTED</strong></h3><ul><li><p><strong>描述</strong>：如果当前有事务，则在当前事务中嵌套一个子事务；如果当前没有事务，则新建一个事务。嵌套事务可以单独回滚，而不影响外部事务。</p></li><li><p><strong>场景</strong>：适用于希望在主事务中有嵌套事务，子事务可以单独提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将作为methodB的嵌套事务执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>作为<code>methodB()</code>的嵌套事务执行，可以独立回滚，但如果<code>methodB()</code>回滚，<code>methodA()</code>也会回滚。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>当前有事务则加入，没有则创建新事务（默认）。</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>总是新建一个事务，挂起当前事务。</td></tr><tr><td><strong>SUPPORTS</strong></td><td>当前有事务则加入，没有事务则以非事务方式执行。</td></tr><tr><td><strong>NOT_SUPPORTED</strong></td><td>总是以非事务方式执行，挂起当前事务。</td></tr><tr><td><strong>MANDATORY</strong></td><td>当前有事务则加入，没有则抛出异常。</td></tr><tr><td><strong>NEVER</strong></td><td>总是以非事务方式执行，当前有事务则抛出异常。</td></tr><tr><td><strong>NESTED</strong></td><td>嵌套事务，允许回滚子事务但不影响父事务。</td></tr></tbody></table><h3 id="示例项目中使用-Transactional："><a href="#示例项目中使用-Transactional：" class="headerlink" title="示例项目中使用 @Transactional："></a>示例项目中使用 <code>@Transactional</code>：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建订单的逻辑</span></span><br><span class="line">        paymentService.processPayment(); <span class="comment">// 调用另一个事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 处理支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>createOrder()</code>使用<code>REQUIRED</code>传播行为，而<code>processPayment()</code>使用<code>REQUIRES_NEW</code>，即<code>processPayment()</code>将运行在一个独立的事务中。</p><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？"><a href="#在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？" class="headerlink" title="在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？"></a>在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？</h3><p>在 Spring Boot 中，<code>@Transactional</code> 注解用于管理事务边界，而 <code>@Transactional(readOnly = true)</code> 和 <code>@Transactional</code> 之间的主要区别在于<strong>事务的读写属性</strong>，从而影响数据库的操作方式和性能优化。具体来说：</p><p><code>@Transactional(readOnly = true)</code>：</p><ul><li><strong>只读事务</strong>：指定该事务仅用于查询操作，即不会涉及对数据库的更新、插入或删除操作。</li><li><strong>性能优化</strong>：Spring 在只读事务中可能对底层数据库连接进行优化，例如关闭脏数据检测等，提高查询性能。</li><li><strong>数据库支持</strong>：某些数据库可以通过只读事务进行额外的性能优化，但要确保该事务中不包含写操作（更新、插入、删除），否则会抛出异常。</li><li><strong>应用场景</strong>：适用于不需要更改数据的服务层方法，比如获取用户列表、查看订单信息等操作。</li></ul><p><code>@Transactional</code> (默认 <code>readOnly = false</code>)：</p><ul><li><strong>读写事务</strong>：支持所有数据库操作，包括查询、插入、更新、删除。</li><li><strong>数据一致性</strong>：该事务在执行过程中会进行数据一致性检查，确保数据库在事务中所有操作要么全部成功，要么在出现异常时全部回滚。</li><li><strong>性能考虑</strong>：因为存在数据修改操作，事务提交时会涉及更多一致性检查和资源锁定，性能开销通常高于只读事务。</li><li><strong>应用场景</strong>：适用于需要更改数据的操作，比如更新用户信息、添加新订单等。</li></ul><p><strong>在 Spring 中，@Transactional(readOnly &#x3D; true) 默认不会改变事务的隔离级别。它只指定了当前事务是“只读”的，主要目的是在执行查询操作时，利用数据库的优化机制提升性能。</strong></p><p>在mysql中事务的隔离级别默认是<code>REPEATABLE READ</code>，事务的默认传播行为是<code>REQUIRED</code>。</p><h3 id="异步接口是否会导致事务超时？"><a href="#异步接口是否会导致事务超时？" class="headerlink" title="异步接口是否会导致事务超时？"></a>异步接口是否会导致事务超时？</h3><p>异步执行时，事务上下文不会自动传播。</p><p>当使用 @Async 注解使方法异步执行时，Spring 会在单独的线程中运行该方法，默认不会继承主线程的事务上下文。这意味着：</p><p>如果主线程中有一个事务（例如通过 @Transactional 注解启动的事务），异步方法中的代码不会运行在同一个事务中。<br>异步方法的执行时长不会受到主线程事务超时配置的影响。</p><p>Spring 的 <code>@Transactiona</code>l 和 <code>@Async</code> 注解存在在同一方法上时，Spring 会分别处理：</p><ul><li><p><code>@Async</code>：会将该方法异步执行，交给线程池管理，事务不再在原来的主线程中执行。</p></li><li><p><code>@Transactional</code>：事务是在当前线程中生效的（Spring 的事务管理器会绑定到线程本地变量中，即 ThreadLocal）。<br>当方法被标记为 @Async，它会在一个新线程中执行，导致：</p><ul><li><p>新线程无法感知到主线程的事务上下文。</p></li><li><p>事务的传播和管理在新线程中不生效，或者新线程可能会开启新的事务。</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;@Transactional&lt;/code&gt;注解，Spring就会知道在哪里启动事务。其约定流程如图：&lt;br&gt;&lt;img src=&quot;/../imgs/image-58.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;@Transactional注解的一些配置：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-MyBatis</title>
    <link href="https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/"/>
    <id>https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/</id>
    <published>2024-10-22T06:46:45.000Z</published>
    <updated>2024-10-22T08:48:39.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDBC代码和参数的手动设置以及结果集的检索。</p><ol><li><p>首先添加依赖(pom.xml)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据库连接(application.yml)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/demo?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.example.entity</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建XML映射文件(<code>resources/mapper/UserMapper.xml</code>)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这个示例展示了MyBatis在Spring Boot中的基本使用，包括：</p><ol><li>Maven依赖配置</li><li>数据库连接配置</li><li>实体类定义</li><li>Mapper接口定义</li><li>XML映射文件</li><li>Service层实现</li><li>Controller层实现</li></ol><p>使用这个示例，可以：</p><ul><li>通过 GET &#x2F;users&#x2F;{id} 查询用户</li><li>通过 POST &#x2F;users 创建新用户</li></ul><p>在使用前需要确保：</p><ol><li>创建对应的数据库和表</li><li>修改数据库连接配置</li><li>启动类添加 <code>@MapperScan(&quot;com.example.mapper&quot;)</code> 注解</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的示例&quot;&gt;&lt;a href=&quot;#一个简单的示例&quot; class=&quot;headerlink&quot; title=&quot;一个简单的示例&quot;&gt;&lt;/a&gt;一个简单的示例&lt;/h2&gt;&lt;p&gt;MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDB</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：全注解下的IoC</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/</id>
    <published>2024-10-22T01:39:29.000Z</published>
    <updated>2024-10-22T08:48:39.127Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。</p><p>Spring 中把每一个<br>需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器） 。 IoC 容器需要具备两个基本的功能：</p><ul><li>通过描述管理 Bean，包括发布和获取 Bean;</li><li>通过描述完成 Bean 之间的依赖关系</li></ul><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>要求所有的 IoC 容器都需要实现接口 BeanFactory，其中定义了获取 Bean 的基本方法。</p><p>BeanFactory源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; required</span></span><br><span class="line"><span class="params">    Type)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    Boolean <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 默认情况下，Spring IoC 容器是单例的，每次返回都是同一个对象</span></span><br><span class="line">    Boolean <span class="title function_">isSingleton</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 原型模式，每次返回都是一个新的对象</span></span><br><span class="line">    Boolean <span class="title function_">isPrototype</span><span class="params">(String name)</span>;</span><br><span class="line">    Boolean <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BeanFactory中，有多个<code>getBean</code>方法，其中最常用的是：</p><ul><li><code>getBean(String name)</code>：根据 Bean 的名称获取 Bean 对象</li><li><code>getBean(Class&lt;T&gt; requiredType)</code>：根据 Bean 的类型获取 Bean 对象</li></ul><p>Spring 提供了一个更高级的 IoC 容器接口 ApplicationContext，它是 BeanFactory 的子接口，提供了更多的功能。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="/../imgs/image-53.png"></p><p>ApplicationContext 接口通过实现多个接口，提供了更多的功能，如国际化、事件传播、资源加载等。</p><p> Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中。</p><h3 id="使用AnnotationConfigApplicationContext"><a href="#使用AnnotationConfigApplicationContext" class="headerlink" title="使用AnnotationConfigApplicationContext"></a>使用AnnotationConfigApplicationContext</h3><p>AnnotationConfigApplicationContext 是一个 IoC 容器，它可以通过注解来装配 Bean 到 Spring IoC 容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建了一个基于注解的Spring IoC容器AnnotationConfigApplicationContext，并将AppConfig类作为配置类传递给它。</span></span><br><span class="line"><span class="comment">         * AppConfig.class是一个包含Spring配置的类，使用了<span class="doctag">@Configurable</span>注解，表明这是一个配置类。</span></span><br><span class="line"><span class="comment">         * 通过这种方式，Spring会扫描AppConfig类中的<span class="doctag">@Bean</span>注解，并将这些方法返回的对象注册为Spring容器中的Bean。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Spring容器中获取一个类型为User的Bean对象。</span></span><br><span class="line"><span class="comment">         * ctx.getBean(User.class)方法会根据类型查找并返回一个User类型的Bean实例。</span></span><br><span class="line"><span class="comment">         * 这个User实例是由AppConfig类中的initUser方法创建并注册到Spring容器中的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(User.class);</span><br><span class="line">        log.info(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"><a href="#在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别" class="headerlink" title="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"></a>在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别</h2><p>在 Spring 中，<code>@Bean</code> 注解通常用于定义和注册 Bean 到 IoC 容器中，而它可以出现在不同的地方。主要有两种常见的方式：</p><ol><li><strong>在配置类中使用 <code>@Bean</code> 注解</strong>（如在你的 <code>AppConfig</code> 类中）  </li><li><strong>在实体类（如 <code>User</code> 类）上使用 <code>@Component</code> 或其他派生注解</strong>，例如 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等。</li></ol><p>这两种方式的不同点主要体现在 <strong>Bean 定义和管理的灵活性、配置的集中化以及依赖管理的差异</strong>：</p><h3 id="1-在配置类中使用-Bean-注解"><a href="#1-在配置类中使用-Bean-注解" class="headerlink" title="1. 在配置类中使用 @Bean 注解"></a>1. <strong>在配置类中使用 <code>@Bean</code> 注解</strong></h3><p>使用 <code>@Bean</code> 注解在一个配置类中（如 <code>AppConfig</code>）定义 Bean 具有以下特点：</p><ul><li><p><strong>集中配置</strong>：你可以在一个地方（配置类）集中管理所有的 Bean 定义。这可以使得配置代码更加清晰和集中，尤其是在需要配置复杂依赖的场景中。</p></li><li><p><strong>灵活性</strong>：配置类中的 <code>@Bean</code> 方法可以让你灵活地定义 Bean，比如在 Bean 创建时通过方法参数注入依赖，或根据某些条件决定返回的对象。这种方式更加灵活，可以使用逻辑控制返回哪个 Bean 实例。</p></li><li><p><strong>可定制性</strong>：通过 <code>@Bean</code>，你可以完全控制对象的创建过程，甚至可以在创建时执行一些逻辑，或者根据应用的某些条件配置不同的 Bean 实例。</p></li><li><p><strong>多实例管理</strong>：你可以在配置类中通过不同的方法名或 <code>@Bean</code> 注解的 <code>name</code> 属性来为同一个类型注册多个不同的 Bean。</p></li><li><p><strong>明确的生命周期控制</strong>：在配置类中，你还可以使用 <code>@PostConstruct</code>, <code>@PreDestroy</code> 等注解来明确控制 Bean 的生命周期。</p></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">initUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;kelin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setGender((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在-User-类中使用-Component-或其他注解"><a href="#2-在-User-类中使用-Component-或其他注解" class="headerlink" title="2. 在 User 类中使用 @Component 或其他注解"></a>2. <strong>在 <code>User</code> 类中使用 <code>@Component</code> 或其他注解</strong></h3><p>如果你直接在实体类（如 <code>User</code> 类）上使用 <code>@Component</code>（或 <code>@Service</code>, <code>@Controller</code> 等注解），Spring 会自动扫描并将这个类注册为 Bean。特点如下：</p><ul><li><p><strong>自动扫描与装配</strong>：<code>@Component</code> 是一个基于类的注解，意味着只要这个类被 Spring 的组件扫描路径扫描到，它就会自动注册为 Bean。你不需要手动在配置类中定义它。</p></li><li><p><strong>简单且自动化</strong>：适合简单的类，只需要标记类为组件即可，通常用于那些不需要复杂配置或初始化逻辑的 Bean。</p></li><li><p><strong>依赖注入</strong>：当使用 <code>@Component</code> 时，通常配合 <code>@Autowired</code> 注解实现自动依赖注入。虽然 <code>@Bean</code> 也可以做到类似的依赖注入，但是 <code>@Component</code> 配合自动扫描更适合规模较大的项目。</p></li><li><p><strong>更少控制权</strong>：与 <code>@Bean</code> 相比，<code>@Component</code> 提供的控制力更少。例如，你无法在定义 Bean 时动态决定返回什么实例，因为 <code>@Component</code> 只是简单地注册类到 IoC 容器中。</p></li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h3><table><thead><tr><th>特点</th><th><code>@Bean</code> 在配置类中使用</th><th><code>@Component</code> 在类中使用</th></tr></thead><tbody><tr><td><strong>注册方式</strong></td><td>手动在配置类中定义并注册 Bean</td><td>自动通过类扫描注册为 Bean</td></tr><tr><td><strong>灵活性</strong></td><td>高，方法中可以有逻辑控制 Bean 的创建</td><td>低，只能通过注解标记类为 Bean</td></tr><tr><td><strong>依赖注入</strong></td><td>可以通过方法参数手动注入依赖</td><td>使用 <code>@Autowired</code> 自动注入依赖</td></tr><tr><td><strong>配置复杂度</strong></td><td>适合复杂或条件性 Bean 定义</td><td>适合简单 Bean 自动化管理</td></tr><tr><td><strong>Bean 名称控制</strong></td><td>可以通过 <code>@Bean(name = &quot;xxx&quot;)</code> 自定义</td><td>默认 Bean 名称为类名，首字母小写</td></tr><tr><td><strong>生命周期控制</strong></td><td>可以通过 <code>@PostConstruct</code>, <code>@PreDestroy</code></td><td>需要配合额外注解管理生命周期</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>@Bean</code> 适用于更复杂、需要灵活控制的 Bean 配置</strong>。例如，需要根据某些条件创建 Bean 或者配置依赖的场景。</li><li><strong><code>@Component</code> 更适合那些不需要复杂配置、依赖自动装配的类</strong>。它的作用类似于自动注册类作为 Spring 管理的组件，适合小型组件或服务类。</li></ul><p>两者都可以实现依赖注入，但适用场景不同，使用时需要根据具体需求选择。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p><code>@ComponentScan</code> 注解是 Spring 提供的一个用于自动扫描和注册 Bean 的注解。它可以指定一个包路径，Spring 会自动扫描这个包路径下的所有类，并将标记了 <code>@Component</code> 及其派生注解的类注册为 Bean。</p><p><code>@ComponentScan</code> 注解通常与 <code>@Configuration</code> 注解一起使用，用于配置 Spring IoC 容器的自动扫描路径。</p><p>可以排除特定的 Bean 类型，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3&quot; &#125; ,</span></span><br><span class="line"><span class="meta">excludeFilters = &#123;@Filter(classes = Service.class) )</span>)</span><br></pre></td></tr></table></figure><p>以上大致是将Bean注入到Spring IoC容器中的方法。</p><h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 根据属性的类型找到对应的Bean进行注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p><code>@Autowired</code>的注入机制最基本的一条是通过类型进行注入。在IoC容器的顶级接口<code>Factory</code>中，有一个<code>getBean</code>方法，这个方法是通过类型来获取<code>Bean</code>的。</p><p>但是在Spring中，有时候我们会有多个实现类，这时候就需要通过<code>@Qualifier</code>注解来指定具体的实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;v8Engine&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被注入的Bean带有参数的构造函数，如何把参数传入呢？<br>使用@Value注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Value 注解注入参数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Engine</span><span class="params">(<span class="meta">@Value(&quot;$&#123;engine.type&#125;&quot;)</span> String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动注入 Engine Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving with engine type: &quot;</span> + engine.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><img src="/../imgs/image-54.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;kelin.com.springnotes.chapter3&quot;, lazyInit = true)</span></span><br></pre></td></tr></table></figure><p>使用lazyInit &#x3D; true，可以延迟初始化Bean，即在第一次使用Bean时才初始化。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../imgs/image-55.png"></p><h2 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h2><p><code>@Profile</code>注解可以根据不同的环境来选择不同的Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for DEV environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for PROD environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。&lt;/p&gt;
&lt;p&gt;Spring 中把每一个&lt;br&gt;需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 S</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-人工神经网络</title>
    <link href="https://kelinkong.github.io/2024/10/18/AI-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://kelinkong.github.io/2024/10/18/AI-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2024-10-18T00:47:24.000Z</published>
    <updated>2024-12-20T07:28:56.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.ruanyifeng.com/blog/2017/07/neural-network.html">入门教程参考</a></p><p>最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？</p><p>我们现在假设要训练的模型是一个函数，首先考虑，这个函数的作用是什么？这个函数的输入是什么？输出是什么？</p><p>人工神经网络可以用来做分类、预测、生成等任务，现在假设我们的函数是一个分类函数，那么输入就是一个数据，输出就是这个数据属于哪个类别。</p><p>所以，训练神经网络，就是训练这个函数，让这个函数能够准确地对数据进行分类。</p><p>所谓训练，有点太拟人化了，听起来比较抽象，其实就是调整函数的参数，使得函数的输出尽可能接近真实值。</p><p>参数又是什么？这里先介绍一下神经网络的基本结构。</p><h2 id="人工神经网络的基本结构"><a href="#人工神经网络的基本结构" class="headerlink" title="人工神经网络的基本结构"></a>人工神经网络的基本结构</h2><p>人工神经网络是一种模拟人脑神经元网络的计算模型，它由多个神经元（Neuron）组成，每个神经元接收多个输入，经过加权和激活函数处理后，输出一个值。</p><h3 id="神经元（Neuron）"><a href="#神经元（Neuron）" class="headerlink" title="神经元（Neuron）"></a>神经元（Neuron）</h3><p><img src="/../imgs/image-51.png" alt="图来源于维基百科"></p><p>一个神经元的结构可以分为三个主要部分：<strong>输入</strong>、<strong>处理单元</strong>、<strong>输出</strong>。如果用前文的函数来描述，每一个神经元就是一个函数，这个函数的输入就是一个特征向量和一个权重向量，这个向量经过某种计算后，输出一个值（一个神经元的输出通常是一个标量）。</p><p>经过了什么处理呢？</p><p>对于单个神经元，其数学表达可以写为：<br>   $$<br>   y &#x3D; \text{activation}(w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b)<br>   $$</p><p>具体来看：</p><h4 id="1-输入层（Input-Layer）："><a href="#1-输入层（Input-Layer）：" class="headerlink" title="1. 输入层（Input Layer）："></a>1. <strong>输入层（Input Layer）</strong>：</h4><ul><li>神经元的输入来自前一层的神经元，或者在网络的第一层，输入是来自外部的数据。</li><li>输入信号（即特征）通过权重(Weights)传递到神经元。每个输入信号都有一个权重值，权重表示输入的重要性。</li></ul><p>   <strong>示例</strong>：<br>   如果我们有三个输入特征 $( a_1, a_2, a_3 )$，每个输入都有一个对应的权重 $( w_1, w_2, w_3 )$。<br>   $$<br>   z &#x3D; w_1 \cdot a_1 + w_2 \cdot a_2 + w_3 \cdot a_3 + b<br>   $$<br>   其中，$b$ 是偏置项。</p><h4 id="2-加权求和（Weighted-Sum）："><a href="#2-加权求和（Weighted-Sum）：" class="headerlink" title="2. 加权求和（Weighted Sum）："></a>2. <strong>加权求和（Weighted Sum）</strong>：</h4><ul><li>输入通过权重后，神经元会将这些加权输入进行加和，再加上一个偏置（Bias）项。</li><li>偏置用于调整激活函数的输出，让神经元的输出更加灵活，帮助网络更好地拟合数据。</li></ul><p>   <strong>数学表示</strong>：<br>   $$<br>   z &#x3D; \sum (w_i \cdot x_i) + b<br>   $$</p><p>   其中，$z$ 是加权求和的结果，$w_i$ 是权重，$x_i$ 是输入，$b$是偏置。</p><h4 id="3-激活函数（Activation-Function）："><a href="#3-激活函数（Activation-Function）：" class="headerlink" title="3. 激活函数（Activation Function）："></a>3. <strong>激活函数（Activation Function）</strong>：</h4><ul><li>加权求和后的结果$z$ 会通过一个<strong>激活函数</strong>，以增加神经元的非线性能力。</li><li>激活函数的目的是引入非线性，以便神经网络能够学习复杂的模式。常见的激活函数有 Sigmoid、ReLU、Tanh 等。</li></ul><h4 id="4-输出（Output）："><a href="#4-输出（Output）：" class="headerlink" title="4. 输出（Output）："></a>4. <strong>输出（Output）</strong>：</h4><ul><li>经过激活函数处理后的输出 $t$ 是神经元的最终结果，这个结果可以作为下一层神经元的输入，或者作为最终输出（例如分类结果或回归值）。</li><li>在输出层，输出值可以是一个分类标签（如Softmax输出的类别）或一个回归值（如预测的数值）。</li></ul><p>我们现在已经知道单个神经元（函数）做了什么工作，那么，为什么要经过加权求和、偏置又是什么、为什么要有激活函数？</p><h3 id="加权求和和偏置"><a href="#加权求和和偏置" class="headerlink" title="加权求和和偏置"></a>加权求和和偏置</h3><h4 id="1-加权求和："><a href="#1-加权求和：" class="headerlink" title="1. 加权求和："></a>1. <strong>加权求和</strong>：</h4><ul><li>加权求和是为了给不同的输入信号赋予不同的重要性。</li><li>通过调整权重，神经元可以学习到不同特征的重要性，从而更好地拟合数据。</li></ul><p>比如说，判断一个人是男人还是女人，我们可以用身高、体重、声音等特征。但是，不同的特征对性别的判断重要性是不同的，比如身高可能比声音更重要，所以我们需要通过权重来调整这些特征的重要性。</p><h4 id="2-偏置："><a href="#2-偏置：" class="headerlink" title="2. 偏置："></a>2. <strong>偏置</strong>：</h4><p>偏置的作用是让神经网络的输出有更多的灵活性，即使输入的值为零，偏置也能确保神经元的激活函数能产生非零的输出。这有助于模型更好地拟合数据。</p><p>为什么要有偏置：如果没有偏置，神经网络的输出完全依赖于输入数据。如果输入为零，输出会总是零，这样模型的表达能力受到限制。通过加入偏置，神经网络可以更好地学习复杂的模式和关系。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>目的：激活函数的主要作用是引入非线性，从而让神经网络能够处理复杂的非线性问题。</p><p>没有激活函数，神经网络只会进行线性变换，加权求和的输出只是输入的线性组合。线性模型的能力有限，无法拟合复杂的非线性数据。因此，激活函数通过对加权和进行非线性处理，使网络可以处理高度复杂的任务，如图像识别、自然语言处理等。</p><h4 id="1-ReLU（Rectified-Linear-Unit）："><a href="#1-ReLU（Rectified-Linear-Unit）：" class="headerlink" title="1. ReLU（Rectified Linear Unit）："></a>1. <strong>ReLU（Rectified Linear Unit）</strong>：</h4><p>   ReLU 是最简单的激活函数之一。它的数学表达式为：<br>   $$<br>   \text{ReLU}(z) &#x3D; \max(0, z)<br>   $$</p><ul><li>当 $z &gt; 0$，输出 $z$。</li><li>当 $z \leq 0$，输出 0。</li></ul><h4 id="2-Sigmoid："><a href="#2-Sigmoid：" class="headerlink" title="2. Sigmoid："></a>2. <strong>Sigmoid</strong>：</h4><p>   Sigmoid 是一种常用的激活函数，尤其适用于二分类任务。它的数学表达式为：<br>   $$<br>   \sigma(z) &#x3D; \frac{1}{1 + e^{-z}}<br>   $$</p><ul><li>该函数将输入 $z$ 映射到区间 (0, 1) 之间。</li><li>当 $z \to \infty$，Sigmoid 函数的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 0。</li></ul><h4 id="3-Tanh（Hyperbolic-Tangent）："><a href="#3-Tanh（Hyperbolic-Tangent）：" class="headerlink" title="3. Tanh（Hyperbolic Tangent）："></a>3. <strong>Tanh（Hyperbolic Tangent）</strong>：</h4><p>   Tanh 是另一个常用的激活函数，它将输入映射到 -1 到 1 之间。其数学表达式为：<br>   $$<br>   \tanh(z) &#x3D; \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>   $$</p><ul><li>该函数将 $z$ 映射到区间 (-1, 1)。</li><li>当 $z \to \infty$，Tanh 的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 -1。</li></ul><h4 id="这三个激活函数的行为："><a href="#这三个激活函数的行为：" class="headerlink" title="这三个激活函数的行为："></a>这三个激活函数的行为：</h4><ul><li><strong>ReLU</strong>：输出非负的值，有助于解决梯度消失问题，但可能会导致“死亡ReLU”问题（即神经元在某些区域永远输出0）。</li><li><strong>Sigmoid</strong>：适用于二分类，但在极值区域梯度容易消失。</li><li><strong>Tanh</strong>：输出范围为 (-1, 1)，通常比 Sigmoid 更有效，但仍可能存在梯度消失问题。</li></ul><p>偏置让模型产生非零输出，激活函数引入非线性，这两个因素使得神经网络能够学习复杂的模式和关系。那什么是线性模型，什么是非线性模型呢？</p><h3 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h3><p>我们先从“线性模型”的概念开始，然后再解释为什么它的能力有限，以及它为什么不能拟合复杂的非线性数据。</p><h4 id="1-线性模型是什么？"><a href="#1-线性模型是什么？" class="headerlink" title="1. 线性模型是什么？"></a>1. <strong>线性模型是什么？</strong></h4><ul><li>线性模型是一种简单的数学模型，它通过输入变量（特征）的线性组合来进行预测。</li><li>公式形式为：<br>$$<br>y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b<br>$$<br>其中：<ul><li>$y$ 是模型的输出（预测结果），</li><li>$x_1, x_2, …, x_n$ 是输入特征，</li><li>$w_1, w_2, …, w_n$ 是每个特征的权重，</li><li>$b$ 是偏置项。</li></ul></li></ul><p>   这个公式表明输出 $y$ 是输入特征的<strong>加权求和</strong>。这种模型在数据的所有关系都是线性时，表现得很好。</p><h4 id="2-线性模型的局限性"><a href="#2-线性模型的局限性" class="headerlink" title="2. 线性模型的局限性"></a>2. <strong>线性模型的局限性</strong></h4><ul><li>线性模型可以很好地处理简单的任务，比如预测身高和体重的关系，如果这两个变量之间的关系是线性的。</li><li><strong>线性关系</strong>意味着，输入特征的变化会导致输出以固定比例变化（即没有复杂的交互或非线性效应）。</li></ul><p>   例如，如果我们在二维平面上绘制一条直线，直线可以通过简单的线性方程来表示，适用于处理两个变量之间的简单比例关系。但在现实世界中，很多问题不是这样简单的线性关系。</p><h4 id="3-什么是非线性数据？"><a href="#3-什么是非线性数据？" class="headerlink" title="3. 什么是非线性数据？"></a>3. <strong>什么是非线性数据？</strong></h4><ul><li>非线性数据是指输入与输出之间的关系无法用简单的直线表示。它可能是弯曲的、复杂的、有多个转折点，或者数据之间存在高度的交互。</li><li>比如，如果想预测一个人的年收入，可能会涉及教育背景、工作经验、职位、技能等多个复杂因素，它们之间的关系是高度复杂的，这样的数据就是<strong>非线性的</strong>。</li></ul><p>   例如，如果我们用简单的线性模型来处理这个问题，它只能画出一条直线，但现实中这些因素的关系是复杂而非线性的，可能是一个波动的曲线。线性模型无法正确表达这种复杂的关系。</p><h4 id="4-为什么线性模型不能拟合复杂的非线性数据？"><a href="#4-为什么线性模型不能拟合复杂的非线性数据？" class="headerlink" title="4. 为什么线性模型不能拟合复杂的非线性数据？"></a>4. <strong>为什么线性模型不能拟合复杂的非线性数据？</strong></h4><ul><li>线性模型的核心在于它只会根据输入特征进行简单的加权和。因此，它无法捕捉到变量之间复杂的交互关系或弯曲的趋势。</li><li>举个简单的例子，假设要预测物体在抛出后的运动轨迹。物体的轨迹是抛物线（非线性），如果你用线性模型去拟合这个轨迹，结果只能是一条直线，完全无法准确描述抛物线的运动。</li><li>现实中的大多数数据，比如图像、语音、自然语言等，往往存在复杂的非线性关系，输入特征之间的交互也很复杂，线性模型无法有效捕捉这些关系。</li></ul><h4 id="5-如何解决这个问题？"><a href="#5-如何解决这个问题？" class="headerlink" title="5. 如何解决这个问题？"></a>5. <strong>如何解决这个问题？</strong></h4><ul><li>为了解决这个问题，我们需要引入<strong>非线性模型</strong>。神经网络就是一种非常强大的非线性模型，它通过<strong>激活函数</strong>（如 ReLU、Sigmoid）引入非线性，使得神经网络能够处理和拟合复杂的非线性数据。</li><li>每一层神经元通过权重和偏置计算出加权和，并通过激活函数引入非线性，逐层递进地学习输入数据的复杂模式，从而对复杂任务做出准确预测。</li></ul><p>用大白话说就是线性模型是拟合为直线的，非线性模型可以拟合为曲线的。</p><p><img src="/../imgs/image-52.png"></p><p><strong>那么，为什么加入激活函数后，神经网络就能处理非线性数据了呢？</strong></p><blockquote><p>当我们给神经网络加入激活函数后，它就能够处理复杂的非线性数据，原因很简单：</p><p>打破线性限制：如果没有激活函数，神经网络每一层的计算都是线性的（像画直线一样），无论堆叠多少层，最终的输出也只是线性组合，无法处理弯曲、复杂的模式。</p><p>激活函数引入变化：激活函数就像给网络“加了个弯”，不再只产生直线关系。比如 ReLU 会把负数变成 0，而正数保持不变，这种变化让网络能处理更复杂的情况，不再是简单的线性相加。<br>层层递进：每一层加上激活函数后，输出的结果会经过更多复杂的非线性处理。最终，网络能学会从数据中找到隐藏的复杂关系，甚至是一些人类看不到的特征。<br>简单来说，激活函数让网络能够画“曲线”，而不是只能画“直线”，这就是它能处理非线性数据的原因。</p></blockquote><p>假设我们有一个简单的两层神经网络：</p><ol><li><strong>第一层</strong>：进行线性变换 $(z_1 &#x3D; W_1 x + b_1)$</li><li><strong>激活函数</strong>：将 $(z_1)$ 传递给激活函数 $(a(z_1))$，得到新的输出 $(a_1 &#x3D; a(z_1))$。</li><li><strong>第二层</strong>：再次进行线性变换 $(z_2 &#x3D; W_2 a_1 + b_2)$</li></ol><p>如果没有激活函数，那么最终输出 $(y &#x3D; z_2)$ 将依然是输入 $(x)$ 的线性组合。但是，由于引入了激活函数 $(a(\cdot))$，整个网络就变成了 $(y &#x3D; W_2 a(W_1 x + b_1) + b_2)$，这不再是简单的线性关系，而是依赖于激活函数 $(a(\cdot))$ 的非线性形式。</p><p>前面提到：输出非负的值，有助于解决梯度消失问题。</p><p><strong>那么，梯度是什么？梯度消失又是什么？</strong></p><h3 id="梯度和梯度消失"><a href="#梯度和梯度消失" class="headerlink" title="梯度和梯度消失"></a>梯度和梯度消失</h3><p>我们先从<strong>梯度</strong>的概念开始，接着解释什么是<strong>梯度消失</strong>。</p><h4 id="1-什么是梯度？"><a href="#1-什么是梯度？" class="headerlink" title="1. 什么是梯度？"></a>1. <strong>什么是梯度？</strong></h4><ul><li>在神经网络中，梯度指的是损失函数（模型预测的误差）对模型参数（权重和偏置）的导数。</li><li>梯度告诉我们如何调整权重才能让损失减少，也就是说，它指示了优化方向。</li><li>比如，假设我们在爬山，梯度就像告诉我们当前所处位置的坡度和方向，帮助我们找到“山顶”（即最小的损失值）。</li></ul><h4 id="2-梯度消失是什么？"><a href="#2-梯度消失是什么？" class="headerlink" title="2. 梯度消失是什么？"></a>2. <strong>梯度消失是什么？</strong></h4><ul><li><strong>梯度消失</strong>是指当神经网络的某些层的梯度变得非常小时，网络更新参数的速度变得非常慢，甚至无法继续学习。</li><li>在训练深层神经网络时，随着误差从输出层逐层向前传播回输入层，梯度会逐渐变小。尤其是当使用像 Sigmoid 或 Tanh 这样的激活函数时，它们的导数很容易变得接近 0，导致梯度消失。</li></ul><h4 id="3-为什么梯度消失是个问题？"><a href="#3-为什么梯度消失是个问题？" class="headerlink" title="3. 为什么梯度消失是个问题？"></a>3. <strong>为什么梯度消失是个问题？</strong></h4><ul><li>梯度消失意味着，神经网络前面几层的权重几乎没有更新。这会导致这些层的学习速度非常慢，网络无法有效学习数据中的复杂特征。</li><li>如果梯度消失，模型在训练过程中就会变得“卡住”，无法通过反向传播有效优化权重，这样模型的表现也就无法提高。</li></ul><h4 id="4-为什么输出非负值可以帮助解决梯度消失？"><a href="#4-为什么输出非负值可以帮助解决梯度消失？" class="headerlink" title="4. 为什么输出非负值可以帮助解决梯度消失？"></a>4. <strong>为什么输出非负值可以帮助解决梯度消失？</strong></h4><ul><li><strong>ReLU激活函数</strong>输出非负值（即当输入大于 0 时，输出等于输入；否则输出 0）。ReLU 的导数是常数 1（对于正数部分），不会像 Sigmoid 或 Tanh 那样迅速衰减为接近 0。这意味着通过 ReLU，网络的梯度不容易消失，前面几层的学习速度也能得到保证。</li><li>换句话说，<strong>输出非负的值</strong>，特别是通过 ReLU 这样的激活函数，可以避免导数过小，从而缓解梯度消失问题。</li></ul><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播（Backpropagation，简称BP）是训练人工神经网络的一种核心算法，它基于梯度下降法，通过计算损失函数关于权重的梯度来更新权重，以最小化损失函数。这个过程可以分为两个主要阶段：前向传播和反向传播。下面将详细介绍这两个阶段，并解释它们如何协同工作以优化神经网络。</p><h3 id="前向传播"><a href="#前向传播" class="headerlink" title="前向传播"></a>前向传播</h3><p>在前向传播过程中，输入数据从网络的一端传入，依次经过每一层中的各个神经元，直到最终输出预测结果。每一步中，每个神经元接收到来自上一层的所有连接的加权输入之和，再加上一个偏置项，然后应用激活函数产生该神经元的输出值。这一系列操作构成了所谓的“前馈”过程。</p><p>具体来说，假设我们有一个简单的三层神经网络（包括输入层、隐藏层和输出层），对于给定的输入样本$(x)$，我们首先计算隐藏层每个神经元的线性组合：</p><p>$$net(h_j) &#x3D; \sum_{i} w_{ij} x_i + b_j$$</p><p>其中，$(w_{ij})$表示从输入层第$(i)$个节点到隐藏层第$(j)$个节点之间的权重，$(b_j)$是隐藏层第$(j)$个节点的偏置。接着，我们将上述线性组合传递给激活函数$(f)$得到隐藏层各神经元的实际输出：</p><p>$$out(h_j) &#x3D; f(net(h_j))$$</p><p>类似地，我们可以计算输出层每个神经元的输出值。当所有计算完成后，我们就得到了整个网络对当前输入样本的预测结果。</p><h3 id="反向传播-1"><a href="#反向传播-1" class="headerlink" title="反向传播"></a>反向传播</h3><p>一旦完成了前向传播并获得了预测结果，接下来就是比较预测值与真实标签之间的差异，即计算损失函数$E$。</p><p>为了实现这一点，我们必须找出哪些地方出了问题，并据此调整网络中的参数。这就是为什么我们要“反向”地从输出层开始，逐步向前追溯每一层的影响，直到输入层为止。在每一步中，我们都想知道如果稍微改变一点某个权重或偏置，会对最终的误差有多大影响。这实际上就是要计算误差相对于各个参数的导数（也叫做梯度）。</p><p>对于输出层而言，误差信号可以直接根据损失函数定义计算得出。例如，在平方误差的情况下：</p><p>$$\delta_k &#x3D; \frac{\partial E}{\partial out(o_k)} &#x3D; -(t_k - out(o_k))<br>$$</p><p>这里，$(t_k)$代表目标输出，而$(out(o_k))$是实际输出。对于隐藏层，则需要考虑来自后续层的影响，因此其误差信号为：</p><p>$$<br>\delta_j &#x3D; f’(net(h_j)) \sum_k w_{kj} \delta_k<br>$$</p><p>这里，$f’$表示激活函数的导数，$\sum_k w_{kj} \delta_k$则是从输出层回传过来的误差贡献。有了这些信息后，我们可以计算出每个权重的具体梯度：</p><p>$$<br>\frac{\partial E}{\partial w_{ij}} &#x3D; out(x_i) \delta_j<br>$$</p><p>最后，使用某种形式的学习率$\eta$来控制更新幅度，并据此调整相应的权重：</p><p>$$<br>w_{ij} :&#x3D; w_{ij} - \eta \frac{\partial E}{\partial w_{ij}}<br>$$</p><p>重复以上步骤直至遍历完所有训练样本，完成一次完整的迭代（epoch）。随着迭代次数增多，模型逐渐学会更准确地映射输入到期望输出。</p><h2 id="为什么通过计算误差相对于各个权重的梯度，就可以了解到不同因素各自贡献了多少误差？"><a href="#为什么通过计算误差相对于各个权重的梯度，就可以了解到不同因素各自贡献了多少误差？" class="headerlink" title="为什么通过计算误差相对于各个权重的梯度，就可以了解到不同因素各自贡献了多少误差？"></a>为什么通过计算误差相对于各个权重的梯度，就可以了解到不同因素各自贡献了多少误差？</h2><p>要理解为什么通过计算误差相对于各个权重的梯度可以了解到不同因素各自贡献了多少误差，我们需要从数学的角度出发，结合神经网络的工作原理来探讨这个问题。简单来说，梯度反映了损失函数（即误差）对模型参数（如权重和偏置）变化的敏感度。当我们计算出这些梯度时，实际上是在衡量每个参数对于最终预测结果的影响程度。</p><h3 id="梯度的意义"><a href="#梯度的意义" class="headerlink" title="梯度的意义"></a>梯度的意义</h3><p>在神经网络中，每个连接都有一个关联的权重，它决定了前一层输出值对该层输入的重要性。当我们将输入数据送入网络，并经过多层处理后得到输出时，这个输出与真实标签之间的差异构成了误差。为了最小化这个误差，我们需要知道调整哪些权重会最有效地降低误差。这就是梯度的作用所在——它告诉我们如果稍微改变某个权重，会导致误差发生怎样的变化。</p><p>具体而言，梯度是一个向量，它的每个分量对应于损失函数关于特定权重的偏导数。例如，如果我们有一个简单的线性回归模型$y &#x3D; wx + b$，其中$w$是权重，$b$是偏置，而$x$是输入特征。那么，对于给定的一组训练样本$(x_i, y_i)$，我们可以定义一个损失函数$E(w,b)$，用于衡量预测值$\hat{y}_i &#x3D; wx_i + b$与真实值$y_i$之间的差距。此时，权重$w$的梯度就是损失函数对$w$的变化率：</p><p>$$<br>\frac{\partial E}{\partial w} &#x3D; \lim_{h \to 0} \frac{E(w+h,b) - E(w,b)}{h}<br>$$</p><p>这意味着，如果我们增加或减少一点权重$w$，预期误差将如何变化。类似地，我们也可以计算偏置$b$的梯度。通过这种方式，我们可以确定哪些参数对于当前误差负有更大的责任，并据此进行相应的调整。</p><h3 id="链式法则的应用"><a href="#链式法则的应用" class="headerlink" title="链式法则的应用"></a>链式法则的应用</h3><p>然而，在实际应用中，神经网络往往包含多个隐藏层，这就使得直接计算每个权重的梯度变得复杂起来。幸运的是，微积分中的链式法则提供了一个解决方案。根据链式法则，复合函数的导数等于内部函数导数乘以外部函数导数。因此，我们可以沿着信号流动的方向，逐步求得每一层参数的梯度。例如，在一个多层感知机（MLP）中，假设第$l$层有一个神经元接收到来自前一层的所有输出作为输入，并产生自己的输出传递给下一层，则该神经元的误差项$\delta_l$可以通过以下公式计算：</p><p>$$<br>\delta_l &#x3D; f’(z_l) \sum_k w_{lk} \delta_k<br>$$</p><p>这里，$f’$表示激活函数的导数，$\sum_k w_{lk} \delta_k$是从下一层传回的误差贡献。一旦得到了所有层的误差项，就可以很容易地计算出相应权重的梯度：</p><p>$$<br>\frac{\partial E}{\partial w_{ij}} &#x3D; a_j \delta_i<br>$$</p><p>其中，$a_j$是前一层第$j$个神经元的激活值，而$\delta_i$是当前层第$i$个神经元的误差项。这样，我们就能够量化每个权重对于总误差的具体影响了。</p><h3 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h3><p>回到最初的问题上，当我们说“通过计算误差相对于各个权重的梯度，就可以了解到不同因素各自贡献了多少误差”时，实际上是指：通过对损失函数求导并应用链式法则，我们可以精确地评估每一个权重在形成最终预测结果的过程中发挥了多大的作用。那些具有较大绝对值梯度的权重意味着它们的变化会对误差产生显著影响；相反，较小的梯度则表明相关权重的影响相对有限。因此，通过分析梯度信息，我们可以识别出哪些连接对于改进模型性能至关重要，并优先对其进行调整。</p><p>此外，值得注意的是，除了权重之外，偏置项同样会影响预测结果。但是由于偏置并不依赖于任何输入特征，所以其梯度总是等于该层的误差项$\delta_i$。这意味着，即使没有来自前一层的有效输入，我们也应该适当调整偏置以确保正确的输出水平。</p><p>综上所述，通过计算误差相对于各个权重的梯度，我们不仅能够了解不同因素各自贡献了多少误差，而且还可以据此采取有效的措施来优化模型参数，从而提高预测精度。这一过程构成了反向传播算法的核心机制之一，使神经网络能够在大量数据的支持下不断学习和成长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2017/07/neural-network.html&quot;&gt;</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-RAG学习</title>
    <link href="https://kelinkong.github.io/2024/10/12/AI-RAG%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/12/AI-RAG%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-12T03:18:19.000Z</published>
    <updated>2024-12-20T07:56:41.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h2><p>RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）和生成（Generation）相结合的技术，常用于自然语言处理任务，特别是在问答和文档生成场景中。</p><h3 id="RAG-的工作原理"><a href="#RAG-的工作原理" class="headerlink" title="RAG 的工作原理"></a>RAG 的工作原理</h3><p>RAG 将两个主要组件结合起来：</p><ul><li><p>信息检索（Retrieval）：当系统接收到问题时，首先会从一个大型的文档数据库或知识库中检索出与问题最相关的文档片段。通常会使用像 ElasticSearch 或基于 BERT 的检索模型来找到最相关的内容。</p></li><li><p>生成模型（Generation）：接下来，生成模型（通常是一个大型语言模型，如 GPT）会将检索到的文档片段作为输入，然后基于这些片段生成答案。这使得生成模型不必完全依赖其自身的训练数据，而是可以利用外部知识库中的信息来生成更准确和上下文相关的响应。</p></li></ul><p>RAG技术虽然有以上显著的优势，但它不是万能的，只是锦上添花的一种手段，因为它主<strong>要是优化了模型的输入过程，通过丰富输入信息的方式，来增强模型的输出质量。但这项技术并不改变模型本身的推理能力，不会改变模型任何的参数</strong>。</p><h2 id="RAG的实现"><a href="#RAG的实现" class="headerlink" title="RAG的实现"></a>RAG的实现</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成）的实现涉及两个关键组件：<strong>检索模块</strong>和<strong>生成模块</strong>。这两者结合起来使得模型可以利用外部知识库动态生成高质量的答案。下面是RAG的典型实现步骤：</p><h3 id="1-构建知识库（Knowledge-Base）"><a href="#1-构建知识库（Knowledge-Base）" class="headerlink" title="1. 构建知识库（Knowledge Base）"></a>1. <strong>构建知识库（Knowledge Base）</strong></h3><p>   RAG的一个关键组件是知识库。这个知识库通常包含与特定领域相关的文档、条目、百科等。它可以是各种形式的文本，比如：</p><ul><li>结构化数据（数据库条目、文档片段等）</li><li>非结构化数据（文章、书籍、PDF等）</li></ul><p>   知识库的构建可以从公开资源获取，或者从特定的领域文档中自动化提取。</p><h3 id="2-检索模块（Retriever）"><a href="#2-检索模块（Retriever）" class="headerlink" title="2. 检索模块（Retriever）"></a>2. <strong>检索模块（Retriever）</strong></h3><p>   检索模块的作用是从知识库中找到与用户问题相关的内容。RAG的检索过程通常分为以下几步：</p><ul><li><p><strong>问题向量化</strong>：当用户提出问题时，首先将问题转化为向量表示（Embedding）。通常使用预训练的语言模型（如BERT、RoBERTa）将问题编码为一个固定大小的向量。</p></li><li><p><strong>文档向量化</strong>：在准备阶段，知识库中的每个文档片段（通常是小的段落或句子）也会被提前转化为向量表示，并保存在向量数据库中。</p></li><li><p><strong>检索相关文档</strong>：通过计算用户问题的向量与知识库中所有文档片段向量之间的相似度（例如余弦相似度），从知识库中找到与问题最相关的文档片段。这通常使用近似最近邻搜索算法（如FAISS）来加速检索。</p></li></ul><p>   <strong>典型检索工具</strong>：</p><ul><li><strong>BM25</strong>：一种经典的信息检索算法，基于词频和逆文档频率（TF-IDF）来衡量文档与查询的相关性。</li><li><strong>Dense Retrieval</strong>：基于深度学习的检索方式，使用语言模型（如BERT）生成的稠密向量表示进行检索。</li></ul><h3 id="3-生成模块（Generator）"><a href="#3-生成模块（Generator）" class="headerlink" title="3. 生成模块（Generator）"></a>3. <strong>生成模块（Generator）</strong></h3><p>   在检索到相关文档片段后，生成模块负责结合这些片段生成最终的答案。生成模块通常基于预训练的大型语言模型（如GPT、T5等）。具体步骤如下：</p><ul><li><p><strong>输入拼接</strong>：将原始用户问题和检索到的文档片段一起作为输入，拼接成一个完整的输入序列，提供给生成模型。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户问题：&quot;什么是机器学习？&quot;</span><br><span class="line">检索到的文档片段：</span><br><span class="line">1. &quot;机器学习是一种通过数据训练算法的技术，用于预测和分类。&quot;</span><br><span class="line">2. &quot;常见的机器学习算法包括线性回归、决策树、神经网络等。&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>生成答案</strong>：生成模型接收这个拼接后的输入，然后基于它生成一个回答。由于检索到的片段为模型提供了上下文，生成的答案将更加准确和领域相关。例如，生成模型可能会输出：“机器学习是一种通过数据训练算法以进行预测和分类的技术，常用算法有线性回归和神经网络。”</p></li></ul><h3 id="4-训练RAG模型"><a href="#4-训练RAG模型" class="headerlink" title="4. 训练RAG模型"></a>4. <strong>训练RAG模型</strong></h3><p>   训练RAG模型的过程中，使用标准的生成任务损失函数（如交叉熵）对生成模块进行优化，并对检索和生成过程进行端到端的联合训练。具体来说：</p><ul><li><strong>监督学习</strong>：训练集通常由问题和答案对组成，同时包含一些相关的文档片段。模型在训练过程中不仅学习如何生成高质量的答案，还会优化检索阶段，使其能选择最相关的文档。</li><li><strong>检索优化</strong>：通过将检索模块与生成模块结合在一起，可以通过生成模块的反馈来优化检索阶段，从而逐步改进文档选择的相关性。</li><li><strong>联合训练</strong>：在一些实现中，检索器和生成器可以联合训练，从而使得检索器学习到更适合生成器的相关文档。</li></ul><h3 id="5-推理过程（Inference-Pipeline）"><a href="#5-推理过程（Inference-Pipeline）" class="headerlink" title="5. 推理过程（Inference Pipeline）"></a>5. <strong>推理过程（Inference Pipeline）</strong></h3><p>   在实际推理过程中，RAG系统通常按以下步骤执行：</p><ul><li><strong>问题输入</strong>：用户提出问题（如“人工智能的主要应用是什么？”）。</li><li><strong>检索文档</strong>：检索模块从知识库中找到与该问题相关的文档片段（如从AI相关文档中找到有关AI应用的片段）。</li><li><strong>生成答案</strong>：将用户问题和检索到的文档片段传递给生成模块，生成基于这些片段的答案。</li><li><strong>返回结果</strong>：最终，RAG系统将生成的答案返回给用户。</li></ul><h3 id="6-RAG的架构图示意"><a href="#6-RAG的架构图示意" class="headerlink" title="6. RAG的架构图示意"></a>6. <strong>RAG的架构图示意</strong></h3><p>RAG的架构可以简要表示为如下流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+    用户问题     +------------------+</span><br><span class="line">|  文档知识库      |  -------------&gt;  |   检索模块（Retriever） |</span><br><span class="line">+------------------+                   +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                      检索到的文档片段</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                     |  生成模块（Generator） |</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                          最终答案</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                           用户</span><br></pre></td></tr></table></figure><h3 id="7-RAG的实际应用"><a href="#7-RAG的实际应用" class="headerlink" title="7. RAG的实际应用"></a>7. <strong>RAG的实际应用</strong></h3><p>RAG的架构非常适合需要结合外部知识生成回答的任务，如：</p><ul><li><strong>领域问答系统</strong>：在法律、医学、金融等特定领域，RAG可以利用专业文档库进行高质量回答。</li><li><strong>文档生成和扩展</strong>：RAG可以根据输入问题生成具有参考资料的文档内容。</li><li><strong>对话系统</strong>：通过结合知识库，RAG能够在对话中生成更加丰富的内容和背景信息。</li></ul><p>通过以上过程，RAG可以有效结合知识库和生成模型，增强生成任务的知识性和准确性，同时灵活处理领域知识扩展问题。</p><h2 id="大模型微调和RAG对比"><a href="#大模型微调和RAG对比" class="headerlink" title="大模型微调和RAG对比"></a>大模型微调和RAG对比</h2><p>将通用大模型调整为某个特定领域的大模型可以通过两种常见的方法来实现：<code>RAG（Retrieval-Augmented Generation）</code>和大模型微调。两者有不同的侧重点和应用场景。以下是它们的区别：</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a>RAG（检索增强生成）</h3><p>核心思路：<br>RAG通过结合外部知识库与生成模型来增强模型的知识能力，而不改变原有的大模型参数。它会先从特定领域的知识库中检索与问题相关的信息，再基于这些检索到的内容由生成模型生成答案。这种方法不需要直接修改模型本身。</p><p>适用场景：RAG特别适用于知识动态更新较快或知识领域非常广泛的场景。它允许你快速将大模型应用于特定领域，而无需重新训练模型。例如：</p><ul><li>医学、法律、金融等领域，可以通过检索领域文档来增强模型的特定领域能力。</li><li>实时问答或需要最新知识时，RAG可以通过检索更新的知识库提供答案。</li></ul><p>优点：</p><ul><li>不需要重新训练大模型，降低计算成本。</li><li>可以即时应用于不同领域，只需准备领域特定的知识库。</li><li>动态扩展模型的知识，知识库可随时更新，增强模型的实时性和灵活性。</li></ul><p>缺点：</p><ul><li>模型仍依赖于外部知识库的质量和准确性。</li><li>检索部分可能导致效率低下，尤其在大型知识库中。</li></ul><h3 id="大模型微调"><a href="#大模型微调" class="headerlink" title="大模型微调"></a>大模型微调</h3><p>核心思路：大模型微调（Fine-tuning）是通过在特定领域的数据上对通用大模型进行进一步训练，来调整其权重，使其更适合该领域的任务。这种方法会直接改变模型的参数，使模型在特定领域表现更好。</p><p>适用场景：微调适合那些希望模型能够在特定领域有深度理解或执行特定任务的情况。微调后的模型可以直接生成该领域的高质量内容，而无需依赖外部检索。例如：</p><ul><li>某些领域的文本生成、分类、或者预测任务需要模型具备细致的专业知识，微调能够提高模型在这些任务中的表现。</li><li>特定领域的对话系统或写作助手。</li></ul><p>优点：</p><ul><li>通过专门的数据进行训练，模型可以深度适应某个领域，提升其在该领域的表现。</li><li>模型的响应可以是自主生成的，不依赖外部资源，具有更高的效率。</li></ul><p>缺点：</p><ul><li>需要大量的领域特定数据进行训练，数据收集成本高。</li><li>微调模型的计算开销大，尤其是大型模型。</li><li>一旦领域知识发生变化，模型需要重新微调，更新过程相对繁琐。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要使用Java实现场景化的RAG（检索增强生成），每个场景对应不同的知识库，底层采用OpenAI大模型，文档检索数据库使用Elasticsearch，开发工作可以分为以下几步：</p><h3 id="1-管理不同场景的知识库"><a href="#1-管理不同场景的知识库" class="headerlink" title="1. 管理不同场景的知识库"></a>1. <strong>管理不同场景的知识库</strong></h3><ul><li><p><strong>场景区分</strong>：每个场景的知识库可能包含不同的数据集。因此，你需要在Elasticsearch中为每个场景创建单独的索引，便于检索时知道该查询对应哪个知识库。</p></li><li><p><strong>Elasticsearch索引创建</strong>：</p><ul><li>针对每个场景创建不同的索引。例如，你可以为“医学场景”和“法律场景”分别创建索引<code>medical_documents</code>和<code>legal_documents</code>。</li><li>在索引中插入文档片段，并将场景信息作为元数据存储，以便后续检索时区分不同场景。</li></ul></li></ul><p>   <strong>示例：为不同场景创建索引并插入文档</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Elasticsearch client 初始化</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">    RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建医学场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">medicalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>);</span><br><span class="line">client.indices().create(medicalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建法律场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">legalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;legal_documents&quot;</span>);</span><br><span class="line">client.indices().create(legalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文档到医学场景的索引</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">medicalDocRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>).id(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    .source(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Medical Document&quot;</span>, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;This is a medical document about diseases.&quot;</span>);</span><br><span class="line">client.index(medicalDocRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure></p><h3 id="2-实现检索模块（Retriever）"><a href="#2-实现检索模块（Retriever）" class="headerlink" title="2. 实现检索模块（Retriever）"></a>2. <strong>实现检索模块（Retriever）</strong></h3><ul><li><p><strong>场景选择</strong>：在用户提问时，根据问题确定使用哪个场景的知识库进行检索。可以通过用户输入的特定关键词或上下文来选择相应的场景。例如，如果用户问的是法律相关问题，就选择“法律场景”的知识库。</p></li><li><p><strong>检索文档</strong>：根据用户的输入，从指定场景的知识库中检索相关文档。可以使用Elasticsearch的Java API，根据用户问题在特定索引中进行查询，提取与问题最相关的文档片段。</p></li></ul><p>   <strong>示例：根据场景进行检索</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">retrieveDocuments</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexName</span> <span class="operator">=</span> scene.equals(<span class="string">&quot;medical&quot;</span>) ? <span class="string">&quot;medical_documents&quot;</span> : <span class="string">&quot;legal_documents&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(indexName);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;content&quot;</span>, userQuery));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">    List&lt;String&gt; retrievedDocs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">        retrievedDocs.add(hit.getSourceAsMap().get(<span class="string">&quot;content&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retrievedDocs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-生成模块的实现（OpenAI-大模型调用）"><a href="#3-生成模块的实现（OpenAI-大模型调用）" class="headerlink" title="3. 生成模块的实现（OpenAI 大模型调用）"></a>3. <strong>生成模块的实现（OpenAI 大模型调用）</strong></h3><ul><li><p><strong>OpenAI 模型调用</strong>：当检索到相关的文档片段后，接下来要调用OpenAI的大模型生成答案。你需要将用户问题和检索到的文档片段拼接，作为模型的输入，让模型基于这些片段生成相关的答案。</p></li><li><p><strong>API 集成</strong>：使用Java的HTTP客户端（例如HttpClient）发送请求到OpenAI的API，并获取生成的答案。</p></li></ul><p>   <strong>示例：调用OpenAI大模型API生成答案</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateAnswer</span><span class="params">(String userQuery, List&lt;String&gt; retrievedDocs)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(userQuery);</span><br><span class="line">    <span class="keyword">for</span> (String doc : retrievedDocs) &#123;</span><br><span class="line">        prompt.append(<span class="string">&quot;\n&quot;</span>).append(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">    <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://api.openai.com/v1/completions&quot;</span>))</span><br><span class="line">        .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_OPENAI_API_KEY&quot;</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;&#123;\&quot;model\&quot;: \&quot;gpt-3.5-turbo\&quot;, \&quot;prompt\&quot;: \&quot;&quot;</span> + prompt.toString() + <span class="string">&quot;\&quot;, \&quot;max_tokens\&quot;: 100&#125;&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    <span class="keyword">return</span> response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-实现RAG逻辑"><a href="#4-实现RAG逻辑" class="headerlink" title="4. 实现RAG逻辑"></a>4. <strong>实现RAG逻辑</strong></h3><ul><li><p><strong>场景选择与文档检索</strong>：根据用户问题选择场景，调用相应场景的知识库，检索相关的文档片段。</p></li><li><p><strong>生成答案</strong>：将用户问题与检索到的文档片段拼接，通过OpenAI大模型生成最终答案。</p></li></ul><p>   <strong>示例：综合检索与生成</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processRAGPipeline</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 根据场景检索文档</span></span><br><span class="line">    List&lt;String&gt; retrievedDocs = retrieveDocuments(userQuery, scene);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用生成模块</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> generateAnswer(userQuery, retrievedDocs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-支持不同场景的用户接口"><a href="#5-支持不同场景的用户接口" class="headerlink" title="5. 支持不同场景的用户接口"></a>5. <strong>支持不同场景的用户接口</strong></h3><ul><li><p><strong>API设计</strong>：你可以为外部应用提供一个统一的接口，支持不同场景的知识库选择。用户可以在请求中指定场景，或让系统根据用户输入自动选择合适的场景。</p></li><li><p><strong>Spring Boot API集成</strong>：使用Spring Boot开发REST API，接收用户请求，并根据请求中的场景信息来调用相应的检索和生成模块。</p></li></ul><p>   <strong>示例：Spring Boot REST API</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RagController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/ask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">askQuestion</span><span class="params">(<span class="meta">@RequestBody</span> QuestionRequest request)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scene</span> <span class="operator">=</span> request.getScene();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userQuery</span> <span class="operator">=</span> request.getQuery();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行RAG流程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> processRAGPipeline(userQuery, scene);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuestionRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String scene;</span><br><span class="line">    <span class="keyword">private</span> String query;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-监控和优化"><a href="#6-监控和优化" class="headerlink" title="6. 监控和优化"></a>6. <strong>监控和优化</strong></h3><ul><li><strong>检索效率优化</strong>：通过优化Elasticsearch查询、配置向量检索或提升索引结构来提高检索效率。</li><li><strong>生成性能优化</strong>：对OpenAI生成的答案进行适当的后处理，例如剪短生成结果，或者通过上下文增强生成效果。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了实现一个基于Java语言、OpenAI大模型和Elasticsearch的RAG系统，你需要完成以下开发工作：</p><ol><li><strong>管理不同场景的知识库</strong>：为每个场景建立不同的Elasticsearch索引。</li><li><strong>实现检索模块</strong>：根据场景检索知识库中的文档片段。</li><li><strong>实现生成模块</strong>：通过调用OpenAI的API生成最终答案。</li><li><strong>实现综合RAG逻辑</strong>：将检索和生成模块结合，构建统一的流程。</li><li><strong>开发用户接口</strong>：通过REST API为用户提供对不同场景的RAG支持。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是RAG&quot;&gt;&lt;a href=&quot;#什么是RAG&quot; class=&quot;headerlink&quot; title=&quot;什么是RAG&quot;&gt;&lt;/a&gt;什么是RAG&lt;/h2&gt;&lt;p&gt;RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-大模型API封装学习</title>
    <link href="https://kelinkong.github.io/2024/10/10/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/10/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-10T10:28:42.000Z</published>
    <updated>2024-12-20T07:57:32.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现背景"><a href="#实现背景" class="headerlink" title="实现背景"></a>实现背景</h2><p>假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理异步请求。</p><p>为什么要做API封装？</p><blockquote><ol><li>保护模型：避免直接暴露模型，保护模型的安全性。</li><li>降低耦合：将模型与业务逻辑分离，降低耦合度。</li><li>与原有的系统对接：将模型封装成API，方便与其他系统对接。</li></ol></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>以下是一个基于 Spring WebFlux 封装 OpenAI API 的完整实现例子，使用 Gradle 管理，项目目录结构为 vo、client 和 biz。</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> └── main</span><br><span class="line">     ├── java</span><br><span class="line">     │    └── com</span><br><span class="line">     │         └── example</span><br><span class="line">     │              ├── controller</span><br><span class="line">     │              │    └── OpenAIController.java</span><br><span class="line">     │              ├── biz</span><br><span class="line">     │              │    └── OpenAIService.java</span><br><span class="line">     │              ├── client</span><br><span class="line">     │              │    └── WebClientConfig.java</span><br><span class="line">     │              └── vo</span><br><span class="line">     │                   ├── PromptRequest.java</span><br><span class="line">     │                   └── CompletionResponse.java</span><br><span class="line">     └── resources</span><br><span class="line">          └── application.yml</span><br></pre></td></tr></table></figure><p><strong>配置 WebClient 类 (client&#x2F;WebClientConfig.java)</strong></p><p>WebClientConfig 用于配置 WebClient，这个类将负责与 OpenAI API 的连接。</p><p><strong>业务逻辑 (biz&#x2F;OpenAIService.java)</strong></p><p>OpenAIService 类用于封装调用 OpenAI API 的逻辑，并且通过 WebClient 处理流式响应，返回 <code>Flux&lt;String&gt;</code>。</p><p><strong>数据传输对象 (DTO) (<code>vo/PromptRequest.java</code> 和 <code>vo/CompletionResponse.java</code>)</strong></p><p><code>PromptRequest.java</code>：定义发送给 OpenAI API 的请求体数据结构。</p><p><code>CompletionResponse.java</code>：定义从 OpenAI API 接收到的响应数据结构</p><h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><h3 id="响应的数据结构"><a href="#响应的数据结构" class="headerlink" title="响应的数据结构"></a>响应的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Choice&gt; choices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Choice</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private List&lt;Choice&gt; choices;</code> 在<code>CompletionResponse</code>类中扮演以下几个重要角色：</p><ol><li>表示响应中的数据结构：</li></ol><ul><li>choices 字段表示 OpenAI API 响应中的一个重要部分。根据 OpenAI API 的响应格式，生成的文本是以 choices 的形式返回的，每一个 Choice 对象包含一段生成的文本。</li></ul><ol start="2"><li>封装多个 Choice 对象：</li></ol><ul><li>由于 OpenAI API 可以生成多个结果（多个选择），因此需要用 List<Choice> 来封装这些生成的结果。List 是一个集合类，允许存储多个 Choice 对象，每个对象代表一个生成的文本。</li></ul><ol start="3"><li>将 JSON 映射为 Java 对象：</li></ol><ul><li>当 OpenAI API 返回一个包含 choices 的 JSON 数组时，Spring WebFlux 的 WebClient 会将 JSON 映射为 Java 对象。List<Choice> 对应的是 JSON 中的数组，Choice 类中的 text 字段对应 JSON 中每个选项的文本内容。</li></ul><p>假设 OpenAI API 的响应如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the first generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the second generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据这个 JSON 结构：</p><p><code>choices</code> 是一个数组（List），每个数组元素对应一个 Choice 对象。<br><code>Choice</code> 对象中有一个 text 字段，存储生成的文本。<br><code>private List&lt;Choice&gt; choices</code>; 在这里就是用来存储和处理这个数组，代表生成的多个文本结果。</p><p><strong>在程序中的作用</strong></p><p>当调用 OpenAI 的 API 并接收响应时，Spring 的反序列化机制会将 JSON 数据自动映射到 <code>CompletionResponse</code> <code>中。choices</code> 字段将包含多个生成的文本，每个文本存储在一个 <code>Choice</code> 对象中。</p><p>可以通过以下方式访问生成的文本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompletionResponse</span> <span class="variable">response</span> <span class="operator">=</span> ... <span class="comment">// 从 API 获取响应</span></span><br><span class="line">List&lt;CompletionResponse.Choice&gt; choices = response.getChoices();</span><br><span class="line"><span class="keyword">for</span> (CompletionResponse.Choice choice : choices) &#123;</span><br><span class="line">    System.out.println(choice.getText());  <span class="comment">// 输出每个生成的文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以逐个处理生成的文本结果。</p><h3 id="请求的数据结构"><a href="#请求的数据结构" class="headerlink" title="请求的数据结构"></a>请求的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromptRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String model; <span class="comment">// text-davinci-003  gpt-3.5-turbo  code-davinci-002</span></span><br><span class="line">    <span class="keyword">private</span> String prompt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max_tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top_p;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebClient-配置"><a href="#WebClient-配置" class="headerlink" title="WebClient 配置"></a>WebClient 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.openai.com/v1&quot;</span>)  <span class="comment">// OpenAI API base URL</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_API_KEY&quot;</span>)  <span class="comment">// 替换为你的 OpenAI API Key</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 WebClient？</strong></p><p><code>WebClient</code> 是 Spring WebFlux 提供的一个响应式、非阻塞的 HTTP 客户端，允许应用程序与外部服务进行交互。相比于传统的 RestTemplate，<code>WebClient</code> 能更好地支持异步操作，特别适合处理高并发、低延迟的应用场景。</p><p><code>WebClient </code>允许我们以编程的方式发起 HTTP 请求并处理响应。可以发送 GET、POST、PUT、DELETE 等各种 HTTP 请求，且可以处理 JSON、XML 或其他格式的数据。</p><h4 id="WebClient-的使用步骤"><a href="#WebClient-的使用步骤" class="headerlink" title="WebClient 的使用步骤"></a>WebClient 的使用步骤</h4><ol><li>创建 <code>WebClient</code> 实例：通过 <code>WebClient.Builder</code> 创建 <code>WebClient</code> 实例，可以配置 <code>baseUrl</code>、<code>header</code> 等信息。</li><li>发起请求：使用 <code>WebClient</code> 实例发起请求，可以发送 GET、POST 等请求。</li><li>处理响应：通过 <code>retrieve()</code> 方法获取响应，可以处理响应数据。</li></ol><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WebClient 实例</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望只返回一个结果（比如从 API 返回的单个 JSON 对象），使用 Mono 来处理</span></span><br><span class="line">Mono&lt;String&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/endpoint&quot;</span>)</span><br><span class="line">    .retrieve()  <span class="comment">// 提取响应体</span></span><br><span class="line">    .bodyToMono(String.class);  <span class="comment">// 将响应体转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望返回多个结果（比如从 API 返回的 JSON 数组），使用 Flux 来处理</span></span><br><span class="line">Flux&lt;MyResponseObject&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/stream-endpoint&quot;</span>)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToFlux(MyResponseObject.class);  <span class="comment">// 将响应体映射为多个对象</span></span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.subscribe(res -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Response: &quot;</span> + res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mono 或 Flux：</p><p>Mono 和 Flux 是响应式编程模型中的核心部分，分别表示单个元素（Mono）或多个元素（Flux）的异步序列。</p><p>这些序列是“惰性”的，意味着它们不会在定义时立刻执行。只有当你“订阅”它们时，数据才会开始流动，或者说，操作才会被真正执行。<br><code>subscribe()</code> 方法：</p><p><code>subscribe() </code>是触发响应式流的关键操作。当你调用 <code>subscribe()</code>，整个请求流程才会被激活和执行。</p><p><code>subscribe()</code> 的参数是一个 Consumer，表示当有数据发出时，你可以定义如何处理这些数据。在这个例子中，res 就是 HTTP 响应体的结果。</p><h3 id="假设和前端进行交互，controller如下"><a href="#假设和前端进行交互，controller如下" class="headerlink" title="假设和前端进行交互，controller如下"></a>假设和前端进行交互，controller如下</h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/openai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIController</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/generate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">generateText</span><span class="params">(<span class="meta">@RequestBody</span> PromptRequest request)</span> &#123;</span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 OpenAIService，并逐步推送生成的文本内容</span></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(request);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(</span><br><span class="line">            <span class="comment">// 这是一个 Lambda 表达式，表示每当 Flux&lt;String&gt; 中有新的文本片段 result，服务器会执行这个代码块：</span></span><br><span class="line">                result -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        emitter.send(SseEmitter.event().data(result));  <span class="comment">// 将生成的文本片段作为 SSE 事件发送到客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        emitter.completeWithError(e);  <span class="comment">// 处理异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="comment">// 每次 Flux 产生新文本段时，调用这个回调函数，将该段文本发送给客户端。</span></span><br><span class="line">                emitter::completeWithError,  <span class="comment">// 处理错误</span></span><br><span class="line">                emitter::complete  <span class="comment">// 完成</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端发送请求后，服务器返回一个 SseEmitter 对象，告诉客户端这将是一个持续的数据流。</span></span><br><span class="line"><span class="comment">         * SseEmitter 用于推送多次数据（在文本逐步生成的过程中）。</span></span><br><span class="line"><span class="comment">         * 当推送完毕后，SseEmitter 会通过 complete() 方法关闭连接。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SseEmitter"><a href="#SseEmitter" class="headerlink" title="SseEmitter"></a>SseEmitter</h4><p><code>SseEmitter</code> 是 Spring 提供的一个类，用于处理 <code>Server-Sent Events (SSE)</code>，一种服务器端推送技术。<br>通过 <code>SseEmitter</code>，服务器可以持续向客户端发送事件，而客户端只需要建立一次连接即可接收多个事件。<br>SSE 是基于 HTTP 协议的持久连接，这使它在实时数据更新场景中非常有用，例如股票价格、社交媒体通知、实时聊天消息等。</p><h3 id="服务类-biz-OpenAIService-java"><a href="#服务类-biz-OpenAIService-java" class="headerlink" title="服务类 (biz/OpenAIService.java)"></a>服务类 (<code>biz/OpenAIService.java</code>)</h3><ul><li>连接是单向的，服务器推送数据，客户端接收数据。</li><li>客户端通过 <code>EventSource API</code> 来接收服务器推送的事件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给其他组件调用，发送请求到 OpenAI API 并流式返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promptRequest 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flux&lt;String&gt; 返回流式响应的每一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">generateText</span><span class="params">(PromptRequest promptRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/completions&quot;</span>)</span><br><span class="line">                .bodyValue(promptRequest)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToFlux(CompletionResponse.class)  <span class="comment">// 将响应映射为 CompletionResponse 对象</span></span><br><span class="line">                .flatMap(response -&gt; Flux.just(response.getChoices().get(<span class="number">0</span>).getText()));  <span class="comment">// 获取响应的文本部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的组件如何调用这个服务类？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.anothercomponent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.biz.OpenAIService;</span><br><span class="line"><span class="keyword">import</span> com.example.vo.PromptRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherComponent</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPrompt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PromptRequest</span> <span class="variable">promptRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PromptRequest</span>();</span><br><span class="line">        promptRequest.setModel(<span class="string">&quot;text-davinci-003&quot;</span>);</span><br><span class="line">        promptRequest.setPrompt(<span class="string">&quot;Explain quantum physics in simple terms.&quot;</span>);</span><br><span class="line">        promptRequest.setMax_tokens(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(promptRequest);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(response -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理每一个返回的文本块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Generated Text: &quot;</span> + response);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现背景&quot;&gt;&lt;a href=&quot;#实现背景&quot; class=&quot;headerlink&quot; title=&quot;实现背景&quot;&gt;&lt;/a&gt;实现背景&lt;/h2&gt;&lt;p&gt;假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
</feed>
