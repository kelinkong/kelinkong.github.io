<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2024-09-30T03:39:32.063Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>包管理器相关</title>
    <link href="https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2024-09-30T03:14:49.000Z</published>
    <updated>2024-09-30T03:39:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。</p><p>到现在已经接触到很多包管理器，比如 <code>npm</code>、<code>yarn</code>、<code>pip</code>、<code>brew</code>、<code>apt</code>、<code>yum</code>、<code>docker</code>、<code>composer</code> 等等。</p><p>于是想到，这些包管理器都是怎么实现的呢？它们之间有什么区别呢？</p><h2 id="什么是包管理器"><a href="#什么是包管理器" class="headerlink" title="什么是包管理器"></a>什么是包管理器</h2><p>包管理器是一种工具，用于自动化管理软件包（libraries, dependencies）的下载、安装、更新和卸载。它帮助开发人员轻松处理项目所需的依赖项，确保不同的库和工具能够正确地协同工作。</p><p>如果不使用包管理器，那么就需要手动下载、安装、更新和卸载软件包，这样会导致很多问题，比如版本冲突、依赖关系、安装路径等等。</p><h2 id="包管理器的包是从哪里来的呢？"><a href="#包管理器的包是从哪里来的呢？" class="headerlink" title="包管理器的包是从哪里来的呢？"></a>包管理器的包是从哪里来的呢？</h2><p>包管理器的包通常存储在一个或多个远程仓库中，开发人员可以从这些仓库中下载所需的软件包。这些仓库通常由软件的开发者或维护者维护，确保软件包的安全性和可靠性。</p><p>有些包管理的仓库服务器在国外，下载速度可能会比较慢，所以有些国内的公司会搭建自己的镜像仓库，比如淘宝的 <code>npm</code> 镜像、阿里云的 <code>docker</code> 镜像等等。（这里涉及到更换源）</p><p>那么理论上来说，也可以在本地搭建一个仓库，然后使用包管理器从本地仓库下载软件包。</p><h2 id="包管理器的作用"><a href="#包管理器的作用" class="headerlink" title="包管理器的作用"></a>包管理器的作用</h2><ul><li>安装依赖项：根据项目的配置文件（如<code>package.json</code>、<code>pom.xml</code>等），自动下载并安装项目所需的依赖包。</li><li>版本管理：包管理器能够处理依赖包的版本，确保项目使用兼容的版本，避免版本冲突。</li><li>更新：可以检查并更新到某个包的最新版本，或者锁定在特定版本。</li><li>卸载：移除不再需要的依赖包。</li></ul><h2 id="包管理器的分类"><a href="#包管理器的分类" class="headerlink" title="包管理器的分类"></a>包管理器的分类</h2><h3 id="1-操作系统级别的包管理器"><a href="#1-操作系统级别的包管理器" class="headerlink" title="1. 操作系统级别的包管理器"></a>1. 操作系统级别的包管理器</h3><p>这些包管理器用于管理操作系统中的软件包和库，通常用于安装和管理操作系统级别的应用程序和工具。它们主要处理的是操作系统中的二进制文件或预编译的软件包</p><ul><li>APT (Advanced Package Tool)：Debian 和 Ubuntu 系统上常用的包管理器。</li><li>YUM (Yellowdog Updater, Modified)：CentOS、RHEL 系统上的包管理器。</li><li>brew：macOS 上的包管理器。</li><li>Chocolatey：Windows 上的包管理器。</li></ul><h3 id="2-编程语言级别的包管理器"><a href="#2-编程语言级别的包管理器" class="headerlink" title="2. 编程语言级别的包管理器"></a>2. 编程语言级别的包管理器</h3><p>这些包管理器用于管理编程语言中的软件包和库，通常用于安装和管理项目级别的依赖项。它们主要处理的是源代码或库文件，通常会下载源代码并编译安装。</p><ul><li>npm (Node Package Manager)：JavaScript 的包管理器，用于 Node.js 项目。</li><li>yarn：JavaScript 的包管理器，用于 Node.js 项目。</li><li>pip：Python 的包管理器。</li><li>Maven：管理 Java 项目的依赖项和构建的工具。</li><li>Gradle：更灵活的构建和依赖管理工具，适用于多种编程语言，包括 Java。</li></ul><h2 id="版本管理器"><a href="#版本管理器" class="headerlink" title="版本管理器"></a>版本管理器</h2><p>这里的版本管理器指conda、nvm、rbenv、pyenv等，它们用于管理不同版本的编程语言或工具。</p><ul><li>conda：Python 的版本管理器，用于创建和管理 Python 环境。</li><li>nvm (Node Version Manager)：Node.js 的版本管理器，用于管理 Node.js 的不同版本。</li></ul><p>在踩坑之前，我觉得conda、nvm都很麻烦，我使用一个版本的python就好了，为什么还需要去做多个版本管理？</p><p>但是在实际开发中，有一次是安装别的工具，这个工具自己下载了一个合适的python版本，并且将我默认的python版本改成了这个版本，导致我之前的项目无法运行，当时的解决方式是更换环境变量，但是这种手动的切换十分麻烦，所以版本管理器就显得很有必要了。</p><p>像node.js也是一样，不同的版本就会出现各种问题，所以本地配置往往需要很多个版本去适应不同的项目。</p><blockquote><p>使用 <code>pip</code> 在不同的 <code>Python</code> 版本（如 Python 3.10 和 Python 3.11）下安装包时，包不能直接在另一个版本下使用，因为每个 <code>Python</code> 版本有自己独立的环境和库安装路径。切换 <code>Python</code> 版本后，之前为另一个版本安装的包不会自动可用。</p><p>正确的做法是为每个 <code>Python</code> 项目指定一个独立的虚拟环境。这样可以确保每个项目拥有独立的依赖项，避免不同项目之间产生冲突或兼容性问题。虚拟环境允许隔离项目的 <code>Python</code> 版本和包管理，使得每个项目可以使用其特定的 <code>Python</code> 版本和依赖库。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>CMake算是一个包管理器吗？</strong></p><p>我们都知道Cmake的功能是用于管理项目的构建过程，它可以生成Makefile、Visual Studio项目文件等，但是它并不是一个包管理器，它只是一个构建工具。</p><p><strong>CMake并不能自动下载和安装依赖项，需要提前安装好，并且在CMakeLists.txt 中指定依赖项</strong></p><p>那么，C++是如何做包管理的呢？（程序员手动管理哈哈）</p><p>C++没有像Java、Python、JavaScript那样有一个统一的包管理器，不过有一些第三方的包管理器，比如：</p><ul><li>Conan：C++ 的包管理器，用于管理 C++ 项目的依赖项。</li><li>vcpkg：微软开发的 C++ 包管理器，用于管理 C++ 项目的依赖项。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。&lt;/p&gt;
&lt;p&gt;到现在已经接触到很多包管理器，比如</summary>
      
    
    
    
    
    <category term="architecture" scheme="https://kelinkong.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记-AOP</title>
    <link href="https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/"/>
    <id>https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/</id>
    <published>2024-09-30T02:19:44.000Z</published>
    <updated>2024-09-30T03:04:55.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业务逻辑和横切关注点分离开来，提高代码的可维护性和可扩展性。</p><p>这里他举了一个例子，例如每个方法都需要统计运行时间，如果不使用AOP，那么每个方法都需要添加统计时间的代码，这样会导致代码冗余，可维护性差。使用AOP，只需要在一个地方添加统计时间的代码，就可以实现所有方法的统计时间。</p><p>这个思想和设计模式中的装饰器模式有点类似，都是在不改变原有代码的情况下，添加新的功能。</p><p>假设用装饰器模式来实现，应该怎么实现呢？</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式是面向对象的思想</strong>，它允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是继承关系的一个替代方案。</p><ol><li>定义 Service 接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>原始实现 ServiceImpl：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 原始任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Performing the task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义装饰器类 ServiceDecorator：</li></ol><p>装饰器类实现了 Service 接口，并组合了一个 Service 实例。我们通过组合模式，将对原始对象的调用进行包装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service decoratedService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceDecorator</span><span class="params">(Service decoratedService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedService = decoratedService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用装饰器类：</li></ol><p>现在，可以使用装饰器模式为 ServiceImpl 添加统计运行时间的功能，而无需修改原始 ServiceImpl 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用装饰器包装原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">decoratedService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceDecorator</span>(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法，自动统计运行时间</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用AOP又该怎么实现呢？</p><h2 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h2><p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p><p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p><p>以上是我搜索到的内容，但是“面向切面编程”确实抽象，难以理解。</p><p>如果核心是不侵入原始代码去增加一些功能。</p><p>那么这里很容易联想到C++中的函数指针、回调函数以及后面出现的Lambda表达式，这些都是在函数调用时，传递的是函数的地址，而不是函数的返回值。这样就可以在函数调用前后，执行一些操作。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>这里都以Lambda表达式为例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lambda传递行为</span></span><br><span class="line">        performTask(() -&gt; System.out.println(<span class="string">&quot;Task executed!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">performTask</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者在形式上没有什么很大的区别。</p><p>但在实现上还是有一些区别：</p><table><thead><tr><th>特性</th><th>Java AOC</th><th>C++ 函数作为参数传入</th></tr></thead><tbody><tr><td>传递方式</td><td>通过实现接口或继承类创建匿名类实例</td><td>通过函数指针、函数对象、lambda 传递函数</td></tr><tr><td>类型要求</td><td>必须实现接口或继承类</td><td>直接传递函数，使用函数指针或 lambda</td></tr><tr><td>语法简洁性</td><td>Java 8 之前语法较冗长，Java 8 后可用 lambda 简化</td><td>Lambda 语法较简洁，函数指针较底层</td></tr><tr><td>捕获上下文</td><td>只能捕获 final 或 effectively final 变量</td><td>可以捕获任意上下文变量，提供闭包特性</td></tr><tr><td>灵活性</td><td>必须依赖接口或类</td><td>不需要接口，函数指针和 lambda 都可以使用</td></tr><tr><td>性能</td><td>由于会生成匿名内部类的实例，可能开销较大</td><td>函数指针直接传递，效率更高</td></tr></tbody></table><p><strong>尽管思想上相似，但两者在实现上有所不同：</strong></p><ul><li><p>Java 更加面向对象。Java 中，匿名内部类和 Lambda 本质上是依赖接口或者类的实现，体现了 Java 面向对象的特性。即便在 Java 8 之后使用 Lambda，依然是函数式接口的简化语法。这意味着 Java 的行为参数化是通过类或接口来进行的。</p></li><li><p>C++ 更加底层。C++ 允许更直接地操作函数本身，既可以通过函数指针传递行为，也可以通过 Lambda 捕获上下文变量，并将其作为参数传递。这种设计体现了 C++ 语言的灵活性，不需要依赖面向对象的设计。C++ 中的函数传递更接近于函数式编程的思想</p></li></ul><h2 id="使用AOP来实现开头提到的统计时间功能"><a href="#使用AOP来实现开头提到的统计时间功能" class="headerlink" title="使用AOP来实现开头提到的统计时间功能"></a>使用AOP来实现开头提到的统计时间功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声明这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 让 Spring 容器能够管理这个切面。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点：匹配所有在 com.example.service 包下的类和它们的所有方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印方法执行时间</span></span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配所有在 <code>com.example.service</code> 包下的类和它们的所有方法，所以当执行 <code>com.example.service</code> 包下的任意方法时，都会执行 <code>logExecutionTime</code> 方法。</p><h2 id="AOP的关键术语"><a href="#AOP的关键术语" class="headerlink" title="AOP的关键术语"></a>AOP的关键术语</h2><ul><li><strong>切面（Aspect）</strong>：切面是一个类，它包含了一些横切关注点（例如日志记录、事务管理）。在 Spring AOP 中，切面是通过 <code>@Aspect</code> 注解声明的 Java 类。</li><li><strong>连接点（Join Point）</strong>：连接点是在应用执行过程中能够插入切面的点。这些点可以是方法的调用、方法的执行、异常的处理等。在 Spring AOP 中，连接点总是表示方法的执行。</li><li><strong>通知（Advice）</strong>：通知是切面在特定连接点（Join Point）执行的动作。在 Spring AOP 中，有以下几种类型的通知：<ul><li><strong>前置通知（Before Advice）</strong>：在连接点之前执行的通知。</li><li><strong>后置通知（After Advice）</strong>：在连接点之后执行的通知，无论连接点是否正常执行。</li><li><strong>返回通知（After Returning Advice）</strong>：在连接点正常执行后执行的通知。</li><li><strong>异常通知（After Throwing Advice）</strong>：在连接点抛出异常后执行的通知。</li><li><strong>环绕通知（Around Advice）</strong>：在连接点之前和之后执行的通知。</li></ul></li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，它定义了哪些连接点应该被通知。在 Spring AOP 中，切点使用 <code>@Pointcut</code> 注解定义。</li><li><strong>目标对象（Target Object）</strong>：被一个或多个切面通知的对象。</li><li><strong>代理对象（Proxy Object）</strong>：在 Spring AOP 中，代理对象是 Spring 框架创建的对象，它包含了目标对象的增强方法。</li><li><strong>织入（Weaving）</strong>：织入是将切面应用到目标对象并创建代理对象的过程。织入可以发生在编译时、类加载时、运行时。</li><li><strong>引入（Introduction）</strong>：引入允许向现有的类添加新方法和属性。Spring AOP 不支持引入。</li></ul><h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们有一个 <code>UserService</code> 类，它有一个 <code>login</code> 方法，登录时我们希望记录这个方法的执行时间。</p><ol><li>目标对象 (Target Object):<br>这是我们想要增强的对象，也就是 <code>UserService</code> 类中的 <code>login</code> 方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟登录逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging in.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>切面 (Aspect):我们创建一个切面，用于记录方法执行时间的逻辑。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 切点 (Pointcut) - 指定在哪些方法上应用增强逻辑</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allUserServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 通知 (Advice) - 具体的增强逻辑，这里使用环绕通知来记录执行时间</span></span><br><span class="line">    <span class="meta">@Around(&quot;allUserServiceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + executionTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>当我们调用 login 方法时，增强逻辑（记录执行时间）会自动插入：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">userService.login(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;password123&quot;</span>);</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User Alice is logging in.</span><br><span class="line">void UserService.login(String, String) executed in 50ms</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-单元测试</title>
    <link href="https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2024-09-26T02:18:29.000Z</published>
    <updated>2024-09-26T02:59:50.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Mockito和JUnit5进行单元测试。</p><p>需要注入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>使用@Test注解标记测试方法。</li><li>测试代码和被测试代码放到同一个包中。</li></ul><h3 id="示例背景"><a href="#示例背景" class="headerlink" title="示例背景"></a>示例背景</h3><ul><li>假设有一个服务类<code>MockService</code>，其中有一个<code>serviceMethod</code>方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个临时类<code>MockTmp</code>，其中有一个<code>tmpMethod</code>方法。<code>MockTmp</code>的构造器需要传入一个<code>MockService</code>对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个被测试类<code>MockUser</code>，其中包含了<code>MockService</code>类、一个私有方法、一个静态方法、一个公有方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试将会覆盖：私有方法测试、静态方法测试、公有方法测试、构造器测试。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建Mock对象"><a href="#创建Mock对象" class="headerlink" title="创建Mock对象"></a>创建Mock对象</h3><ol><li>使用<code>@Mock</code>注解或<code>Mockito.mock</code>方法创建Mock对象。</li><li>使用<code>@Spy</code>注解或<code>Mockito.spy</code>方法创建Mock对象。</li><li>使用<code>MockBean</code>注解创建Mock对象。</li><li>使用<code>@InjectMocks</code>注解或<code>MockitoAnnotations.initMocks</code>方法注入Mock对象。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line"><span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>@Mock</code>和<code>@Spy</code>注解的区别：</p><ul><li><code>@Mock</code>注解创建的对象是一个真正的Mock对象，它会覆盖被Mock的方法。</li><li><code>@Spy</code>注解创建的对象是一个真实的对象，它会保留被Mock的方法的原始实现。</li></ul><h3 id="Mock方法"><a href="#Mock方法" class="headerlink" title="Mock方法"></a>Mock方法</h3><ol><li>使用<code>Mockito.when</code>方法模拟方法调用。</li><li>使用<code>Mockito.doReturn</code>方法模拟方法调用。</li><li>使用<code>Mockito.doThrow</code>方法模拟方法调用。</li><li>使用<code>Mockito.doNothing</code>方法模拟方法调用。</li><li>使用<code>Mockito.doAnswer</code>方法模拟方法调用。<br>…</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)).thenReturn(<span class="string">&quot;Hello, Tom!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doReturn(<span class="string">&quot;Hello, Tom!&quot;</span>).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doNothing().when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="verify方法和assert方法"><a href="#verify方法和assert方法" class="headerlink" title="verify方法和assert方法"></a>verify方法和assert方法</h3><ol><li>使用<code>Mockito.verify</code>方法验证方法调用。</li><li>使用<code>Assert.assertEquals</code>方法断言方法调用。</li><li>使用<code>Assert.assertTrue</code>方法断言方法调用。<br>…<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(mockService, Mockito.times(<span class="number">1</span>)).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;Hello, Tom!&quot;</span>, mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">Assert.assertTrue(<span class="string">&quot;Hello, Tom!&quot;</span>.equals(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过反射调用私有方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mockito无法直接模拟私有方法，需要通过反射调用。</p><h3 id="测试静态方法"><a href="#测试静态方法" class="headerlink" title="测试静态方法"></a>测试静态方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试公有方法"><a href="#测试公有方法" class="headerlink" title="测试公有方法"></a>测试公有方法</h3><p>被调用的所有方法都mock掉，只测试公有方法。这样可以保证测试的是公有方法的逻辑，而不是依赖的其他方法。<br><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">        <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">        <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">        <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">    Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">    <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">    <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">    <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">        MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">        mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果是<code>test test private test test test</code>。</p><p>可以看出，只有<code>privateMethod</code>方法没有被<code>mock</code>掉，其他方法都被<code>mock</code>掉了。</p><p>目前还没有找到方法去<code>mock</code>类内私有方法（基于不能修改源代码、也不能使用powerMockito）。（如果有大佬看到，求教，邮箱<a href="mailto:&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>）</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">    assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><code>MockService</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;serviceMethod&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; service&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockTmp</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; tmp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUser</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">            <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">            <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">            <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUserTest</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.ArgumentMatchers.anyString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockUserTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Spy</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">        Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">        <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">        <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">        <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">            MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            )&#123;</span><br><span class="line"></span><br><span class="line">            mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">            assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">        assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用Mockito和JUnit5进行单元测试。&lt;/p&gt;
&lt;p&gt;需要注入依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xm</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-组合、继承、接口</title>
    <link href="https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-09-25T01:30:55.000Z</published>
    <updated>2024-09-25T08:43:26.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合和聚合"><a href="#组合和聚合" class="headerlink" title="组合和聚合"></a>组合和聚合</h2><ul><li><p>组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。例如，“汽车拥有引擎”</p></li><li><p>聚合（Aggregation）动态的组合。</p></li></ul><p><strong>组合</strong>：表示整体与部分的关系，整体和部分的生命周期一样，整体不存在了，部分也不存在了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine starting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>聚合</strong>：表示整体与部分的关系，整体和部分的生命周期不一样，整体不存在了，部分还存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departments; <span class="comment">// Company 聚合多个 Department</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.departments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        departments.add(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDepartments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Department department : departments) &#123;</span><br><span class="line">            System.out.println(department.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">hr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;HR&quot;</span>);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.addDepartment(hr); <span class="comment">// Company 聚合 Department</span></span><br><span class="line">        company.addDepartment(it);</span><br><span class="line"></span><br><span class="line">        company.showDepartments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么推荐使用组合而不是继承"><a href="#为什么推荐使用组合而不是继承" class="headerlink" title="为什么推荐使用组合而不是继承"></a>为什么推荐使用组合而不是继承</h2><ul><li>继承在某些特定情况下是有用的，比如实现“是一个”的关系（如 Dog 是一种 Animal），但由于它带来的耦合问题、封装性破坏以及灵活性不足，推荐尽可能优先使用组合。</li><li>组合更加灵活、可维护性更好，能够在不破坏现有代码结构的情况下进行修改和扩展。因此，在大多数情况下，推荐使用组合而不是继承。</li></ul><blockquote><p>组合和继承都可以实现在不修改源代码的情况下，扩张已有的类的功能。但是组合更加灵活，因为它可以在运行时动态地改变对象的行为。</p><p>组合是一种包含关系，一个类的对象包含另一个类的对象，通过调用另一个类的方法来实现功能。</p></blockquote><h2 id="继承和接口的区别"><a href="#继承和接口的区别" class="headerlink" title="继承和接口的区别"></a>继承和接口的区别</h2><p>继承：</p><ul><li>继承是面向对象编程中的一种机制，允许一个类（子类）从另一个类（父类）继承其属性和方法。</li><li>继承表示的是 “is-a” 关系，比如 Dog 继承自 Animal，意味着狗是一种动物。</li><li>在继承关系中，子类继承父类的非私有（private）的成员变量和方法，并且可以重写父类方法。</li><li>Java 中类的继承是单继承的，一个类只能有一个父类。</li></ul><p>接口：</p><ul><li>接口是一种抽象类型，定义了类必须实现的行为，但不提供具体实现。</li><li>接口表示的是 “can-do” 或者 “contract-based” 关系，意味着类必须实现接口中声明的方法。</li><li>一个类可以实现多个接口，这使得接口在多态设计中非常有用。</li><li>Java 支持多接口实现，一个类可以实现多个接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java中的接口和C-中的抽象类的区别"><a href="#Java中的接口和C-中的抽象类的区别" class="headerlink" title="Java中的接口和C++中的抽象类的区别"></a>Java中的接口和C++中的抽象类的区别</h2><h3 id="语法和定义"><a href="#语法和定义" class="headerlink" title="语法和定义"></a>语法和定义</h3><p>Java 的接口：</p><ul><li>接口使用 interface 关键字定义。</li><li>接口中的方法默认是抽象的（不提供实现），并且所有字段默认是 public static final（常量）。</li><li>Java 8 及之后，接口可以有 default 和 static 方法，这些方法可以有实现。</li><li>接口中的所有方法默认是 public，即使没有显式声明。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">prepareForFlight</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing for flight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>C++ 的抽象类：</p><ul><li>抽象类使用 class 关键字定义。</li><li>抽象类可以包含抽象方法（纯虚函数）和具体方法（有实现的方法）。</li><li>抽象类可以包含成员变量，并且可以是各种访问级别：private、protected 或 public。</li><li>纯虚函数在 C++ 中用 &#x3D; 0 标记，表示该方法没有实现，必须由子类实现。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareForFlight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Preparing for flight&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和成员变量"><a href="#构造函数和成员变量" class="headerlink" title="构造函数和成员变量"></a>构造函数和成员变量</h3><p>Java 的接口：</p><p>接口中不能有构造函数，因为接口不能直接实例化。<br>接口不能包含实例变量，只有 static 和 final 常量。</p><p>C++ 的抽象类：</p><p>抽象类可以有构造函数，尽管不能直接实例化抽象类，但它可以用来初始化子类。<br>抽象类可以包含实例变量，这些变量可以在子类中继承。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Java 的接口：</p><p>接口的方法调用通过虚拟机的动态分派机制来实现，通常比直接调用类中的方法略慢。<br>随着 JVM 优化，接口的性能已经非常接近普通类的方法调用。</p><p>C++ 的抽象类：</p><p>C++ 使用虚函数表（vtable）来处理多态调用，性能相对较高，因为是在编译时确定虚函数表，运行时通过指针查找。<br>由于虚函数机制的直接性，C++ 抽象类的多态调用在许多情况下比 Java 的接口实现更快</p><h2 id="Java是如何实现多态的"><a href="#Java是如何实现多态的" class="headerlink" title="Java是如何实现多态的"></a>Java是如何实现多态的</h2><h3 id="编译时多态（静态多态）"><a href="#编译时多态（静态多态）" class="headerlink" title="编译时多态（静态多态）"></a>编译时多态（静态多态）</h3><p>方法重载（Method Overloading）：</p><p>方法重载是指同一个类中可以有多个方法名相同，但参数类型或参数数量不同的方法。根据传入参数的不同，编译器会在编译时决定调用哪个版本的重载方法。</p><p>这是静态多态的表现形式，因为在编译阶段就确定了调用的方法。</p><h3 id="运行时多态（动态多态）"><a href="#运行时多态（动态多态）" class="headerlink" title="运行时多态（动态多态）"></a>运行时多态（动态多态）</h3><p>方法重写（Method Overriding）：</p><p>运行时多态的核心在于方法重写。当一个子类继承父类，并在子类中提供了对父类方法的不同实现时，Java 会在运行时根据对象的实际类型决定调用哪一个方法。</p><p>通过父类引用指向子类对象，调用重写的方法时，实际执行的是子类的实现。这是在运行时根据对象的实际类型动态决定的，因此称为动态多态。<br>实现方式：虚方法机制：</p><p>Java 中的所有非 final 和 private 方法都被认为是虚方法。虚方法是可以被子类重写的方法，Java 使用虚方法表（vtable）来实现多态。</p><p>当调用一个方法时，JVM 会通过对象的实际类型在运行时决定调用哪个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();  <span class="comment">// Animal 类型引用</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        myAnimal.sound();  <span class="comment">// 调用的是 Animal 的 sound() 方法</span></span><br><span class="line">        myDog.sound();     <span class="comment">// 调用的是 Dog 的 sound() 方法</span></span><br><span class="line">        myCat.sound();     <span class="comment">// 调用的是 Cat 的 sound() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>Java 通过接口也可以实现多态。当一个类实现了某个接口时，接口引用可以指向该类的实例，并且在运行时会根据对象的实际类型执行具体的方法实现。</p><h3 id="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"><a href="#当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？" class="headerlink" title="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"></a>当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？</h3><p>如何确定调用的是哪一个接口的实现？</p><ul><li>编译时：当你传入一个接口类型的参数时，编译器只会检查这个对象是否实现了该接口，但不会关心具体是哪一个实现类。</li><li>运行时：在程序运行时，JVM 会根据<strong>传入对象</strong>的实际类型决定调用具体实现类的方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合和聚合&quot;&gt;&lt;a href=&quot;#组合和聚合&quot; class=&quot;headerlink&quot; title=&quot;组合和聚合&quot;&gt;&lt;/a&gt;组合和聚合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm中的temperature</title>
    <link href="https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/"/>
    <id>https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/</id>
    <published>2024-09-23T07:32:39.000Z</published>
    <updated>2024-09-25T01:59:43.925Z</updated>
    
    <content type="html"><![CDATA[<p>$$<br>\begin{aligned}<br>\text { for } i &amp; &#x3D;1, \ldots, L: \<br>x_i &amp; \sim p\left(x_i \mid x_{1: i-1}\right)^{1 &#x2F; T},<br>\end{aligned}<br>$$</p><p>其中  $T≥0$  是一个控制我们希望从语言模型中得到多少随机性的温度参数：</p><ul><li>T&#x3D;0：确定性地在每个位置 i 选择最可能的词元 $x_{i}$</li><li>T&#x3D;1：从纯语言模型“正常（normally）”采样</li><li>T&#x3D;∞：从整个词汇表上的均匀分布中采样</li></ul><p>这个公式和描述与语言模型的温度调节（temperature scaling）有关，常用于生成任务（如文本生成、语言建模）中，控制模型生成的随机性。它影响从模型的概率分布中采样的方式，使生成的文本更加多样化或更加确定。</p><p><img src="/../imgs/image-48.png" alt="alt text"><br><img src="/../imgs/image-49.png" alt="alt text"><br><img src="/../imgs/image-50.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$$&lt;br&gt;&#92;begin{aligned}&lt;br&gt;&#92;text { for } i &amp;amp; &amp;#x3D;1, &#92;ldots, L: &#92;&lt;br&gt;x_i &amp;amp; &#92;sim p&#92;left(x_i &#92;mid x_{1: i-1}&#92;right)^{1 &amp;#x2F; T},&lt;br</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>one-hot编码</title>
    <link href="https://kelinkong.github.io/2024/09/23/one-hot%E7%BC%96%E7%A0%81/"/>
    <id>https://kelinkong.github.io/2024/09/23/one-hot%E7%BC%96%E7%A0%81/</id>
    <published>2024-09-23T06:22:51.000Z</published>
    <updated>2024-09-23T06:32:44.834Z</updated>
    
    <content type="html"><![CDATA[<p>One-hot 编码是一种将类别数据（比如文本或分类标签）转换为数值表示的方法。它的基本思想是用一个二进制向量来表示每个类别，其中只有一个位置为1，其他位置全为0。</p><p>为什么需要 One-hot 编码？<br>在机器学习中，算法通常无法直接处理文字或类别，需要先将它们转化为数值才能输入模型。而 One-hot 编码就是其中一种常用的数值化方法。</p><h2 id="具体操作步骤："><a href="#具体操作步骤：" class="headerlink" title="具体操作步骤："></a>具体操作步骤：</h2><ol><li>记录每个特征的类别数量<br>在编码时，记录下每个特征有多少类别以及每个类别的顺序。例如：</li></ol><p>颜色特征：有3个类别 -&gt; [“红色”, “绿色”, “蓝色”]</p><p>大小特征：有2个类别 -&gt; [“小”, “大”]</p><ol start="2"><li>确定编码位置<br>在编码时，按照顺序将每个特征的 One-hot 向量拼接起来。根据特征的类别数量，确定每个特征占据向量中的哪些位置。</li></ol><p>例如：</p><p>颜色有3个类别，所以编码的第1到3个位置对应颜色：</p><p>红色 [1, 0, 0]<br>绿色 [0, 1, 0]<br>蓝色 [0, 0, 1]</p><p>大小有2个类别，所以编码的第4到5个位置对应大小：</p><p>小 [1, 0]<br>大 [0, 1]</p><p>因此，对于编码向量 [1, 0, 0, 0, 1]，我们知道：</p><p>前3个元素 [1, 0, 0] 对应颜色特征。<br>后2个元素 [0, 1] 对应大小特征。</p><ol start="3"><li>解码过程<br>根据上面记录的规则和位置，我们可以解码向量：</li></ol><p>前3个位置是 [1, 0, 0]，对应颜色特征 -&gt; 红色。<br>后2个位置是 [0, 1]，对应大小特征 -&gt; 大。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义特征类别</span></span><br><span class="line">color_categories = [<span class="string">&quot;红色&quot;</span>, <span class="string">&quot;绿色&quot;</span>, <span class="string">&quot;蓝色&quot;</span>]</span><br><span class="line">size_categories = [<span class="string">&quot;小&quot;</span>, <span class="string">&quot;大&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_encode</span>(<span class="params">color, size</span>):</span><br><span class="line">    color_one_hot = [<span class="number">1</span> <span class="keyword">if</span> color == c <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> color_categories]</span><br><span class="line">    size_one_hot = [<span class="number">1</span> <span class="keyword">if</span> size == s <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> s <span class="keyword">in</span> size_categories]</span><br><span class="line">    <span class="keyword">return</span> color_one_hot + size_one_hot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解码函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">one_hot_decode</span>(<span class="params">encoded_vector</span>):</span><br><span class="line">    color_encoded = encoded_vector[:<span class="built_in">len</span>(color_categories)]</span><br><span class="line">    size_encoded = encoded_vector[<span class="built_in">len</span>(color_categories):]</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 通过位置找到相应的类别</span></span><br><span class="line">    color = color_categories[color_encoded.index(<span class="number">1</span>)]</span><br><span class="line">    size = size_categories[size_encoded.index(<span class="number">1</span>)]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> color, size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">encoded = one_hot_encode(<span class="string">&quot;红色&quot;</span>, <span class="string">&quot;大&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;编码: <span class="subst">&#123;encoded&#125;</span>&quot;</span>)  <span class="comment"># 输出: [1, 0, 0, 0, 1]</span></span><br><span class="line"></span><br><span class="line">decoded = one_hot_decode(encoded)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;解码: <span class="subst">&#123;decoded&#125;</span>&quot;</span>)  <span class="comment"># 输出: (&#x27;红色&#x27;, &#x27;大&#x27;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>简单直观：<ul><li>One-hot 编码非常容易理解和实现，每个类别被表示为独立的二进制向量，清晰明确。</li></ul></li><li>无序关系：<ul><li>One-hot 编码不会引入类别之间的顺序关系或大小关系，这对于类别之间没有天然顺序的特征（如颜色、城市名称等）是非常合适的。</li></ul></li><li>减少分类误差：<ul><li>不同类别之间不会有直接的数值距离。例如，如果用 1, 2, 3 表示不同类别，模型可能会认为“1”和“2”之间的距离比“1”和“3”之间更近，但使用 One-hot 编码就避免了这种误解。</li></ul></li><li>广泛使用：<ul><li>在各种分类算法和神经网络中，One-hot 编码是一种标准的类别处理方法，特别是在 NLP、图像分类等领域。</li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>维度爆炸：<ul><li>高维稀疏性：如果类别特征有很多不同的类别，One-hot 编码会导致非常大的稀疏矩阵。比如有1000个不同的类别，One-hot 编码后每个数据点的向量长度就是1000，这不仅增加了存储开销，还可能导致计算性能下降。</li></ul></li><li>无法捕捉类别之间的相似性：<ul><li>One-hot 编码把每个类别都看作彼此独立，不能表达类别之间的相似性或关联。例如，“猫”和“狗”之间可能比“猫”和“车”更相似，但 One-hot 编码无法反映这种信息。</li></ul></li><li>不适用于高基数特征：<ul><li>如果类别的取值非常多（例如用户ID、商品ID等高基数特征），One-hot 编码会生成过大的编码向量，导致计算资源消耗过高，难以处理。</li></ul></li><li>缺乏信息量：<ul><li>虽然 One-hot 编码能够区分类别，但它不包含类别的任何附加信息。每个类别仅通过单独的位表示，不包括类别的重要性、相关性等信息。</li></ul></li></ul><h3 id="何时使用-One-hot-编码："><a href="#何时使用-One-hot-编码：" class="headerlink" title="何时使用 One-hot 编码："></a>何时使用 One-hot 编码：</h3><ul><li>类别数量较少：如果某个特征的类别数量适中（比如10~100个类别），One-hot 编码通常是很好的选择。</li><li>类别没有顺序关系：当类别之间没有自然的顺序或等级时，One-hot 编码能够避免引入不必要的偏差。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;One-hot 编码是一种将类别数据（比如文本或分类标签）转换为数值表示的方法。它的基本思想是用一个二进制向量来表示每个类别，其中只有一个位置为1，其他位置全为0。&lt;/p&gt;
&lt;p&gt;为什么需要 One-hot 编码？&lt;br&gt;在机器学习中，算法通常无法直接处理文字或类别，需要先</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>提示工程</title>
    <link href="https://kelinkong.github.io/2024/09/23/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/"/>
    <id>https://kelinkong.github.io/2024/09/23/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-09-23T02:24:55.000Z</published>
    <updated>2024-09-23T06:27:09.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h3><p>参考<a href="https://www.promptingguide.ai/zh">提示工程指南</a></p><ul><li>Temperature：准确度和发散程度</li><li>Top_p：准确度和发散程度</li><li>Max Length：回复的最大token数</li><li>Stop Sequences：组织模型生成token</li><li>Frequency Penalty</li><li>Presence Penalty</li></ul><h3 id="提示词格式"><a href="#提示词格式" class="headerlink" title="提示词格式"></a>提示词格式</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><p>提示词可以包含以下任意要素：</p><p>指令：想要模型执行的特定任务或指令。  例如：请将文本分为中性、否定或肯定.</p><p>上下文：包含外部信息或额外的上下文信息，引导语言模型更好地响应。 </p><p>输入数据：用户输入的内容或问题。  例如：我觉得食物还可以。</p><p>输出指示：指定输出的类型或格式。 例如：情绪：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请将文本分为中性、否定或肯定</span><br><span class="line">文本：我觉得食物还可以。</span><br><span class="line">情绪：</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>你可以使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提取以下文本中的地名。</span><br><span class="line"></span><br><span class="line">所需格式：</span><br><span class="line">地点：&lt;逗号分隔的公司名称列表&gt;</span><br><span class="line"></span><br><span class="line">输入：“虽然这些发展对研究人员来说是令人鼓舞的，但仍有许多谜团。里斯本未知的香帕利莫德中心的神经免疫学家 Henrique Veiga-Fernandes 说：“我们经常在大脑和我们在周围看到的效果之间有一个黑匣子。”“如果我们想在治疗背景下使用它，我们实际上需要了解机制。””</span><br></pre></td></tr></table></figure><h4 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h4><ul><li>避免不明确，尽量数字化，如几句话：2～3句话</li><li>避免说不要做什么，而要说要做什么</li></ul><h4 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h4><p>Explain the above in one sentence</p><p>Mention the large language model based product mentioned in the paragraph above:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classify the text into neutral, negative or positive. </span><br><span class="line"></span><br><span class="line">Text: I think the vacation is okay.</span><br><span class="line">Sentiment: neutral </span><br><span class="line"></span><br><span class="line">Text: I think the food was okay. </span><br><span class="line">Sentiment:</span><br></pre></td></tr></table></figure><h3 id="少样本提示"><a href="#少样本提示" class="headerlink" title="少样本提示"></a>少样本提示</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“whatpu”是坦桑尼亚的一种小型毛茸茸的动物。一个使用whatpu这个词的句子的例子是：</span><br><span class="line">我们在非洲旅行时看到了这些非常可爱的whatpus。</span><br><span class="line">“farduddle”是指快速跳上跳下。一个使用farduddle这个词的句子的例子是：</span><br></pre></td></tr></table></figure><p><strong>标签</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这太棒了！// Negative</span><br><span class="line">这太糟糕了！// Positive</span><br><span class="line">哇，那部电影太棒了！// Positive</span><br><span class="line">多么可怕的节目！//</span><br></pre></td></tr></table></figure><h3 id="链式思考"><a href="#链式思考" class="headerlink" title="链式思考"></a>链式思考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这组数中的奇数加起来是偶数：4、8、9、15、12、2、1。</span><br><span class="line">A：将所有奇数相加（9、15、1）得到25。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、10、19、4、8、12、24。</span><br><span class="line">A：将所有奇数相加（17、19）得到36。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：16、11、14、4、8、13、24。</span><br><span class="line">A：将所有奇数相加（11、13）得到24。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、9、10、12、13、4、2。</span><br><span class="line">A：将所有奇数相加（17、9、13）得到39。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：15、32、5、13、82、7、1。</span><br><span class="line">A：</span><br></pre></td></tr></table></figure><p><strong>自动思维链</strong><br>Auto-CoT 主要由两个阶段组成：</p><ul><li>阶段1：问题聚类：将给定问题划分为几个聚类</li><li>阶段2：演示抽样：从每组数组中选择一个具有代表性的问题，并使用带有简单启发式的 Zero-Shot-CoT 生成其推理链</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;模型设置&quot;&gt;&lt;a href=&quot;#模型设置&quot; class=&quot;headerlink&quot; title=&quot;模型设置&quot;&gt;&lt;/a&gt;模型设置&lt;/h</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-开发实战一</title>
    <link href="https://kelinkong.github.io/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>https://kelinkong.github.io/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</id>
    <published>2024-09-05T03:47:07.000Z</published>
    <updated>2024-09-25T01:31:26.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>开发一个通用项目管理项目，前端使用react，后端使用Spring Boot</p><h2 id="开发中遇到的知识点"><a href="#开发中遇到的知识点" class="headerlink" title="开发中遇到的知识点"></a>开发中遇到的知识点</h2><h3 id="Spring-Boot的开发框架"><a href="#Spring-Boot的开发框架" class="headerlink" title="Spring Boot的开发框架"></a>Spring Boot的开发框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">project-root/</span><br><span class="line">│</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/example/project/</span><br><span class="line">│   │   │       ├── controller/ # 存放控制器类,处理HTTP请求</span><br><span class="line">│   │   │       ├── service/ # 存放业务逻辑类</span><br><span class="line">│   │   │       ├── repository/ #  存放数据访问层的接口和实现</span><br><span class="line">│   │   │       ├── model/ # 存放实体类和数据传输对象(DTO)</span><br><span class="line">│   │   │       ├── └── dto/ </span><br><span class="line">│   │   │       └── ProjectApplication.java # Spring Boot的主应用类,包含main()方法</span><br><span class="line">│   │   │</span><br><span class="line">│   │   └── resources/</span><br><span class="line">│   │       ├── static/ # 存放静态资源如CSS、JavaScript、图片等。</span><br><span class="line">│   │       ├── templates/ # 存放模板文件(如Thymeleaf模板)。</span><br><span class="line">│   │       ├── db/ # 存放sql文件，scheme.sql  data.sql</span><br><span class="line">│   │       └── application.properties # 主配置文件,用于设置应用程序属性。</span><br><span class="line">│   │</span><br><span class="line">│   └── test/  # 存放测试代码。</span><br><span class="line">│       └── java/</span><br><span class="line">│           └── com/example/project/</span><br><span class="line">│</span><br><span class="line">├── target/ # Maven构建生成的目录,包含编译后的类文件和可执行JAR</span><br><span class="line">├── pom.xml # Maven项目配置文件,定义项目依赖和构建过程。</span><br><span class="line">└── README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p><a href="https://javabetter.cn/springboot/lombok.html">Spring Boot 整合 Lombok，用注解简化 Java 代码，比如说 getter和setter | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>Lombok可以更方便的生成set、get方法，在Maven管理的Java项目中，需要添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.6&lt;/version&gt;   # 在jdk21以上的版本，需要设置版本为1.18.30以上</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>其中<code> scope=provided</code>，就说明 Lombok 只在编译阶段生效。也就是说，Lombok 会在编译期静悄悄地将带 Lombok 注解的源码文件正确编译为完整的 class 文件。</p><p>SpringBoot 2.1.x 版本后不需要再显式地添加 Lombok 依赖了。之后，还需要为 Intellij IDEA 安装 Lombok 插件，否则 Javabean 的 getter &#x2F; setter 就无法自动编译，也就不能被调用。不过，新版的 Intellij IDEA 也已经内置好了，不需要再安装。</p><h4 id="常用的Lombok注解"><a href="#常用的Lombok注解" class="headerlink" title="常用的Lombok注解"></a>常用的Lombok注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Setter</span> <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>. <span class="comment">// @Data 注解可以生成 getter / setter、equals、hashCode，以及 toString，是个总和的选项。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p><a href="https://javabetter.cn/springboot/jpa.html">Spring Boot 整合 JPA | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>JPA（Java Persistence API）是一种Java对象持久化技术，它提供了一种将Java对象映射到关系数据库表的机制。当我们定义一个实体类时，JPA会根据类上的注解（如@Entity、@Table、@Column等）来生成对应的数据库表结构。</p><p>可以使用JPA创建：</p><ul><li>Entity（User）</li><li>Repository（UserRepository）</li></ul><p>JPA可以通过实体类来生成数据库表（spring.jpa.hibernate.ddl-auto），常见的配置有：（在生成环境中，不建议使用create、create、drop、update）</p><ul><li>create: 每次应用程序启动时，都会删除现有的数据库表，并根据实体类重新创建。</li><li>create-drop: 与create类似，但是在应用程序关闭时会删除所有表。</li><li>update: 每次应用程序启动时，会根据实体类的定义来更新数据库表结构。</li><li>validate: 仅验证数据库表结构与实体类是否匹配，不会做任何修改。</li><li>none：不做任何操作。</li></ul><p>在<code>application.properties</code>中设置：<code>spring.jpa.hibernate.ddl-auto=update</code></p><p><strong>更新数据库表时，不会自动更新实体类</strong></p><p>JPA生成Repository内置了一些方法，但是也可以通过注解的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeamRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Team, Integer&gt;, JpaSpecificationExecutor&lt;Team&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all teams</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t&quot;)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findAllTeams</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a team by its ID</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t WHERE t.id = :id&quot;)</span></span><br><span class="line">    Team <span class="title function_">findTeamById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom SQL query to find teams by name</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM teams WHERE name = :name&quot;, nativeQuery = true)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findTeamsByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Query注解的nativeQuery属性作用：</p><ul><li>nativeQuery&#x3D;false：使用HQL，JPA会根据实体类和关联关系自动生成SQL。</li><li>nativeQuery&#x3D;true：使用原生SQL，JPA直接执行你写的SQL语句</li></ul><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p>在Spring Boot中，<code>@RequestMapping</code> 是一个非常基础且强大的注解，用于将HTTP请求映射到特定的处理方法上。它可以配置请求路径、HTTP方法（GET、POST、PUT、DELETE等）、参数等信息。</p><p>为了简化开发，Spring Boot提供了几个更具体的注解，它们都是<code>@RequestMapping</code>的缩写形式：</p><ul><li><strong>@GetMapping:</strong> 通常用于获取数据，比如查询列表、获取详情等。</li><li><strong>@PostMapping:</strong> 通常用于创建新的资源，比如添加用户、提交表单等。</li><li><strong>@PutMapping:</strong> 通常用于更新整个资源，比如修改用户信息。</li><li><strong>@DeleteMapping:</strong> 通常用于删除资源，比如删除用户。</li><li><strong>@PatchMapping:</strong> 通常用于部分更新资源，比如修改用户的部分信息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/teams&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TeamService teamService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TeamController</span><span class="params">(TeamService teamService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.teamService = teamService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;teamId&#125;/members/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteMember</span><span class="params">(<span class="meta">@PathVariable</span> Integer teamId, <span class="meta">@PathVariable</span> Integer userId)</span> &#123;</span><br><span class="line">    teamService.deleteMember(teamId, userId);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestMapping</code>注解可以接受多个参数，如<code>value</code>、<code>method</code>、<code>params</code>、<code>headers</code>等，用于指定请求路径、HTTP方法、请求参数、请求头等信息。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/api/teams&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Team&gt; <span class="title function_">getTeams</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> teamService.getTeams();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用到的注解"><a href="#用到的注解" class="headerlink" title="用到的注解"></a>用到的注解</h3><h4 id="注解是什么？"><a href="#注解是什么？" class="headerlink" title="注解是什么？"></a>注解是什么？</h4><p>注解（Annotation）是一种提供元数据（metadata）的机制。它可以用于标记类、方法、字段等程序元素，从而为编译器或运行时环境提供额外的信息。注解本身不会影响程序的执行逻辑，但可以被编译器、IDE、框架等工具读取并进行相应的处理。</p><h4 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h4><p>注解本质上是一个接口。当我们定义一个注解时，实际上是在定义一个接口，并且这个接口继承自<code>java.lang.annotation.Annotation</code>接口。</p><ul><li><strong>注解处理器：</strong><ul><li>注解处理器是实现注解功能的关键。它们在编译时或运行时读取注解信息，并根据注解的定义执行相应的操作。</li><li>常用的注解处理器有：<ul><li><strong>编译时注解处理器：</strong> 在编译时处理注解，如APT（Annotation Processing Tool）。</li><li><strong>运行时注解处理器：</strong> 在运行时处理注解，如反射机制。</li></ul></li></ul></li><li><strong>反射机制：</strong><ul><li>通过反射机制，可以在运行时获取类、方法、字段的注解信息，并动态地调用这些元素。</li></ul></li></ul><h4 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h4><p>注解在Java开发中发挥着重要的作用，主要有以下几个方面：</p><ul><li><strong>提供元数据：</strong> 为编译器、IDE、框架等工具提供额外的信息，如：<ul><li><strong>生成代码：</strong> 比如Lombok注解可以自动生成getter、setter、构造方法等。</li><li><strong>配置信息：</strong> 比如Spring框架中的<code>@Autowired</code>注解用于自动装配Bean。</li><li><strong>验证：</strong> 比如Hibernate Validator中的<code>@NotNull</code>注解用于验证字段不能为空。</li></ul></li><li><strong>减少重复代码：</strong> 通过注解可以减少重复的代码编写，提高开发效率。</li><li><strong>提高代码可读性：</strong> 注解可以明确地表达代码的意图，提高代码的可维护性。</li><li><strong>实现AOP：</strong> 注解可以作为AOP切入点，实现横切关注点。</li></ul><h4 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h4><ul><li><strong>内置注解：</strong> Java内置了一些注解，如<code>@Override</code>、<code>@Deprecated</code>等。</li><li><strong>元注解：</strong> 用于定义注解的注解，如<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>等。</li><li><strong>自定义注解：</strong> 开发者可以自定义注解，以满足特定的需求</li></ul><h4 id="用到的注解-1"><a href="#用到的注解-1" class="headerlink" title="用到的注解"></a>用到的注解</h4><ul><li>声明 Bean 的注解<br>@Component：通用注解，可以标注任何类为 Spring 组件。<br>@Repository：专用于数据访问层（DAO）的组件。<br>@Service：专用于业务逻辑层（Service）的组件。<br>@Controller：专用于表现层（Controller）的组件。</li><li>注入 Bean 的注解@Autowired：根据类型自动装配 Bean，可以用于字段、方法参数和构造函数。<br>@Qualifier：配合 @Autowired 使用，根据 Bean 的名称进行注入。<br>@Resource：来自 JSR-250，也可以用于注入 Bean，功能类似于 @Autowired。</li><li>配置类相关的注解<br>@Configuration：声明一个配置类，等同于 XML 配置文件。<br>@ComponentScan：指定 Spring 在创建容器时要扫描的包。<br>@Bean：把方法的返回值作为 Bean 对象存入 Spring 容器。</li><li>切面（AOP）相关的注解<br>@Aspect：声明一个切面。<br>@Before、@After、@Around：定义切面中的增强方法。<br>@Pointcut：声明切点，用于定义拦截规则。</li><li>其他常用注解<br>@Value：注入配置文件中的值。<br>@RequestMapping：用于处理 Web 请求。<br>@ResponseBody：将方法的返回值直接写入 HTTP 响应体。<br>@RequestBody：将 HTTP 请求中的 JSON 数据绑定到 Java 对象。<br>@PathVariable：用于获取路径变量的值。<br>@Transactional：声明事务。</li></ul><h2 id="工具-技巧使用"><a href="#工具-技巧使用" class="headerlink" title="工具&#x2F;技巧使用"></a>工具&#x2F;技巧使用</h2><p>Intellj idea快速创建某个接口的实现类：<code>alt+enter</code></p><h3 id="接口类和实现类的调用"><a href="#接口类和实现类的调用" class="headerlink" title="接口类和实现类的调用"></a>接口类和实现类的调用</h3><p>Java中的接口类类似C++中的抽象类。</p><p>我的tokenServiceImpl是tokenService接口的实现，我在别的class中调用这个服务时，我应该使用tokenService还是tokenServiceImpl？</p><blockquote><p>应该使用tokenService。</p><ul><li><strong>依赖注入（Dependency Injection）：</strong> 当 Spring 容器管理你的 Bean 时，它会将 <code>TokenServiceImpl</code> 的实例注入到需要使用 token 服务的类中，但是注入的变量名通常是接口名 <code>tokenService</code>，而不是实现类名 <code>tokenServiceImpl</code>。</li><li><strong>面向接口编程：</strong> 面向接口编程是一种良好的编程习惯。通过使用接口 <code>tokenService</code>，你的代码与具体的实现类解耦，提高了代码的可维护性、可测试性和扩展性。</li><li><strong>多态：</strong> 由于 Java 的多态特性，当你使用 <code>tokenService</code> 时，实际上调用的是 <code>TokenServiceImpl</code> 中实现的方法。这样，如果你以后想更换 <code>TokenServiceImpl</code> 的实现，只需要修改 Spring 配置，而不需要修改调用代码。</li></ul></blockquote><p><strong>Service的注解应该放到实现类上，而不是接口类。</strong></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>为什么要使用JUnit4、mock和verify？</p><ul><li><strong>JUnit4</strong> 是Java中最流行的单元测试框架，提供了丰富的断言和测试注解。</li><li><strong>mock</strong> （模拟对象）可以让我们在测试中替换掉真实对象，从而隔离被测代码，方便测试。</li><li><strong>verify</strong> 用于验证模拟对象的方法调用情况，确保代码的正确性。</li></ul><p>示例，测试一个简单的<code>UserService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 依赖注入,在单元测试中，使用mock模拟</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建UserDao的模拟对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> mock(UserDao.class);</span><br><span class="line">        <span class="comment">// 创建期望的User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">expectedUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">        <span class="comment">// 设置模拟对象的行为，当userDao调用getUserById(1)时，返回期望的User对象</span></span><br><span class="line">        when(userDao.getUserById(<span class="number">1</span>)).thenReturn(expectedUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UserService实例，这是我们要测试的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(userDao);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用UserService的方法，这是我们要测试的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">actualUser</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证UserDao的getUserById方法被调用了一次</span></span><br><span class="line">        verify(userDao, times(<span class="number">1</span>)).getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言实际的User对象和期望的User对象相等</span></span><br><span class="line">        assertEquals(expectedUser, actualUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"><a href="#在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？" class="headerlink" title="在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"></a>在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？</h3><p>@RequestMapping 注解在 Spring MVC 中起着至关重要的作用，它建立了 HTTP 请求与控制器方法之间的映射关系。当前端发送一个 HTTP 请求时，Spring MVC 框架会根据请求的 URL，去寻找匹配的 @RequestMapping 注解，然后调用对应的控制器方法来处理这个请求。</p><p>整个过程可以简化为以下几步：</p><ol><li><strong>前端发送请求:</strong> 用户在浏览器中输入 URL，浏览器将这个请求发送到服务器。</li><li><strong>Spring MVC 拦截请求:</strong> Spring MVC 作为 Web 框架，会拦截所有的 HTTP 请求。</li><li><strong>匹配 @RequestMapping:</strong> Spring MVC 会根据请求的 URL，去容器中查找所有被<code>@RequestMapping</code> 注解标注的方法，并尝试匹配。</li><li><strong>执行控制器方法:</strong> 如果找到了匹配的方法，Spring MVC 就会调用这个方法，并把请求参数传递给方法。</li><li><strong>返回响应:</strong> 控制器方法执行完成后，会返回一个 ModelAndView 对象，Spring MVC 会将这个对象转换为 HTTP 响应，返回给前端。</li></ol><h3 id="Spring-MVC-与-Socket-的关系"><a href="#Spring-MVC-与-Socket-的关系" class="headerlink" title="Spring MVC 与 Socket 的关系"></a>Spring MVC 与 Socket 的关系</h3><ul><li>Spring MVC 的工作原理： Spring MVC 作为一款基于 Servlet 的 Web 框架，其核心是处理 HTTP 请求。当一个 HTTP 请求到达服务器时，Servlet 容器会将请求封装成 HttpServletRequest 和 HttpServletResponse 对象，然后交给 DispatcherServlet 处理。<ul><li>Servlet 和 Socket： Servlet 本质上是运行在 Servlet 容器中的一个 Java 类，它提供了处理 HTTP 请求和响应的接口。Servlet 容器（如 Tomcat、Jetty）则是基于 Socket 实现的，负责监听网络端口，接收客户端的 HTTP 请求，并将其传递给 Servlet。</li></ul></li><li>Spring MVC 与 Socket 的关系：<ul><li>间接依赖： Spring MVC 依赖于 Servlet 容器，而 Servlet 容器直接基于 Socket 工作。因此，Spring MVC 可以说是间接地利用了 Socket 的功能。</li><li>抽象层级： Spring MVC 提供了一层更高级的抽象，将开发者从底层的 Socket编程细节中解放出来。开发者只需要关注业务逻辑，而不需要关心如何处理网络连接、协议解析等。</li></ul></li><li>Socket 的作用：<ul><li>建立连接： Socket 用于在客户端和服务器之间建立网络连接。</li><li>数据传输： 通过 Socket 进行数据传输，实现客户端和服务器之间的通信。</li><li>协议解析： Socket 负责解析 HTTP 协议，将请求和响应数据进行编码和解码。</li></ul></li></ul><h3 id="当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？"><a href="#当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？" class="headerlink" title="当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？"></a>当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？</h3><p><strong>一般情况下，在 Spring Boot 中，我们不需要手动创建数据库连接池。</strong> Spring Boot 默认集成了 HikariCP 这个高性能的数据库连接池，并提供了自动配置。只需在配置文件（如 application.properties 或 application.yml）中配置数据库连接信息，Spring Boot 就会自动创建并管理连接池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mydatabase</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=yourpassword</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver <span class="comment">// 这个配置项在 Spring Boot 中用于指定连接数据库的 JDBC 驱动类的全限定名。</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-如何处理多个用户请求"><a href="#Spring-Boot-如何处理多个用户请求" class="headerlink" title="Spring Boot 如何处理多个用户请求?"></a>Spring Boot 如何处理多个用户请求?</h3><p>通常情况下，不需要手动创建线程池。 Spring Boot 已经为您内置了许多自动配置，其中就包括线程池的创建和管理。</p><p>Spring Boot 默认的线程池</p><ul><li>Tomcat线程池: 对于传统的 Servlet 容器 Tomcat，Spring Boot 会默认使用 Tomcat 的线程池来处理 HTTP 请求。</li><li>Undertow线程池: 如果您使用的是 Undertow 作为嵌入式 Servlet 容器，那么 Spring Boot 会使用 Undertow 的线程池。</li></ul><p>这些线程池通常已经经过优化，可以满足大多数应用的并发处理需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h2&gt;&lt;p&gt;开发一个通用项目管理项目，前端使用react，后端使用Spring Boot&lt;/p&gt;
&lt;h2 id=&quot;开发中遇到的知识点&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-代码规范</title>
    <link href="https://kelinkong.github.io/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://kelinkong.github.io/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-09-04T01:56:31.000Z</published>
    <updated>2024-09-25T01:31:32.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><table><thead><tr><th align="center">类型</th><th>风格</th><th>示例</th></tr></thead><tbody><tr><td align="center">变量名</td><td>驼峰</td><td>localValue</td></tr><tr><td align="center">方法名</td><td>驼峰</td><td>getValue</td></tr><tr><td align="center">类名</td><td>首字母大写</td><td>JavaServer</td></tr><tr><td align="center">包名</td><td>小写，分隔符之间有且仅有一个自然语义的单词</td><td>com.excample.demo</td></tr><tr><td align="center">枚举类型&#x2F;常量</td><td>全大写，单词间用下划线隔开</td><td>MAX_STOCK_COUNT</td></tr></tbody></table><p><strong>禁止的命名：</strong></p><ul><li>不能以下划线&#x2F;&amp;开始或结束</li><li>禁止中英文混合</li><li>布尔类型不要加is前缀<ul><li>统一使用 xxx&#x2F;setXxx&#x2F;getXxx</li></ul></li></ul><h3 id="推荐的代码风格"><a href="#推荐的代码风格" class="headerlink" title="推荐的代码风格"></a>推荐的代码风格</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ol><li>如果变量值仅在一个固定范围内变化，使用enum类型来定义。如SRTING、SUMMER、AUTUMN、WINTER</li><li>如果大括号内为空，简洁地写成{},无需换行和空格，如果是非空代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getUserID</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>小括号和字符间不留空格，与保留字需要有空格（if&#x2F;while&#x2F;for）</li><li>锁进为4个空格、注释的双斜线和内容之间有且仅有一个空格</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>类、类属性、类方法注释使用Javadoc的规范，使用<code>/* xxx */</code></li><li>所有抽象方法（包括接口）都必须要用Javadoc注释，除了返回值、参数、异常说明外，还必须指出什么方法做什么事情</li><li>枚举类型需要注释</li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li>每行最多包含一条语句</li><li>当switch括号内的变量类型为String时，必须先进行null判断</li><li>在高并发场景中，避免使用等于作为中断或退出的条件，应该用大于等于或者小于等于</li><li>不要在表达式中插入赋值语句</li><li>避免使用取反逻辑运算符</li></ol><h2 id="高级编码规范"><a href="#高级编码规范" class="headerlink" title="高级编码规范"></a>高级编码规范</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>使用类名直接引用<strong>静态</strong>类型和<strong>静态方法</strong></li><li>避免使用构造函数创建字符串对象</li><li>所有的覆写方法都必须要加<code>@Override</code>注解</li><li>尽量不使用可变参数编程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h2&gt;&lt;h3 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-语法基础篇</title>
    <link href="https://kelinkong.github.io/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://kelinkong.github.io/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2024-08-28T06:13:28.000Z</published>
    <updated>2024-09-26T03:31:52.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扫盲，Java和C-的一些区别"><a href="#扫盲，Java和C-的一些区别" class="headerlink" title="扫盲，Java和C++的一些区别"></a>扫盲，Java和C++的一些区别</h3><p><strong>Java项目需要编译吗？底层编译原理和C++有什么不同？</strong></p><ol><li>   编译输出：</li></ol><ul><li>Java：编译输出的是平台无关的字节码文件（.class 文件），这些字节码可以在任何安装了 JVM 的平台上运行。</li><li>C++：编译输出的是特定平台的机器码文件（如 .exe 文件），这些文件只能在编译时指定的平台上运行。</li></ul><ol start="2"><li>   跨平台性：</li></ol><ul><li>Java：通过 JVM 的跨平台特性，Java 程序可以“一次编写，到处运行”（Write Once, Run Anywhere）。</li><li>C++：需要为每个平台分别编译代码才能生成可以执行的文件，不具备 Java 那样的跨平台能力。</li></ul><ol start="3"><li>   运行时性能：</li></ol><ul><li>Java：由于字节码需要在运行时通过 JVM 翻译为机器码，可能会在启动时稍慢，但 JIT 编译可以在运行期间优化代码，提高性能。</li><li>C++：由于是直接编译为机器码，C++ 程序的启动和运行速度通常会比 Java 程序快，尤其是在性能关键的应用中。</li></ul><ol start="4"><li>   编译速度：</li></ol><ul><li>Java 编译通常更快，因为编译器只需将代码编译为字节码，而不需要生成机器码。</li><li>C++ 编译通常更慢，尤其是在大型项目中，因为编译器需要生成并优化特定平台的机器码。</li></ul><p><strong>Java编译是否需要再单独安装编译器？</strong></p><p>在编写 Java 程序时，不需要单独安装编译器，因为 Java 编译器是包含在 JDK（Java Development Kit）中</p><p><strong>JDK包含了什么？</strong></p><p>JDK 是 Java 开发的核心工具包，它包含了一整套开发 Java 应用程序所需的工具和库。JDK 的主要组成部分包括：</p><ol><li>   Java 编译器 (javac)：</li></ol><ul><li>这是用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）的工具。</li><li>javac 是 JDK 中最重要的组件之一，负责将人类可读的 Java 代码转换为 JVM 可执行的字节码。</li></ul><ol start="2"><li>   Java 运行时环境 (JRE, Java Runtime Environment)：</li></ol><ul><li>JRE 是运行 Java 程序所需的环境，包括 JVM、Java 类库和其他资源。</li><li>JRE 包含了 Java 虚拟机（JVM）、核心类库和支持文件，但不包括编译器和调试工具。</li><li>JDK 本身包含了一个完整的 JRE，所以在安装 JDK 时也会获得 JRE。</li></ul><ol start="3"><li>   Java 虚拟机 (JVM)：</li></ol><ul><li>JVM 是一个平台独立的虚拟机，负责解释和执行编译后的字节码。</li><li>JVM 使得 Java 程序可以在任何支持 JVM 的操作系统上运行。</li></ul><ol start="4"><li>   核心类库：</li></ol><ul><li>这是 Java 标准库（API），包含了大量的预定义类和接口，用于执行各种常见的编程任务（如数据结构、网络通信、文件操作、并发处理等）。</li><li>核心类库是 Java 程序构建的基础，几乎所有 Java 程序都会使用其中的类和方法。</li></ul><ol start="5"><li>   开发工具：</li></ol><ul><li>java：用于启动 Java 应用程序的命令行工具，它调用 JVM 来执行字节码。</li><li>javadoc：用于生成 Java 代码文档的工具，可以从源码中的注释生成 API 文档。</li><li>jdb：Java 调试工具，允许开发者在运行时调试 Java 应用程序。</li><li>jar：用于创建和管理 Java Archive（JAR）文件的工具，这些文件通常用于打包 Java 类库和应用程序。</li><li>javap：Java 类文件反汇编工具，用于查看编译后的字节码。</li></ul><ol start="6"><li>   其他工具：</li></ol><ul><li>javah：用于生成 C 头文件和源文件，支持 JNI（Java Native Interface）。</li><li>jarsigner：用于对 JAR 文件进行签名和验证的工具。</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>在Java中，每个源文件都是一个类，类名必须与文件名相同。Java程序的入口是<code>main</code>方法，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</span></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个源码文件只能包含一个public类型的类。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Java的数据类型分为两大类：基本数据类型和引用数据类型。</p><ol><li>   基本数据类型：byte、short、int、long、float、double、char、boolean。<strong>基本类型的变量直接存储值。</strong></li><li>   引用数据类型：类、接口、数组、String等。<strong>引用类型变量存储的是对象的内存地址（引用）</strong>。</li></ol><p>引用类型变量通常通过 <code>new</code> 关键字创建对象（但也有例外，比如字符串常量池），而基本类型变量则直接赋值。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java中的字符串是不可变的，即一旦创建，就不能再修改。字符串的比较要使用<code>equals()</code>方法，而不是<code>==</code>运算符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong>：</p><ul><li>使用<code>+</code>运算符拼接字符串。</li><li>使用<code>StringBuilder</code>类进行字符串拼接，它是可变的字符串，效率更高。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(s); <span class="comment">// Hello, Mr Bob!</span></span><br></pre></td></tr></table></figure><p>多行字符串可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SELECT * FROM</span></span><br><span class="line"><span class="string">    users</span></span><br><span class="line"><span class="string">    WHERE id = 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>); <span class="comment">// 输出并换行</span></span><br><span class="line">System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 输出不换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// 格式化输出</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 导入某个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>在Java的类中，有构造函数，但是没有析构函数。Java的垃圾回收器会自动回收不再使用的对象。</p><p><strong>但是Java同样会有内存泄漏的问题，比如静态变量、集合类等。</strong></p><p>在Java的类中，也有一个this关键字，表示当前实例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用extends关键字实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>在Java中一个子类只能继承一个父类，子类继承后无法访问父类的私有字段和方法，可以将父类的字段和方法设置为<code>protected</code>。</strong></p></li><li><p>子类不会继承父类的构造方法，但是可以通过<code>super()</code>调用父类的构造方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和C++一样，在Java中可以使用父类的引用指向子类的实例。</li><li>Java中的方法可以被子类覆写，使用<code>@Override</code>注解可以让编译器检查是否正确覆写了父类的方法。</li><li>在Java中 ，同样存在抽象类，使用<code>abstract</code>关键字修饰，抽象类不能被实例化，只能被继承。<code>abstract class Person &#123;&#125;</code></li></ul><p><strong>实例化子类时，会调用父类的构造器，Java是单继承，且所有的类都继承于Object类，那么是这条线上的所有父类、祖父类的构造器都会被调用吗？</strong></p><blockquote><p>是的，在 Java 中，当实例化一个子类时，父类、祖父类乃至更高层次的所有父类的构造函数都会被依次调用，直到根类 Object 的构造函数。这个过程是通过构造函数链实现的。</p></blockquote><p><strong>在Java中，继承是一棵树，构造函数的调用是从下往上的，即先调用子类的构造函数，再调用父类的构造函数，直到根类的构造函数。</strong></p><p><strong>在C++中，继承是一个图。</strong></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://liaoxuefeng.com/books/java/oop/basic/interface/index.html">接口-参考文献</a></p><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：interface。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的class去实现一个interface时，需要使用implements关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>  在定义class的时候，我们需要在第一行声明这个class属于哪个包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example; <span class="comment">// 定义包名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有Java文件对应的目录层次要和包的层次一致。</p><h3 id="和C-作对比："><a href="#和C-作对比：" class="headerlink" title="和C++作对比："></a>和C++作对比：</h3><table><thead><tr><th align="center">关键字</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">常量</td><td align="center">final</td><td align="right">const</td></tr><tr><td align="center">自动类型推导</td><td align="center">var</td><td align="right">auto</td></tr><tr><td align="center">空指针</td><td align="center">null</td><td align="right">nullptr</td></tr><tr><td align="center">字符串</td><td align="center">String</td><td align="right">std::string</td></tr><tr><td align="center">静态方法</td><td align="center">static</td><td align="right">static</td></tr><tr><td align="center">继承</td><td align="center">extends</td><td align="right">: public</td></tr><tr><td align="center">实现</td><td align="center">implements</td><td align="right">: public</td></tr><tr><td align="center">抽象类</td><td align="center">abstract class</td><td align="right">class</td></tr><tr><td align="center">接口</td><td align="center">interface</td><td align="right">class</td></tr><tr><td align="center">包</td><td align="center">package</td><td align="right">namespace</td></tr><tr><td align="center">异常处理</td><td align="center"><a href="https://liaoxuefeng.com/books/java/exception/java-exception/index.html">try-catch-finally</a></td><td align="right">try-catch</td></tr><tr><td align="center">泛型</td><td align="center">List&lt;String&gt;</td><td align="right">vector&lt;string&gt; 模版</td></tr></tbody></table><h4 id="Java和C-中的STL容器区别"><a href="#Java和C-中的STL容器区别" class="headerlink" title="Java和C++中的STL容器区别"></a>Java和C++中的STL容器区别</h4><table><thead><tr><th align="center">容器</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">动态数组</td><td align="center">ArrayList</td><td align="right">vector</td></tr><tr><td align="center">链表</td><td align="center">LinkedList</td><td align="right">list</td></tr><tr><td align="center">栈</td><td align="center">Stack</td><td align="right">stack</td></tr><tr><td align="center">队列</td><td align="center">Queue</td><td align="right">queue</td></tr><tr><td align="center">双端队列</td><td align="center">Deque</td><td align="right">deque</td></tr><tr><td align="center">集合</td><td align="center">Set</td><td align="right">set</td></tr><tr><td align="center">映射</td><td align="center">Map</td><td align="right">map</td></tr><tr><td align="center">哈希表</td><td align="center">HashMap</td><td align="right">unordered_map</td></tr><tr><td align="center">哈希集合</td><td align="center">HashSet</td><td align="right">unordered_set</td></tr><tr><td align="center">优先队列</td><td align="center">PriorityQueue</td><td align="right">priority_queue</td></tr></tbody></table><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>Java的反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法。</p><p>如果要实现一个通用的对象<code>拷贝</code>方法，就必须要用反射机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        person.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        copyProperties(person, employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Name: &quot;</span> + employee.name); <span class="comment">// 输出: Employee Name: John</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Age: &quot;</span> + employee.age);   <span class="comment">// 输出: Employee Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取源对象的所有字段</span></span><br><span class="line">        Field[] fields = source.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标对象中同名的字段</span></span><br><span class="line">            Field targetField;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetField = target.getClass().getField(field.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果目标对象中没有这个字段，则跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查字段类型是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (targetField.getType().equals(field.getType())) &#123;</span><br><span class="line">                <span class="comment">// 将值设置到目标对象中</span></span><br><span class="line">                targetField.set(target, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ol><li>注解的作用</li></ol><ul><li>标注和说明: 注解通常用来标注或说明代码中的某些元素。例如，@Override注解表明一个方法是重写父类或接口的方法，这是一种对代码的说明。</li><li>代码行为的调整: 某些注解会影响代码的行为。例如，@Deprecated注解标注某个方法已经过时，编译器会在使用该方法时发出警告。</li><li>与框架和工具的集成: 许多框架（如Spring、Hibernate）和工具（如JUnit、编译器）使用注解来配置和控制代码的行为。例如，@Autowired注解用于在Spring中自动注入依赖。</li></ul><ol start="2"><li>注解的使用场景</li></ol><ul><li>编译时处理: 注解可以在编译时被处理，例如生成额外的代码、文档，或进行代码校验。例如，@SuppressWarnings注解可以告诉编译器忽略特定的警告。</li><li>运行时反射: 注解可以在运行时通过反射机制读取和使用。例如，JUnit在运行时通过反射读取@Test注解来识别哪些方法是测试方法。</li><li>框架配置: 许多Java框架通过注解来配置和管理对象的行为，这种配置方式比传统的XML配置更加直观和简洁。</li></ul><p><strong>Java的注解和Python的装饰器有什么不同？</strong></p><ol><li>功能与用途：</li></ol><ul><li>Java注解主要用于提供元数据，标记类、方法、字段等。主要用于配置和框架集成，如依赖注入、ORM映射等。</li><li>Python装饰器用于动态改变函数或方法的行为，可以在运行时修改代码逻辑，常用于日志记录、权限控制等。</li></ul><ol start="2"><li>   实现方式：</li></ol><ul><li>Java注解是静态的，不能直接改变代码逻辑，通过编译器或框架在编译时或运行时处理。</li><li>Python装饰器是高阶函数，可以在运行时动态生成、修改或应用，具有更强的灵活性。</li></ul><ol start="3"><li>   使用场景：</li></ol><ul><li>Java注解常见于企业级应用中的配置和元数据标注。</li><li>Python装饰器用于简化代码、提高复用性，特别是在Web开发和数据处理领域。</li></ul><p>两者虽然都是用于增强代码的功能性，但Java注解偏向于静态配置，而Python装饰器偏向于动态行为修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;扫盲，Java和C-的一些区别&quot;&gt;&lt;a href=&quot;#扫盲，Java和C-的一些区别&quot; class=&quot;headerlink&quot; title=&quot;扫盲，Java和C++的一些区别&quot;&gt;&lt;/a&gt;扫盲，Java和C++的一些区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Java项目需要</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的网络攻击方式</title>
    <link href="https://kelinkong.github.io/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>https://kelinkong.github.io/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2024-04-03T04:54:28.000Z</published>
    <updated>2024-05-18T01:53:38.853Z</updated>
    
    <content type="html"><![CDATA[<p>学习网站：<a href="https://xss-game.appspot.com/level1">https://xss-game.appspot.com/level1</a></p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>XSS（Cross Site Scripting）跨站脚本攻击，是一种代码注入攻击。攻击者在目标网站植入恶意脚本，当用户访问目标网站时，恶意脚本会被执行，从而达到攻击目的。</p><p>假设有一个简单的网页，用于用户输入评论，然后显示在页面上。如果用户输入的内容没有经过过滤，那么用户可以输入一段恶意脚本，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>评论页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>留言板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;post_comment.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交评论&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端代码没有进行恰当的输入过滤和输出转义，导致用户输入的恶意脚本被执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;评论结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;评论结果&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;您的评论是：<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>]; <span class="meta">?&gt;</span>&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当用户输入如下内容时，就会弹出一个对话框：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果尝试在<code>&lt;script&gt;</code>标签中输入恶意代码失败了，那么可以尝试使用带有JavaScript属性的HTML元素来执行XSS攻击。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span></span><br><span class="line">&#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span>&#x27;</span><br><span class="line">0&#x27;); alert(&#x27;XSS&#x27;); //</span><br></pre></td></tr></table></figure><h4 id="XSS攻击的解决措施"><a href="#XSS攻击的解决措施" class="headerlink" title="XSS攻击的解决措施"></a>XSS攻击的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>输出转义：对用户输入的内容进行转义，确保用户输入的内容不会被当做HTML代码执行。</li><li>HTTP头部设置：设置HTTP头部的Content-Security-Policy字段，限制页面加载的资源。</li><li>Cookie设置：设置Cookie的HttpOnly属性，防止JavaScript读取Cookie。</li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF（Cross Site Request Forgery）跨站请求伪造，是一种利用用户已登录的身份，以用户不知情的情况下，完成非法操作的攻击方式。</p><ul><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问断线都具备一定的有效期，比如1天过期，或者几个小时过气，再次期间权限信息会保留在用户浏览器的cookie中，这本例子中假设用户C刚刚登录了网站A，全新还没有过期。</li><li>攻击者利用正常网站A的CSFR漏洞，构造页面一个恶意网页B，在页面中包含对发往正常网站A的请求，在用户C加载页面B（或者点击某些元素时触发）时，会触发攻击请求，完成攻击。</li><li>由于加载恶意页面B和触发攻击请求都是在用户浏览器端完成的，因为之前用户登录过正常网站，发往正常网站的请求会带有用户授权信息（在cookie中），在授权信息没有过期的情况达到攻击目的。</li></ul><h4 id="CSRF攻击的解决措施"><a href="#CSRF攻击的解决措施" class="headerlink" title="CSRF攻击的解决措施"></a>CSRF攻击的解决措施</h4><ul><li>验证来源站点：在服务器端验证请求的来源站点，只允许来自合法站点的请求。</li><li>验证请求内容：在请求中添加验证信息，确保请求是用户自己发起的。</li><li>防止重复提交：使用Token验证，确保请求只能被执行一次。</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是一种利用Web应用程序中的漏洞，通过在用户提交的数据中插入恶意的SQL语句，从而实现非法操作的攻击方式。</p><p>例如：登陆查询的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果用户输入的<code>$username</code>和<code>$password</code>没有经过过滤，那么用户可以输入一段恶意的SQL语句，比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;archer2017&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样就会返回所有用户的信息，因为<code>OR 1=1</code>永远为真。</p><h4 id="SQL注入的解决措施"><a href="#SQL注入的解决措施" class="headerlink" title="SQL注入的解决措施"></a>SQL注入的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>如果不可避免地使用SQL语句进行拼装，可以对用户输入数据进行转义，确保用户输入的内容不会被当做SQL语句执行。</li></ul><h3 id="上传文件漏洞"><a href="#上传文件漏洞" class="headerlink" title="上传文件漏洞"></a>上传文件漏洞</h3><p>上传文件漏洞也是一种常见的web漏洞，攻击者可以用利用服务器端的上传文件漏洞绕过安全验证将代码提交到服务器端，并想办法让代码文件被执行。一单可执行的代码上传成功，会造成比较严重的安全问题，比如获取服务器权限，为攻击者开后门，或者让服务器超载，破快服务器的可用性，甚至是上传病毒，木马。</p><h4 id="上传文件漏洞的解决措施"><a href="#上传文件漏洞的解决措施" class="headerlink" title="上传文件漏洞的解决措施"></a>上传文件漏洞的解决措施</h4><ul><li>限制上传文件类型：限制上传文件的类型，确保只能上传安全的文件。</li><li>将上传文件和应用程序分开存储</li><li>对上传的图片进行重绘</li><li>对上传文件重命名，最好具有一定的随机性，提高攻击成本</li></ul><h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>DDOS（Distributed Denial of Service）分布式拒绝服务攻击，是一种通过大量合法请求，占用服务器资源，导致服务器无法正常提供服务的攻击方式。</p><p>在了解 DDoS 之前，我们需要先知道什么是 DoS。最基本的 DoS 就是利用合理的客户端请求里占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDoS 攻击便是在传统的 DoS 攻击的基础上产生的一类攻击方式。传统的 DoS攻击一般是一对一的方式，当攻击目标的CPU速度、内存或者网络带宽等各项性能指标不高的情况下，它的效果是明显的，但随着计算机与网络技术的发展，计算机的处理能力显著增加，内存不断增大，这便使得 DoS 攻击逐渐失去了效果。</p><h4 id="DDOS分类"><a href="#DDOS分类" class="headerlink" title="DDOS分类"></a>DDOS分类</h4><p><strong>SYN Flood</strong></p><p>SYN Flood就是利用了 TCP 协议三次握手的过程来达到攻击的目的。攻击者伪造大量的 IP 地址给服务器发送 SYN 报文，因为伪造的 IP 地址不可能存在，也就不可能从客户端得到任何响应，就会一直卡在第三步，服务端就得维护一个非常大的半连接等待列表，并且不断对这个列表中的 IP 地址进行遍历重试，占用了大量的系统资源。而由于服务器资源有限，恶意的连接占满了服务器的等待队列，导致服务器不再接收新的 SYN 请求，使正常的用户无法完成通信。</p><p><strong>DNS Query Flood</strong></p><p>DNS Query Flood 攻击采用的方法是向被攻击的服务器发送海量的域名解析请求。而这部分请求解析的域名一般都是随机生成的，大部分不存在，并且通过伪造端口和客户端IP，防止查询请求被 ACL（访问控制列表）过滤。被攻击的 DNS服务器 在收到域名解析的请求后，首先会在自己的服务器上查找是否该域名的 IP，因为域名的不存在，在自身自然是找不到的，因此DNS 服务器便会向上层的 DNS服务器递归查询域名，直到全球互联网的 13台 根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量级的时候，就会造成 DNS服务器 解析域名超时，使正常的域名都查询不到对应的 IP，达到了攻击的效果。</p><p><strong>HTTP&#x2F;CC Flood</strong></p><p>CC攻击的原理是通过控制大量的 “肉鸡” 或者利用从互联网上搜寻的大量匿名的 HTTP 代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过 CDN 以及分布式缓存来加快服务端的响应，提高网站的吞吐量。而这些恶意的 HTTP 请求会有意的避开这些缓存，需要进行多次 DB 查询操作或者一次请求会返回大量的数据，加速系统资源的消耗，从而拖垮后端的业务处理系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习网站：&lt;a href=&quot;https://xss-game.appspot.com/level1&quot;&gt;https://xss-game.appspot.com/level1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Network Security" scheme="https://kelinkong.github.io/categories/Network-Security/"/>
    
    
  </entry>
  
  <entry>
    <title>API-architecture</title>
    <link href="https://kelinkong.github.io/2024/03/31/API-architecture/"/>
    <id>https://kelinkong.github.io/2024/03/31/API-architecture/</id>
    <published>2024-03-31T07:39:41.000Z</published>
    <updated>2024-03-31T08:43:45.368Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<a href="https://www.youtube.com/watch?v=4vLxWqE94l4">Top 6 Most Popular API Architecture Styles</a></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API（Application Programming Interface）是一组定义了软件应用程序之间如何互相通信的规则的接口。API可以让不同的软件应用程序之间共享数据和功能，从而提高开发效率。</p><p>主要是用于不同系统之间的通信，比如前端和后端之间的通信。</p><p>如果没有定义API，那么不同的系统之间就无法通信。</p><h3 id="常用API架构风格"><a href="#常用API架构风格" class="headerlink" title="常用API架构风格"></a>常用API架构风格</h3><p><img src="/../imgs/image-47.png"></p><h3 id="Highlights"><a href="#Highlights" class="headerlink" title="Highlights"></a>Highlights</h3><ul><li>📜 SOAP是一种成熟、全面且基于XML的API架构风格，尤其适用于金融服务和支付网关等需要安全性和可靠性的场景。</li><li>🌐 RESTful APIs是Internet的骨干，易于实现，使用HTTP方法，适用于大多数日常交互的网络服务。</li><li>📊 GraphQL不仅是一种架构风格，还是一种查询语言，能够高效地提供精确的数据，尤其适用于复杂数据需求的应用程序。</li><li>💻 gRPC是现代高性能的API架构风格，适用于微服务架构，但在处理浏览器客户端时可能存在一些挑战。</li><li>🔄 WebSocket是实时、双向且持久连接的API架构风格，适用于实时聊天和实时游戏等场景。</li><li>🎣 Webhook是基于事件驱动的API架构风格，适用于异步操作，但不适合需要同步通信或立即响应的场景。</li></ul><h3 id="restful-API"><a href="#restful-API" class="headerlink" title="restful API"></a>restful API</h3><p>Github的API设计规范学习：<a href="https://docs.github.com/en/rest/using-the-rest-api/getting-started-with-the-rest-api?apiVersion=2022-11-28">Github API</a></p><h4 id="rest架构特征"><a href="#rest架构特征" class="headerlink" title="rest架构特征"></a>rest架构特征</h4><ul><li>以资源为基础：资源可以是一个图片、音乐、一个XML格式、HTML格式或者JSON格式等网络上的一个实体，除了一些二进制的资源外普通的文本资源更多以JSON为载体、面向用户的一组数据(通常从数据库中查询而得到)。</li><li>统一接口：对资源的操作包括获取、创建、修改和删除资源，这些操作分别对应HTTP协议中的GET、POST、PUT、DELETE方法。</li><li>无状态：每次请求必须包含所有的信息，服务器不会保存客户端的状态。</li><li>url指向资源：一个url对应一个资源，通过url获取资源。</li></ul><h3 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h3><p>参考学习：<a href="https://juejin.cn/post/6844903475420069902">GraphQL</a></p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（Remote Procedure Call）是一种协议，用于在不同的进程之间传递数据。RPC协议允许一个程序调用另一个程序的子程序，而不需要了解底层网络细节。</p><p><strong>rpc是一种思想，广义的rpc是包含http的。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;a href=&quot;https://www.youtube.com/watch?v=4vLxWqE94l4&quot;&gt;Top 6 Most Popular API Architecture Styles&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;API&quot;&gt;&lt;a href=&quot;#API&quot;</summary>
      
    
    
    
    <category term="Frontend" scheme="https://kelinkong.github.io/categories/Frontend/"/>
    
    
    <category term="architecture" scheme="https://kelinkong.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（下）</title>
    <link href="https://kelinkong.github.io/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://kelinkong.github.io/2024/03/07/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2024-03-07T07:03:28.000Z</published>
    <updated>2024-03-30T12:56:10.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求整理"><a href="#需求整理" class="headerlink" title="需求整理"></a>需求整理</h2><p><strong>popup.html：</strong></p><ul><li>是否开启划词翻译</li><li>选择划词翻译的默认目标语言</li><li>是否开启输入翻译</li><li>输入框翻译的简介</li><li>项目地址</li></ul><p><strong>popup.js</strong></p><ul><li>从popup界面接收信息，如果用户更新设置，就更新存储在浏览器中的值，同时发送消息给content脚本，让其监听</li><li>监听用户是否点击项目地址</li><li>每次点开popup界面都重新从浏览器中加载存储的设置</li></ul><p><strong>content.js</strong></p><ul><li>从浏览器中获取设置</li><li>监听用户的输入</li><li>监听用户是否复制文本</li><li>将信息发送给background脚本</li><li>显示翻译框</li></ul><p><strong>background.js</strong></p><ul><li>接收content脚本发来的信息</li><li>发送请求给API，同时接收应答信息</li><li>将翻译后的内容发送给content脚本</li></ul><p>翻译展示框：</p><ul><li>上方：左边显示logo，右边显示关闭按钮</li><li>中间显示译文</li><li>当用户点击别的地方时关闭翻译框，同时取消选中</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h3><p>在上一篇有写过popup脚本支持跨域，所以我最初的想法是，在划词翻译这个功能中，content脚本只负责发送、接收信息，并且将信息显示出来，而向百度翻译发送请求由popup脚本完成。</p><p>但是<strong>popup 脚本（popup.js）只在用户点击扩展图标并打开 popup 页面时才会运行。</strong></p><p>所以最终改为popup脚本只负责接收popup界面的信息，并传递给content脚本，与外界的交互还是<br>由background脚本完成，这样子增加了代码复用性，也更符合逻辑。</p><p><strong>需要保存用户的设置，所以当用户点击插件时都需要从storage中获取保存的设置</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">get</span>([<span class="string">&#x27;autoTranslate&#x27;</span>, <span class="string">&#x27;targetLanguage&#x27;</span>, <span class="string">&#x27;inputTranslate&#x27;</span>], <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">autoTranslate</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span> = result.<span class="property">targetLanguage</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span> = result.<span class="property">inputTranslate</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当用户更新设置时，也需要将设置保存下来，同时发给content脚本。</strong></p><p>这里为什么要发送给content脚本呢？而不是要content脚本自己去获取？</p><p>这里我更想用通知的方法，这样假设用户开启或关闭某一个功能，content脚本可以第一时间得到反馈。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">saveSettings</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">let</span> autoTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auto-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line"><span class="keyword">let</span> targetLanguage = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;target-language&#x27;</span>).<span class="property">value</span>;</span><br><span class="line"><span class="keyword">let</span> inputTranslate = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input-translate&#x27;</span>).<span class="property">checked</span>;</span><br><span class="line">chrome.<span class="property">storage</span>.<span class="property">sync</span>.<span class="title function_">set</span>(&#123; <span class="attr">autoTranslate</span>: autoTranslate, <span class="attr">targetLanguage</span>: targetLanguage, <span class="attr">inputTranslate</span>: inputTranslate &#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">sendMessageToContent</span>(autoTranslate, targetLanguage, inputTranslate);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于扩展不支持直接从popup界面跳转链接，所以要在popup脚本去跳转。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;project-link&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">create</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;https://github.com/kelinkong/Input-Translation.git&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>这里真的是折磨我好几个小时，主要是调试弹出的翻译框。</p><p>和popup一样，在每次加载界面时需要从storage中获取用户之前的设置。</p><p>然后就是监听用户是否进行选中文本。这里除了记录选中的文本，还需要记录选中的位置，因为我想要直接在选中文本下方弹出翻译框。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取文本</span></span><br><span class="line"><span class="keyword">var</span> selectedText = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 获取位置</span></span><br><span class="line"><span class="keyword">var</span> rect = <span class="variable language_">window</span>.<span class="title function_">getSelection</span>().<span class="title function_">getRangeAt</span>(<span class="number">0</span>).<span class="title function_">getBoundingClientRect</span>();</span><br></pre></td></tr></table></figure><p>和background交互方式与上一篇相同，此处不再赘述。</p><p>接收到饭回来的译文后，这里可以直接调用<code>panel = document.createElement(&#39;div&#39;);</code>来创建一个视图。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">panel.<span class="property">innerHTML</span> = innerHTMLContent; <span class="comment">// 可以使用内嵌html</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;fixed&#x27;</span>;  <span class="comment">// 可以直接调整样式</span></span><br><span class="line">panel.<span class="property">style</span>.<span class="property">top</span> = rect.<span class="property">bottom</span> + <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">panel.<span class="property">style</span>.<span class="property">left</span> = rect.<span class="property">left</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其实这里的逻辑，应该是有一个单独的HTML文件来控制翻译框。但是我对前端太不了解，折腾了好久也没有折腾成功，只能将就着写进content脚本中。</p><h4 id="开启和关闭功能的实现"><a href="#开启和关闭功能的实现" class="headerlink" title="开启和关闭功能的实现"></a>开启和关闭功能的实现</h4><p>对于输入翻译来说，<code>if (event.target.tagName.toLowerCase() === &#39;input&#39; &amp;&amp; inputTranslate)</code>，检测到输入且inputTranslate为真才会去分析用户的输入是否含有目标语言前缀。</p><p>对于划词翻译，和输入翻译不同的是，这里还涉及到弹出框的开启与关闭。</p><ul><li>当检测到用户更新设置时，先移除所有的鼠标监听，如果划词翻译被开启，则开始监听鼠标。</li><li>当用户点了弹出框的关闭，或者点击其他地方，关闭翻译框，同时取消选中。</li></ul><p>这里取消选中其实有个坑。一开始我没有设置关闭翻译框后取消选中，结果就是，不断弹出翻译框。</p><p>当我设置了取消选中后，我一开始担心，也许用户选中并不是想要翻译，而是想要复制。所以我又给用户在翻译框下添加了两个选项：复制原文和复制译文。作为一个前端小白，调试界面的过程真的太难了，这些元素我怎么摆放都不好看。好不容易调试好了，我突然发现其实我不需要给用户提供这个功能，因为弹出翻译框并不影响用户的复制。</p><p>所以最终我没有给复制的选项。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>popup脚本—&gt;右键点击插件，选择检查，就可以打开调试控制台<br>content脚本—&gt;打开浏览器开发者面板，就可以看到<br>background脚本—&gt;在插件管理中，点击服务工作进程，可以打开后台的调试控制台</p><h3 id="理解前端"><a href="#理解前端" class="headerlink" title="理解前端"></a>理解前端</h3><p>前端就类似做IDesign设计，由各种框组成，大框套小框，前后层叠关系类似图层的概念。每一对尖括号就是一个框。</p><p>那么<strong>先把所有的框显示出来，就可以看到各个页面的包含关系</strong>。</p><p>同样，在前端调试界面，可以看到每一个框的代码。如果呈现出来的画面不是自己想要的那样，可以去界面上调试，来查看是哪一块的代码出现了问题。</p><h4 id="如何去设计这些框？"><a href="#如何去设计这些框？" class="headerlink" title="如何去设计这些框？"></a>如何去设计这些框？</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 新框<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>属于哪一类<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  class可以被css和js用来访问和操作元素</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>可以有不同的标签<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;auto-translate&quot;</span> <span class="attr">checked</span>&gt;</span>可以交互</span><br></pre></td></tr></table></figure><p><code>.css</code>文件可以定义框的属性，框内元素的呈现。比如：</p><ul><li>padding：内部元素与框的距离。padding-left</li><li>margin：内部框与外部框的距离。margin-left</li></ul><h4 id="如何与用户交互"><a href="#如何与用户交互" class="headerlink" title="如何与用户交互"></a>如何与用户交互</h4><p>当用户改变前端界面时，发生了什么？</p><p>比如当用户点击了一个复选框，那么这条信息传到哪里？对后台有什么影响？</p><p>这些交互都可以在js脚本中定义。写js脚本和写其他的编程语言更像，都是写一个又一个的函数去实现各种各样的功能。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>整个插件开发的有效工作时间大概是4天，这个过程AI帮我写了大部份代码，我只是在努力debug。之前的开发debug就是打断点，看变量信息，而在浏览器上调试就是用笨办法，在每一个函数入口都输出日志，然后去看是哪里出现了问题。</p><p>整个过程耗费时间的点：</p><ul><li>各个脚本之间的通信</li><li>浏览器API</li><li>界面调试</li></ul><p>在界面调试时，遇到了几个我实在是解决不了的bug，请外援帮忙解决的。易用性和UI上同门们也都给过建议。</p><p>如果觉得有用，可以在GitHub上帮忙点个star。感谢。<a href="https://github.com/kelinkong/Input-Translation.git">https://github.com/kelinkong/Input-Translation.git</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求整理&quot;&gt;&lt;a href=&quot;#需求整理&quot; class=&quot;headerlink&quot; title=&quot;需求整理&quot;&gt;&lt;/a&gt;需求整理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;popup.html：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否开启划词翻译&lt;/li&gt;
&lt;li&gt;选择</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>input-translation开发日志（上）</title>
    <link href="https://kelinkong.github.io/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://kelinkong.github.io/2024/03/05/input-translation%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2024-03-05T09:07:30.000Z</published>
    <updated>2024-03-30T12:55:52.394Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。</strong></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>在检索内容时，很多时候需要检索英文内容，但是现有的翻译插件都需要先复制中文翻译后再复制回搜索框，要么就是将输入框翻译作为付费项目，于是就想自己开发一款插件来解决这个问题。</p><p>同时在浏览网页时难免会遇到不认识的单词，所以想融入一个划词翻译的功能，就不需要再额外安装插件。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>在输入框中输入检索内容后，加上尾缀可自动翻译为对应语言，目前支持<code>/en /zh /fr /de</code><ul><li>如<code>测试/en ---&gt; test</code></li></ul></li><li>划词翻译（开发中，暂不支持）</li></ul><h3 id="开发教程"><a href="#开发教程" class="headerlink" title="开发教程"></a>开发教程</h3><h4 id="基于MV3的项目结构"><a href="#基于MV3的项目结构" class="headerlink" title="基于MV3的项目结构"></a>基于MV3的项目结构</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">my-extension/</span><br><span class="line">│</span><br><span class="line">├── manifest<span class="selector-class">.json</span>  // 配置文件</span><br><span class="line">│</span><br><span class="line">├── icons/</span><br><span class="line">│   └── icon16<span class="selector-class">.png</span></span><br><span class="line">│</span><br><span class="line">├── scripts/</span><br><span class="line">│   ├── <span class="attribute">content</span><span class="selector-class">.js</span> // 内容脚本，向访问的网页注入js代码的一种方式</span><br><span class="line">│   ├── <span class="attribute">background</span><span class="selector-class">.js</span> // 后台脚本，可以访问浏览器的所有API</span><br><span class="line">│   └── popup<span class="selector-class">.js</span></span><br><span class="line">│</span><br><span class="line">├── pages/</span><br><span class="line">└── └── popup<span class="selector-class">.html</span> // 弹出窗口样式</span><br></pre></td></tr></table></figure><h5 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;manifest_version&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span>  <span class="comment">// 这是manifest文件的版本，当前版本是3。</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Input Translation&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Translate text input and selected words.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;permissions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">//这里配置一些相关权限，如该脚本在那些网站上可以运行</span></span><br><span class="line"><span class="string">&quot;*://*/*&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义了扩展的浏览器动作，包括默认的弹出窗口和默认的图标。</span></span><br><span class="line"><span class="attr">&quot;default_popup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;popup/popup.html&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;default_icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;icons&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;16&quot;</span><span class="punctuation">:</span> <span class="string">&quot;images/icon-16.png&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;background&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>  <span class="comment">// 定义了扩展的后台页面，这里使用了一个服务工作线程。</span></span><br><span class="line"><span class="attr">&quot;service_worker&quot;</span><span class="punctuation">:</span> <span class="string">&quot;background.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;content_scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="comment">// 定义了扩展的内容脚本，包括要注入的JS文件和匹配的网页URL。</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;js&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   <span class="comment">// 如果content.js脚本要引用其他脚本，可以写在这里</span></span><br><span class="line"><span class="string">&quot;scripts/content.js&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;matches&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;&lt;all_urls&gt;&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>各个脚本的权限：</strong></p><p><img src="/../imgs/image-46.png" alt="alt text"></p><p>在调用百度翻译的API时，由于content脚本不支持直接跨域，所以要先将输入框的信息发送到background脚本，再由background脚本发送，所以这里涉及到两个脚本的通信。</p><p>脚本通信的教程参考：</p><p><a href="https://juejin.cn/post/6844903985711677453">background、content、popup的通信 - 掘金 (juejin.cn)</a></p><h4 id="popup"><a href="#popup" class="headerlink" title="popup"></a>popup</h4><p>popup就是点击扩展图标弹出来的框，输入框翻译这个功能并不需要这个，所以留到下篇再写。</p><h4 id="content-js"><a href="#content-js" class="headerlink" title="content.js"></a>content.js</h4><p>这个脚本的功能是：</p><ul><li>监测用户输入框，判断用户是否输入了相关后缀，如果检测到用户输入相关后缀，就将输入的内容和后缀发送至background脚本。</li><li>接收到信息后，替换原本输入框中的内容</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> match = text.<span class="title function_">match</span>(<span class="regexp">/(.*)(\/en|\/zh|\/fr|\/de)$/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (match) &#123; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;start to translate&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> textToTranslate = match[<span class="number">1</span>]; <span class="comment">// 匹配到的文本，不包括语言代码</span></span><br><span class="line"><span class="keyword">var</span> languageCode = match[<span class="number">2</span>].<span class="title function_">slice</span>(<span class="number">1</span>); <span class="comment">// 匹配到的语言代码</span></span><br><span class="line">chrome.<span class="property">runtime</span>.<span class="title function_">sendMessage</span>(&#123; <span class="attr">text</span>: textToTranslate, <span class="attr">lang</span>: languageCode &#125;, <span class="keyword">function</span> (<span class="params">response</span>) &#123; </span><br><span class="line"><span class="keyword">if</span> (chrome.<span class="property">runtime</span>.<span class="property">lastError</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(chrome.<span class="property">runtime</span>.<span class="property">lastError</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">event.<span class="property">target</span>.<span class="property">value</span> = response.<span class="property">data</span>.<span class="property">trans_result</span>[<span class="number">0</span>].<span class="property">dst</span>;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的是<code>chrome.runtime.sendMessage</code>通信方式，将输入的文本和语言发送至background脚本。</p><p>另外，单独检测用户输入框，会导致用户正在输入<code>/en</code>时，就会被翻译，此时再按anter键，就会导致翻译后的文本多一个<code>/en</code>，如<br><code>测试/en  ----&gt; test/en</code><br>这很不优雅，所以这里的监听事件设置为<code>keyup</code>，且设置了1s的延迟。<br><code>document.addEventListener(&#39;keyup&#39;, function (event)</code></p><h4 id="background-js"><a href="#background-js" class="headerlink" title="background.js"></a>background.js</h4><p>这个脚本的功能是：接受content脚本发来的信息，调用百度翻译API，将翻译完成的信息发送给content脚本。</p><p>因为百度翻译API接受的内容需要使用md5算法加密，所以这里要引入md5算法。</p><p><strong>但是在mv3版本中，不支持直接在配置文件中引入脚本，所以这里要使用import的方式。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">importScripts(<span class="string">&#x27;scripts/lib/md5.js&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发送信息回content脚本有一个问题要注意，因为background脚本可能同时会和很多脚本通信，所以要使用tab的方式进行通信。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.<span class="property">runtime</span>.<span class="property">onMessage</span>.<span class="title function_">addListener</span>(<span class="function">(<span class="params">request, sender, sendResponse</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Message received in content script:&#x27;</span>, request);</span><br><span class="line"><span class="title function_">translateText</span>(request.<span class="property">text</span>, request.<span class="property">lang</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">query</span>(&#123; <span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span> &#125;, <span class="keyword">function</span> (<span class="params">tabs</span>) &#123;</span><br><span class="line">chrome.<span class="property">tabs</span>.<span class="title function_">sendMessage</span>(tabs[<span class="number">0</span>].<span class="property">id</span>, &#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">sendResponse</span>(&#123; <span class="attr">data</span>: data &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/kelinkong/input-translate">kelinkong&#x2F;input-translate (github.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本人是前端小白，写这个教程只是为了回顾用，可能会有错误的理解，请勿完全信任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h3&gt;&lt;p&gt;在检索内容时，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>托管博客源码</title>
    <link href="https://kelinkong.github.io/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/"/>
    <id>https://kelinkong.github.io/2024/01/31/%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81/</id>
    <published>2024-01-31T03:14:41.000Z</published>
    <updated>2024-03-30T03:53:01.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，将源码也上传到仓库，方便查看。</p><h2 id="使用多分支管理"><a href="#使用多分支管理" class="headerlink" title="使用多分支管理"></a>使用多分支管理</h2><ol><li><p>在GitHub创建一个hexo分支，并将其设置为默认分支；</p></li><li><p>将其clone到本地，默认clone的是hexo分支内容，此时会包含一个.git文件夹，还有原本仓库中有的编译后的文件；</p></li><li><p>将原本仓库中的内容删除，只保留.git文件夹；</p></li><li><p>将原本的文件除了.deploy_git文件夹复制到本地仓库中；</p></li><li><p>在.gitignore文件中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure><p><strong>如果clone过主题文件，需要把主题文件夹中的.git文件夹删除，因为不能嵌套clone</strong></p></li><li><p>将clone的文件提交到hexo分支中；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit –m add_branch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li></ol><p><strong>之后网站更新到main分支，源代码更新到hexo分支。</strong></p><h2 id="解决GitHub无法上传问题"><a href="#解决GitHub无法上传问题" class="headerlink" title="解决GitHub无法上传问题"></a>解决GitHub无法上传问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 127.0.0.1 port 7890</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br></pre></td></tr></table></figure><ul><li>使用代理或者不使用都会提示该问题</li><li>之前使用正常</li></ul><p>参考这个问题：<br><a href="https://github.com/orgs/community/discussions/55269">https://github.com/orgs/community/discussions/55269</a></p><p>最终解决方案：<br>在<code>~/.ssh/config</code>中添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname 20.200.245.248</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用hexo在GitHub部署静态博客时，上传到仓库的是bianry文件（在.deploy_git中），无法直接查看源码。这里介绍一种方法，</summary>
      
    
    
    
    <category term="Frontend" scheme="https://kelinkong.github.io/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="https://kelinkong.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="https://kelinkong.github.io/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>https://kelinkong.github.io/2023/12/05/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-12-05T04:29:14.479Z</published>
    <updated>2024-03-30T03:51:23.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/../imgs/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed --save</code></p><h3 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h3><p>在vscode中预览是有图片的，生成和发布之后无法显示图片。<br><img src="/../imgs/image-4.png"></p><p>因为在源文件的 post 目录下新建了 img 子目录,然后在 markdown 中使用相对路径引用图片。</p><p>这在本地预览时可以正常显示,但是部署后会出错。</p><p>因为 Hexo 在生成时,会将 post 中的 markdown 和资源文件一起复制到 public 目录,相对位置不变。</p><p>但是 img 子目录不会自动复制过去。所以 public 中找不到 img 中的图片,导致无法显示。</p><p><strong>解决方法：</strong> 将img重命名为imgs(因为会和主题的img文件夹命名冲突)，然后将文件夹移动到<code>source</code>目录下，而不是放在<code>_posts</code>目录下，注意粘贴的设置也需要修改为imgs。</p><p><img src="/../imgs/image-6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="Frontend" scheme="https://kelinkong.github.io/categories/Frontend/"/>
    
    
    <category term="hexo" scheme="https://kelinkong.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>前端基础学习</title>
    <link href="https://kelinkong.github.io/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2023/10/18/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-17T21:54:32.000Z</published>
    <updated>2024-03-30T03:52:47.492Z</updated>
    
    <content type="html"><![CDATA[<ol><li>html定义了网页内容</li><li>css描述了网页的布局</li><li>js控制了网页的行为(通过函数)</li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><strong>HTML:</strong> 超文本标记语言，运行在浏览器上，由浏览器来解析。文件名后缀为<code>.html</code>。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 声明文档类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!-- 头部元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 可见内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 定义一个大标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 定义一个段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="什么是html？"><a href="#什么是html？" class="headerlink" title="什么是html？"></a>什么是html？</h3><ul><li>html是一种标记语言（标记标签）</li><li>使用标记标签来描述网页</li><li>html文档包含了html标签及文本内容</li></ul><p><strong>html的标签：</strong> </p><ul><li>由尖括号包围的关键词，如<code>&lt;html&gt;</code></li><li>标签通常是成对出现的，如<code>&lt;html&gt;&lt;/html&gt;</code></li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li><li>开始标签和结束标签也被称为开放标签和闭合标签 <code>&lt;标签&gt;内容&lt;/标签&gt;</code></li></ul><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 段落 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="comment">&lt;!-- 超链接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">decoding</span>=<span class="string">&quot;async&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;百度logo&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span>&gt;</span> <span class="comment">&lt;!-- 图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 换行 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ol><li>对于中文网页需要使用<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>来指定编码格式，否则会出现乱码。</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>CSS:</strong> 层叠样式表，用于设置HTML元素的样式，如颜色、字体、大小、间距、边框等。文件名后缀为<code>.css</code>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f3f3f3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>选择器：要改变样式的html元素</li><li>声明块：由<code>&#123;&#125;</code>包围的一条或多条声明，如<code>color: red;</code>，总是以分号结尾，用大括号括起来</li><li>注释：<code>/* */</code>，不会被浏览器读取，可以提高代码可读性</li></ul><h3 id="id和class选择器"><a href="#id和class选择器" class="headerlink" title="id和class选择器"></a>id和class选择器</h3><p><strong>id：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#para1</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个段落不受该样式的影响。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class：</strong><br>class用于描述一组元素的样式，可以在多个元素中使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.center</span></span></span><br><span class="line"><span class="language-css">    &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题居中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>段落居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id选择器用于唯一的元素</li><li>class选择器通常具有重用性</li></ul><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><ul><li>id不要以数字开头</li></ul><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>每个页面使用<code>&lt;link&gt;</code>标签链接到外部样式表，外部样式表通常存储在<code>.css</code>文件中。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会从文件<code>mystyle.css</code>中读取样式信息，然后将其应用到当前的文档上。</p><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h3><p>参考上面的写法。</p><p>优先级：内联样式 》 内部样式 》 外部样式</p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>不过多赘述，需要时再查阅。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p><strong>JavaScript:</strong> 一种轻量级的编程语言，可用于创建动态网页。文件名后缀为<code>.js</code>。</p><p>编程语言语法不做过多赘述，主要关注JavsScript是如何和HTML交互的。</p><h3 id="js能够直接写入html输出流中"><a href="#js能够直接写入html输出流中" class="headerlink" title="js能够直接写入html输出流中"></a>js能够直接写入html输出流中</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="js对事件的反应"><a href="#js对事件的反应" class="headerlink" title="js对事件的反应"></a>js对事件的反应</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Welcome!&#x27;)&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="改变html内容"><a href="#改变html内容" class="headerlink" title="改变html内容"></a>改变html内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一段 JavaScript<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">JavaScript 能改变 HTML 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="language-javascript">&#123;</span></span><br><span class="line"><span class="language-javascript">x=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>);  <span class="comment">// 找到元素</span></span></span><br><span class="line"><span class="language-javascript">x.<span class="property">innerHTML</span>=<span class="string">&quot;Hello JavaScript!&quot;</span>;    <span class="comment">// 改变内容</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>HTML中的JavaScript代码必须位于<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间。放置到<code>&lt;body&gt;</code>和<code>&lt;head&gt;</code>标签中都可以。</p><p>通常的做法是把函数放入到<code>&lt;head&gt;</code>标签中，然后在<code>&lt;body&gt;</code>标签中调用函数。或者是放置到底部。</p><h4 id="外部的JavaScript"><a href="#外部的JavaScript" class="headerlink" title="外部的JavaScript"></a>外部的JavaScript</h4><p>如果需要使用外部文件，在<code>&lt;script&gt;</code>标签的src属性中设置该文件：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myScript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><strong>输出：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">// 弹出警告框</span></span><br><span class="line">innerHTML <span class="comment">// 内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() <span class="comment">// 控制台</span></span><br></pre></td></tr></table></figure><p><strong>变量：</strong><br>Number\String\Array\Object\Function</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x, length;</span><br><span class="line">x = <span class="number">1.2</span>;</span><br><span class="line">length = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">firstName</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastName</span>:<span class="string">&quot;Doe&quot;</span>&#125;;  <span class="comment">// Object 通过对象字面量赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;                                <span class="comment">// 返回 a 乘以 b 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些交互示例"><a href="#一些交互示例" class="headerlink" title="一些交互示例"></a>一些交互示例</h3><ul><li>JavaScript可以附加到HTML元素上的事件处理程序，例如点击事件、鼠标移动事件、键- 盘事件等。<br>当事件发生时，与该事件相关的JavaScript代码将被执行，以响应用户的操作。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;myButton&quot;</span>&gt;</span>点击我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮被点击了！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以访问和操作文档对象模型（DOM），这是HTML页面的表示。</li><li>通过JavaScript，您可以创建、修改、删除HTML元素，以及改变元素的样式和内容。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    myDiv.<span class="property">innerHTML</span> = <span class="string">&quot;现在我被JavaScript修改了！&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript可以用于验证表单数据、提交表单、以及处理表单的输入。</li><li>可以使用JavaScript来验证用户输入是否有效，然后根据验证结果采取相应的行动。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myForm&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> nameInput = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (nameInput.<span class="property">value</span> === <span class="string">&quot;&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;请输入您的姓名！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            event.<span class="title function_">preventDefault</span>(); <span class="comment">// 阻止表单提交</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;html定义了网页内容&lt;/li&gt;
&lt;li&gt;css描述了网页的布局&lt;/li&gt;
&lt;li&gt;js控制了网页的行为(通过函数)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++代码调试</title>
    <link href="https://kelinkong.github.io/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>https://kelinkong.github.io/2023/10/10/%E3%80%90c++%E3%80%91%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</id>
    <published>2023-10-10T00:15:48.000Z</published>
    <updated>2024-09-26T03:35:09.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC-工作流程"><a href="#GCC-工作流程" class="headerlink" title="GCC 工作流程"></a>GCC 工作流程</h2><table><thead><tr><th>说明</th><th>文件后缀</th><th>参数</th></tr></thead><tbody><tr><td>预处理</td><td>.c</td><td>-</td></tr><tr><td>编译</td><td>.i</td><td>-E</td></tr><tr><td>汇编</td><td>.s</td><td>-S</td></tr><tr><td>链接</td><td>.o</td><td>-c</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预处理。 -o 参数是为了指定编译后的文件名</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -S test.i -o test.s </span><br><span class="line"><span class="comment"># 汇编</span></span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>生成调试信息，即可调试</td></tr><tr><td>-D</td><td>指定一个宏</td></tr><tr><td>-l</td><td>指定链接库</td></tr><tr><td>-std</td><td>指定C++版本</td></tr><tr><td>-I</td><td>指定头文件路径</td></tr><tr><td>-Wall</td><td>打开所有警告信息</td></tr></tbody></table><p><strong><code>-D</code>参数应用场景：</strong><br>在发布程序的时候，一般会将所有log输出去掉，如果不去掉会影响程序的执行效率。这时候可以在编译的时候加上<code>-D</code>参数，定义一个宏，然后在程序中使用这个宏，如果是发布程序，就不定义这个宏，这样就可以在编译的时候去掉所有的log输出。</p><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> string.c main.c</span><br></pre></td></tr></table></figure><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p><strong>在编译阶段：</strong></p><ul><li>后缀为.c的文件，gcc会将其当做C语言源文件，g++会将其当做C++语言源文件。</li><li>后缀为.cpp的文件，两者都会将其当做C++语言源文件。</li><li>g++会调用gcc，对于C++代码，两者是等价的，也就是说gcc和g++都可以编译C&#x2F;C++代码</li></ul><p><strong>在链接阶段：</strong></p><ul><li>gcc和g++都可以自动连接到标准C库</li><li>g++会自动连接到标准C++库，gcc如果要链接到标准C++库需要加参数<code>-lstdc++</code></li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><strong>gdb调试的代码必须添加-g参数，-g的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行。</strong></p><p><em>使用CMake编译的，添加<code>-DCMAKE_BUILD_TYPE=Debug</code>参数</em>。</p><h3 id="启动和退出gdb"><a href="#启动和退出gdb" class="headerlink" title="启动和退出gdb"></a>启动和退出gdb</h3><p><strong>gdb进程启动之后，需要被调试的应用程序是没有执行的。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;program&gt; <span class="comment"># 启动</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args &lt;arg1&gt; &lt;arg2&gt; <span class="comment"># 设置参数,启动应用程序之前可能需要传参</span></span><br><span class="line"></span><br><span class="line">show args <span class="comment"># 查看参数</span></span><br></pre></td></tr></table></figure><p><strong>在gdb中启动程序：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">(gdb) start <span class="comment"># 会阻塞到main函数第一行</span></span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>run</td><td>启动程序</td><td></td></tr><tr><td>continue &#x3D; c</td><td>继续执行程序</td><td></td></tr><tr><td>quit &#x3D;&#x3D; q</td><td>退出gdb</td><td></td></tr><tr><td>list &#x3D;&#x3D; l</td><td>列出源代码</td><td>l 行号, l 函数名， l 文件名：行号</td></tr><tr><td>break &#x3D;&#x3D; b</td><td>设置断点</td><td>b 行号, b 函数名， b 文件名：行号， b 行数 if 变量名&#x3D;某个值</td></tr><tr><td>info &#x3D;&#x3D; i</td><td>查看信息</td><td>i breakpoints, i locals, i args</td></tr><tr><td>delete &#x3D; del &#x3D; d</td><td>删除断点</td><td>d 断点号</td></tr><tr><td>disable &#x3D; dis</td><td>禁用断点</td><td>disable 断点号</td></tr><tr><td>enable &#x3D; ena</td><td>启用断点</td><td>enable 断点号</td></tr><tr><td>print &#x3D; p</td><td>打印变量</td><td>p 变量名</td></tr><tr><td>ptype</td><td>打印变量类型</td><td>ptype 变量名</td></tr><tr><td>display</td><td>跟踪查看变量</td><td>display 变量名</td></tr><tr><td>step &#x3D; s</td><td>单步执行，进入函数</td><td></td></tr><tr><td>finish</td><td>执行到当前函数返回为止</td><td></td></tr><tr><td>next &#x3D; n</td><td>单步执行，不进入函数</td><td></td></tr><tr><td>until</td><td>跳出循环</td><td></td></tr><tr><td>set</td><td>修改变量值</td><td>set 变量名&#x3D;值</td></tr></tbody></table><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>参考<a href="https://www.hahack.com/codes/cmake/">Cmake快速入门</a></p><p>cmake的基本语法：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake &lt;<span class="keyword">option</span>&gt; &lt;path&gt;</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table><thead><tr><th>含义</th><th>指令</th></tr></thead><tbody><tr><td>编译</td><td>cmake <code>&lt;path&gt;</code>, 当前目录为<code>.</code>,上一级目录为<code>..</code></td></tr><tr><td>清理cmake缓存</td><td><code>rm -rf CMakeFiles/ CMakeCache.txt cmake_install.cmake Makefile</code></td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每一个层级都需要写CMakeLists.txt文件</li><li>需要在父层级添加子层级的目录</li><li>需要在父层级添加子层级的库&#x2F;子目录包含可执行文件</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>文件结构：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── cmake_notes</span><br><span class="line">│   ├── build</span><br><span class="line">│   └── math</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├── myfunction.h</span><br><span class="line">│       └── myfunction.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.txt</span><br></pre></td></tr></table></figure><p>第一层级的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(Demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否用自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DUSE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否加入MathFunctions库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable(Demo main.cpp print.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="comment"># add_subdirectory(math)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo -lpthread)</span><br></pre></td></tr></table></figure><p><strong>在源代码中使用：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use my math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use system math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// USE_MYMATH</span></span></span><br></pre></td></tr></table></figure><p><strong>子目录的CMakeLists文档，需要add_executable吗?</strong></p><p>子目录包含可执行文件：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp other_source.cpp)</span><br></pre></td></tr></table></figure><p>子目录只包含库代码：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_library</span>(my_library my_source.cpp)</span><br></pre></td></tr></table></figure><p>这将创建一个库目标而不是可执行文件，以便在主目录的CMakeLists.txt文件中或其他子目录中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GCC-工作流程&quot;&gt;&lt;a href=&quot;#GCC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;GCC 工作流程&quot;&gt;&lt;/a&gt;GCC 工作流程&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="CPP" scheme="https://kelinkong.github.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="https://kelinkong.github.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程模型</title>
    <link href="https://kelinkong.github.io/2023/10/10/%E3%80%90c++%E3%80%91-threads/"/>
    <id>https://kelinkong.github.io/2023/10/10/%E3%80%90c++%E3%80%91-threads/</id>
    <published>2023-10-09T22:47:41.000Z</published>
    <updated>2024-09-26T03:35:01.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步和线程通信"><a href="#线程同步和线程通信" class="headerlink" title="线程同步和线程通信"></a>线程同步和线程通信</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>互斥锁</li><li>条件变量</li><li>互斥量</li><li>信号量</li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li>条件变量</li><li>队列</li><li>原子操作</li><li>条件变量和定时器</li></ol><h2 id="C-标准库提供了哪些锁？"><a href="#C-标准库提供了哪些锁？" class="headerlink" title="C++标准库提供了哪些锁？"></a>C++标准库提供了哪些锁？</h2><p><code>std::mutex</code>：互斥锁是最基本的锁类型，用于确保一次只有一个线程可以访问共享资源。你可以使用 std::mutex 来创建一个互斥锁对象，然后使用 lock() 和 unlock() 方法来手动锁定和解锁。</p><p><code>std::unique_lock：</code>std::unique_lock 是一个更加灵活的互斥锁包装器，它允许你在需要时手动锁定和解锁，也可以在构造函数和析构函数中自动锁定和解锁。</p><p><code>std::lock_guard：</code>std::lock_guard 是另一个互斥锁包装器，但它只支持自动锁定和解锁。一旦 std::lock_guard 对象被创建，它会自动锁定互斥锁，并在其生命周期结束时自动解锁。</p><p><code>std::recursive_mutex：</code>递归互斥锁允许同一线程多次获得锁。这对于某些特定的情况很有用，但要小心避免死锁。</p><p><code>std::shared_mutex：</code>共享互斥锁（C++17引入）允许多个线程同时读取共享资源，但只有一个线程可以写入资源。这有助于提高并发性能。</p><p><code>std::condition_variable：</code>条件变量用于线程之间的同步和通信。它们允许一个线程等待某个条件成立，然后另一个线程发出信号以通知等待线程。</p><h2 id="实现线程的交替打印："><a href="#实现线程的交替打印：" class="headerlink" title="实现线程的交替打印："></a>实现线程的交替打印：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATTIONS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 锁，用于线程同步</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量，用于线程通信</span></span><br><span class="line"><span class="type">int</span> current_thread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> thread_num, <span class="type">const</span> std::string&amp; messages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITERATTIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取锁，进入临界区</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是当前线程，就等待</span></span><br><span class="line">        <span class="keyword">while</span> (current_thread != thread_num) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 释放锁，允许其他线程进入临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        std::cout &lt;&lt; messages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改当前线程的编号</span></span><br><span class="line">        current_thread = (current_thread + <span class="number">1</span>) % NUM_THREADS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知下一个线程开始打印</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>(); <span class="comment">// 这里并没有释放锁，当前线程仍然持有锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print, i, <span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span> -pthread</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么使用条件变量唤醒的时候要用while而不用if？"><a href="#为什么使用条件变量唤醒的时候要用while而不用if？" class="headerlink" title="为什么使用条件变量唤醒的时候要用while而不用if？"></a>为什么使用条件变量唤醒的时候要用while而不用if？</h3><p>条件变量在等待期间可能会收到虚假唤醒（spurious wakeups），也就是在条件尚未满足时，线程被唤醒。</p><p>虚假唤醒是由于操作系统或底层线程库的实现细节引起的，他们可能会偶尔导致条件变量的信号量被错误唤醒。所以要循环检查，直到条件不满足。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程同步和线程通信&quot;&gt;&lt;a href=&quot;#线程同步和线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程同步和线程通信&quot;&gt;&lt;/a&gt;线程同步和线程通信&lt;/h2&gt;&lt;h3 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="CPP" scheme="https://kelinkong.github.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="https://kelinkong.github.io/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CS50课程学习笔记</title>
    <link href="https://kelinkong.github.io/2023/10/08/cs50/"/>
    <id>https://kelinkong.github.io/2023/10/08/cs50/</id>
    <published>2023-10-07T19:26:51.000Z</published>
    <updated>2024-03-30T03:54:37.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h3><ul><li>input –&gt; black box –&gt; output</li><li>binary&#x2F;bit: A bit is a zero or one</li><li>text: using ASCII</li><li>Emojis: Unicode</li><li>RGB: three numbers</li><li>Images, Video and Sound are simply collections of RGB values</li></ul><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ul><li>Problem-solving is central to computer science and computer programming</li></ul><h3 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h3><ul><li>function：pick up</li><li>conditions：if elseif</li><li>Boolean expression</li><li>loops：for&#x2F;while</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p><strong>command line interface</strong>：CLI， send commands to the computer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><em>这里并没有写makefile文件，为什么可以直接编译呢？</em><br><em>make程序默认会根据源代码文件的后缀名，自动生成并使用一个默认的Makefile规则进行编译。对于c语言的源代码，会有一个默认规则，类似如下：</em></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c <span class="comment"># % 是通配符，匹配任意字符串，匹配所有.c结尾的文件，生成以.o结尾的目标文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment"># $(CC) 变量，使用CC编译器。 $(CFLAGS)编译参数， -c表示进行编译而不链接， $&lt; 取出第一个前置文件的名字，即.c文件，-o指定输出目标文件，&amp;@ 取出目标文件的名字，既.o文件</span></span><br></pre></td></tr></table></figure><p>这里提到一个进行编译而不链接。回顾一下c语言编译的过程</p><ol><li>预处理，生成扩展后的.i文件。删除所有注释、#define 宏展开、文件包含 #include&lt;文件名&gt;</li><li>编译，汇编代码文件.s。会进行语法检查</li><li>组装。将汇编文件转化为机器码。生成.o文件</li><li>链接。链接是将库文件包含在我们的程序中的过程。生成可执行文件.out</li></ol><p><strong>静态成员变量是在哪一个阶段被初始化的呢？</strong></p><p><em>我们都知道静态成员变量是在运行<code>main</code>函数前初始化，那么究竟是在编译的哪一个阶段呢？</em></p><ol><li>定义在类内部的静态成员变量,其初始化是在编译期初期完成的。</li><li>定义在类外部的静态成员变量,其初始化是在链接阶段完成的。</li></ol><p>区别在于:</p><p>对于类内部定义的静态成员变量,编译器可以在编译当前类的定义时直接初始化它。</p><p>而对于类外部定义的静态成员变量,需要到链接阶段不同的目标文件合并时,由链接器完成初始化操作。</p><p><strong>预编译阶段，编译器会把#include包含的头文件内容展开Inline，但是对于lib库的引用则不会展开，而是保留该引用。真正使用库里的目标文件是在链接阶段。由链接器解析引用，并从外部库获取目标代码进行连接。</strong></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>linear and binary search</li><li>data structures</li><li>sorting</li><li>recursion</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><strong>内存地址为什么用16进制存放？</strong></p><ol><li>紧凑表示：使用尽可能少的数字来表示较大的内存空间</li><li>与CPU寻址匹配： CPU使用总线地址线表示内存地址，地址线数量是2的指数倍（如8条、16条），这与16进制表示是匹配的</li><li>转换为二进制方便，16进制中的每一个恰好对应2进制中的4位，可以非常方便的转换为二进制数。</li></ol><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>指针的本质就是一个地址变量。指向的是操作系统给模拟出来的虚拟内存空间的地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p是一个指针，(*p)表示获取指针所指向的值，&amp;符合代表取地址</span></span><br></pre></td></tr></table></figure><p>在c语言中<br><code>string</code>类型本质就是一个指针，以<code>&#39;\0&#39;</code>位标识符结尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HI!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">1</span>]); <span class="comment">// I</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">2</span>]); <span class="comment">// !</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">3</span>]); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">4</span>]); <span class="comment">// %</span></span><br></pre></td></tr></table></figure><p>为什么没有提示数组越界呢？</p><p><em>在c语言中数组边界检查并不是强制的。所以这访问越界并没有报错，但是可能会导致其他问题。当访问s[3]之后的值时，读取的是垃圾内存的值。</em></p><h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>valgrind是一个检查是否有内存泄漏的工具，比如使用malloc但是没有使用free。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    x[<span class="number">0</span>] = <span class="number">72</span>;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">73</span>;</span><br><span class="line">    x[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make test</code></p><p><code>valgrind --leak-check=full ./test</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==61782== HEAP SUMMARY:</span><br><span class="line">==61782==     in use at exit: 12 bytes in 1 blocks</span><br><span class="line">==61782==   total heap usage: 1 allocs, 0 frees, 12 bytes allocated</span><br><span class="line">==61782== </span><br><span class="line">==61782== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==61782==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==61782==    by 0x10915E: main (in /home/kelin/cs50/test)</span><br></pre></td></tr></table></figure><p><strong>valgind可以检查哪些类型的错误呢？</strong></p><ol><li>内存管理错误：访问越界、未释放、访问未初始化的内存等</li><li>线程错误：程序未正确join线程、线程同步错误（多个线程争用资源未加锁）</li><li>I&#x2F;O操作错误：文件描述符泄漏、socket使用错误</li><li>未定义行为：访问未初始化的变量</li></ol><h3 id="在c语言中，打开文件是如何实现的？"><a href="#在c语言中，打开文件是如何实现的？" class="headerlink" title="在c语言中，打开文件是如何实现的？"></a>在c语言中，打开文件是如何实现的？</h3><ol><li>open系统调用</li><li>分配文件描述符：文件描述符是内核用来标识这个文件打开状态的整数</li><li>更新文件表：将文件描述符放入进程的文件描述符表，该表维护了进程打开文件的状态</li><li>返回文件描述符：open系统调用返回文件描述符给应用程序</li><li>read&#x2F;write调用</li><li>关闭</li></ol><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p><strong><code>curl</code></strong></p><p>curl用来发送各种HTTP请求，获取或传输数据。</p><table><thead><tr><th>参数</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-X</td><td>指定http请求的方法</td><td>-X GET</td></tr><tr><td>-d</td><td>指定发送的数据体</td><td>-d ‘data&#x3D;test’</td></tr><tr><td>-I</td><td>只显示响应头信息，不显示响应内容</td><td></td></tr><tr><td>-w</td><td>将响应头信息保存到文件</td><td></td></tr><tr><td>-O</td><td>将服务器访问保存为文件</td><td>curl -O example.com&#x2F;file1.zip</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;Computational-Thinking&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Operating System" scheme="https://kelinkong.github.io/categories/Operating-System/"/>
    
    
    <category term="note" scheme="https://kelinkong.github.io/tags/note/"/>
    
  </entry>
  
</feed>
