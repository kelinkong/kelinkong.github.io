<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2026-02-11T09:02:33.942Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx-配置note</title>
    <link href="https://kelinkong.github.io/2026/01/23/nginx-%E9%85%8D%E7%BD%AEnote/"/>
    <id>https://kelinkong.github.io/2026/01/23/nginx-%E9%85%8D%E7%BD%AEnote/</id>
    <published>2026-01-23T07:14:57.000Z</published>
    <updated>2026-02-11T09:02:33.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx的作用">nginx的作用</h2><p>Nginx 是一个高性能的 Web 服务器 + 反向代理 + 负载均衡器。</p><h3 id="web服务器">web服务器</h3><p>Nginx 可以作为静态文件服务器，处理客户端的 HTTP 请求，返回 HTML、CSS、JavaScript 和图片等静态资源。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /var/www/html;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://example.com">example.com</a>，Nginx 直接把文件丢回去.</p><h3 id="反向代理">反向代理</h3><p>Nginx 可以作为反向代理服务器，接收客户端请求并将其转发到后端应用服务器（如 Node.js、Python、Java 等），然后将后端服务器的响应返回给客户端。</p><p>后端服务不直接暴露在公网。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:3000;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负载均衡">负载均衡</h3><p>Nginx 可以将客户端请求分发到多个后端服务器，以实现负载均衡，提高系统的可用性和性能。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载均衡策略</strong></p><ul><li>轮询（默认）：依次将请求分发到每个服务器。</li><li>权重：根据服务器的权重分配请求，权重高的服务器获得更多请求。</li><li>IP 哈希：根据客户端的 IP 地址分配请求，确保同一客户端的请求总是分发到同一台服务器。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ip</span> hash;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8080</span> weight=<span class="number">3</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8081</span> weight=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>HTTP 请求：状态不能放在实例里，必须外置（Redis / DB），这样双活才成立。</p></blockquote><blockquote><p>长连接：连接一旦建立，就天然固定在某一个 Pod / 实例上，不需要额外处理“双活路由”。</p></blockquote><h4 id="静态资源与动态请求分离">静态资源与动态请求分离</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /static/ &#123; // 静态资源不占用后端线程</span><br><span class="line">        <span class="attribute">root</span> /data/web;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTTPS-SSL-终结（证书统一）">HTTPS / SSL 终结（证书统一）</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>     cert.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> key.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端不用管 HTTPS，全部交给 Nginx</p><h2 id="nginx的变量">nginx的变量</h2><h3 id="内置变量">内置变量</h3><p>随时都能用的，来自 Nginx 核心请求上下文。</p><ul><li>$remote_addr: 客户端 IP 地址。</li><li>$host: 请求的主机名。</li><li>$request_uri: 包含参数的完整请求 URI。</li><li>$uri: 不包含参数的请求 URI。</li><li>$args: 请求参数部分。</li><li>$http_user_agent: 客户端的 User-Agent 头信息。</li><li>$http_referer: 请求的来源页面 URL。</li><li>$server_port: 服务器监听的端口号。</li><li>$scheme: 请求使用的协议（http 或 https）。</li></ul><h3 id="自定义变量">自定义变量</h3><p>可以在配置文件中使用 <code>set</code> 指令定义自己的变量。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set</span> <span class="variable">$my_var</span> <span class="string">&quot;some_value&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="header派生变量">header派生变量</h3><p>可以通过 <code>$http_</code> 前缀访问请求头信息，将请求头名称中的连字符 <code>-</code> 替换为下划线 <code>_</code>，全部小写。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-User-Id</span><span class="punctuation">: </span>123</span><br></pre></td></tr></table></figure><p>可以通过 <code>$http_x_user_id</code> 访问其值 <code>123</code>。</p><h3 id="map生成的变量">map生成的变量</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$http_user_id</span> <span class="variable">$backend</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> app_b;</span><br><span class="line">    1001    app_a;</span><br><span class="line">    1002    app_c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$backend</code> 变量将自动生成，并包含 <code>app_b</code>、<code>app_a</code> 和 <code>app_c</code> 三个值。</p><p>使用<code>proxy_pass http://$backend;</code>实现基于用户 ID 的请求路由。</p><h2 id="nginx配置">nginx配置</h2><h3 id="基本结构">基本结构</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main（全局</span><br><span class="line">└── events</span><br><span class="line">└── http</span><br><span class="line">    ├── upstream</span><br><span class="line">    ├── <span class="keyword">server</span></span><br><span class="line">        └── <span class="keyword">location</span></span><br></pre></td></tr></table></figure><h3 id="示例配置文件">示例配置文件</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> auto; // 默认为CPU核数</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>; // 一个 <span class="attribute">worker</span> 能接多少连接</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> digitalhuman &#123; // 后端服务定义</span><br><span class="line">        <span class="attribute">server</span> <span class="number">1.2.3.4:8000</span>;</span><br><span class="line">        <span class="attribute">keepalive</span> <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>; // 监听端口</span><br><span class="line">        <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /digitalhuman_app/ &#123; // 前端请求路径，正则匹配</span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">50m</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_buffering</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">300s</span>;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://digitalhuman/; // 这里加 / 表示去掉前缀</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考问答：<br><a href="https://www.zhihu.com/question/21483073">nginx能做什么好玩的事情</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nginx的作用&quot;&gt;nginx的作用&lt;/h2&gt;
&lt;p&gt;Nginx 是一个高性能的 Web 服务器 + 反向代理 + 负载均衡器。&lt;/p&gt;
&lt;h3 id=&quot;web服务器&quot;&gt;web服务器&lt;/h3&gt;
&lt;p&gt;Nginx 可以作为静态文件服务器，处理客户端的 HTTP 请求</summary>
      
    
    
    
    <category term="Frontend" scheme="https://kelinkong.github.io/categories/Frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>【c++】brtc项目开发记录</title>
    <link href="https://kelinkong.github.io/2026/01/22/%E3%80%90c++%E3%80%91brtc%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://kelinkong.github.io/2026/01/22/%E3%80%90c++%E3%80%91brtc%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2026-01-22T08:25:01.000Z</published>
    <updated>2026-01-22T11:10:01.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编译">编译</h3><p>同一个 C++ 进程里的所有 C++ SDK，ABI 必须一致，否则会出现莫名其妙的问题。</p><p>要使用</p><ul><li>同一个编译器</li><li>同一个 libstdc++</li><li>同一个 _GLIBCXX_USE_CXX11_ABI</li></ul><h4 id="什么是ABI？">什么是ABI？</h4><p>ABI（Application Binary Interface）是应用程序二进制接口，它是一个接口，应用程序和动态链接库（DLL）之间进行通信的协议。 ABI 定义了函数调用约定、数据类型、内存布局等内容。</p><p>target_compile_definitions(<target> PUBLIC _GLIBCXX_USE_CXX11_ABI=0)</p><p>这里ABI=0表示使用旧版本ABI。</p><p>旧版本ABI的编译选项为：-D_GLIBCXX_USE_CXX11_ABI=0<br>新版本ABI的编译选项为：-D_GLIBCXX_USE_CXX11_ABI=1</p><h4 id="如何查看SDK的ABI版本？">如何查看SDK的ABI版本？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -Ws libbaidurtc.so | grep GLIBCXX_</span><br></pre></td></tr></table></figure><h3 id="初始化">初始化</h3><p>C++的类的成员变量，都需要在构造函数中初始化吗？标准的写法是什么样子的？</p><p>C++ 成员变量：</p><ul><li>const / 引用 / 无默认构造 → 必须初始化</li><li>其他可以赋值，但 不推荐</li><li>初始化列表是唯一正确的工程实践</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">a_</span>(x), <span class="built_in">b_</span>(y), <span class="built_in">c_</span>(<span class="number">0</span>) &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;同一个 C++ 进程里的所有 C++ SDK，ABI 必须一致，否则会出现莫名其妙的问题。&lt;/p&gt;
&lt;p&gt;要使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个编译器&lt;/li&gt;
&lt;li&gt;同一个 libstdc++&lt;/li&gt;
&lt;li&gt;同一个 _GLI</summary>
      
    
    
    
    <category term="C++" scheme="https://kelinkong.github.io/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-copy模式</title>
    <link href="https://kelinkong.github.io/2025/12/08/Java-copy%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kelinkong.github.io/2025/12/08/Java-copy%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-12-08T08:07:01.000Z</published>
    <updated>2025-12-08T08:24:19.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的赋值">Java中的赋值</h2><p>在 Java 中，对象变量（非基本数据类型，如 int、boolean 等）存储的实际上是 引用（或者说内存地址），它指向堆（Heap）上的实际对象。</p><p>当使用等号进行赋值时，默认执行的是 引用赋值（Reference Assignment）：</p><ul><li>ObjectA = ObjectB</li></ul><p>这个操作不会创建新的对象。</p><p>它使得变量 ObjectA 存储的引用与变量 ObjectB 存储的引用 相同，它们现在都指向 堆上同一个对象实例。</p><p><strong>这意味着通过 ObjectA 或 ObjectB 对对象进行的任何修改，都会影响到同一个底层数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyObject</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(); <span class="comment">// 创建对象1</span></span><br><span class="line"><span class="type">MyObject</span> <span class="variable">b</span> <span class="operator">=</span> a;              <span class="comment">// 引用赋值，b 和 a 都指向 对象1</span></span><br><span class="line">b.setValue(<span class="number">10</span>);              <span class="comment">// 通过 b 修改 对象1</span></span><br><span class="line"><span class="comment">// 此时 a.getValue() 也是 10</span></span><br></pre></td></tr></table></figure><h3 id="C-默认复制构造函数或重载运算符">C++ (默认复制构造函数或重载运算符)</h3><p>在 C++ 中，一个普通的 类对象变量 通常直接包含其数据成员。</p><p>当使用等号进行赋值时，默认执行的是 成员逐个复制（Memberwise Copy）：</p><ul><li>ObjectA = ObjectB</li></ul><p>如果 ObjectA 已经存在，这个操作会调用 赋值运算符（Assignment Operator, 即 operator=）。</p><p>如果没有显式定义，默认的赋值运算符 会将 ObjectB 的所有非静态数据成员 逐个复制 给 ObjectA。</p><p>这会创建一个 新的独立的对象状态（虽然数据一样），ObjectA 和 ObjectB 仍是两个独立的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyClass A;      <span class="comment">// 对象 A</span></span><br><span class="line">MyClass B;      <span class="comment">// 对象 B</span></span><br><span class="line">B.<span class="built_in">setValue</span>(<span class="number">10</span>);</span><br><span class="line">A = B;          <span class="comment">// 默认赋值：将 B 的数据成员复制给 A</span></span><br><span class="line">A.<span class="built_in">setValue</span>(<span class="number">20</span>); <span class="comment">// 修改 A 的值，不会影响 B</span></span><br><span class="line"><span class="comment">// 此时 B 的值仍是 10</span></span><br></pre></td></tr></table></figure><h4 id="注意-C-浅拷贝陷阱-：">注意 (C++ 浅拷贝陷阱)：</h4><p>默认的逐个复制对于对象内包含 动态分配的内存（例如，一个类中有一个 int* 指针）时，会导致 浅拷贝 问题。<a href="https://kelinkong.github.io/2021/09/18/%E3%80%90c++%E3%80%91%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/">C++浅拷贝</a></p><p>赋值后，<code>ObjectA</code> 和 <code>ObjectB</code> 的指针成员将指向 同一块 动态内存。</p><p>当其中一个对象（如 <code>ObjectB</code>）被销毁时，它会释放这块内存，导致另一个对象（<code>ObjectA</code>）的指针变成悬空指针，再次访问或销毁时会导致程序崩溃。</p><p>为了解决这个问题，在 C++ 中包含动态内存的类通常需要显式定义 深拷贝 的 复制构造函数 和 赋值运算符，以确保新对象拥有自己独立的数据副本。</p><h2 id="Java是怎么避免浅拷贝陷阱的？">Java是怎么避免浅拷贝陷阱的？</h2><p><strong>简而言之：</strong> Java 避免 C++ 默认赋值导致的浅拷贝陷阱，是因为它们对“赋值”的定义根本不同。</p><h3 id="1-Java-如何避免浅拷贝陷阱？">1. Java 如何避免浅拷贝陷阱？</h3><p>Java 通过其 <strong>引用的本质</strong> 避免了 C++ 默认赋值运算符所导致的浅拷贝陷阱。</p><h4 id="1-1-赋值运算符（-）的角色不同">1.1 赋值运算符（<code>=</code>）的角色不同</h4><table><thead><tr><th style="text-align:left">语言</th><th style="text-align:left">操作符 (<code>=</code>) 的默认行为</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Java</strong></td><td style="text-align:left"><strong>引用赋值 (Reference Assignment)</strong></td><td style="text-align:left"><code>A = B</code> 意味着 <code>A</code> 和 <code>B</code> 都指向堆内存中的 <strong>同一对象</strong>。这永远不会创建新的数据副本，因此不会发生 C++ 意义上的浅拷贝（即复制对象数据时只复制指针地址）。</td></tr><tr><td style="text-align:left"><strong>C++</strong></td><td style="text-align:left"><strong>数据赋值 (Data Copying)</strong></td><td style="text-align:left">默认调用赋值运算符，将 <code>B</code> 对象的数据成员 <strong>逐个复制</strong> 给 <code>A</code> 对象。当数据成员是指针时，复制的只是指针的值（地址），导致两个对象共享同一块堆内存。</td></tr></tbody></table><h4 id="1-2-Java-的内存管理机制">1.2 Java 的内存管理机制</h4><p>在 Java 中，当你说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>();</span><br><span class="line"><span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> obj1; <span class="comment">// 引用赋值</span></span><br></pre></td></tr></table></figure><p>这是 <strong>引用赋值</strong>。</p><ul><li><code>obj1</code> 和 <code>obj2</code> 都是 <strong>遥控器</strong>。</li><li>它们都指向 <strong>堆上同一个电视机（对象）</strong>。</li></ul><p>因此，当你通过 <code>obj2</code> 改变电视机的频道时，<code>obj1</code> 看到的也是新频道。既然没有发生数据的“复制”行为，自然就不会触发 C++ 那种“复制指针”的陷阱。</p><h4 id="1-3-clone-方法与浅拷贝风险">1.3 <code>clone()</code> 方法与浅拷贝风险</h4><p>需要注意的是，虽然 Java 的 <strong>默认赋值</strong> 是安全的，但当你尝试在 Java 中进行 <strong>显式拷贝</strong> 时，风险仍然存在：</p><p>Java 的 <code>Object</code> 类中自带的 <code>clone()</code> 方法，其默认实现是 <strong>浅拷贝（Shallow Copy）</strong>。</p><ul><li><strong>浅拷贝</strong>：它创建了一个新对象，并将原对象的所有字段值复制给新对象。<ul><li>如果字段是 <strong>基本类型</strong> 或 <strong>不可变对象</strong>（如 <code>String</code>），则安全。</li><li>如果字段是 <strong>可变对象引用</strong>（如 <code>ArrayList</code> 或自定义类），则只复制了该引用地址。新对象和原对象会 <strong>共享</strong> 内部的这个可变对象，当你修改其中一个时，另一个也会被影响。</li></ul></li></ul><p>所以，Java 避免了 C++ <strong>赋值</strong> 带来的默认陷阱，但如果你不正确地使用 <code>clone()</code> 或自定义拷贝方法，<strong>浅拷贝的风险依然存在</strong>。</p><h3 id="2-如何在-Java-中实现-C-风格的独立拷贝（深拷贝）？">2. 如何在 Java 中实现 C++ 风格的独立拷贝（深拷贝）？</h3><p>实现 C++ 风格的独立拷贝（即 <strong>深拷贝 Deep Copy</strong>），目的是创建一个全新的、与原对象在数据上完全独立的副本，包括所有嵌套的子对象。</p><p>实现深拷贝主要有两种推荐的方法：<strong>拷贝构造函数</strong> 和 <strong>重写 <code>clone()</code></strong>。</p><h4 id="方式一：使用拷贝构造函数（推荐）">方式一：使用拷贝构造函数（推荐）</h4><p>这是最常用、最清晰、也是最推荐的方法。它在创建新对象时，递归地为所有可变（Mutable）引用字段创建新的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Department department; <span class="comment">// 假设 Department 是一个可变对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, Department department)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐ 拷贝构造函数 (执行深拷贝)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Employee original)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = original.name; <span class="comment">// String 是不可变的，浅拷贝即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键：对可变引用类型执行深拷贝（调用其拷贝构造函数）</span></span><br><span class="line">        <span class="built_in">this</span>.department = <span class="keyword">new</span> <span class="title class_">Department</span>(original.department); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong> 1.  <strong>明确性高：</strong> 意图清晰，易于维护。<br>2.  <strong>更灵活：</strong> 不依赖于 <code>Cloneable</code> 接口。</p><h4 id="方式二：正确重写-clone-方法">方式二：正确重写 <code>clone()</code> 方法</h4><p>使用 <code>clone()</code> 需要遵循特定的步骤来实现深拷贝：</p><ol><li>实现 <code>Cloneable</code> 接口（标记接口）。</li><li>重写 <code>Object</code> 的 <code>protected clone()</code> 方法，并将其访问权限改为 <code>public</code>。</li><li>在方法中，先调用 <code>super.clone()</code> 获得浅拷贝。</li><li><strong>手动</strong> 对所有可变引用字段进行深拷贝。</li></ol><!-- end list --><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 1. 获得对象的浅拷贝</span></span><br><span class="line">        <span class="type">Department</span> <span class="variable">newDept</span> <span class="operator">=</span> (Department) <span class="built_in">super</span>.clone(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 如果 Department 内部还有可变对象，需要在这里递归进行深拷贝。</span></span><br><span class="line">        <span class="comment">// 例如：newDept.staff = new ArrayList&lt;&gt;(this.staff);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newDept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong> 1.  实现了 Java 标准库的约定。</p><p><strong>缺点：</strong> 1.  <strong>侵入性强：</strong> 必须实现 <code>Cloneable</code> 接口。<br>2.  <strong>不安全：</strong> <code>clone()</code> 返回 <code>Object</code> 类型，需要进行类型转换。<br>3.  <strong>复杂：</strong> 必须处理 <code>CloneNotSupportedException</code> 异常。</p><h4 id="方式三：通过序列化（不推荐用于日常操作）">方式三：通过序列化（不推荐用于日常操作）</h4><p>通过将对象写入输出流（序列化）再从输入流读出（反序列化），可以最简单地保证深拷贝，因为序列化过程会为整个对象图创建全新的副本。</p><p><strong>缺点：</strong> 1.  <strong>性能差：</strong> 涉及 I/O 操作，比前两种方法慢得多。<br>2.  <strong>限制：</strong> 对象及其所有内部对象必须实现 <code>Serializable</code> 接口。</p><h2 id="可变对象和不可变对象">可变对象和不可变对象</h2><p>我的类A中有一个Integer对象，我使用B=A，那么当我修改B中的Integer对象时，A中的也会跟着改变？</p><p>这是一个非常关键的问题，它涉及到 <strong>Java 的引用赋值</strong> 和 <strong>Integer 的不变性</strong>。</p><p>答案是：<strong>不会</strong>。当你修改 <code>B</code> 中的 <code>Integer</code> 字段时，<strong><code>A</code> 中的 <code>Integer</code> 字段不会跟着改变</strong>。</p><h3 id="为什么不会改变？">为什么不会改变？</h3><p>虽然 <code>B = A</code> 是引用赋值（意味着 <code>A</code> 和 <code>B</code> 指向堆上同一个 <code>A</code> 类实例），并且它们共享了内部的 <code>Integer</code> 字段，但这种共享是安全的，原因在于 <code>Integer</code> 类的核心特性：<strong>不可变性 (Immutability)</strong>。</p><p>让我们通过一个假设的例子来详细分析这个过程：</p><h4 id="1-初始状态-引用共享">1. 初始状态 (引用共享)</h4><p>假设你有一个 <code>MyClass</code>，其中包含一个 <code>Integer</code> 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    Integer value; <span class="comment">// 字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(Integer v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">B</span> <span class="operator">=</span> A; <span class="comment">// A 和 B 引用赋值，指向同一个 MyClass 实例</span></span><br></pre></td></tr></table></figure><ul><li>此时，<code>A.value</code> 和 <code>B.value</code> 都指向 <strong>同一个 <code>Integer(100)</code> 对象</strong>。<ul><li><code>A</code> 指向 Object X。</li><li><code>B</code> 也指向 Object X。</li><li>Object X 内部的 <code>value</code> 字段指向 Integer(100)。</li></ul></li></ul><h4 id="2-执行-“修改”-操作-断开共享">2. 执行 “修改” 操作 (断开共享)</h4><p>当你执行一个看似修改 <code>B</code> 中 <code>Integer</code> 字段的操作时，实际上并不是在修改那个 <code>Integer</code> 对象，而是在 <strong>改变 <code>B</code> 内部的引用指向</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你尝试修改 B.value 的值</span></span><br><span class="line">B.value = <span class="number">200</span>; <span class="comment">// 假设 B 类中有一个公共的 setter 或直接访问字段</span></span><br></pre></td></tr></table></figure><p>这个操作的底层机制是：</p><ol><li><code>Integer</code> 对象是 <strong>不可变</strong> 的。你无法修改那个值为 <code>100</code> 的对象本身。</li><li>Java 会创建一个 <strong>新的 <code>Integer(200)</code> 对象</strong>。</li><li><code>B.value</code> 这个字段的 <strong>引用</strong> 被更新，使其指向这个 <strong>新的 <code>Integer(200)</code> 对象</strong>。</li><li>因为 <code>A</code> 和 <code>B</code> 仍然指向同一个 <code>MyClass</code> 实例 (Object X)，所以 <code>A.value</code> 和 <code>B.value</code> 都改变了。</li></ol><h4 id="3-陷阱的真正发生条件：可变对象（Mutable-Object）">3. 陷阱的真正发生条件：可变对象（Mutable Object）</h4><p>如果你的类 <code>A</code> 中包含的不是 <code>Integer</code>（不可变对象），而是像 <strong><code>ArrayList</code></strong> 或你自定义的 <strong>可变对象</strong>，那么陷阱就会发生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMutableClass</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; data; <span class="comment">// 可变对象</span></span><br><span class="line">    <span class="comment">// ... 构造函数等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyMutableClass</span> <span class="variable">A_mut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMutableClass</span>(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;X&quot;</span>)));</span><br><span class="line"><span class="type">MyMutableClass</span> <span class="variable">B_mut</span> <span class="operator">=</span> A_mut; <span class="comment">// 引用赋值，共享同一个 MyMutableClass 实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试修改 B 中的字段内容</span></span><br><span class="line">B_mut.data.add(<span class="string">&quot;Y&quot;</span>); <span class="comment">// ⚠️ 陷阱发生！</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li><code>B_mut.data.add(&quot;Y&quot;)</code> 是在调用 <code>ArrayList</code> 对象的 <strong>内部修改方法</strong>。</li><li>这个方法修改了 <strong>堆上共享的那个 <code>ArrayList</code> 实例</strong>。</li><li>因为 <code>A_mut</code> 和 <code>B_mut</code> 都指向同一个 <code>ArrayList</code>，所以 <code>A_mut.data</code> 也会看到新的元素 <code>&quot;Y&quot;</code>。</li></ol><h3 id="总结-🚀">总结 🚀</h3><table><thead><tr><th style="text-align:left">字段类型</th><th style="text-align:left">赋值 (<code>B = A</code>) 后修改 <code>B</code> 中的字段</th><th style="text-align:left">结果</th></tr></thead><tbody><tr><td style="text-align:left"><strong><code>Integer</code> (不可变)</strong></td><td style="text-align:left"><code>B.value = 200;</code></td><td style="text-align:left"><strong>A 不变</strong>。因为该操作创建了新的 <code>Integer</code> 对象并更新了 <code>B</code> 的引用。</td></tr><tr><td style="text-align:left"><strong><code>ArrayList</code> (可变)</strong></td><td style="text-align:left"><code>B.data.add(&quot;Y&quot;);</code></td><td style="text-align:left"><strong>A 跟着改变</strong>。因为该操作修改了共享的 <code>ArrayList</code> 对象的内部状态。</td></tr></tbody></table><p><strong>对于 不可变对象 (Immutable Object)，当对它进行“修改”操作时，本质上就是创建了一个新的对象。</strong></p><h3 id="常见的可变对象和不可变对象">常见的可变对象和不可变对象</h3><p>常见的 <strong>可变对象</strong>（Mutable Objects）和 <strong>不可变对象</strong>（Immutable Objects）是 Java 语言设计的基础。</p><h4 id="🔒-常见的不可变对象-Immutable-Objects">🔒 常见的不可变对象 (Immutable Objects)</h4><p>不可变对象是线程安全的，它们的值在创建后不会改变。</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">示例类</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><strong>基本类型包装类</strong></td><td style="text-align:left"><code>java.lang.Integer</code></td><td style="text-align:left">所有基本数据类型的包装类，包括 <code>Byte</code>, <code>Short</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Character</code>, <code>Boolean</code>，都是不可变的。</td></tr><tr><td style="text-align:left"><strong>字符串</strong></td><td style="text-align:left"><code>java.lang.String</code></td><td style="text-align:left">最常用的不可变对象。所有修改字符串的操作（如 <code>concat()</code>）都会返回一个新的 <code>String</code> 实例。</td></tr><tr><td style="text-align:left"><strong>日期时间 API</strong></td><td style="text-align:left"><code>java.time.LocalDate</code></td><td style="text-align:left">Java 8 引入的新的日期时间 API 中的核心类，如 <code>LocalDateTime</code>, <code>ZonedDateTime</code> 等，都是不可变的。</td></tr><tr><td style="text-align:left"><strong>通用类</strong></td><td style="text-align:left"><code>java.lang.Class</code></td><td style="text-align:left">表示类的对象，是不可变的。</td></tr><tr><td style="text-align:left"><strong>集合 (部分)</strong></td><td style="text-align:left"><code>java.util.Collections.unmodifiableList(...)</code></td><td style="text-align:left">通过工具类创建的 <strong>不可修改的集合视图</strong>，虽然不是真正的不可变，但不能通过视图修改内容。</td></tr></tbody></table><h4 id="🔓-常见的可变对象-Mutable-Objects">🔓 常见的可变对象 (Mutable Objects)</h4><p>可变对象可以随时修改其内部状态，因此在多线程环境下需要特别注意同步问题。</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">示例类</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left"><strong>日期时间 API (旧)</strong></td><td style="text-align:left"><code>java.util.Date</code></td><td style="text-align:left">老的日期时间类，它的时间可以被 <code>setTime()</code> 方法修改。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>java.util.Calendar</code></td><td style="text-align:left">同样是可变的，可以通过 <code>set()</code> 方法修改内部日期字段。</td></tr><tr><td style="text-align:left"><strong>字符串构建</strong></td><td style="text-align:left"><code>java.lang.StringBuilder</code></td><td style="text-align:left">用于在单线程环境中高效地修改字符串。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>java.lang.StringBuffer</code></td><td style="text-align:left">线程安全的版本，用于在多线程环境中高效地修改字符串。</td></tr><tr><td style="text-align:left"><strong>集合框架</strong></td><td style="text-align:left"><code>java.util.ArrayList</code></td><td style="text-align:left">可以通过 <code>add()</code>, <code>remove()</code>, <code>set()</code> 等方法修改列表内容。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>java.util.HashMap</code></td><td style="text-align:left">可以通过 <code>put()</code>, <code>remove()</code> 等方法修改映射内容。</td></tr><tr><td style="text-align:left"><strong>IO 框架</strong></td><td style="text-align:left"><code>java.io.File</code></td><td style="text-align:left">表示文件路径的对象，虽然文件路径本身通常不变，但它不符合不可变对象的严格定义。</td></tr><tr><td style="text-align:left"><strong>数组</strong></td><td style="text-align:left">所有数组类型 (e.g., <code>String[]</code>, <code>int[]</code>)</td><td style="text-align:left">数组的内容可以被直接修改。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java中的赋值&quot;&gt;Java中的赋值&lt;/h2&gt;
&lt;p&gt;在 Java 中，对象变量（非基本数据类型，如 int、boolean 等）存储的实际上是 引用（或者说内存地址），它指向堆（Heap）上的实际对象。&lt;/p&gt;
&lt;p&gt;当使用等号进行赋值时，默认执行的是 引用赋值</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>网络安全-学习笔记</title>
    <link href="https://kelinkong.github.io/2025/11/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-tryHackMe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2025/11/28/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-tryHackMe%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2025-11-28T03:14:34.000Z</published>
    <updated>2025-11-30T01:11:48.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是SIEM工具？">什么是SIEM工具？</h2><p>SIEM（Security Information and Event Management，安全信息和事件管理）工具是一种用于实时监控、分析和管理安全事件的软件系统。它通过收集和分析来自各种来源的日志数据，帮助组织识别潜在的安全威胁和漏洞，从而提高整体的安全态势。</p><h3 id="常见的SIEM工具">常见的SIEM工具</h3><ol><li>Splunk：Splunk是一种流行的SIEM工具，提供强大的数据收集、分析和可视化功能。它支持多种数据源，并提供丰富的安全分析功能。</li><li>IBM QRadar：QRadar是IBM提供的SIEM解决方案，具有强大的威胁检测和响应能力。它能够自动化安全事件的分析和响应，提高安全运营效率。</li><li>ArcSight：ArcSight是Micro Focus提供的SIEM工具，具有强大的日志管理和事件关联功能。它支持大规模数据处理，适用于大型企业环境。</li><li>LogRhythm：LogRhythm是一种集成的SIEM平台，提供全面的安全信息和事件管理功能。它支持实时威胁检测和响应，帮助组织快速应对安全事件。</li><li>AlienVault OSSIM：AlienVault OSSIM是一种开源的SIEM工具，提供基本的安全信息和事件管理功能。它适用于中小型企业，具有易于使用和部署的特点。</li></ol><h3 id="寻找可疑ip">寻找可疑ip</h3><p>在SIEM工具中，寻找可疑IP地址通常涉及以下步骤：</p><ol><li>数据收集：首先，确保SIEM工具已经配置为收集来自各种数据源的日志数据，包括防火墙、入侵检测系统（IDS）、服务器日志等。</li><li>日志分析：使用SIEM工具的日志分析功能，筛选出与IP地址相关的日志条目。可以根据时间范围、事件类型等条件进行过滤。</li><li>威胁情报集成：将威胁情报源集成到SIEM工具中，以便识别已知的恶意IP地址。许多SIEM工具支持与外部威胁情报平台的集成。</li><li>异常检测：利用SIEM工具的异常检测功能，识别与正常行为模式不符的IP地址。例如，频繁的登录失败、异常的流量模式等。</li><li>报告和告警：配置SIEM工具生成关于可疑IP地址的报告和告警，以便安全团队能够及时响应潜在的威胁。</li><li>调查和响应：一旦识别出可疑IP地址，安全团队应进一步调查其活动，并采取适当的响应措施，如阻止该IP地址的访问或进行深入的取证分析。</li></ol><p>把恶意ip地址添加到阻止列表中，可以有效地防止来自这些地址的潜在攻击，保护组织的网络安全。</p><h2 id="防火墙阻止可疑-IP-的机制">防火墙阻止可疑 IP 的机制</h2><p>防火墙主要通过两种核心技术来阻止可疑 IP：<strong>静态规则过滤</strong>和<strong>动态策略/情报集成</strong>。</p><h3 id="1-静态规则过滤（ACLs-Blacklisting）">1. 静态规则过滤（ACLs / Blacklisting）</h3><p>这是最基本、最直接的方法。</p><ul><li><strong>访问控制列表 (ACL)：</strong> 防火墙管理员会手动或通过自动化工具，在防火墙的访问控制列表中添加已知的、恶意的或不受信任的 IP 地址。</li><li><strong>匹配过程：</strong><ol><li>当一个网络数据包到达防火墙时，防火墙会检查该数据包的<strong>源 IP 地址</strong>。</li><li>它将该源 IP 地址与配置好的 ACL 或<strong>黑名单</strong>进行比对。</li><li>如果 IP 地址匹配到黑名单中的条目，防火墙会执行预设的操作，通常是：<ul><li><strong>Drop (丢弃):</strong> 直接静默地丢弃数据包，不通知源端。</li><li><strong>Reject (拒绝):</strong> 丢弃数据包，并向源端发送一个 ICMP 错误消息（例如，Destination Unreachable），表明连接被拒绝。</li></ul></li></ol></li></ul><h3 id="2-动态策略与安全情报集成（IPS-Threat-Intelligence）">2. 动态策略与安全情报集成（IPS/Threat Intelligence）</h3><p>现代防火墙（特别是下一代防火墙 NGFW）拥有更智能、更动态的阻止能力。</p><h4 id="A-基于威胁情报-Threat-Intelligence-的阻止">A. 基于威胁情报 (Threat Intelligence) 的阻止</h4><ul><li><strong>情报订阅：</strong> 防火墙会订阅或集成外部的安全威胁情报源（如来自 SIEM、云服务商、或专业安全厂商的 Feeds）。</li><li><strong>实时更新：</strong> 这些情报源提供了一个持续更新的、全球范围内的恶意 IP 地址列表，包括：<strong>僵尸网络 C&amp;C 服务器、恶意软件分发点、已知的攻击源</strong>等。</li><li><strong>动态阻止：</strong> 防火墙将这些情报动态加载到其阻止列表中，实现对全球新兴威胁的实时防御。</li></ul><h4 id="B-基于行为和入侵检测的阻止-IPS-IDS">B. 基于行为和入侵检测的阻止 (IPS/IDS)</h4><ul><li><strong>入侵防御系统 (IPS)：</strong> IPS 通常是集成在防火墙内的模块。它不仅仅查看 IP 地址，还会对数据包的**内容（Payload）**进行深度检查。</li><li><strong>异常行为：</strong> 如果一个 IP 地址开始发送<strong>大量探测请求</strong>、<strong>尝试登录多次失败</strong>、或者发送了<strong>包含已知漏洞特征码</strong>的数据包，IPS 就会将其标记为可疑。</li><li><strong>临时封锁：</strong> 一旦检测到恶意行为，防火墙会<strong>自动</strong>在一段预设时间内（例如 10 分钟或 24 小时）阻止该可疑 IP 地址，即使该 IP 不在静态黑名单中。</li></ul><h3 id="3-基于地理位置的阻止-Geo-Blocking">3. 基于地理位置的阻止 (Geo-Blocking)</h3><ul><li><strong>地理定位：</strong> 防火墙通过 IP 地址的地理位置信息，识别数据包的来源国家或地区。</li><li><strong>策略应用：</strong> 如果企业的业务不需要与某个高风险国家或地区进行网络通信，防火墙可以配置策略，<strong>直接阻止来自整个国家/地区 IP 范围的所有流量</strong>。</li></ul><p>防火墙阻止可疑 IP 地址是一个多层次的防御过程：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">依据</th><th style="text-align:left">决策方式</th><th style="text-align:left">常见应用</th></tr></thead><tbody><tr><td style="text-align:left"><strong>静态/ACL</strong></td><td style="text-align:left">IP 地址是否在管理员配置的黑名单中。</td><td style="text-align:left">规则匹配（精确或范围）。</td><td style="text-align:left">阻止已知的、长期的攻击者 IP。</td></tr><tr><td style="text-align:left"><strong>动态/IPS</strong></td><td style="text-align:left">IP 地址的行为模式和数据包的内容。</td><td style="text-align:left">实时分析、特征码比对、异常行为检测。</td><td style="text-align:left">阻止正在进行中的暴力破解或漏洞利用尝试。</td></tr><tr><td style="text-align:left"><strong>情报集成</strong></td><td style="text-align:left">IP 地址是否被全球威胁情报源标记为恶意。</td><td style="text-align:left">动态订阅和匹配。</td><td style="text-align:left">阻止最新的、全球性的僵尸网络或恶意活动。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是SIEM工具？&quot;&gt;什么是SIEM工具？&lt;/h2&gt;
&lt;p&gt;SIEM（Security Information and Event Management，安全信息和事件管理）工具是一种用于实时监控、分析和管理安全事件的软件系统。它通过收集和分析来自各种来源的日志</summary>
      
    
    
    
    <category term="Network-Security" scheme="https://kelinkong.github.io/categories/Network-Security/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-命令模式</title>
    <link href="https://kelinkong.github.io/2025/11/18/Java-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kelinkong.github.io/2025/11/18/Java-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2025-11-18T01:43:49.000Z</published>
    <updated>2025-11-18T01:51:45.288Z</updated>
    
    <content type="html"><![CDATA[<p><strong>命令模式（Command Pattern）和大模型调用中的 Chain（Chain of Thought / Chain of Actions / Agent Chain / Pipeline Chain）本质上是同一种思想：将复杂逻辑拆成可插拔、可组合、可扩展的步骤链式执行。</strong></p><p><strong>大模型调用流程场景的命令链（Chain）简化 Demo</strong></p><blockquote><p>场景：对话请求 → 经过步骤链：<strong>内容安全检查 → Prompt 优化 → 调用模型 → 结果润色 → 结果输出</strong></p></blockquote><p>如果是我来设计这个 Chain 模式，我会怎么写？</p><p>将每一种工具调用都封装为一个函数or一个类，然后按照步骤一个个调用。</p><p>如果是使用命令模式，要怎么实现？</p><h2 id="目录结构">目录结构</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chain</span><br><span class="line"> ├─ step <span class="comment">// 各步骤实现</span></span><br><span class="line"> │   ├─ <span class="module-access"><span class="module"><span class="identifier">CheckSafetyStep</span>.</span></span>java</span><br><span class="line"> │   ├─ <span class="module-access"><span class="module"><span class="identifier">EnhancePromptStep</span>.</span></span>java</span><br><span class="line"> │   ├─ <span class="module-access"><span class="module"><span class="identifier">CallLLMStep</span>.</span></span>java</span><br><span class="line"> │   ├─ <span class="module-access"><span class="module"><span class="identifier">PolishOutputStep</span>.</span></span>java</span><br><span class="line"> ├─ <span class="module-access"><span class="module"><span class="identifier">ChainStep</span>.</span></span>java <span class="comment">// 统一接口</span></span><br><span class="line"> ├─ <span class="module-access"><span class="module"><span class="identifier">ChainContext</span>.</span></span>java <span class="comment">// 上下文对象</span></span><br><span class="line"> ├─ <span class="module-access"><span class="module"><span class="identifier">ChainExecutor</span>.</span></span>java <span class="comment">// 执行器</span></span><br></pre></td></tr></table></figure><h2 id="①-统一接口：ChainStep">① 统一接口：ChainStep</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span>;</span><br><span class="line">    String <span class="title function_">stepName</span><span class="params">()</span>; <span class="comment">// 用于日志、调试、动态开关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个step都需要实现这个统一接口，包含执行方法execute和步骤名称stepName。</p><p>调用execute方法，进行执行。</p><h2 id="②-上下文对象：ChainContext">② 上下文对象：ChainContext</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userInput;</span><br><span class="line">    <span class="keyword">private</span> String optimizedPrompt;</span><br><span class="line">    <span class="keyword">private</span> String llmResult;</span><br><span class="line">    <span class="keyword">private</span> String finalOutput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="③-各步骤示例">③ 各步骤示例</h2><h3 id="内容安全检测">内容安全检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckSafetyStep</span> <span class="keyword">implements</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.getUserInput().contains(<span class="string">&quot;违法&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;内容违规&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;安全检查通过&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stepName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;check_safety&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prompt-优化">Prompt 优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhancePromptStep</span> <span class="keyword">implements</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span> &#123;</span><br><span class="line">        ctx.setOptimizedPrompt(<span class="string">&quot;请专业、克制地回答：&quot;</span> + ctx.getUserInput());</span><br><span class="line">        System.out.println(<span class="string">&quot;Prompt 优化完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stepName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;enhance_prompt&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用大模型">调用大模型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallLLMStep</span> <span class="keyword">implements</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 假装调用大模型</span></span><br><span class="line">        ctx.setLlmResult(<span class="string">&quot;【大模型回答】&quot;</span> + ctx.getOptimizedPrompt());</span><br><span class="line">        System.out.println(<span class="string">&quot;模型调用完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stepName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;call_llm&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出润色">输出润色</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolishOutputStep</span> <span class="keyword">implements</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span> &#123;</span><br><span class="line">        ctx.setFinalOutput(ctx.getLlmResult().replace(<span class="string">&quot;【大模型回答】&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;输出润色完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">stepName</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;polish_output&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="④-Chain-执行器（最核心部分）">④ Chain 执行器（最核心部分）</h2><p>结合 Spring 自动装载所有 ChainStep：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放所有需要执行的步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ChainStep&gt; steps;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChainExecutor</span><span class="params">(List&lt;ChainStep&gt; stepList)</span> &#123;</span><br><span class="line">        <span class="comment">// 可按注解排序、配置化排序</span></span><br><span class="line">        <span class="built_in">this</span>.steps = stepList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    <span class="keyword">public</span> ChainContext <span class="title function_">run</span><span class="params">(ChainContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ChainStep step : steps) &#123;</span><br><span class="line">            step.execute(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="⑤-调用链执行">⑤ 调用链执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChainExecutor chainExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/chat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">chat</span><span class="params">(<span class="meta">@RequestBody</span> String input)</span> &#123;</span><br><span class="line">        <span class="type">ChainContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainContext</span>();</span><br><span class="line">        ctx.setUserInput(input);</span><br><span class="line"></span><br><span class="line">        chainExecutor.run(ctx);</span><br><span class="line">        <span class="keyword">return</span> ctx.getFinalOutput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试输出结果">测试输出结果</h2><p>请求：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hello</span></span><br></pre></td></tr></table></figure><p>控制台：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安全检查通过</span><br><span class="line">Prompt 优化完成</span><br><span class="line">模型调用完成</span><br><span class="line">输出润色完成</span><br></pre></td></tr></table></figure><p>返回给前端：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请专业、克制地回答：hello</span><br></pre></td></tr></table></figure><h2 id="优点（非常适用于大模型开发）">优点（非常适用于大模型开发）</h2><table><thead><tr><th>传统做法</th><th>Chain 做法</th></tr></thead><tbody><tr><td>所有逻辑写在一个方法</td><td>每一步一个 Step</td></tr><tr><td>无法扩展</td><td>新增 Step 即插拔</td></tr><tr><td>难调试</td><td>日志基于 stepName</td></tr><tr><td>逻辑顺序静态</td><td>steps 可动态配置</td></tr><tr><td>不支持灰度</td><td>Step 可开关、版本化</td></tr></tbody></table><h2 id="高阶玩法（真实上生产的）">高阶玩法（真实上生产的）</h2><table><thead><tr><th>增强</th><th>用法</th></tr></thead><tbody><tr><td>动态规则链</td><td>steps 从 DB / Redis / YAML 读取排序</td></tr><tr><td>灰度开关</td><td>Step 加注解决定开启关闭</td></tr><tr><td>多链共存</td><td>ChainExecutor 根据 Chain ID 选择链</td></tr><tr><td>回滚</td><td>Step 支持 reverse() 实现补偿</td></tr><tr><td>并行链</td><td>CompletableFuture 执行部分 step</td></tr></tbody></table><p>如果是要支持回滚，在step接口中增加一个reverse方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChainStep</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(ChainContext ctx)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ChainContext ctx)</span>; <span class="comment">// 回滚方法</span></span><br><span class="line">    String <span class="title function_">stepName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回滚方法中，可以进行一些清理工作，比如删除临时文件、数据库记录等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;命令模式（Command Pattern）和大模型调用中的 Chain（Chain of Thought / Chain of Actions / Agent Chain / Pipeline Chain）本质上是同一种思想：将复杂逻辑拆成可插拔、可组合、可</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-项目开发记录</title>
    <link href="https://kelinkong.github.io/2025/09/11/Java-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://kelinkong.github.io/2025/09/11/Java-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</id>
    <published>2025-09-11T03:12:45.000Z</published>
    <updated>2026-01-22T11:10:33.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mybatis-plus相关">mybatis-plus相关</h3><p><strong>软删除：</strong></p><p>使用标志位进行软删除，通常在数据库表中添加一个<code>deleted</code>字段，标记记录是否被删除。通过在查询时过滤掉<code>deleted</code>字段为<code>true</code>的记录，实现软删除功能。</p><p>在MyBatis-Plus中，可以通过<code>@TableLogic</code>注解来实现软删除功能。只需在实体类的<code>deleted</code>字段上添加该注解，MyBatis-Plus会自动处理软删除逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑删除标志: 0代表未删除，1代表已删除</span></span><br><span class="line">    <span class="meta">@TableLogic(value = &quot;0&quot;, delval = &quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>会自动拼接为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name, type, deleted</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">WHERE</span> deleted <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>在数据库中查询时，使用mybaits plus，Ipage有可能返回null吗？还是说只会返回零条记录？</strong></p><p>在使用MyBatis Plus进行分页查询时，如果查询结果为空，则返回的IPage对象中的total属性为0，而不是null。</p><p>如果查找不到记录，使用gettRecords()方法获取list得到的结果为[];</p><h3 id="请求和响应">请求和响应</h3><p>在请求和响应中，有一些注解可以帮助我们更好地处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestBody</span> <span class="comment">// 用于将请求体中的JSON数据转换为Java对象</span></span><br><span class="line"><span class="meta">@ResponseBody</span> <span class="comment">// 用于将Java对象转换为JSON格式的响应体</span></span><br><span class="line"><span class="meta">@PathVariable</span> <span class="comment">// 用于从URL路径中提取变量</span></span><br><span class="line"><span class="meta">@RequestParam</span> <span class="comment">// 用于从请求参数中提取数据</span></span><br></pre></td></tr></table></figure><p>在请求和响应中vo对象中，有一些注解可以帮助我们更好地处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat</span> <span class="comment">// 用于格式化日期和时间</span></span><br><span class="line"><span class="meta">@Max</span> <span class="comment">// 用于指定字段的最大值</span></span><br><span class="line"><span class="meta">@Min</span> <span class="comment">// 用于指定字段的最小值</span></span><br><span class="line"><span class="meta">@NotBlank</span> <span class="comment">// 用于验证字符串字段不能为空</span></span><br><span class="line"><span class="meta">@NotNull</span> <span class="comment">// 用于验证字段不能为空</span></span><br><span class="line"><span class="meta">@Size</span> <span class="comment">// 用于验证字符串或集合的大小</span></span><br></pre></td></tr></table></figure><p><strong>在写请求的vo时，应该去校验前端返回的字段是否正确。</strong><br>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRequestVO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用validator去校验，并把错误信息返回给前端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;ConstraintViolation&lt;UserRequestVO&gt;&gt; violations = validator.validate(userRequestVO);</span><br><span class="line"><span class="keyword">if</span> (!violations.isEmpty()) &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">errorMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (ConstraintViolation&lt;UserRequestVO&gt; violation : violations) &#123;</span><br><span class="line">        errorMessage.append(violation.getMessage()).append(<span class="string">&quot;; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(errorMessage.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在action中，使用-Valid注解，自动校验请求参数">在action中，使用@Valid注解，自动校验请求参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRequestVO userRequestVO)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="对枚举值进行校验">对枚举值进行校验</h3><p>示例枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AudioType</span> &#123;</span><br><span class="line">    NORMAL(<span class="number">0</span>, <span class="string">&quot;普通音频&quot;</span>),</span><br><span class="line">    TRIAL(<span class="number">1</span>, <span class="string">&quot;试听音频&quot;</span>),</span><br><span class="line">    VIP(<span class="number">2</span>, <span class="string">&quot;会员音频&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个枚举值校验器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = EnumValidator.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnumValid &#123;</span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;枚举值不合法&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt;&gt; enumClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;EnumValid, Object&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;?&gt;&gt; enumClass;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(EnumValid annotation)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.enumClass = annotation.enumClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Object value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 允许空</span></span><br><span class="line">        <span class="keyword">for</span> (Enum&lt;?&gt; e : enumClass.getEnumConstants()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.name().equals(value.toString())) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IDEA配置">IDEA配置</h3><h4 id="自动导包">自动导包</h4><p>File -&gt; Settings -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Add unambiguous imports on the fly</p><h4 id="自动格式化代码">自动格式化代码</h4><p>File -&gt; Settings -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Formatter Control -&gt; Enable formatter markers in comments</p><h4 id="自动删去无用的包">自动删去无用的包</h4><p>File -&gt; Settings -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Optimize imports on the fly</p><h4 id="自动添加类描述">自动添加类描述</h4><p>File -&gt; Settings -&gt; Editor -&gt; File and Code Templates -&gt; Class -&gt; 在模板开头添加注释</p><h3 id="异常处理">异常处理</h3><p>不能抛出非受检异常，应该定义自定义异常，常见的：BizException、RuntimeException等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> <span class="keyword">throws</span> BizException &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局异常处理">全局异常处理</h4><h3 id="代码规范">代码规范</h3><p>1、抛出异常的地方都需要记录日志<br>2、日志的格式：时间+类名+方法名+异常信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.error(<span class="string">&quot;时间：&#123;&#125;，类名：&#123;&#125;，方法名：&#123;&#125;，异常信息：&#123;&#125;&quot;</span>, LocalDateTime.now(), <span class="built_in">this</span>.getClass().getName(), <span class="string">&quot;方法名&quot;</span>, e.getMessage());</span><br></pre></td></tr></table></figure><p>3、如果需要有空返回，先返回空，而不是先走业务逻辑</p><h3 id="Spring-Boot相关">Spring Boot相关</h3><h4 id="Value注解">@Value注解</h4><p>为什么@Value注解可以注入配置文件中的值？</p><blockquote><p><strong>Spring 在创建 Bean 时，会使用专门的处理器（BeanPostProcessor）扫描 <code>@Value</code> 注解，把 <code>$&#123;xxx&#125;</code> 转成真正的配置值，然后通过反射赋值给字段。</strong></p></blockquote><p>这背后分三步：</p><h5 id="1-Spring-会加载配置文件进-Environment"><strong>1. Spring 会加载配置文件进 Environment</strong></h5><p><code>application.yml</code> / <code>application.properties</code><br>➡ 会被 Spring 解析成一堆 key-value<br>➡ 存进 <strong>Environment</strong>（它是所有配置的统一容器）</p><p>例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">app.name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>Spring 会存成：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment[<span class="string">&quot;app.name&quot;</span>] <span class="operator">=</span> <span class="string">&quot;demo&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-Spring-创建-Bean-时，会扫描字段上的-Value"><strong>2. Spring 创建 Bean 时，会扫描字段上的 @Value</strong></h5><p>Spring 在创建 Bean 时，会用到一个特殊的处理器：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">AutowiredAnnotationBeanPostProcessor</span></span><br></pre></td></tr></table></figure><p>它会检查字段上是否有：</p><ul><li><code>@Autowired</code></li><li><code>@Value</code></li><li><code>@Resource</code></li><li>……等</li></ul><p>看到 <code>@Value(&quot;$&#123;app.name&#125;&quot;)</code><br>➡ 它会把 <code>$&#123;app.name&#125;</code> 交给 <strong>PlaceholderResolver</strong> 去解析。</p><h5 id="3-Spring-解析占位符并通过反射把值注入字段"><strong>3. Spring 解析占位符并通过反射把值注入字段</strong></h5><p><code>$&#123;app.name&#125;</code><br>➡ 解析得到 <code>&quot;demo&quot;</code><br>➡ 反射赋值给字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.name = <span class="string">&quot;demo&quot;</span>;</span><br></pre></td></tr></table></figure><p>Bean 就成功拿到配置文件中的值了。</p><h4 id="配置的优先级">配置的优先级</h4><ol><li>命令行参数</li><li>Java 系统属性（-Dkey=value）</li><li>OS 环境变量</li><li>jar 外部的 application.yml / properties</li><li>jar 内部（/resources）的 application.yml / properties</li><li>@PropertySource 指定的配置文件</li><li>默认配置（Spring Boot 自动配置设置的默认值）</li></ol><h3 id="启动参数">启动参数</h3><p>Java和 Spring Boot 常用启动参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java -Xms1g -Xmx2g \</span><br><span class="line">  -Denv=prod \</span><br><span class="line">  -Duser.timezone=Asia/Shanghai \</span><br><span class="line">  -jar app.jar \</span><br><span class="line">  --spring.profiles.active=prod \</span><br><span class="line">  --server.port=9000 \</span><br><span class="line">  --logging.level.root=INFO</span><br></pre></td></tr></table></figure><h2 id="Serializable">Serializable</h2><p>在 Java 中，实现 <code>Serializable</code> 接口的类可以将其实例转换为字节流，从而实现对象的持久化存储或通过网络传输。</p><h3 id="serialVersionUID-的作用">serialVersionUID 的作用</h3><p><code>serialVersionUID</code> 是 Java 序列化机制中的一个重要概念。它是一个唯一的标识符，用于验证序列化和反序列化过程中类的版本一致性。</p><ul><li>当一个对象序列化后写入文件或缓存，再次反序列化时，JVM 会检查类的 serialVersionUID 是否一致。</li><li>如果类结构改变（新增/删除字段等），但 serialVersionUID 没变，可能导致 序列化不兼容问题。</li><li>如果没有显式定义，JVM 会根据类的结构生成一个默认的 serialVersionUID，但类结构一改，生成的值会变，导致反序列化失败。</li></ul><h2 id="事务">事务</h2><p>在 Spring 中，事务管理通常通过 <code>@Transactional</code> 注解来实现。它可以应用于类或方法上，以指定该类或方法需要在事务上下文中执行。</p><h3 id="注意事项">注意事项</h3><ol><li>@Transactional 必须加在 public 方法上，才一定生效</li><li>同一个类内部方法调用（self-invocation）不会触发事务</li><li>事务方法应该放在 Service 层，而不是 Controller</li></ol><h4 id="正常调用的链路">正常调用的链路</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部调用实际执行的是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OrderService$$Proxy.createOrder()</span><br><span class="line">  → 开启事务</span><br><span class="line">  → 调用 OrderService.createOrder()</span><br><span class="line">  → 提交 / 回滚事务</span><br></pre></td></tr></table></figure><h4 id="同一个类的内部调用：">同一个类的内部调用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        methodB(); <span class="comment">// ❌ 内部调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际执行的是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OrderService.methodA()</span><br><span class="line">  → this.methodB()</span><br></pre></td></tr></table></figure><p>此时不会触发事务，完全绕开了Spring AOP，因为没有经过代理对象。</p><h4 id="拆成新的类：">拆成新的类：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderApplyService applyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        applyService.apply(); <span class="comment">// ✔ 代理调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际执行是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderService → OrderApplyService$$Proxy → apply()</span><br></pre></td></tr></table></figure><h2 id="tips">tips</h2><ol><li>构造器注入优于@Autowired注入，推荐使用构造器注入。</li><li>少用 @Component 扫一切<ol><li>推荐使用 @Service、@Repository、@Controller 等更具体的注解，明确类的角色和职责。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;mybatis-plus相关&quot;&gt;mybatis-plus相关&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;软删除：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用标志位进行软删除，通常在数据库表中添加一个&lt;code&gt;deleted&lt;/code&gt;字段，标记记录是否被删除。通过在查询时过滤</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>雷达原理-ukf 滤波器</title>
    <link href="https://kelinkong.github.io/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-ukf-%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>https://kelinkong.github.io/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-ukf-%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2025-06-13T07:41:23.000Z</published>
    <updated>2025-06-13T08:18:20.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UKF（无迹卡尔曼滤波器）和-KF（卡尔曼滤波器）？">UKF（无迹卡尔曼滤波器）和 KF（卡尔曼滤波器）？</h2><ul><li><strong>卡尔曼滤波器（KF）</strong> 适用于线性系统；</li><li><strong>无迹卡尔曼滤波器（UKF）</strong> 是它的非线性扩展，精度更高，且比EKF更稳健。</li></ul><h3 id="KF（Kalman-Filter）适用于什么？">KF（Kalman Filter）适用于什么？</h3><ul><li><p>系统必须是<strong>线性</strong>的</p></li><li><p>系统模型可以写成：</p><p>$$<br>x_k = F x_{k-1} + w_k \<br>z_k = H x_k + v_k<br>$$</p></li><li><p>状态转移（<code>F</code>）和观测（<code>H</code>）都是<strong>线性矩阵</strong></p></li><li><p>噪声是高斯的</p></li></ul><blockquote><p>KF 的优势：计算简单、推理快速<br>KF 的局限：无法处理非线性，比如角度、旋转、曲线运动等</p></blockquote><h3 id="UKF（Unscented-Kalman-Filter）是什么？">UKF（Unscented Kalman Filter）是什么？</h3><p>UKF 设计来处理<strong>非线性系统</strong>，不再用简单矩阵来描述状态和观测，而是使用函数形式：</p><p>$$<br>x_k = f(x_{k-1}) + w_k \<br>z_k = h(x_k) + v_k<br>$$</p><blockquote><p><strong>核心思想：Unscented Transform（无迹变换）</strong><br>用一组“<strong>sigma点</strong>”来近似高斯分布，通过这些点来传递非线性变换的影响，比线性化方式更精确。</p></blockquote><hr><h3 id="KF-vs-UKF：具体对比">KF vs UKF：具体对比</h3><table><thead><tr><th>项目</th><th>KF（卡尔曼滤波）</th><th>UKF（无迹卡尔曼滤波）</th></tr></thead><tbody><tr><td>是否能处理非线性</td><td>不能</td><td>可以</td></tr><tr><td>状态转移模型</td><td>线性 <code>F</code></td><td>非线性 <code>f(x)</code></td></tr><tr><td>观测模型</td><td>线性 <code>H</code></td><td>非线性 <code>h(x)</code></td></tr><tr><td>处理非线性方式</td><td>不支持</td><td>用 sigma 点传播分布</td></tr><tr><td>精度</td><td>高（在线性系统）</td><td>更高（在非线性系统）</td></tr><tr><td>稳定性</td><td>易于理解和实现</td><td>更强健，但复杂些</td></tr><tr><td>计算量</td><td>低</td><td>略高一些</td></tr><tr><td>应用场景</td><td>匀速直线、线性加速度</td><td>飞行姿态估计、目标跟踪（非直线）</td></tr></tbody></table><h3 id="一个直观的例子">一个直观的例子</h3><p>假设要估计目标的<strong>位置和朝向（角度）</strong>：</p><ul><li>KF 会认为朝向线性变化，但实际上角度是一个非线性变量（会 wrap-around，例如 359° → 0°）</li><li>UKF 会用 sigma 点来“描绘”一小群可能的位置+角度，然后对这些点做真实的非线性变换，结果比直接线性化更靠谱！</li></ul><h3 id="UKF-的适用场景">UKF 的适用场景</h3><ul><li>目标非线性运动（比如目标在弯道或做曲线移动）</li><li>系统模型或测量模型是非线性函数</li><li>IMU+GPS 融合、SLAM、雷达目标跟踪、姿态估计等</li></ul><p>很好，你已经对卡尔曼滤波（KF）有一定了解，这会非常有助于理解无迹卡尔曼滤波（UKF）。你提到“不太懂 UKF 中是不是用了很多协方差矩阵”，我们就围绕<strong>UKF 中的协方差矩阵</strong>来解释它和 KF 的关系与不同。</p><h2 id="UKF-中用到了哪些协方差矩阵？">UKF 中用到了哪些协方差矩阵？</h2><p>实际上，<strong>UKF 使用的协方差矩阵和 KF 是一样的，仍然是这三个</strong>：</p><table><thead><tr><th>矩阵</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td><code>P</code></td><td>状态协方差矩阵</td><td>当前对导弹位置/速度估计的可信度（不确定性）</td></tr><tr><td><code>Q</code></td><td>过程噪声协方差矩阵</td><td>描述导弹运动过程中模型误差（比如风力、系统扰动）</td></tr><tr><td><code>R</code></td><td>观测噪声协方差矩阵</td><td>描述雷达测量的不确定性（比如雷达噪声、精度限制）</td></tr></tbody></table><p>这些矩阵的作用和卡尔曼滤波中的一致，只不过 <strong>UKF 的更新方式是通过“采样多个可能点”（Sigma 点）计算协方差</strong>，而不是用一阶线性估计（雅可比矩阵）去近似。</p><h3 id="它们分别在-UKF-哪些步骤中用到？">它们分别在 UKF 哪些步骤中用到？</h3><table><thead><tr><th>步骤</th><th>用到的协方差矩阵</th><th>说明</th></tr></thead><tbody><tr><td>1. 状态预测</td><td><code>Q</code></td><td>每个 Sigma 点预测之后，要加上过程噪声协方差 <code>Q</code></td></tr><tr><td>2. 状态协方差预测</td><td><code>Q</code> + 预测协方差</td><td>生成新的预测协方差矩阵 <code>P</code></td></tr><tr><td>3. 观测预测协方差</td><td><code>R</code></td><td>将预测观测值的散布计算协方差，并加上测量噪声协方差 <code>R</code></td></tr><tr><td>4. 更新卡尔曼增益</td><td><code>P</code>, <code>R</code></td><td>用于计算 Kalman 增益，融合观测</td></tr><tr><td>5. 状态更新</td><td><code>P</code></td><td>根据观测误差和增益调整状态与 <code>P</code></td></tr></tbody></table><hr><h3 id="一个直观的例子理解三者作用（导弹观测）">一个直观的例子理解三者作用（导弹观测）</h3><p>假设我们预测导弹下一步在 <code>(x=100, y=50)</code>，然后：</p><ol><li><p><strong>Q（过程噪声）</strong><br>表示我们对导弹运动模型的不确定，比如可能有风，预测可能偏了：</p><ul><li>Q 越大 → 说明你不太信模型 → 卡尔曼增益会更偏向观测值。</li><li>Q 越小 → 说明你非常信模型 → 更偏向预测轨迹。</li></ul></li><li><p><strong>R（观测噪声）</strong><br>雷达测出 <code>(102, 52)</code>，但你知道雷达有 ±5 米误差，所以 R=25。</p><ul><li>R 越大 → 说明你不信雷达 → 更信模型预测。</li><li>R 越小 → 说明雷达很准 → 卡尔曼增益更依赖观测值。</li></ul></li><li><p><strong>P（状态协方差）</strong><br>你自己对预测值的置信度，也会影响 Kalman 增益 K 的计算：</p><ul><li>P 很大 → 说明你对自己预测很不自信 → 更信观测。</li><li>P 很小 → 你信预测 → 更忽略观测。</li></ul></li></ol><p>非常好问题！我们来<strong>完整梳理 UKF 的工作流程</strong>，包括：</p><ol><li>每一步的计算公式；</li><li><code>P</code>、<code>Q</code>、<code>R</code> 等协方差矩阵的作用；</li><li>如何初始化这些值（有经验法也有实践法）。</li></ol><h2 id="UKF-的具体计算步骤">UKF 的具体计算步骤</h2><p>设状态维度为 <code>n</code>，观测维度为 <code>m</code>。</p><h3 id="0-初始化（初值设定）">0. 初始化（初值设定）</h3><p>需要提供：</p><ul><li><p>初始状态估计向量 <code>x₀</code>，比如导弹初始位置和速度<br><code>x₀ = [x, y, vx, vy]^T</code></p></li><li><p>初始状态协方差 <code>P₀</code>：你对这个估计的信心，通常用对角矩阵，如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P</span>₀ = diag([<span class="number">10</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure></li><li><p>系统过程噪声协方差 <code>Q</code>：运动模型的误差，比如风、引擎干扰</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Q</span> = diag([<span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">1</span>, <span class="number">0</span>.<span class="number">05</span>, <span class="number">0</span>.<span class="number">05</span>])</span><br></pre></td></tr></table></figure></li><li><p>观测噪声协方差 <code>R</code>：传感器的误差，比如雷达误差 ±2 米 → 方差为 4</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">R</span> = diag([<span class="number">4</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-生成-Sigma-点">1. 生成 Sigma 点</h3><p>给定当前状态 <code>x_k</code> 和协方差 <code>P_k</code>，生成 <code>2n + 1</code> 个 Sigma 点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X[0] = x_k</span><br><span class="line">X[i]   = x_k + (sqrt((n+λ) * P))_i,   i = 1...n</span><br><span class="line">X[i+n] = x_k - (sqrt((n+λ) * P))_i,   i = 1...n</span><br></pre></td></tr></table></figure><p>λ 是一个超参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">λ = α²(n + κ) - n</span><br></pre></td></tr></table></figure><p>一般经验设置：</p><ul><li>α = 1e-3（影响 Sigma 点间距）</li><li>κ = 0</li><li>β = 2（高斯分布的最优值）</li></ul><hr><h3 id="2-预测步骤">2. 预测步骤</h3><h4 id="a-对每个-Sigma-点用系统动力学函数-f-传播">(a) 对每个 Sigma 点用系统动力学函数 f 传播</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X⁻[i] = f(X[i])</span><br></pre></td></tr></table></figure><h4 id="b-用加权平均计算预测状态均值：">(b) 用加权平均计算预测状态均值：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x⁻ = Σ Wm[i] * X⁻[i]</span><br></pre></td></tr></table></figure><h4 id="©-计算预测协方差：">© 计算预测协方差：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P⁻ = Σ Wc[i] * (X⁻[i] - x⁻)(X⁻[i] - x⁻)^T + Q</span><br></pre></td></tr></table></figure><h3 id="3-更新步骤（测量观测更新）">3. 更新步骤（测量观测更新）</h3><h4 id="a-通过观测模型-h-·-将预测点投影到观测空间：">(a) 通过观测模型 h(·) 将预测点投影到观测空间：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Z[i] = h(X⁻[i])</span><br></pre></td></tr></table></figure><h4 id="b-计算预测观测均值：">(b) 计算预测观测均值：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z⁻ = Σ Wm[i] * Z[i]</span><br></pre></td></tr></table></figure><h4 id="©-计算观测协方差矩阵-S：">© 计算观测协方差矩阵 <code>S</code>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = Σ Wc[i] * (Z[i] - z⁻)(Z[i] - z⁻)^T + R</span><br></pre></td></tr></table></figure><h4 id="d-计算状态与观测之间的协方差矩阵-P-xz：">(d) 计算状态与观测之间的协方差矩阵 <code>P_xz</code>：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P_xz = Σ Wc[i] * (X⁻[i] - x⁻)(Z[i] - z⁻)^T</span><br></pre></td></tr></table></figure><h4 id="e-计算-Kalman-增益：">(e) 计算 Kalman 增益：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = P_xz * S⁻¹</span><br></pre></td></tr></table></figure><h4 id="f-更新状态估计和协方差：">(f) 更新状态估计和协方差：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_k = x⁻ + K * (z_k - z⁻)</span><br><span class="line">P_k = P⁻ - K * S * K^T</span><br></pre></td></tr></table></figure><h2 id="初始状态协方差矩阵-P₀"><strong>初始状态协方差矩阵 P₀</strong></h2><h3 id="1-P₀-的含义是什么？">1. P₀ 的含义是什么？</h3><ul><li><p><strong>P₀ 是状态估计的初始“不确定性”矩阵。</strong></p></li><li><p>它告诉滤波器“我对初始状态估计有多大的信心”。</p></li><li><p>P₀ 是一个方阵，大小是状态向量维度的平方。</p></li><li><p>典型情况下，P₀ 是对角矩阵，表示各个状态变量之间的估计误差<strong>不相关</strong>，对角线上元素代表各状态分量的<strong>方差（不确定度大小）</strong>。</p></li></ul><p>举例：状态向量是四维 <code>[位置_x, 位置_y, 速度_x, 速度_y]</code>，那么</p><p>$$<br>P_0 = \begin{bmatrix}<br>\sigma_{x}^2 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; \sigma_{y}^2 &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; \sigma_{v_x}^2 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; \sigma_{v_y}^2<br>\end{bmatrix}<br>$$</p><p>这里的 $\sigma_x, \sigma_y, \sigma_{v_x}, \sigma_{v_y}$ 是对应变量的<strong>标准差</strong>，平方即是方差。</p><hr><h3 id="2-为什么一般用对角矩阵？">2. 为什么一般用对角矩阵？</h3><ul><li><p>因为初始状态估计的不同维度变量误差通常被假设<strong>相互独立</strong>（没有协方差）。</p></li><li><p>如果你有更详细的先验知识，知道某些变量误差相关，可以把相应位置设置非零协方差。</p></li></ul><hr><h4 id="4-不同-P₀-会对滤波有什么影响？">4. 不同 P₀ 会对滤波有什么影响？</h4><ul><li><p><strong>P₀ 太小</strong> → 滤波器对初始估计过于自信，遇到真实状态大幅偏离时反应迟钝，收敛慢。</p></li><li><p><strong>P₀ 太大</strong> → 表示对初始估计不确定，滤波器会更快信任观测数据，收敛较快，但可能有较大抖动。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;UKF（无迹卡尔曼滤波器）和-KF（卡尔曼滤波器）？&quot;&gt;UKF（无迹卡尔曼滤波器）和 KF（卡尔曼滤波器）？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;卡尔曼滤波器（KF）&lt;/strong&gt; 适用于线性系统；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无迹卡尔曼滤波器（</summary>
      
    
    
    
    <category term="Radar Principle" scheme="https://kelinkong.github.io/categories/Radar-Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>雷达原理-卡尔曼滤波器基础学习</title>
    <link href="https://kelinkong.github.io/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2025/06/13/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-06-13T02:36:08.000Z</published>
    <updated>2025-11-18T02:45:09.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何理解卡尔曼滤波器？">如何理解卡尔曼滤波器？</h2><p>卡尔曼滤波（<strong>Kalman Filter，KF</strong>）是一个<strong>用于估计系统状态</strong>的递归算法，适用于<strong>线性系统+高斯噪声</strong>情形。它的核心思想是：</p><blockquote><p><strong>融合“预测”和“观测”，在噪声存在的情况下对动态目标状态进行最优估计。</strong></p></blockquote><p>卡尔曼滤波就是：</p><blockquote><p>“我知道目标昨天的位置和速度（预测），今天我观测到一个不太准的位置（测量），我要综合这两者，用数学方法给出一个更准的现在的位置和速度（估计）。”</p></blockquote><p><strong>为什么会观测到不太准的位置？</strong></p><p>因为现实世界中，测量总会有噪声，比如雷达测量的距离可能受天气、设备精度等影响。</p><h3 id="场景类比：雷达跟踪飞机">场景类比：雷达跟踪飞机</h3><ul><li>目标：跟踪一架飞机的位置和速度</li><li>问题：雷达测得位置不准（测量有噪声）；目标也不一定匀速飞行（运动有噪声）</li><li>解法：卡尔曼滤波根据过去的状态“预测”位置，又结合当前雷达观测，进行“校正”</li></ul><h3 id="卡尔曼滤波核心概念">卡尔曼滤波核心概念</h3><h3 id="1-系统状态模型">1. <strong>系统状态模型</strong></h3><p>目标的状态用一个向量表示，比如二维空间：</p><p>$$<br>x = [位置_x, 位置_y, 速度_x, 速度_y]^T<br>$$</p><p>系统状态随时间演化：<br>$$<br>x_k = F x_{k-1} + w_k<br>$$</p><p>其中：</p><ul><li><code>F</code> 是状态转移矩阵（如匀速模型）。</li><li><code>w_k</code> 是过程噪声，表示系统的不确定性（如飞机突然转向）</li></ul><h4 id="状态转移矩阵-F">状态转移矩阵 <code>F</code></h4><p>状态转移矩阵（记作 <strong>F</strong>）描述的是：</p><p><strong>从上一个时刻 $x_{k-1}$，系统是如何过渡到当前时刻 $x_k$ 的。</strong></p><p>也就是说，它描述目标的“运动规律”或“预测模型”。</p><p>公式如下：</p><p>$$<br>x_k = F x_{k-1} + B u_k + w_k<br>$$</p><ul><li>$F$：状态转移矩阵（你要问的）</li><li>$x_{k-1}$：上一个时刻的状态</li><li>$x_k$：当前时刻的状态</li><li>$B u_k$：控制项（如果有控制输入）</li><li>$w_k$：过程噪声（建模随机扰动，通常假设是高斯）</li></ul><p><strong>一个经典的例子：一维匀速运动</strong></p><p>我们想跟踪一个物体在一维直线上的运动，它的状态是：</p><p>$$<br>x = \begin{bmatrix} 位置 \ 速度 \end{bmatrix}<br>$$</p><p>设时间间隔为 $\Delta t$，也就是每隔 1 秒更新一次状态。</p><p><strong>匀速直线运动公式：</strong></p><p>$$<br>\text{新位置} = \text{旧位置} + \text{速度} \cdot \Delta t\text{新速度} = \text{旧速度}（速度不变）<br>$$</p><p>假设状态向量为：</p><p>$$<br>x_k = \begin{bmatrix} x \\ \dot{x} \end{bmatrix}_k = F \begin{bmatrix} x \\ \dot{x} \end{bmatrix}_{k-1}<br>$$</p><p>那么状态转移矩阵 F 是：</p><p>$$<br>F =<br>\begin{bmatrix}<br>1 &amp; \Delta t \\<br>0 &amp; 1 \\<br>\end{bmatrix}<br>$$</p><p>解释：</p><ul><li>位置 = 位置 + 速度 × 时间</li><li>速度保持不变</li></ul><p>假设：</p><ul><li>上一时刻：位置 10 米，速度 2 米/秒</li><li>时间间隔：1 秒</li></ul><p>$$<br>x_{k-1} =<br>\begin{bmatrix}<br>10 \<br>2 \<br>\end{bmatrix},<br>\quad \Delta t = 1<br>$$</p><p>$$<br>F = \begin{bmatrix}<br>1 &amp; 1 \\<br>0 &amp; 1 \\<br>\end{bmatrix}<br>\Rightarrow<br>x_k = F x_{k-1} = \begin{bmatrix}<br>1 &amp; 1 \\<br>0 &amp; 1 \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>10 \\<br>2 \\<br>\end{bmatrix}<br>= \begin{bmatrix}<br>12 \\<br>2 \\<br>\end{bmatrix}<br>$$</p><p>→ <strong>预测下一时刻的位置是 12，速度仍然是 2</strong></p><h3 id="2-观测模型">2. <strong>观测模型</strong></h3><p>我们能观测到的是测量值：<br>$$<br>z_k = H x_k + v_k<br>$$</p><p>其中：</p><ul><li><code>H</code> 是观测矩阵（把状态映射为观测）</li><li><code>v_k</code> 是测量噪声（例如雷达不准）</li></ul><h3 id="KF-的几个关键点">KF 的几个关键点</h3><table><thead><tr><th>术语</th><th>解释</th></tr></thead><tbody><tr><td>状态向量 <code>x</code></td><td>要估计的真实值，如位置、速度</td></tr><tr><td>状态转移矩阵 <code>F</code></td><td>描述状态如何从前一时刻演化</td></tr><tr><td>观测矩阵 <code>H</code></td><td>描述如何从状态映射出观测值， 展现能观测到的值</td></tr><tr><td>协方差矩阵 <code>P</code></td><td>表示估计值的不确定性</td></tr><tr><td>卡尔曼增益 <code>K</code></td><td>预测值和观测值之间的加权比例</td></tr></tbody></table><h2 id="协方差矩阵">协方差矩阵</h2><p>最常见的 <strong>3 个关键协方差矩阵</strong>：</p><h3 id="1-状态估计协方差矩阵-P（最核心）">1. 状态估计协方差矩阵 <code>P</code>（最核心）</h3><ul><li><p><strong>含义</strong>：表示我们对当前状态估计（如位置、速度）的<strong>不确定性</strong>。（值越大，意味着对预测结果越没有信心）</p></li><li><p><strong>维度</strong>：与状态向量 <code>x</code> 同维度，如位置+速度就是 2×2。</p></li><li><p><strong>行为</strong>：</p><ul><li>初始值很大，表示我们一开始“很不确定”。</li><li>随着测量不断修正，<code>P</code> 会逐步变小，表示我们“越来越确信”。</li><li>是滤波器自己对估计结果的信心，不断更新（越小表示越相信自己的估计）</li></ul></li><li><p><strong>初始值设定</strong>：</p><ul><li><p>如果你一开始<strong>对状态估计不确定</strong>（如初始速度不知道），设成较大：</p><p>$$<br>P_0 =<br>\begin{bmatrix}<br>1000 &amp; 0 \<br>0 &amp; 1000<br>\end{bmatrix}<br>$$</p></li><li><p>如果你知道初始位置很准但速度不确定，可以设置为：</p><p>$$<br>P_0 =<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 1000<br>\end{bmatrix}<br>$$</p></li></ul></li><li><p><strong>是否调整？</strong></p><ul><li><code>P</code> 是自动更新的，不需要你手动优化。</li></ul></li></ul><p>这里的协方差，比如左边斜对角的值代表特征之间的相关性，右边斜对角的值代表特征自身的方差。如这里0表示位置和速度之间没有相关性，位置的方差是1000，速度的方差是1000。</p><h3 id="2-过程噪声协方差矩阵-Q">2. 过程噪声协方差矩阵 <code>Q</code></h3><ul><li><p><strong>含义</strong>：表示系统模型中由于不可控因素（如摩擦、风、加速度变化）带来的随机扰动。</p></li><li><p><strong>行为</strong>：</p><ul><li>加在预测阶段，使得 <code>P</code> 不会无限减小。</li><li>控制预测时的“扩散程度”。</li></ul></li><li><p>如果设置 <code>Q = 0</code>，KF 就会过于自信，忽略真实世界的“抖动”或“误差”。</p></li><li><p><strong>怎么理解？</strong></p><ul><li><p>表示你的系统模型（如匀速运动）有多大的不确定性，比如：</p><ul><li>风的扰动</li><li>摩擦不同步</li><li>目标突然加速等</li></ul></li></ul></li><li><p><strong>初始值设定方式</strong>：</p><ul><li>如果你相信系统运动模型比较准 → 设 <code>Q</code> 小一些（如 <code>Q = 0.01</code>）</li><li>如果目标运动变化很不稳定 → 设 <code>Q</code> 大一些（如 <code>Q = 1</code> 或更高）</li></ul></li><li><p><strong>优化建议</strong>：</p><ul><li>先手动尝试不同的值，看误差大小。</li><li>可以通过历史轨迹拟合/估计（如用系统残差反推）获得更优的 Q。</li><li>高级方法：用 EM 算法自动估计 <code>Q</code>。</li></ul></li></ul><p><strong>如何理解运动模型准不准？</strong></p><p>卡尔曼滤波的“系统运动模型”是你假设的目标运动方式，比如：</p><ul><li><p>匀速直线运动：</p><p>$$<br>x_k = x_{k-1} + v \cdot \Delta t<br>$$</p></li><li><p>匀加速运动：</p><p>$$<br>x_k = x_{k-1} + v_{k-1} \cdot \Delta t + \frac{1}{2} a \cdot \Delta t^2<br>$$</p></li></ul><p>如果真实目标确实这么动（如在轨道上匀速滑行），就可以说系统运动模型很准！</p><p>为什么模型准时 <code>Q</code> 应该小？</p><p><code>Q</code> 是<strong>过程噪声协方差矩阵</strong>，表示系统运动过程的<strong>不可控扰动</strong>，比如：</p><ul><li>忽然加速、减速</li><li>突然转弯</li><li>风、坡道、轮胎打滑等干扰</li></ul><p>如果你“<strong>相信模型非常准</strong>”，意味着你觉得这些突发情况不常发生，因此：</p><blockquote><p><strong>你希望滤波器更信任模型的预测</strong>，不去太敏感地响应突然变化<br>→ 所以要设置 <code>Q</code> 较小！</p></blockquote><p>假设你在跟踪一个小火车：</p><ul><li><p>它沿着轨道匀速前进，外界扰动几乎没有 → <strong>模型非常可靠</strong></p></li><li><p>每秒你预测位置更新为：</p><p>$$<br>x_k = x_{k-1} + v \cdot \Delta t<br>$$</p></li><li><p>如果设置 <code>Q = 0.01</code>，表示：</p><blockquote><p>“我认为预测误差很小，所以我非常信任这个预测位置。”</p></blockquote></li></ul><p>当观测值（比如 GPS）有偏差时，滤波器不会被轻易“拉偏”——它会主要信任自己的预测。</p><p><strong>如果 <code>Q</code> 设大，会发生什么？</strong></p><p>你在说：“我不太信自己预测得准，可能运动发生了突变（比如拐弯、刹车）”</p><p>此时卡尔曼滤波会：</p><ul><li>增强对观测值的依赖（即传感器说啥就信啥）</li><li><strong>减少对模型预测的信任</strong></li></ul><p>这在目标运动很复杂、频繁变化时（如：行人、动物、赛车）是合理的。</p><blockquote><p><strong><code>Q</code> 越小，表示你越信任预测模型</strong>，越认为目标的运动方式是可以预期的；<br><strong><code>Q</code> 越大，表示你觉得模型靠不住，要更多依赖实际观测值。</strong></p></blockquote><h3 id="3-观测噪声协方差矩阵-R">3. 观测噪声协方差矩阵 <code>R</code></h3><ul><li><p><strong>含义</strong>：表示观测值本身的测量误差。是滤波器对观测值误差的估计，即传感器精度的数学表达。</p></li><li><p><strong>行为</strong>：</p><ul><li>决定我们“信任预测多一点”还是“信任传感器多一点”。</li><li>越大 → 表示观测很不可靠，KF 更信预测。</li><li>越小 → 表示观测更精准，KF 更信传感器。</li></ul></li><li><p><strong>初始值设定方式</strong>：</p><ul><li><p>看你用的传感器精度。比如：</p><ul><li>GPS ±5米 → <code>R ≈ 25</code></li><li>激光雷达 ±0.1米 → <code>R ≈ 0.01</code></li></ul></li></ul></li><li><p><strong>优化建议</strong>：</p><ul><li>初期可用经验值设定。</li><li>可以从大量历史测量数据中计算真实的测量误差方差。</li><li>多传感器融合时，可单独估计每种传感器的 <code>R</code>。</li></ul></li></ul><h3 id="总结对比表">总结对比表</h3><table><thead><tr><th>矩阵</th><th>全称</th><th>含义</th><th>作用阶段</th><th>通常大小</th></tr></thead><tbody><tr><td><code>P</code></td><td>状态估计协方差</td><td>我对状态估计的信心（不确定性）</td><td>预测 + 更新</td><td>动态变化</td></tr><tr><td><code>Q</code></td><td>过程噪声协方差</td><td>模型预测的不确定性（系统噪声）</td><td>预测</td><td>通常较小</td></tr><tr><td><code>R</code></td><td>观测噪声协方差</td><td>传感器测量的不确定性</td><td>更新</td><td>固定或缓变</td></tr></tbody></table><ul><li><code>P</code> 是滤波器自己<strong>对估计结果的信心</strong>，不断更新（越小表示越相信自己的估计）；</li><li><code>Q</code> 是滤波器<strong>对模型预测误差的估计</strong>，表示系统内部未知的“突变”或干扰；</li><li><code>R</code> 是滤波器<strong>对观测值误差的估计</strong>，即传感器精度的数学表达。</li></ul><h2 id="简单梳理">简单梳理</h2><p>设：</p><ul><li>$x_k$：当前时刻的状态</li><li>$\hat{x}_k^-$：<strong>预测的状态</strong></li><li>$\hat{x}_k$：<strong>更新后的状态</strong></li><li>$z_k$：测量值</li><li>$F$：状态转移矩阵</li><li>$H$：观测矩阵</li><li>$K_k$：卡尔曼增益</li></ul><h3 id="第一步：预测（Predict）">第一步：<strong>预测（Predict）</strong></h3><p>我们根据上一时刻的状态和模型预测当前状态：</p><h4 id="状态预测：">状态预测：</h4><p>$$<br>\hat{x}_k^- = F \cdot \hat{x}_{k-1} （通过状态矩阵F去预测）<br>$$</p><h4 id="协方差预测（用到-P-和-Q）：">协方差预测（用到 <code>P</code> 和 <code>Q</code>）：</h4><p>$$<br>P_k^- = F \cdot P_{k-1} \cdot F^T + Q<br>$$</p><blockquote><ul><li><code>P</code> 是我们对上一步状态的不确定性</li><li><code>Q</code> 是我们对模型预测的“额外担忧”</li><li>两者一起影响当前这步预测的不确定性（<code>P_k^-</code>）</li></ul></blockquote><h3 id="第二步：更新（Update）">第二步：<strong>更新（Update）</strong></h3><p>我们用当前传感器观测值 $z_k$ 来修正预测。</p><h4 id="计算卡尔曼增益（用到-P-k-和-R）：">计算卡尔曼增益（用到 <code>P_k^-</code> 和 <code>R</code>）：</h4><p>$$<br>K_k = P_k^- \cdot H^T \cdot (H \cdot P_k^- \cdot H^T + R)^{-1}<br>$$</p><blockquote><ul><li>如果 <code>R</code> 很小 → 测量非常可靠 → 卡尔曼增益大 → 更信观测值</li><li>如果 <code>P_k^-</code> 很小 → 预测非常可靠 → 卡尔曼增益小 → 更信预测值</li></ul></blockquote><h4 id="状态更新：">状态更新：</h4><p>$$<br>\hat{x}_k = \hat{x}_k^- + K_k \cdot (z_k - H \cdot \hat{x}_k^-)<br>$$</p><p>用卡尔曼增益 <code>K_k</code> 来融合预测值和观测值，达到平衡。</p><h4 id="协方差更新（更新-P）：">协方差更新（更新 <code>P</code>）：</h4><p>$$<br>P_k = (I - K_k \cdot H) \cdot P_k^-<br>$$</p><blockquote><p>表示我们对当前状态的不确定性在更新之后如何变化（通常会变小）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何理解卡尔曼滤波器？&quot;&gt;如何理解卡尔曼滤波器？&lt;/h2&gt;
&lt;p&gt;卡尔曼滤波（&lt;strong&gt;Kalman Filter，KF&lt;/strong&gt;）是一个&lt;strong&gt;用于估计系统状态&lt;/strong&gt;的递归算法，适用于&lt;strong&gt;线性系统+高斯噪声&lt;/str</summary>
      
    
    
    
    <category term="Radar Principle" scheme="https://kelinkong.github.io/categories/Radar-Principle/"/>
    
    
    <category term="雷达原理" scheme="https://kelinkong.github.io/tags/%E9%9B%B7%E8%BE%BE%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java-Java的容器和C++的STL容器的对比</title>
    <link href="https://kelinkong.github.io/2025/06/05/Java-Java%E7%9A%84%E5%AE%B9%E5%99%A8%E5%92%8CC-%E7%9A%84STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://kelinkong.github.io/2025/06/05/Java-Java%E7%9A%84%E5%AE%B9%E5%99%A8%E5%92%8CC-%E7%9A%84STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94/</id>
    <published>2025-06-05T02:56:11.000Z</published>
    <updated>2025-06-05T02:58:40.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java容器与C-STL容器深度对比">Java容器与C++ STL容器深度对比</h2><h3 id="类型系统差异">类型系统差异</h3><table><thead><tr><th>特性</th><th>C++ STL</th><th>Java 集合框架</th></tr></thead><tbody><tr><td>泛型实现</td><td>编译时模板（类型安全）</td><td>类型擦除（运行时类型信息丢失）</td></tr><tr><td>基础类型处理</td><td>原生支持（<code>vector&lt;int&gt;</code>）</td><td>必须使用包装类（<code>ArrayList&lt;Integer&gt;</code>）</td></tr><tr><td>类型检查</td><td>编译期检查</td><td>编译期部分检查 + 运行期检查</td></tr></tbody></table><p>示例对比：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 模板特化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">// 直接存储int</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 类型擦除</span></span><br><span class="line">List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 自动装箱int-&gt;Integer</span></span><br><span class="line">nums.add(<span class="string">&quot;text&quot;</span>); <span class="comment">// 编译通过，运行时报ClassCastException</span></span><br></pre></td></tr></table></figure><h2 id="核心容器对比">核心容器对比</h2><p>线性容器</p><table><thead><tr><th>容器类型</th><th>C++ STL</th><th>Java集合框架</th><th>关键差异</th></tr></thead><tbody><tr><td>动态数组</td><td>vector</td><td>ArrayList</td><td>Java扩容50%，C++扩容2倍</td></tr><tr><td>双端队列</td><td>deque</td><td>ArrayDeque</td><td>Java不支持随机访问</td></tr><tr><td>链表</td><td>list</td><td>LinkedList</td><td>Java实现了Deque接口</td></tr><tr><td>线程安全数组</td><td>-</td><td>CopyOnWriteArrayList</td><td>Java特有</td></tr></tbody></table><p>性能对比：<br>• 随机访问：<code>vector</code> ≈ <code>ArrayList</code> &gt; <code>LinkedList</code></p><p>• 头部插入：<code>LinkedList</code> &gt; <code>ArrayList</code></p><p>• 迭代器遍历：C++迭代器性能更高（无边界检查）</p><p>关联容器</p><table><thead><tr><th>容器类型</th><th>C++ STL</th><th>Java集合框架</th><th>实现差异</th></tr></thead><tbody><tr><td>红黑树Map</td><td>map</td><td>TreeMap</td><td>Java基于NavigableMap接口</td></tr><tr><td>哈希Map</td><td>unordered_map</td><td>HashMap</td><td>Java解决冲突=链表+红黑树</td></tr><tr><td>集合</td><td>set</td><td>HashSet/TreeSet</td><td>Java基于Map实现</td></tr></tbody></table><p>哈希碰撞处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ unordered_map (链地址法)</span></span><br><span class="line">bucket <span class="number">0</span>: [键<span class="number">1</span>] → [键<span class="number">2</span>] → null</span><br><span class="line">bucket <span class="number">1</span>: [键<span class="number">3</span>] → null</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java HashMap (链表转红黑树)</span></span><br><span class="line">bucket <span class="number">0</span>: [键<span class="number">1</span>] → [键<span class="number">2</span>]（当长度&gt;<span class="number">8</span>转红黑树）</span><br></pre></td></tr></table></figure><h3 id="内存管理差异">内存管理差异</h3><table><thead><tr><th>维度</th><th>C++ STL</th><th>Java集合框架</th></tr></thead><tbody><tr><td>元素存储</td><td>值语义（直接存储对象）</td><td>引用语义（存储对象引用）</td></tr><tr><td>内存释放</td><td>析构函数立即释放</td><td>GC延迟回收</td></tr><tr><td>对象所有权</td><td>容器拥有元素所有权</td><td>容器持有引用，不管理对象生命周期</td></tr><tr><td>内存布局</td><td>连续内存(vector)或节点内存</td><td>数组(ArrayList)或节点(LinkedList)</td></tr></tbody></table><p>内存泄露风险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java典型内存泄露场景</span></span><br><span class="line">Map&lt;Key, Value&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">cache.put(key, heavyObject);</span><br><span class="line"><span class="comment">// 即使移除key，heavyObject仍可能被其他引用持有</span></span><br></pre></td></tr></table></figure><h3 id="迭代器设计对比">迭代器设计对比</h3><table><thead><tr><th>特性</th><th>C++ STL迭代器</th><th>Java迭代器</th></tr></thead><tbody><tr><td>设计模式</td><td>泛型编程思想</td><td>Iterator设计模式</td></tr><tr><td>并发修改检测</td><td>未定义行为</td><td>fail-fast机制抛ConcurrentModificationException</td></tr><tr><td>遍历中删除</td><td><code>it = vec.erase(it)</code></td><td><code>iterator.remove()</code></td></tr><tr><td>双向访问</td><td>支持(bidirectional iterator)</td><td>仅ListIterator支持</td></tr></tbody></table><p>安全删除示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++安全删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=vec.<span class="built_in">begin</span>(); it!=vec.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">  <span class="keyword">if</span>(condition) it = vec.<span class="built_in">erase</span>(it);</span><br><span class="line">  <span class="keyword">else</span> ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java安全删除</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">  <span class="keyword">if</span>(condition) it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全实现">线程安全实现</h3><table><thead><tr><th>安全级别</th><th>C++ STL</th><th>Java集合框架</th></tr></thead><tbody><tr><td>默认情况</td><td>非线程安全</td><td>非线程安全</td></tr><tr><td>同步容器</td><td>无</td><td>Collections.synchronizedXXX()</td></tr><tr><td>并发容器</td><td>TBB库中的concurrent_vector</td><td>ConcurrentHashMap, CopyOnWriteArrayList</td></tr><tr><td>无锁实现</td><td>atomic类型</td><td>AtomicInteger等</td></tr></tbody></table><p>Java并发容器原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap分段锁实现</span></span><br><span class="line">Map&lt;String, Object&gt; concurrentMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 写操作锁定单个segment而不是整个map</span></span><br><span class="line">concurrentMap.compute(key, (k,v) -&gt; v == <span class="literal">null</span> ? newValue : modify(v));</span><br></pre></td></tr></table></figure><h3 id="API设计哲学差异">API设计哲学差异</h3><table><thead><tr><th>设计特点</th><th>C++ STL</th><th>Java集合框架</th></tr></thead><tbody><tr><td>接口复杂度</td><td>算法与容器分离(<code>sort(vec.begin(), vec.end())</code>)</td><td>容器集成方法(<code>Collections.sort()</code>)</td></tr><tr><td>函数式支持</td><td>C++11 lambda表达式</td><td>Java8 Stream API</td></tr><tr><td>空值处理</td><td>不允许null元素</td><td>允许null元素（需谨慎）</td></tr><tr><td>接口统一性</td><td>不同容器接口差异大</td><td>通过Collection/Map接口统一</td></tr></tbody></table><p>Java Stream API示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filtered = list.stream()</span><br><span class="line">    .filter(s -&gt; s != <span class="literal">null</span>)</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="性能关键差异点">性能关键差异点</h3><p>时间复杂度对比</p><table><thead><tr><th>操作</th><th>vector/ArrayList</th><th>list/LinkedList</th><th>unordered_map/HashMap</th></tr></thead><tbody><tr><td>随机访问</td><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>头部插入</td><td>O(n)</td><td>O(1)</td><td>-</td></tr><tr><td>查找操作</td><td>O(n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td>迭代器失效</td><td>频繁(扩容后全失效)</td><td>安全(节点删除)</td><td>Java视图迭代器部分安全</td></tr></tbody></table><p>内存占用分析</p><table><thead><tr><th>容器类型</th><th>C++ 内存特点</th><th>Java 内存特点</th></tr></thead><tbody><tr><td>动态数组</td><td>紧凑（无额外开销）</td><td>每个元素16字节对象头</td></tr><tr><td>链表节点</td><td>指针8字节</td><td>每个节点24字节（对象头+多个指针）</td></tr><tr><td>哈希表</td><td>桶数组+链表节点</td><td>桶数组+节点（可能转树节点）</td></tr></tbody></table><p>迁移实践建议</p><ol><li><p>容器选择转换表：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C++ STL       =&gt; Java集合框架</span><br><span class="line">----------      --------------</span><br><span class="line">vector        =&gt; ArrayList (随机访问多)</span><br><span class="line">deque         =&gt; ArrayDeque (队列场景)</span><br><span class="line">list          =&gt; LinkedList (频繁插入删除)</span><br><span class="line">unordered_map =&gt; HashMap (通用KV)</span><br><span class="line">map           =&gt; TreeMap (需排序)</span><br><span class="line"><span class="built_in">set</span>           =&gt; HashSet/TreeSet</span><br></pre></td></tr></table></figure></li><li><p>避免常见陷阱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陷阱1：循环删除</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">  list.remove(i); <span class="comment">// 会跳过元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式</span></span><br><span class="line">Iterator&lt;Item&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) it.remove();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陷阱2：并发修改</span></span><br><span class="line"><span class="keyword">for</span>(Item item : collection) &#123;</span><br><span class="line">  collection.add(newItem); <span class="comment">// 抛ConcurrentModificationException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>性能优化策略：<br>• 预分配容量：<code>new ArrayList&lt;&gt;(1000)</code></p><p>• 基本类型优化：使用FastUtil库的<code>IntArrayList</code></p><p>• 内存控制：及时clear()并置null帮助GC</p></li></ol><blockquote><p>作为C++转Java开发者，核心转变是从对象所有权管理到引用管理的思维转换。Java容器更像是&quot;对象引用管理系统&quot;，而非真正的对象容器。这种设计带来GC便利性的同时，也增加了内存泄露的风险点。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java容器与C-STL容器深度对比&quot;&gt;Java容器与C++ STL容器深度对比&lt;/h2&gt;
&lt;h3 id=&quot;类型系统差异&quot;&gt;类型系统差异&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;C++ STL&lt;/th&gt;
&lt;th&gt;Java</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>数字人-Java音视频处理-音频推流失败问题排查</title>
    <link href="https://kelinkong.github.io/2025/06/05/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-%E9%9F%B3%E9%A2%91%E6%8E%A8%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://kelinkong.github.io/2025/06/05/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86-%E9%9F%B3%E9%A2%91%E6%8E%A8%E6%B5%81%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2025-06-05T02:16:11.000Z</published>
    <updated>2025-06-05T08:01:15.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求">需求</h2><ol><li>从brtc房间拉流数字人的音视频</li><li>将音视频推流到trtc房间</li><li>从trtc房间获取用户音频数据</li><li>将音频数据推流到brtc房间</li></ol><h2 id="问题">问题</h2><p>在将音频数据推流到brtc房间时，遇到了音频推流失败的问题。</p><h2 id="排查步骤">排查步骤</h2><p>1、音频格式：经过多次确认，音频格式均为16kHz，单声道，16bit。</p><p>2、用户登陆brtc房间参数和百度提供的demo保持一致</p><p>这里登陆brtc房间有个坑，卡了两天，最后发现是websocket的线程和底层jni异步调用登陆的线程冲突了，导致登陆失败。后启动新线程去执行登陆操作，问题解决。</p><p>3、音频数据</p><p>从trtc拉下来的音频流使用brtc的demo能推成功，音频格式没问题。</p><p>4、排查网络问题</p><p>把demo放到cicd的容器中运行，能推流成功。</p><p>5、排查代码问题</p><p>使用多种方式推流，均推不上去。</p><p>6、怀疑和trtc的sdk不兼容</p><p>把使用到trtc的sdk的代码注释掉，能推流成功。</p><h2 id="原因">原因</h2><p>经过排查，问题的根本原因是 <strong><code>.so</code>（native shared library）加载的顺序冲突</strong>。</p><p>这在 Android/Java 中是非常常见的问题，特别是当两个 SDK 都依赖于底层音视频处理库（如 FFmpeg、libyuv、libaudio、OpenSL ES 等）时：</p><h2 id="来自大模型的解答">来自大模型的解答</h2><h3 id="为什么加载顺序会影响音频推流？">为什么加载顺序会影响音频推流？</h3><p>多个 SDK 引入相同名字但版本不同的 <code>.so</code> 库（如 <code>libavcodec.so</code>、<code>libaudio.so</code> 等）时：</p><ul><li>JVM 在 <code>System.loadLibrary</code> 第一次加载某个 so 后，会缓存该 native 映射；</li><li>后续加载同名 so 的 SDK 无法覆盖已加载的符号表；</li><li>结果导致某些 native 方法绑定错误，或者 native 初始化逻辑出错；</li><li>表现为推流失败、音频失真、甚至崩溃。</li></ul><p>是的，<strong><code>.so</code>库的加载顺序</strong>确实会影响音频推流，尤其是你当前这种使用多个音视频 SDK（如腾讯 + 百度）的场景。这类问题本质是 <strong>多个 SDK 引用了相同名字的 <code>.so</code> 或底层 C/C++ 库，并存在符号冲突或初始化覆盖</strong>。</p><hr><h3 id="✅-问题原因">✅ <strong>问题原因</strong></h3><p>当你用 JNI 加载多个 SDK（例如腾讯 SDK 和百度 SDK）时：</p><ul><li>两者可能都使用了 <strong>相同的第三方库</strong>（如 <code>libavcodec.so</code>、<code>libyuv.so</code>、<code>libaudio.so</code>）；</li><li>JVM 加载 <code>.so</code> 是<strong>按顺序且一次性的</strong>，后加载的 <code>.so</code> 无法覆盖已加载的；</li><li>如果两个库中有相同的函数名、变量名或全局符号，<strong>先加载的 <code>.so</code> 优先生效</strong>，后加载的可能会失效或行为异常；</li><li>导致你使用百度 SDK 推流时，native 层没有绑定到它自己的实现，而是用了腾讯 SDK 的符号，结果推流失败或异常。</li></ul><hr><h3 id="✅-你的验证结果说明了什么？">✅ <strong>你的验证结果说明了什么？</strong></h3><blockquote><p>✅ 你说“改变顺序，<strong>先加载百度的 so 库就可以解决推流的问题</strong>”，这说明是<strong>库冲突 + 加载顺序导致 native 方法绑定错误</strong>。</p></blockquote><hr><h3 id="✅-解决方案">✅ <strong>解决方案</strong></h3><h4 id="1-强制控制加载顺序（推荐）">1. <strong>强制控制加载顺序（推荐）</strong></h4><p>在 Java 中，使用 <code>System.loadLibrary()</code> 明确指定加载顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 先加载百度的 so，确保百度的 native 方法先绑定</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;baidu_audio_core&quot;</span>);</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;baidu_audio_jni&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再加载腾讯的 so</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;tx_audio_core&quot;</span>);</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;tx_audio_jni&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>放在同一个类的 static 块中或初始化时调用，确保顺序生效。</strong></p></blockquote><hr><h4 id="2-避免加载重复库">2. <strong>避免加载重复库</strong></h4><ul><li><p>如果你自己也打了 JNI 的 <code>.so</code> 包，确保名称唯一，比如用前缀 <code>yourapp_***.so</code>；</p></li><li><p>可以用 <code>nm</code> 或 <code>readelf</code> 工具检查两个 SDK 是否有相同符号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nm -D libbaidu_audio.so | grep Init</span><br><span class="line">nm -D libtx_audio.so | grep Init</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="3-手动使用-dlopen-（高级方案）">3. <strong>手动使用 <code>dlopen()</code>（高级方案）</strong></h4><p>如果你在 JNI 层调用了百度和腾讯的 <code>.so</code>，可以通过 <code>dlopen(path, RTLD_NOW)</code> 在 native 层动态加载并隔离符号空间（部分平台支持）。</p><hr><h4 id="4-使用不同进程隔离（可选）">4. <strong>使用不同进程隔离（可选）</strong></h4><p>如两个 SDK 冲突过于严重，甚至可以把两套逻辑放在两个 Android <code>Service</code> 的子进程中运行，通过 Binder 通信。这会带来一定复杂度，但是彻底隔离 native 的终极方案。</p><h2 id="改变加载顺序后，对trtc有影响">改变加载顺序后，对trtc有影响</h2><p>继续排查，使用trtc的线程池去执行往brtc房间推流的操作，会导致推流失败。<br>这说明 trtc 的线程池和 brtc 的推流操作存在冲突。</p><p>解决方案：启动新线程去执行推流的操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;需求&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从brtc房间拉流数字人的音视频&lt;/li&gt;
&lt;li&gt;将音视频推流到trtc房间&lt;/li&gt;
&lt;li&gt;从trtc房间获取用户音频数据&lt;/li&gt;
&lt;li&gt;将音频数据推流到brtc房间&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;问题&quot;</summary>
      
    
    
    
    <category term="Digital Human" scheme="https://kelinkong.github.io/categories/Digital-Human/"/>
    
    
  </entry>
  
  <entry>
    <title>数字人-Java音视频处理-推流和拉流</title>
    <link href="https://kelinkong.github.io/2025/05/21/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    <id>https://kelinkong.github.io/2025/05/21/%E6%95%B0%E5%AD%97%E4%BA%BA-Java%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</id>
    <published>2025-05-21T07:17:08.000Z</published>
    <updated>2025-06-05T02:15:21.965Z</updated>
    
    <content type="html"><![CDATA[<h1>Java处理音视频流-推流和拉流</h1><p>Java本身不支持音视频处理，但可以通过第三方库来实现。</p><p>一般音视频流处理流程如下：</p><ul><li>读取流数据：通过网络（如 RTMP、HTTP）或本地文件读取音视频流。</li><li>解码：将压缩的音视频数据解码为原始帧（如 PCM、YUV）。</li><li>处理/分析：对帧数据进行处理，如转码、剪辑、特效、识别等。</li><li>编码：将处理后的帧重新编码为目标格式。</li><li>输出/推流：保存到文件或通过网络推送到服务器</li></ul><h2 id="什么是RTMP协议？">什么是RTMP协议？</h2><p>RTMP（Real-Time Messaging Protocol）是一种用于音视频流传输的协议，最初由Adobe开发。它主要用于Flash Player与服务器之间的实时音视频传输。</p><p>RTMP协议支持低延迟的音视频流传输，适用于直播、视频会议等场景。</p><p>RTMP协议的特点包括：</p><ul><li>低延迟：适合直播等实时性要求高的场景。</li><li>支持音视频同步传输：可以同时传输音频、视频和数据。</li><li>广泛应用：被许多流媒体服务器（如 Nginx-RTMP、Wowza、Red5）和平台（如斗鱼、B站、抖音等）支持。</li></ul><p>典型推流地址格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtmp://服务器地址/应用名/流名</span><br></pre></td></tr></table></figure><p>Java使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FFmpegFrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FFmpegFrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Frame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RtmpPushExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// RTMP 拉流地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rtmpUrl</span> <span class="operator">=</span> <span class="string">&quot;rtmp://服务器地址/应用名/流名&quot;</span>;</span><br><span class="line">        <span class="type">FFmpegFrameGrabber</span> <span class="variable">grabber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FFmpegFrameGrabber</span>(rtmpUrl);</span><br><span class="line">        grabber.setOption(<span class="string">&quot;rtmp_buffer&quot;</span>, <span class="string">&quot;1000&quot;</span>); <span class="comment">// 设置缓冲区大小</span></span><br><span class="line">        grabber.setFormat(<span class="string">&quot;flv&quot;</span>); <span class="comment">// 设置输入格式</span></span><br><span class="line">        grabber.start(); <span class="comment">// 开始抓取：初始化解码器并打开输入流（比如 RTMP 网络流、本地文件等），为后续逐帧读取音视频数据做准备。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标采样率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">targetSampleRate</span> <span class="operator">=</span> <span class="number">44100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 推流到RTMP服务器</span></span><br><span class="line">        <span class="type">FFmpegFrameRecorder</span> <span class="variable">recorder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FFmpegFrameRecorder</span>(</span><br><span class="line">            <span class="string">&quot;rtmp://服务器地址/应用名/流名&quot;</span>,</span><br><span class="line">            grabber.getImageWidth(),</span><br><span class="line">            grabber.getImageHeight(),</span><br><span class="line">            grabber.getAudioChannels()</span><br><span class="line">        );</span><br><span class="line">        recorder.setFormat(<span class="string">&quot;flv&quot;</span>);</span><br><span class="line">        recorder.setSampleRate(targetSampleRate); <span class="comment">// 设置目标采样率</span></span><br><span class="line">        recorder.start(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 音频重采样器</span></span><br><span class="line">        <span class="type">AudioResampler</span> <span class="variable">resampler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (grabber.getSampleRate() != targetSampleRate) &#123;</span><br><span class="line">            resampler = AudioResampler.create(</span><br><span class="line">                targetSampleRate, grabber.getSampleRate(),</span><br><span class="line">                grabber.getAudioChannels(), grabber.getAudioChannels(),</span><br><span class="line">                avutil.AV_SAMPLE_FMT_S16, grabber.getSampleFormat()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// grabber.grab()方法用于逐帧读取音视频数据，返回一个Frame对象。Frame对象包含了音视频的原始数据和相关信息。</span></span><br><span class="line">        Frame frame;</span><br><span class="line">        <span class="keyword">while</span> ((frame = grabber.grab()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (frame.samples != <span class="literal">null</span> &amp;&amp; resampler != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 对音频帧进行采样率转换</span></span><br><span class="line">                <span class="type">Frame</span> <span class="variable">resampledFrame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Frame</span>();</span><br><span class="line">                resampledFrame.sampleRate = targetSampleRate;</span><br><span class="line">                resampledFrame.audioChannels = frame.audioChannels;</span><br><span class="line">                resampledFrame.samples = resampler.resample(frame.samples);</span><br><span class="line">                recorder.record(resampledFrame);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recorder.record(frame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        recorder.stop();</span><br><span class="line">        grabber.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FFmpegFrameGrabber</code>是 JavaCV（基于 FFmpeg 的 Java 封装库）中的一个类，用于抓取（读取）音视频流的数据帧。它可以从本地文件、网络流（如 RTMP、HTTP、RTSP）等多种来源读取音视频内容，并将其解码为可处理的帧（Frame）对象。</p><p><code>FFmpegFrameRecorder</code>是 JavaCV 中用于录制（写入）音视频流的类。它可以将处理后的帧数据编码为指定格式，并输出到文件或网络流中。</p><p><code>Frame</code>是 JavaCV 中的一个类，表示音视频的单帧数据。它包含了音频样本、视频图像等信息。</p><p><strong>FFmpegFrameGrabber 和 FFmpegFrameRecorder 的典型用法就是一帧帧地处理。</strong></p><p>具体流程如下：</p><ul><li>FFmpegFrameGrabber 负责从流或文件中逐帧读取音视频数据（每次调用 grab() 返回一帧 Frame）。</li><li>对每一帧进行处理（如重采样、转码、加特效等）。</li><li>处理完一帧后，立即用 FFmpegFrameRecorder 推流或写出（每次调用 record(frame) - 送一帧到目标服务器或文件）。</li></ul><h2 id="从Frame中读取原始数据">从Frame中读取原始数据</h2><p><code>Frame</code>类中包含了音频和视频的原始数据，具体字段如下：</p><ul><li><code>samples</code>：音频样本数据，通常是一个二维数组，表示音频的 PCM 数据。</li><li><code>image</code>：视频图像数据，通常是一个三维数组，表示视频图像的像素数据。</li><li><code>timestamp</code>：时间戳，表示该帧的时间位置。</li><li><code>imageWidth</code>：视频图像的宽度。</li><li><code>imageHeight</code>：视频图像的高度。</li><li><code>audioChannels</code>：音频通道数。</li><li><code>sampleRate</code>：音频采样率。</li><li><code>sampleFormat</code>：音频样本格式。</li><li><code>audioData</code>：音频数据，通常为一个一维数组，表示音频的采样数据。</li><li><code>audioTimestamp</code>：音频时间戳，表示该帧的时间位置。</li><li><code>videoData</code>：视频数据，通常为一个一维数组，表示视频的像素数据。</li><li><code>videoTimestamp</code>：视频时间戳，表示该帧的时间位置。</li></ul><p>读取音频数据并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frame.samples != <span class="literal">null</span>) &#123;</span><br><span class="line">    Buffer[] samples = frame.samples;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 例如：假设是 ShortBuffer</span></span><br><span class="line">    <span class="type">ShortBuffer</span> <span class="variable">audioBuffer</span> <span class="operator">=</span> (ShortBuffer) samples[<span class="number">0</span>];</span><br><span class="line">    <span class="type">short</span>[] audioData = <span class="keyword">new</span> <span class="title class_">short</span>[audioBuffer.remaining()];</span><br><span class="line">    audioBuffer.get(audioData); <span class="comment">// 复制数据到数组</span></span><br><span class="line">    myFrame.setAudioData(audioData); <span class="comment">// 填充到自定义的结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取视频数据并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (frame.image != <span class="literal">null</span>) &#123;</span><br><span class="line">    Buffer[] images = frame.image;</span><br><span class="line">    <span class="comment">// 例如：假设是 ByteBuffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">imageBuffer</span> <span class="operator">=</span> (ByteBuffer) images[<span class="number">0</span>];</span><br><span class="line">    <span class="type">byte</span>[] imageData = <span class="keyword">new</span> <span class="title class_">byte</span>[imageBuffer.remaining()];</span><br><span class="line">    imageBuffer.get(imageData); <span class="comment">// 复制数据到数组</span></span><br><span class="line">    myFrame.setImageData(imageData); <span class="comment">// 填充到自定义的结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Buffer 是桥梁，用于在 JavaCV 的 Frame 和你的自定义帧结构之间传递原始数据。</p><p>如何判断音频和视频数据的类型？</p><ul><li><code>frame.samples</code>：如果不为 null，则表示音频数据存在。</li><li><code>frame.image</code>：如果不为 null，则表示视频数据存在。</li><li><code>frame.imageType</code>：可以通过该字段判断视频数据的类型，如 RGB、YUV 等。</li><li><code>frame.sampleFormat</code>：可以通过该字段判断音频数据的格式，如 PCM、AAC 等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">format</span> <span class="operator">=</span> frame.sampleFormat;</span><br><span class="line"><span class="keyword">if</span> (format == avutil.AV_SAMPLE_FMT_S16) &#123;</span><br><span class="line">    <span class="comment">// 16位整型，samples[0] 是 ShortBuffer</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == avutil.AV_SAMPLE_FMT_FLT) &#123;</span><br><span class="line">    <span class="comment">// 32位浮点型，samples[0] 是 FloatBuffer</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == avutil.AV_SAMPLE_FMT_S32) &#123;</span><br><span class="line">    <span class="comment">// 32位整型，samples[0] 是 IntBuffer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以根据 avutil 的其他常量判断更多格式</span></span><br></pre></td></tr></table></figure><h2 id="如何理解Java中的Buffer">如何理解Java中的Buffer</h2><p>Buffer 是 Java 中用于处理原始数据的类，通常用于音频、视频等多媒体数据的存储和传输。</p><p>Buffer 提供了一种高效的方式来处理原始数据，避免了频繁的内存分配和复制。</p><p>Buffer 是一个抽象类，具体实现有 ByteBuffer、ShortBuffer、IntBuffer、<br>FloatBuffer 等。每种 Buffer 都有自己的数据类型和操作方法。</p><p>Buffer 的基本操作包括：</p><ul><li><code>put()</code>：将数据写入 Buffer。</li><li><code>get()</code>：从 Buffer 中读取数据。</li><li><code>flip()</code>：将 Buffer 的读写模式切换。</li><li><code>clear()</code>：清空 Buffer。</li><li><code>rewind()</code>：重置 Buffer 的读写位置。</li><li><code>remaining()</code>：获取 Buffer 中剩余可读数据的大小。</li><li><code>position()</code>：获取当前读写位置。</li><li><code>limit()</code>：获取 Buffer 的限制位置。</li><li><code>capacity()</code>：获取 Buffer 的总容量。</li><li><code>hasRemaining()</code>：判断 Buffer 中是否还有可读数据。</li></ul><p><code>flip()</code> 方法是 Java NIO Buffer 中非常重要的一个操作，用于切换 Buffer 的读写模式。</p><p>当向 Buffer 写入数据时（比如 put 操作），Buffer 处于“写模式”，position 指向下一个要写入的位置。</p><p>写完数据后，如果想从 Buffer 读取刚才写入的数据，需要先调用 flip()。</p><p><code>flip()</code> 会把 position 设为 0，把 limit 设为原来的 position，这样就可以从头开始读取刚才写入的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">buffer.put((<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">buffer.put((<span class="type">byte</span>)<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 此时 position=2, limit=10</span></span><br><span class="line"></span><br><span class="line">buffer.flip(); <span class="comment">// 切换到读模式</span></span><br><span class="line"><span class="comment">// 现在 position=0, limit=2</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> buffer.get(); <span class="comment">// 读取第一个字节</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buffer.get(); <span class="comment">// 读取第二个字节</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java处理音视频流-推流和拉流&lt;/h1&gt;
&lt;p&gt;Java本身不支持音视频处理，但可以通过第三方库来实现。&lt;/p&gt;
&lt;p&gt;一般音视频流处理流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取流数据：通过网络（如 RTMP、HTTP）或本地文件读取音视频流。&lt;/li&gt;
&lt;li&gt;解码：</summary>
      
    
    
    
    <category term="Digital Human" scheme="https://kelinkong.github.io/categories/Digital-Human/"/>
    
    
  </entry>
  
  <entry>
    <title>数字人-基础扫盲</title>
    <link href="https://kelinkong.github.io/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"/>
    <id>https://kelinkong.github.io/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/</id>
    <published>2025-04-25T01:00:57.000Z</published>
    <updated>2025-04-29T02:12:10.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字人模型">数字人模型</h2><h3 id="什么是数字人模型？">什么是数字人模型？</h3><p>“虚拟数字人模型”是近年来非常热门的一个概念，它结合了人工智能、计算机图形学、语音合成、自然语言处理等技术，用来创建和驱动一个在视觉、语音和行为上都像真人一样的“数字人”。</p><h4 id="核心构成模块">核心构成模块</h4><ol><li><p><strong>视觉模型（Avatar生成）</strong></p><ul><li>用来生成虚拟人的三维形象（2D 或 3D）</li><li>可以使用：Unity、Unreal Engine、MetaHuman、Blender 等工具</li><li>技术支持：计算机图形学、人脸建模、动作捕捉</li></ul></li><li><p><strong>语音模型（TTS &amp; ASR）</strong></p><ul><li>TTS：文字转语音（Text to Speech）</li><li>ASR：语音识别（Automatic Speech Recognition）</li></ul></li><li><p><strong>语言理解与生成模型（NLP）</strong></p><ul><li>负责理解用户说的话，生成合适的回应</li><li>如：GPT、ChatGLM、BERT 等大语言模型</li><li>也包含意图识别、情感识别、对话管理等</li></ul></li><li><p><strong>行为驱动模型（动画与情绪联动）</strong></p><ul><li>根据语音和文本生成对应的面部表情和动作</li><li>技术：表情驱动（facial animation）、骨骼动画、AI驱动的姿态识别</li></ul></li><li><p><strong>知识图谱 / 记忆系统（可选）</strong></p><ul><li>帮助数字人拥有长期记忆、个性化推荐能力</li></ul></li></ol><h4 id="常见技术栈">常见技术栈</h4><ul><li><strong>语言处理</strong>：OpenAI GPT、ChatGLM、BERT、Rasa</li><li><strong>语音合成/识别</strong>：科大讯飞、腾讯云、百度语音、微软 Azure</li><li><strong>3D建模</strong>：MetaHuman、Unreal Engine、Unity</li><li><strong>驱动引擎</strong>：Unity、UE + Python/JS 脚本控制</li><li><strong>集成平台</strong>：D-ID、Synthesia、Alibaba数字人平台等</li></ul><h3 id="常用的数字人模型有哪些？">常用的数字人模型有哪些？</h3><table><thead><tr><th>模型类别</th><th>代表模型</th><th>用途说明</th></tr></thead><tbody><tr><td>🌐 语言模型（NLP）</td><td>ChatGPT / GPT-4 / ChatGLM / Mistral / LLaMA</td><td>处理自然语言对话，生成内容</td></tr><tr><td>🔊 语音合成模型（TTS）</td><td>FastSpeech、VITS、Edge TTS、科大讯飞语音</td><td>将文本转成语音，表达情绪语调</td></tr><tr><td>🎙️ 语音识别模型（ASR）</td><td>Whisper、腾讯云语音识别、百度ASR</td><td>将用户语音转成文字，供语言模型处理</td></tr><tr><td>😃 表情/驱动模型</td><td>Audio2Face、DeepMotion、Faceware</td><td>根据语音驱动面部表情、动作</td></tr><tr><td>🧠 多模态模型</td><td>GPT-4V、CLIP、Flamingo</td><td>让数字人具备图文混合理解与生成能力</td></tr></tbody></table><h2 id="LiveTalking学习">LiveTalking学习</h2><p>仓库地址：<a href="https://github.com/lipku/LiveTalking">LiveTalking</a></p><p>LiveTalking是一个基于数字人技术开发的实时语音交互平台，它允许用户与数字人进行实时语音交互，并实时展示数字人的表情和动作。</p><h3 id="项目运行的流程">项目运行的流程</h3><p>在<code>app.py</code></p><p>在if <strong>name</strong> == ‘<strong>main</strong>’:块中，首先通过argparse.ArgumentParser()解析命令行参数。这些参数控制模型类型、传输协议（如WebRTC、RTMP等）、音频处理选项、TTS服务器地址等。</p><p>加载模型和头像 根据选择的模型类型（opt.model），从不同的模块（如ernerf、musetalk、wav2lip）加载相应的模型和头像。</p><table><thead><tr><th>模型</th><th>一句话功能定位</th></tr></thead><tbody><tr><td><strong>ER-NeRF</strong></td><td>高保真的<strong>3D人脸建模和渲染</strong></td></tr><tr><td><strong>MUSE-Talk</strong></td><td>基于音频的<strong>语音驱动唇形动画生成</strong>（多情绪）</td></tr><tr><td><strong>Wav2Lip</strong></td><td>基于音频的<strong>视频嘴型对齐模型</strong></td></tr><tr><td><strong>Ultralight Digital Human</strong></td><td>全流程数字人系统：<strong>轻量建模 + 驱动合成</strong></td></tr></tbody></table><h4 id="📊-功能与特性对比表">📊 功能与特性对比表</h4><table><thead><tr><th>项目</th><th><strong>ER-NeRF</strong></th><th><strong>MUSE-Talk</strong></th><th><strong>Wav2Lip</strong></th><th><strong>Ultralight-Digital-Human</strong></th></tr></thead><tbody><tr><td>类型</td><td>NeRF建模</td><td>动画生成（头部）</td><td>嘴型对齐（视频增强）</td><td>全栈式数字人引擎</td></tr><tr><td>输入</td><td>多视角照片 + 音频</td><td>音频（可选图像）</td><td>视频 + 音频</td><td>语音/文本 + 图像</td></tr><tr><td>输出</td><td>高精度3D人脸</td><td>带嘴型动画的头像视频</td><td>嘴型对齐修正后视频</td><td>数字人口播视频</td></tr><tr><td>是否3D</td><td>✅（NeRF）</td><td>❌（伪3D/2D）</td><td>❌</td><td>可2D或伪3D</td></tr><tr><td>表情/情绪控制</td><td>✅</td><td>✅（multi-style）</td><td>❌</td><td>支持一定表情合成</td></tr><tr><td>实时性</td><td>❌（较慢）</td><td>❌（需预处理）</td><td>✅（较快）</td><td>✅（轻量）</td></tr><tr><td>模型体积</td><td>大</td><td>中等</td><td>小</td><td>小（可部署）</td></tr><tr><td>是否可商用</td><td>❌ 研究为主</td><td>❌ 研究为主</td><td>✅（MIT开源）</td><td>✅（商用可谈）</td></tr><tr><td>适用方向</td><td>数字人建模/高保真渲染</td><td>虚拟主播嘴型动画</td><td>提升对口型视频真实感</td><td>快速构建轻量数字人客服等</td></tr></tbody></table><p><strong>“口型驱动模型”只是构建数字人的一小部分，而 LiveTalking 是把语音输入 → 模型推理 → 视频输出 → 播放/控制 这整条流程封装起来的完整运行框架。</strong></p><h2 id="LatentSync学习">LatentSync学习</h2><p>仓库地址：<a href="https://github.com/bytedance/LatentSync">LatentSync</a></p><p><code>scripts/inference.py</code>代码的核心解析，这是LatentSync项目的<strong>模型推理核心实现</strong>，实现了音视频同步生成的完整处理流程：</p><hr><h3 id="一、代码核心架构">一、代码核心架构</h3><table><thead><tr><th>模块</th><th>功能说明</th><th>关键技术</th></tr></thead><tbody><tr><td><strong>音频编码器</strong></td><td>通过Whisper模型提取音频特征</td><td><code>Audio2Feature</code>类实现</td></tr><tr><td><strong>VAE</strong></td><td>视频潜在空间编码/解码</td><td>StabilityAI的<code>sd-vae-ft-mse</code></td></tr><tr><td><strong>UNet3D</strong></td><td>时空特征融合与去噪</td><td>3D条件扩散模型</td></tr><tr><td><strong>推理管线</strong></td><td>协调各模块完成生成流程</td><td><code>LipsyncPipeline</code>类</td></tr></tbody></table><h3 id="二、关键代码流程">二、关键代码流程</h3><h4 id="1-初始化阶段">1. 初始化阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择计算精度（根据GPU能力自动切换FP16/FP32）</span></span><br><span class="line">is_fp16_supported = torch.cuda.get_device_capability()[<span class="number">0</span>] &gt; <span class="number">7</span></span><br><span class="line">dtype = torch.float16 <span class="keyword">if</span> is_fp16_supported <span class="keyword">else</span> torch.float32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载扩散模型调度器</span></span><br><span class="line">scheduler = DDIMScheduler.from_pretrained(<span class="string">&quot;configs&quot;</span>)  <span class="comment"># 使用DDIM加速采样</span></span><br></pre></td></tr></table></figure><h4 id="2-模型加载">2. 模型加载</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 音频特征提取器（根据cross_attention_dim选择模型规模）</span></span><br><span class="line">audio_encoder = Audio2Feature(</span><br><span class="line">    model_path=<span class="string">&quot;checkpoints/whisper/tiny.pt&quot;</span>,  <span class="comment"># 384维特征</span></span><br><span class="line">    num_frames=config.data.num_frames,         <span class="comment"># 视频帧数（如16帧）</span></span><br><span class="line">    audio_feat_length=config.data.audio_feat_length  <span class="comment"># 音频特征长度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像潜在空间编解码器</span></span><br><span class="line">vae = AutoencoderKL.from_pretrained(<span class="string">&quot;stabilityai/sd-vae-ft-mse&quot;</span>)</span><br><span class="line">vae.config.scaling_factor = <span class="number">0.18215</span>  <span class="comment"># 潜在空间缩放系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D UNet去噪模型</span></span><br><span class="line">denoising_unet = UNet3DConditionModel.from_pretrained(</span><br><span class="line">    config=OmegaConf.to_container(config.model),  <span class="comment"># 模型结构配置</span></span><br><span class="line">    ckpt_path=args.inference_ckpt_path            <span class="comment"># 预训练权重</span></span><br><span class="line">).to(dtype=dtype)</span><br></pre></td></tr></table></figure><h4 id="3-推理管线构建">3. 推理管线构建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline = LipsyncPipeline(</span><br><span class="line">    vae=vae,                   <span class="comment"># 潜在空间编解码</span></span><br><span class="line">    audio_encoder=audio_encoder,  <span class="comment"># 音频特征提取</span></span><br><span class="line">    denoising_unet=denoising_unet,  <span class="comment"># 时空去噪</span></span><br><span class="line">    scheduler=scheduler         <span class="comment"># 扩散调度策略</span></span><br><span class="line">).to(<span class="string">&quot;cuda&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="4-生成执行">4. 生成执行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pipeline(</span><br><span class="line">    video_path=args.video_path,  <span class="comment"># 输入视频（驱动姿态）</span></span><br><span class="line">    audio_path=args.audio_path,  <span class="comment"># 输入音频（驱动唇形）</span></span><br><span class="line">    video_out_path=args.video_out_path,  <span class="comment"># 输出视频路径</span></span><br><span class="line">    num_inference_steps=args.inference_steps,  <span class="comment"># 去噪步数（默认20）</span></span><br><span class="line">    guidance_scale=args.guidance_scale,  <span class="comment"># 分类器自由引导强度（默认1.0）</span></span><br><span class="line">    width=config.data.resolution,  <span class="comment"># 输出分辨率（如512）</span></span><br><span class="line">    mask_image_path=config.data.mask_image_path  <span class="comment"># 面部区域掩码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="三、关键参数说明">三、关键参数说明</h3><table><thead><tr><th>参数</th><th>作用</th><th>典型值</th></tr></thead><tbody><tr><td><code>num_inference_steps</code></td><td>控制生成质量与速度的平衡</td><td>20-50步</td></tr><tr><td><code>guidance_scale</code></td><td>调节音频条件对生成的引导强度</td><td>1.0-3.0</td></tr><tr><td><code>num_frames</code></td><td>同时处理的视频帧数</td><td>16帧</td></tr><tr><td><code>resolution</code></td><td>输出视频分辨率</td><td>512x512</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数字人模型&quot;&gt;数字人模型&lt;/h2&gt;
&lt;h3 id=&quot;什么是数字人模型？&quot;&gt;什么是数字人模型？&lt;/h3&gt;
&lt;p&gt;“虚拟数字人模型”是近年来非常热门的一个概念，它结合了人工智能、计算机图形学、语音合成、自然语言处理等技术，用来创建和驱动一个在视觉、语音和行为上都像真人</summary>
      
    
    
    
    <category term="Digital Human" scheme="https://kelinkong.github.io/categories/Digital-Human/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-基础学习</title>
    <link href="https://kelinkong.github.io/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-04-18T02:03:00.000Z</published>
    <updated>2025-12-25T10:24:02.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本类型和包装类型的区别？">基本类型和包装类型的区别？</h3><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>:基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li><li><strong>比较方式</strong>：对于基本数据类型来说，== 比较的是值。对于包装数据类型来说，== 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li></ul><h2 id="Java的垃圾回收（GC算法）、内存模型（堆-栈）、类加载机制和C-的区别">Java的垃圾回收（GC算法）、内存模型（堆/栈）、类加载机制和C++的区别</h2><p>Java和C++在内存管理、内存模型和类加载机制上有显著区别，主要源于Java的自动内存管理（GC）和运行时环境（JVM）的设计。以下是详细对比：</p><h3 id="1-垃圾回收（GC）-vs-手动内存管理">1. 垃圾回收（GC） vs. 手动内存管理</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>内存管理方式</td><td>自动垃圾回收（GC）</td><td>手动管理（<code>new</code>/<code>delete</code>或智能指针）</td></tr><tr><td>内存泄漏风险</td><td>较低（GC自动回收不可达对象）</td><td>较高（需手动释放，易遗漏或重复删除）</td></tr><tr><td>回收算法</td><td>分代收集（Young/Old区）、标记-清除、G1等</td><td>无内置GC，需手动实现或依赖第三方库（如Boehm GC）</td></tr><tr><td>性能影响</td><td>GC可能导致STW（Stop-The-World）暂停</td><td>无GC开销，但手动管理可能引入性能问题</td></tr><tr><td>典型工具</td><td>JVM参数调优（<code>-Xms</code>, <code>-Xmx</code>）、VisualVM</td><td>Valgrind（检测内存泄漏）、智能指针（<code>shared_ptr</code>）</td></tr></tbody></table><p>关键区别：<br>• Java的GC自动处理对象生命周期，而C++依赖程序员手动控制（或通过RAII模式）。</p><p>• Java的GC算法针对不同对象生命周期优化（如分代假设），C++无此机制。</p><h3 id="2-内存模型（堆-栈）">2. 内存模型（堆/栈）</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>对象存储位置</td><td>所有对象在堆上（栈仅存基本类型和引用）</td><td>对象可分配在堆（<code>new</code>）或栈（局部变量）</td></tr><tr><td>栈分配效率</td><td>栈仅存基本类型（如<code>int</code>）和对象引用</td><td>栈可存完整对象，访问更快（无堆分配开销）</td></tr><tr><td>堆内存释放</td><td>由GC自动回收</td><td>需手动<code>delete</code>或依赖作用域结束（栈对象）</td></tr><tr><td>内存碎片问题</td><td>GC会整理内存（如CMS的压缩阶段）</td><td>需手动处理（如自定义内存池）</td></tr></tbody></table><p>示例代码对比：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java：对象只能在堆上</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// obj是引用，存储在栈；Object实例在堆</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++：对象可在栈或堆上</span></span><br><span class="line">Object obj_stack;          <span class="comment">// 对象在栈上（自动析构）</span></span><br><span class="line">Object* obj_heap = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 对象在堆上（需手动delete）</span></span><br></pre></td></tr></table></figure><p>关键区别：<br>• Java强制对象分配在堆上（栈仅存引用），C++允许灵活选择。</p><p>• C++栈对象生命周期与作用域绑定，Java需依赖GC。</p><h3 id="3-类加载机制-vs-编译链接">3. 类加载机制 vs. 编译链接</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>代码加载时机</td><td>运行时动态加载（按需由ClassLoader加载）</td><td>编译时静态链接（所有符号在编译期解析）</td></tr><tr><td>动态性</td><td>支持运行时反射、动态代理等</td><td>无原生反射，需额外库（如RTTI）</td></tr><tr><td>类初始化顺序</td><td>严格规范（静态块、父类优先）</td><td>依赖编译顺序，无明确规范</td></tr><tr><td>依赖管理</td><td>通过ClassPath/Jar包隔离</td><td>通过头文件（<code>.h</code>）和库文件（<code>.so</code>/<code>.dll</code>）</td></tr></tbody></table><p>Java类加载流程：</p><ol><li>加载：查找字节码（<code>.class</code>文件）→ 生成<code>Class</code>对象。</li><li>验证：检查字节码安全性。</li><li>准备：分配静态变量内存（默认值）。</li><li>解析：将符号引用转为直接引用。</li><li>初始化：执行静态代码块和赋值。</li></ol><p>C++编译流程：</p><ol><li>预处理 → 编译 → 汇编 → 链接（静态/动态）。</li></ol><p>关键区别：<br>• Java的类加载是运行时行为，支持动态特性（如热部署）；C++在编译时完成链接，更静态。</p><p>• Java通过ClassLoader实现隔离（如Tomcat的多Web应用），C++需手动管理符号冲突。</p><h3 id="4-其他重要区别">4. 其他重要区别</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>指针与引用</td><td>无显式指针，只有引用（安全）</td><td>支持指针和引用（灵活但危险）</td></tr><tr><td>多继承</td><td>不支持（通过接口<code>interface</code>模拟）</td><td>支持多继承（菱形继承问题需虚继承解决）</td></tr><tr><td>运行时类型</td><td>反射API完整（<code>Class</code>对象、方法调用等）</td><td>有限RTTI（<code>typeid</code>、<code>dynamic_cast</code>）</td></tr></tbody></table><h2 id="Java反射的原理">Java反射的原理</h2><p>Java的反射（Reflection）和C++的类似功能实现有本质区别，主要源于两者在运行时类型信息（RTTI）和语言设计哲学上的差异。以下是详细对比和原理分析：</p><hr><p><strong>一、Java反射的原理</strong><br><strong>1. 核心机制</strong><br>• Class对象：每个加载的类在JVM中都有一个唯一的<code>Class</code>对象，存储类的元数据（字段、方法、构造器等）。</p><p>• 动态访问：通过<code>Class</code>对象，可以在运行时获取并操作类的成员，无需在编译时知道具体类结构。</p><p>• 关键类库：</p><p>• <code>Class&lt;T&gt;</code>：表示类的元数据。</p><p>• <code>Field</code>：类的字段（包括私有字段）。</p><p>• <code>Method</code>：类的方法。</p><p>• <code>Constructor</code>：类的构造器。</p><p><strong>2. 实现原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：通过反射调用String的substring方法</span></span><br><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(<span class="string">&quot;Hello World&quot;</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>• 步骤解析：</p><ol><li>类加载：JVM的类加载子系统加载目标类（如<code>String</code>），生成<code>Class</code>对象。 <strong>因为Java的每一个类的类名都是唯一的，所以可以通过类名来获取Class对象。</strong></li><li>元数据提取：通过<code>Class</code>对象的方法（如<code>getMethod()</code>）从方法区中查找元数据。</li><li>动态调用：<code>Method.invoke()</code>通过JNI（Java Native Interface）或JVM内部方法触发实际调用。</li></ol><p><strong>3. 底层支持</strong><br>• 方法区：存储类的元数据（JVM规范中的“类数据”部分）。</p><p>• JVM指令：</p><p>• <code>invokevirtual</code>：普通方法调用。</p><p>• <code>invokespecial</code>：构造器/私有方法调用。</p><p>• <code>invokeinterface</code>：接口方法调用。</p><p>• <code>invokedynamic</code>：动态语言支持（如Lambda表达式）。</p><p><strong>4. 性能开销</strong><br>• 原因：</p><p>• 运行时解析方法/字段（跳过编译期优化）。</p><p>• 安全检查（如私有方法访问权限）。</p><p>• 优化手段：</p><p>• 缓存<code>Class</code>/<code>Method</code>对象。</p><p>• 使用<code>MethodHandle</code>（JSR 292，类似C++的函数指针）。</p><h3 id="举个例子">举个例子</h3><p>这里通过一个必须使用反射的典型场景——动态加载并调用未知类的私有方法，结合代码示例详细说明：</p><hr><p><strong>场景描述</strong><br>假设你正在开发一个插件系统，需要加载第三方开发的插件类（编译时无法获知具体实现），并调用其私有初始化方法 <code>init()</code>。<br>由于以下限制，必须使用反射：</p><ol><li>插件类名和方法名仅在运行时通过配置文件获取（编译时无法确定）。</li><li>目标方法是<code>private</code>的，常规调用无法访问。</li></ol><hr><p><strong>示例代码</strong><br><strong>1. 插件类（第三方提供，编译时未知）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三方插件（实际开发中可能是动态加载的jar包中的类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecretPlugin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; <span class="comment">// 私有方法，常规方式无法调用</span></span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&quot;ACTIVE&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;插件已秘密初始化，状态：&quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 主程序（通过反射强制调用私有方法）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 动态获取插件类名（例如从配置文件中读取）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pluginClassName</span> <span class="operator">=</span> <span class="string">&quot;SecretPlugin&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反射加载类（编译时无法知道SecretPlugin的存在）</span></span><br><span class="line">        Class&lt;?&gt; pluginClass = Class.forName(pluginClassName);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">pluginInstance</span> <span class="operator">=</span> pluginClass.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 反射获取私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">initMethod</span> <span class="operator">=</span> pluginClass.getDeclaredMethod(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 突破私有限制！</span></span><br><span class="line">        initMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// 关键操作：关闭访问检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 调用私有方法</span></span><br><span class="line">        initMethod.invoke(pluginInstance); <span class="comment">// 输出：插件已秘密初始化，状态：ACTIVE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>为什么必须用反射？</strong></p><table><thead><tr><th>限制条件</th><th>常规Java代码</th><th>反射的解决方案</th></tr></thead><tbody><tr><td>类名在编译时未知</td><td>无法直接<code>new SecretPlugin()</code></td><td><code>Class.forName()</code>动态加载</td></tr><tr><td>方法是<code>private</code>的</td><td>无法通过对象调用<code>plugin.init()</code></td><td><code>getDeclaredMethod()</code> + <code>setAccessible(true)</code></td></tr><tr><td>方法签名可能变化</td><td>硬编码调用会导致编译错误</td><td>通过字符串名称获取方法，灵活适应变化</td></tr></tbody></table><hr><p><strong>关键反射API解析</strong></p><ol><li><p><code>Class.forName(String)</code><br>• 动态加载类，完全通过字符串类名操作。</p><p>• <em>类似场景</em>：JDBC驱动加载（如<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）。</p></li><li><p><code>getDeclaredMethod(String)</code><br>• 获取类声明的任意方法（包括私有方法），而<code>getMethod()</code>只能获取公共方法。</p></li><li><p><code>setAccessible(true)</code><br>• 关闭Java的访问控制检查，突破<code>private</code>/<code>protected</code>限制。</p><p>• <em>警告</em>：滥用会破坏封装性，应谨慎使用！</p></li><li><p><code>Method.invoke(Object)</code><br>• 动态调用方法，第一个参数是方法所属对象实例。</p></li></ol><hr><p><strong>实际应用场景</strong></p><ol><li><p>框架开发<br>• Spring：通过反射注入<code>@Autowired</code>依赖，调用<code>@PostConstruct</code>方法。</p><p>• JUnit：发现并运行测试方法（标记<code>@Test</code>的方法名在编译时未知）。</p><p><img src="../imgs/image-91.png" alt=""></p></li><li><p>动态代理<br>• <code>InvocationHandler</code>内部用反射调用目标方法。</p></li><li><p>序列化/反序列化<br>• Jackson/GSON通过反射访问私有字段将JSON转为对象。</p></li></ol><h2 id="使用-Autowired注解和手动创建的区别">使用@Autowired注解和手动创建的区别</h2><p>Spring 的构造函数注入，本质上就是：把“new 对象时传参”这件事，交给 Spring 容器来做。</p><p><strong>当构造函数参数是 List<T> / Set<T> / Map&lt;String, T&gt; 时：<br>Spring 会自动注入“容器中所有 T 类型的 Bean”</strong></p><p>在Spring框架中，使用<code>@Autowired</code>自动注入依赖和手动创建（如<code>new</code>关键字）有显著区别，主要体现在对象生命周期管理、代码耦合度和扩展性等方面。以下是详细对比：</p><hr><p><strong>1. 核心区别对比</strong></p><table><thead><tr><th>维度</th><th>使用<code>@Autowired</code></th><th>手动创建（<code>new</code>）</th></tr></thead><tbody><tr><td>控制权</td><td>Spring容器管理对象的创建、依赖注入和生命周期</td><td>开发者手动控制</td></tr><tr><td>耦合度</td><td>低（依赖接口而非具体实现）</td><td>高（直接依赖具体类）</td></tr><tr><td>单例管理</td><td>默认单例（共享实例）</td><td>每次<code>new</code>生成独立实例</td></tr><tr><td>依赖注入</td><td>自动解析并注入嵌套依赖（如A依赖B，B依赖C）</td><td>需手动逐层创建依赖链</td></tr><tr><td>扩展性</td><td>轻松替换实现（如通过<code>@Primary</code>或<code>@Qualifier</code>）</td><td>需修改代码重新编译</td></tr><tr><td>测试友好性</td><td>方便Mock依赖（如<code>@MockBean</code>）</td><td>需手动构造测试环境</td></tr><tr><td>AOP支持</td><td>自动代理（事务、日志等切面生效）</td><td>手动创建的对象无法被Spring AOP增强</td></tr></tbody></table><hr><p><strong>2. 代码示例对比</strong><br><strong>场景</strong>：订单服务（<code>OrderService</code>）依赖支付服务（<code>PaymentService</code>）</p><p><strong>方案1：使用<code>@Autowired</code>（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 由Spring注入</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2：手动创建（不推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手动创建依赖（高耦合）</span></span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>3. 关键差异解析</strong><br><strong>(1) 对象生命周期管理</strong><br>• <code>@Autowired</code>：</p><p>• Spring容器统一管理Bean，默认单例模式（整个应用共享一个<code>PaymentService</code>实例）。</p><p>• 可通过<code>@Scope(&quot;prototype&quot;)</code>改为多例。</p><p>• 手动创建：</p><p>• 每次<code>new</code>都会生成新实例，生命周期由开发者控制，容易导致内存泄漏或资源浪费。</p><p><strong>(2) 依赖解耦</strong><br>• <code>@Autowired</code>：</p><p>• <code>OrderService</code>仅依赖<code>PaymentService</code>的接口（如果提取了接口），后续替换实现（如<code>AlipayService</code>替换<code>PaymentService</code>）无需修改<code>OrderService</code>代码。</p><p>• 手动创建：</p><p>• <code>OrderService</code>直接绑定<code>PaymentService</code>的具体实现，变更实现需修改源代码并重新编译。</p><p><strong>(3) 复杂依赖链处理</strong><br>假设依赖链：<code>OrderService → PaymentService → FraudDetectionService</code><br>• <code>@Autowired</code>：</p><p>Spring自动完成整个依赖链的注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FraudDetectionService fraudDetectionService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 手动创建：</p><p>需手动逐层构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>(<span class="keyword">new</span> <span class="title class_">FraudDetectionService</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) AOP与代理支持</strong><br>• <code>@Autowired</code>：</p><p>• 若<code>PaymentService</code>有<code>@Transactional</code>注解，Spring会自动生成代理对象实现事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; <span class="comment">/* 事务生效 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 手动创建：</p><p>• <code>new PaymentService()</code>的对象不会被代理，事务、日志等AOP功能全部失效。</p><hr><p><strong>4. 何时选择手动创建？</strong><br>尽管<code>@Autowired</code>是推荐做法，但在以下场景可能需要手动创建：</p><ol><li>不可控的第三方类：某些库需要手动实例化（如<code>new Gson()</code>）。</li><li>性能敏感代码：避免Spring代理开销（但99%的场景无需考虑）。</li><li>单元测试：测试中可能需要手动构造对象（但Spring也提供<code>@TestConfiguration</code>）。</li></ol><hr><p><strong>5. 常见误区</strong><br><strong>误区1：<code>@Autowired</code>等于<code>new</code>？</strong><br>• 错误认知：认为<code>@Autowired</code>只是“自动帮你写<code>new</code>”。</p><p>• 真相：<code>@Autowired</code>是依赖注入（DI），强调控制反转（IoC），容器负责管理对象及其依赖关系。</p><p><strong>误区2：手动创建更简单？</strong><br>• 短期看：手动创建似乎更直接。</p><p>• 长期看：随着项目复杂化，手动管理依赖会变成灾难（如修改依赖需全局搜索<code>new</code>语句）。</p><hr><p><strong>6. 最佳实践</strong></p><ol><li>始终优先使用<code>@Autowired</code>：<br>让Spring管理依赖，享受单例、AOP、易于测试等优势。</li><li>面向接口编程：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentGateway paymentGateway; <span class="comment">// 依赖接口而非具体类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>必要时配合<code>@Bean</code>：<br>在配置类中手动定义Bean（仍由Spring管理）：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaymentService <span class="title function_">paymentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaymentService</span>(customConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新">使用@Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新</h3><p>是的，如果Bean是单例（默认）且状态可变，修改其字段会影响所有依赖该Bean的地方。这是Spring单例模式的核心特性，需要根据业务场景谨慎设计。以下是详细分析和解决方案：</p><hr><p><strong>1. 问题复现：单例Bean的字段共享</strong><br><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 默认单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 可变字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入单例Human</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入同一个单例Human</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作后的影响</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">personServiceA.getHuman().setAge(<span class="number">30</span>); </span><br><span class="line">System.out.println(personServiceB.getHuman().getAge()); <span class="comment">// 输出30！所有注入的地方同步修改</span></span><br></pre></td></tr></table></figure><hr><p><strong>2. 解决方案（根据场景选择）</strong></p><p><strong>方案1：改用原型（Prototype）作用域</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 每次注入新实例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p>• 每次<code>@Autowired</code>或<code>getBean()</code>时生成新实例，修改字段互不影响。</p><p>缺点：</p><p>• 内存开销增大（适合轻量级对象）。</p><p>• 需确保无循环依赖（原型Bean注入单例Bean需额外配置）。</p><p><strong>方案2：使用线程局部变量（ThreadLocal）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; age = ThreadLocal.withInitial(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age.set(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 效果：</p><p>• 每个线程独立修改<code>age</code>字段（适合Web应用的请求级隔离）。</p><p>• 注意：</p><p>• 需在请求结束时调用<code>age.remove()</code>防止内存泄漏（可通过拦截器实现）。</p><p><strong>方案3：无状态设计（最佳实践）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 不存储可变状态，仅提供方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateRetirementAge</span><span class="params">(<span class="type">int</span> currentAge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentAge + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p>• 所有方法参数由调用方传入，Bean本身无字段。</p><p>• 彻底避免线程安全问题，适合工具类。</p><p><strong>方案4：动态获取Bean（手动控制生命周期）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context; <span class="comment">// 注入Spring上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> context.getBean(Human.class); <span class="comment">// 每次获取新实例（需配合@Scope(&quot;prototype&quot;)）</span></span><br><span class="line">        human.setAge(<span class="number">30</span>); <span class="comment">// 不影响其他Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场景：</p><p>• 需要精细控制Bean生命周期的特殊逻辑。</p><p><strong>3. 不同场景的推荐策略</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>配置类（如数据库连接参数）</td><td>单例 + 不可变字段</td><td>配置通常全局一致，启动后不应修改</td></tr><tr><td>用户会话信息（如购物车）</td><td>原型作用域或Request作用域</td><td>每个用户需要独立实例</td></tr><tr><td>工具类（如日期计算）</td><td>单例 + 无状态</td><td>无需存储状态，线程安全</td></tr><tr><td>缓存管理</td><td>单例 + ConcurrentHashMap</td><td>共享缓存数据，但需线程安全容器</td></tr></tbody></table><hr><p><strong>4. 关键注意事项</strong></p><ol><li><p>不要滥用单例：<br>• 单例Bean应尽量设计为无状态或只读状态（如<code>@Service</code>、<code>@Repository</code>）。</p><p>• 可变状态单例Bean是线程安全的大敌（除非用同步锁或并发容器）。</p></li><li><p>慎用<code>@Scope(&quot;prototype&quot;)</code>：<br>• 原型Bean注入单例Bean时，需配合<code>@Lookup</code>或<code>ObjectProvider</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonBean</span> &#123;</span><br><span class="line">    <span class="meta">@Lookup</span> <span class="comment">// Spring会动态生成子类覆盖此方法</span></span><br><span class="line">    <span class="keyword">public</span> PrototypeBean <span class="title function_">getPrototypeBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 实际由Spring实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Web应用的作用域：<br>• 使用<code>@RequestScope</code>或<code>@SessionScope</code>替代手动线程隔离：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequestScope</span> <span class="comment">// 每个HTTP请求独立实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="autowired注解和-RequiredArgConstructor的区别">@autowired注解和@RequiredArgConstructor的区别</h2><p><code>@Autowired</code> 和 <code>@RequiredArgsConstructor</code> 都是用于依赖注入的注解，但它们的实现方式、使用场景和底层机制有显著区别。以下是详细对比：</p><hr><p><strong>1. 核心区别总结</strong></p><table><thead><tr><th>维度</th><th><code>@Autowired</code> (Spring原生)</th><th><code>@RequiredArgsConstructor</code> (Lombok)</th></tr></thead><tbody><tr><td>所属框架</td><td>Spring 原生注解</td><td>Lombok 生成的代码（编译时生效）</td></tr><tr><td>注入方式</td><td>反射（运行时通过字段或构造器注入）</td><td>编译时生成全参构造器（基于final或<code>@NonNull</code>字段）</td></tr><tr><td>代码可见性</td><td>显式出现在代码中</td><td>编译后生成实际代码（开发时不可见）</td></tr><tr><td>灵活性</td><td>支持字段、构造器、Setter注入</td><td>仅支持构造器注入</td></tr><tr><td>依赖范围</td><td>必须引入Spring</td><td>需引入Lombok（不依赖Spring）</td></tr><tr><td>适用场景</td><td>需要动态代理或复杂注入逻辑时</td><td>追求代码简洁、减少样板代码</td></tr></tbody></table><hr><p><strong>2. 使用示例对比</strong><br><strong>场景</strong>：一个服务类依赖两个组件</p><p><strong>方案1：<code>@Autowired</code>（字段注入）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 字段注入（反射直接赋值）</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：</p><p>• 代码简洁，但违反了&quot;不可变对象&quot;原则（字段可被反射修改）。</p><p>• 依赖Spring容器运行时通过反射注入。</p><p><strong>方案2：<code>@Autowired</code>（构造器注入）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 构造器注入（Spring推荐方式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">        <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：</p><p>• 明确依赖关系，支持不可变对象（final字段）。</p><p>• Spring 4.3+ 可省略<code>@Autowired</code>（单一构造器时自动注入）。</p><p><strong>方案3：<code>@RequiredArgsConstructor</code>（Lombok）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  <span class="comment">// 自动生成final字段的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译后等效于方案2的构造器注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：</p><p>• 代码最简洁，Lombok在编译时生成完整构造器。</p><p>• 需要字段标记为<code>final</code>或添加<code>@NonNull</code>注解。</p><p>• 不依赖Spring（也可用于非Spring项目）。</p><hr><p><strong>3. 关键差异解析</strong><br><strong>(1) 实现原理</strong><br>• <code>@Autowired</code>：</p><p>• 运行时通过反射或代理注入依赖，Spring容器负责查找并赋值。</p><p>• 支持三种注入方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 字段注入（不推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Setter注入</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123; <span class="built_in">this</span>.a = a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构造器注入（推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(A a)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>• <code>@RequiredArgsConstructor</code>：</p><p>• 编译时由Lombok生成包含所有<code>final</code>/<code>@NonNull</code>字段的构造器。</p><p>• 生成的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后实际代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">    <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 依赖验证</strong><br>• <code>@Autowired</code>：</p><p>• 默认要求依赖必须存在（可通过<code>@Autowired(required=false)</code>设为可选）。</p><p>• 启动时如果依赖缺失，抛出<code>BeanCreationException</code>。</p><p>• <code>@RequiredArgsConstructor</code>：</p><p>• 依赖的校验基于<code>final</code>或<code>@NonNull</code>：</p><pre><code>◦ 如果字段有`@NonNull`且依赖为null，抛出`NullPointerException`。  ◦ 非final字段不包含在生成构造器中。</code></pre><p><strong>(3) 与Spring的整合</strong></p><table><thead><tr><th>行为</th><th><code>@Autowired</code></th><th><code>@RequiredArgsConstructor</code></th></tr></thead><tbody><tr><td>AOP代理</td><td>支持（如<code>@Transactional</code>生效）</td><td>支持（生成的构造器能被Spring处理）</td></tr><tr><td>循环依赖</td><td>支持（通过三级缓存）</td><td>支持（同构造器注入）</td></tr><tr><td>Qualifier选择</td><td>支持（<code>@Qualifier</code>指定Bean）</td><td>需手动在字段添加<code>@Qualifier</code></td></tr></tbody></table><hr><p><strong>4. 如何选择？</strong><br><strong>优先使用 <code>@RequiredArgsConstructor</code> 当：</strong><br>• 项目已引入Lombok。</p><p>• 追求代码简洁性，减少样板代码。</p><p>• 需要不可变对象（final字段）。</p><p><strong>优先使用 <code>@Autowired</code> 当：</strong><br>• 需要非final字段注入。</p><p>• 需要Setter注入或字段注入（尽管不推荐）。</p><p>• 需要动态条件注入（如<code>@Autowired(required=false)</code>）。</p><p><strong>最佳实践组合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;  <span class="comment">// 必须的依赖</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span>  <span class="comment">// 可选的依赖</span></span><br><span class="line">    <span class="keyword">private</span> DiscountService discountService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>5. 常见问题</strong><br><strong>Q1: 两者能混用吗？</strong><br>• 可以，但通常没必要。例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 额外注入非final依赖</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q2: Lombok和Spring谁先执行？</strong><br>• Lombok在编译时生成代码，Spring在运行时处理注解。顺序：</p><p>Lombok生成代码 → 编译 → Spring扫描注解。</p><p><strong>Q3: 为什么IDEA提示<code>@Autowired</code>警告？</strong><br>• 现代IDE推荐构造器注入（明确依赖+不可变），而<code>@Autowired</code>字段注入隐藏了依赖关系。使用<code>@RequiredArgsConstructor</code>可避免此警告。</p><hr><p><strong>总结</strong><br>• <code>@Autowired</code>：Spring原生的灵活注入方式，适合复杂场景。</p><p>• <code>@RequiredArgsConstructor</code>：Lombok的简洁方案，适合追求代码整洁和不可变性。</p><p>• 推荐：在新项目中优先使用<code>@RequiredArgsConstructor</code>，保持代码简洁且线程安全。</p><h2 id="Java中的构造器注入和C-中的组合有什么区别？">Java中的构造器注入和C++中的组合有什么区别？</h2><p>在 现代Spring（尤其是Spring 4.3+版本）中，构造器注入的<code>@Autowired</code>注解是可以省略的，这正是为了减少代码的冗余，让它更接近“纯Java”的风格（类似C++的组合）。下面分几个层面解释：</p><hr><p><strong>1. 为什么早期需要<code>@Autowired</code>？</strong><br>在Spring 4.3之前，如果类有多个构造器，Spring不知道应该用哪个构造器来注入依赖，必须用<code>@Autowired</code>明确标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 告诉Spring用这个构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123; <span class="comment">/* Spring不会用这个无参构造器 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>2. 现代Spring的改进（省略<code>@Autowired</code>）</strong><br>从 Spring 4.3 开始，如果类只有一个构造器，Spring会自动选择它进行依赖注入，无需<code>@Autowired</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 4.3+ 可以省略@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动被Spring用于依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，代码看起来和C++的组合（Composition）几乎一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++的依赖注入（手动组合）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService paymentService) </span><br><span class="line">        : <span class="built_in">paymentService</span>(paymentService) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>3. 和C++组合的核心区别</strong><br>虽然语法相似，但Spring的构造器注入和C++手动组合有本质区别：</p><table><thead><tr><th>维度</th><th>Spring构造器注入</th><th>C++手动组合</th></tr></thead><tbody><tr><td>对象创建权</td><td>Spring容器负责实例化并注入依赖</td><td>开发者手动<code>new</code>依赖对象</td></tr><tr><td>依赖解析</td><td>Spring自动查找匹配的Bean（按类型/名称）</td><td>需手动构造依赖链（如<code>new PaymentService()</code>）</td></tr><tr><td>单例管理</td><td>默认单例（共享实例）</td><td>每次<code>new</code>生成独立实例</td></tr><tr><td>动态代理</td><td>支持AOP（如<code>@Transactional</code>生效）</td><td>无原生支持</td></tr><tr><td>测试友好性</td><td>可轻松替换为Mock（Spring测试支持）</td><td>需手动替换依赖</td></tr></tbody></table><hr><p><strong>4. 为什么Spring仍然比C++组合强大？</strong></p><p><strong>(1) 自动依赖解析</strong><br>• Spring：</p><p>若<code>PaymentService</code>本身依赖其他Bean（如<code>@Repository</code>），Spring会自动递归解决整个依赖树。<br>• C++：</p><p>需手动构造所有嵌套依赖：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动管理依赖链</span></span><br><span class="line">Database db = <span class="keyword">new</span> <span class="built_in">Database</span>();</span><br><span class="line">Logger logger = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">PaymentService ps = <span class="keyword">new</span> <span class="built_in">PaymentService</span>(db, logger);</span><br><span class="line">OrderService os = <span class="keyword">new</span> <span class="built_in">OrderService</span>(ps);</span><br></pre></td></tr></table></figure><p><strong>(2) 动态扩展能力</strong><br>• Spring：</p><p>通过<code>@Profile</code>、<code>@Conditional</code>等动态选择实现类，无需修改代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span> <span class="comment">// 仅在开发环境生效</span></span><br><span class="line"><span class="keyword">public</span> PaymentService <span class="title function_">mockPaymentService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockPaymentService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• C++：</p><p>需通过预编译宏或工厂模式硬编码：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV</span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">MockPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">RealPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>(3) 解耦与测试</strong><br>Spring：</p><p>单元测试时可直接注入Mock对象：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PaymentService</span> <span class="variable">mockPs</span> <span class="operator">=</span> Mockito.mock(PaymentService.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockPs); <span class="comment">// 不依赖Spring容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++：</p><p>需依赖虚接口或模板技巧实现类似效果。</p><hr><p><strong>5. 什么情况下该用<code>@Autowired</code>？</strong><br>虽然构造器注入可以省略<code>@Autowired</code>，但在以下场景仍需显式标注：</p><ol><li>多个构造器时：指定哪个构造器用于注入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 明确告诉Spring用这个构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(paymentService, <span class="keyword">new</span> <span class="title class_">DefaultLogger</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService, Logger logger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">        <span class="built_in">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可选依赖：结合<code>@Autowired(required=false)</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span>  <span class="comment">// discountService可选</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, DiscountService ds)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>6. 终极对比：Spring vs C++</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring构造器注入（现代写法）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++手动组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService* paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService* ps) : <span class="built_in">paymentService</span>(ps) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">OrderService</span>() &#123; <span class="keyword">delete</span> paymentService; &#125; <span class="comment">// 需手动管理内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相同点：表面语法相似，都通过构造器传入依赖。</p><p>不同点：</p><p>• Spring的依赖是容器管理的Bean，C++是原始对象指针。</p><p>• Spring自动处理依赖链、代理、作用域，C++需手动实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本类型和包装类型的区别？&quot;&gt;基本类型和包装类型的区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>deepseek-v3技术报告学习</title>
    <link href="https://kelinkong.github.io/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-02-13T10:20:17.000Z</published>
    <updated>2025-04-18T02:02:38.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型架构层">模型架构层</h2><p><img src="../imgs/image-86.png" alt="模型结构图"></p><p>DeepSeekMoE架构相对于传统的Transformer架构，做了以下几项主要改进：</p><p><strong>Mixture of Experts (MoE)</strong>：</p><ul><li>DeepSeekMoE引入了路由专家（routed experts）和共享专家（shared experts）。与传统的Transformer不同，DeepSeekMoE可以根据输入动态选择不同的专家，从而使得模型能够根据任务需求利用不同的专门知识，而不是对所有输入使用相同的参数。</li><li>路由机制和Top-K路由机制确保每层只使用部分专家进行计算，从而提高了计算效率，避免了传统Transformer中对所有专家都进行计算的冗余。</li></ul><p><strong>多头潜在注意力（MLA）：</strong></p><ul><li>DeepSeekMoE的注意力机制进行了增强，使用了潜在Q和潜在K表示，区别于传统的查询（Q）、键（K）和值（V）表示。这样可以在注意力机制中提供更丰富的表示，从而改进了模型捕捉序列中依赖关系的能力。</li><li>通过RoPE（旋转位置编码）进一步增强了位置编码，帮助模型捕捉序列中的复杂模式。</li><li>引入了推理过程中的缓存机制，部分计算可以在推理时预计算或缓存，从而加速推理过程。</li></ul><p><strong>共享专家层：</strong></p><ul><li>DeepSeekMoE使用共享专家层，这意味着多个输入可以共享同一层的计算资源，而不是每个输入都使用完全独立的层。这样可以减少冗余计算，提升计算效率。</li></ul><p><strong>前馈网络和注意力机制的改进：</strong></p><ul><li>DeepSeekMoE采用了RMSNorm归一化机制，它是对层归一化（LayerNorm）的一种变体，能够在不依赖大批量训练的情况下稳定训练过程。</li><li>尽管保留了传统Transformer的前馈网络和多头注意力层，但通过MoE和潜在注意力的增强，使得模型能够处理更复杂的数据表示和更高效的计算。</li></ul><h3 id="MLA">MLA</h3><p>当我们谈到DeepSeekMoE在注意力机制和其他方面的改进时，实际上这些改进是为了提升模型的表达能力、捕捉更复杂的依赖关系并加速推理过程。以下是对每个改进的更具体的解释：</p><h4 id="潜在Q和潜在K表示-Latent-Q-Latent-K"><strong>潜在Q和潜在K表示 (Latent Q &amp; Latent K)</strong></h4><ul><li><strong>传统注意力机制：</strong> 在标准的Transformer架构中，查询（Q）、键（K）和值（V）是直接从输入中计算出来的。这些向量通过标准的点积操作来计算注意力权重，最终决定了每个输入对其他输入的影响。</li><li><strong>潜在Q和潜在K表示：</strong> 在DeepSeekMoE中，注意力机制引入了<strong>潜在Q</strong>（latent query）和<strong>潜在K</strong>（latent key）表示。与传统方法不同，这些潜在表示并不是直接从输入数据中提取的，而是通过学习到的潜在空间生成的。这允许模型捕捉更复杂的关系和特征。<ul><li><strong>潜在Q</strong>和<strong>潜在K</strong>通过生成更丰富的表示，使得模型能够处理更高阶的依赖关系，不仅限于传统的直接输入映射。</li><li>这种方法能够提升模型的表达能力，尤其是在需要捕捉长期依赖或者更复杂的输入特征时，潜在表示比传统的直接映射方式更加灵活和高效。</li></ul></li></ul><h4 id="RoPE（旋转位置编码）"><strong>RoPE（旋转位置编码）</strong></h4><ul><li><strong>传统位置编码：</strong> 在经典的Transformer模型中，位置编码（通常是正弦和余弦函数的组合）被加入到输入的词向量中，以便模型能够理解单词在序列中的相对位置。这些位置编码是固定的，对不同的输入序列进行相同的编码。</li><li><strong>RoPE（旋转位置编码）：</strong> DeepSeekMoE采用了<strong>RoPE</strong>，即旋转位置编码，这是一种改进的相对位置编码方法。RoPE通过对位置编码进行旋转，能够使得位置编码不仅与输入的绝对位置相关，还与输入之间的相对位置（距离）相关。<ul><li>这使得模型能够更好地处理长序列，并且更加灵活地理解序列中不同位置之间的相对关系。</li><li>RoPE编码的旋转性质使得模型能够在处理长距离依赖时表现得更好，尤其是在处理具有复杂结构的序列时。</li></ul></li></ul><h4 id="推理过程中的缓存机制"><strong>推理过程中的缓存机制</strong></h4><ul><li><strong>传统推理过程：</strong> 在传统的Transformer模型中，每次推理都会从头开始计算所有的输入，无论这些输入是否已经在之前的推理过程中计算过。这个过程可能会导致较慢的推理速度，特别是在处理长序列时。</li><li><strong>缓存机制：</strong> 在DeepSeekMoE中，推理过程引入了缓存机制。通过缓存中间计算结果，模型可以避免重复计算，特别是当处理重复或相似的输入时，缓存机制可以显著加速推理过程。<ul><li>在推理时，部分计算（例如中间的表示）可以提前计算并缓存起来，这样在处理后续输入时，模型可以直接使用缓存的结果，而无需重新计算。</li><li>这种机制提高了推理效率，尤其在推理时需要多次处理相似输入的情况下，可以大大减少计算的开销。</li></ul></li></ul><p>这些改进使得DeepSeekMoE不仅能够处理更加复杂的输入，还能够提高推理效率：</p><ul><li><strong>潜在Q和潜在K</strong>的引入使得模型能够捕捉更高阶的依赖关系，提升了注意力机制的表现。</li><li><strong>RoPE</strong>提供了一种更加灵活的相对位置编码方式，帮助模型更好地理解序列中的相对位置，尤其是在长序列中表现更优。</li><li><strong>缓存机制</strong>则通过减少重复计算加速了推理过程，提高了效率，特别是在处理大量或相似的输入时。</li></ul><h3 id="MOE">MOE</h3><p>在DeepSeekMoE架构中，<strong>专家</strong>（Experts）是指一组参数化的子模型，它们可以针对特定的任务或输入做出不同的响应。这些专家是网络中的子模型或计算单元，每个专家通常具备独特的知识或处理能力，因此它们能够在不同的任务或输入下展现出不同的特性。</p><h4 id="什么是专家？">什么是专家？</h4><p>专家可以理解为一类具有特定参数的子模型或计算单元，每个专家在模型中负责处理输入的某些特定部分或任务。这些专家可以是类似于普通神经网络层的结构，或者更复杂的模块，它们在训练过程中会学习到针对某些类型输入的特殊模式。</p><h4 id="如何使用专家？">如何使用专家？</h4><p>DeepSeekMoE中的专家使用方式依赖于<strong>路由机制</strong>。在每次前向传播过程中，输入数据首先会通过一个<strong>路由器</strong>（Router）来选择哪些专家将被激活进行计算。路由器根据输入的特征决定哪些专家最适合处理当前输入。专家选择的过程通常有以下几个关键步骤：</p><ol><li><p><strong>输入数据进入路由器：</strong> 输入首先通过路由器，它根据输入的特征计算出每个专家的权重或得分。</p></li><li><p><strong>Top-K路由：</strong> 路由器根据计算结果选择得分最高的前K个专家进行处理（例如Top-K），这意味着并不是所有专家都会被激活，只有最相关的专家才会被使用。</p></li><li><p><strong>专家的激活：</strong> 被选中的专家进行计算并生成相应的输出。每个专家的计算结果可能会不同，因为它们专注于不同的特征或任务。</p></li><li><p><strong>输出合成：</strong> 激活的专家的输出将被合成并传递给后续的网络层。通常，会对多个专家的输出进行加权合成，以得到最终的输出。</p></li><li><p><strong>共享专家：</strong> 在一些情况下，也可以有<strong>共享专家</strong>，即多个输入共享相同的专家进行计算，这样可以进一步节省计算资源。</p></li></ol><h4 id="如何判断选择哪些专家？">如何判断选择哪些专家？</h4><p>在DeepSeekMoE架构中，激活哪些专家是通过<strong>路由机制</strong>来判断的。具体来说，路由机制根据输入的特征来动态选择需要激活的专家。这一过程包含了Share专家和Router专家的激活策略，具体如下：</p><p><strong>Share 专家</strong></p><ul><li><strong>一直激活：</strong> Share专家是始终参与计算的，它们不依赖于输入的特征，而是对所有的输入都会进行计算。换句话说，Share专家不经过路由选择，而是直接计算每个输入的输出。</li></ul><p><strong>Router 专家</strong></p><ul><li><p><strong>计算亲和度：</strong> Router专家的激活过程通过计算输入与各个专家之间的亲和度（相似性）来选择合适的专家。具体来说，这个过程通过以下步骤进行：</p><ul><li>首先，输入经过一个线性变换（通常是一个线性层），得到一个新的表示（亲和度评分），这个表示可以用来衡量输入与每个专家之间的相关性。</li><li>接着，这些评分会被用来选择Top-K个专家，即选择与输入亲和度最高的专家进行计算。</li></ul></li><li><p><strong>分组选择与Top-K策略：</strong></p><ul><li>在实际实现中，Router专家的选择会更加复杂。首先，会将所有的专家分成若干个组（n_groups）。每个组内包含多个专家。</li><li>然后，对于每个组，选择<strong>Top-2</strong>个专家，通过加总每组内Top-2专家的亲和度评分来确定哪个组的亲和度最高。</li><li>最后，在亲和度最高的这些组中，选择<strong>Top-K</strong>个专家，这样就可以确定最终需要激活的K个专家。</li></ul></li></ul><p><strong>加权输出：</strong></p><ul><li>最终，Router专家和Share专家的输出会通过亲和度加权融合在一起。具体来说，对于每个输入，Router专家和Share专家都会计算其输出，之后根据计算出的亲和度（即输入与每个专家之间的相关性），将这两个部分的输出进行加权求和，得到MoE层的最终输出。</li></ul><h2 id="训练方法创新">训练方法创新</h2><h3 id="FP8高低混合精度训练">FP8高低混合精度训练</h3><p><img src="../imgs/image-87.png" alt=""></p><p>首先，为提高模型训练速度，大部分核心计算操作（尤其是 GEMM 运算），均采用 FP8 精度实现。这些 GEMM 运算接收 FP8 格式的张量输入，输出 BF16 或 FP32 格式的结果。如图6所示，线性运算相关的三个 GEMM 操作，包括 Fprop（前向传播）、Dgrad（激活值反向传播）和 Wgrad（权重反向传播），均采用 FP8 执行。这种设计策略理论上将计算速度提升至原有 BF16 方法的两倍。同时，FP8 格式的 Wgrad GEMM 使得激活值能够以 FP8 格式存储用于反向传播，显著降低了内存使用量。</p><p>虽然 FP8 格式在效率方面具有优势，但某些运算由于对计算精度较为敏感，仍需要更高精度的支持。另外，部分计算开销较小的运算可以采用更高精度而不会显著影响整体训练效率。</p><p>因此，经过详细评估，系统对以下模块保持原有精度（BF16 或 FP32）：向量层、输出层、MoE 门控模块、标准化运算和注意力运算模块。这种针对性的高精度保留策略确保了 DeepSeek-V3 训练过程的动态稳定性。为进一步保障数值计算的稳定性，主要权重参数、权重梯度和优化器状态均采用更高精度存储。虽然这些高精度组件会带来一定的内存开销，但通过在分布式训练系统中跨多个 DP 层级进行高效数据分割，这些额外开销得到了有效控制。</p><p><strong>激活值反向传播（Dgrad）：</strong> 当神经网络进行前向传播时，每一层会计算其激活值（通常是通过激活函数的输出）。反向传播过程中，我们会通过计算每个层的误差，并通过梯度来更新网络的参数。激活值反向传播的核心目的是计算损失函数相对于每一层的输入（即激活值）的梯度。</p><p><strong>权重反向传播（Wgrad）</strong>： 在神经网络中，权重是模型的可学习参数。每次计算梯度时，目标是计算损失函数相对于权重的梯度，即计算权重在模型输出错误中的贡献。通过这些梯度信息，网络的权重会被调整，从而使得网络能够更好地拟合训练数据。</p><ul><li>激活值反向传播：计算的是每个层的激活值相对于损失函数的梯度，作用是提供层与层之间的误差传递，帮助调整每一层的输入（激活值）。</li><li>权重反向传播：则是计算每一层的权重相对于损失函数的梯度。它的目的是通过更新每一层的权重来降低模型的误差，最终优化网络性能。</li></ul><p><img src="../imgs/image-88.png" alt=""></p><p>BF16、FP32 向 FP8 转换采用分组量化。</p><h3 id="DualPipe-框架">DualPipe 框架</h3><p>分布式训练的目的其实就一个：节省更多的资源，资源包括计算时间、显存、机器数量。总的来说应该是节省总的GPUhours。</p><p><img src="../imgs/image-89.png" alt=""><br>模型训练中主要计算量来源于ATTENTION-O(L2)，MLP-O(H2)。<br>由于分布式训练，导致前向后向计算均需要通信，通信包括dispatch（将输入分到各个weight、expert）、combine（将各个weight、expert的输出结果聚合）两部分。</p><p>由于在同一个batch中，通信和计算是交替进行的，这将导致效率低下。为此deepseek v3 提出双管路的方法，使得通信与计算能够并行。</p><p><img src="../imgs/image-90.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模型架构层&quot;&gt;模型架构层&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../imgs/image-86.png&quot; alt=&quot;模型结构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;DeepSeekMoE架构相对于传统的Transformer架构，做了以下几项主要改进：&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>DB-图数据库Neo4j</title>
    <link href="https://kelinkong.github.io/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/"/>
    <id>https://kelinkong.github.io/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/</id>
    <published>2025-01-10T02:12:24.000Z</published>
    <updated>2025-01-10T02:17:00.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neo4j-图数据库简介">Neo4j 图数据库简介</h2><p><strong>Neo4j</strong> 是一种基于 <strong>图模型</strong> 的开源图数据库，专为存储和查询高度连接的数据而设计。与传统关系型数据库不同，Neo4j 的底层原理专注于实体（节点）和它们之间的关系（边）的直接存储和管理，具有高效处理复杂连接查询的能力。</p><p>以下是 Neo4j 的简介和底层原理：</p><h3 id="一、Neo4j-简介">一、Neo4j 简介</h3><h4 id="1-主要特点">1. <strong>主要特点</strong></h4><ul><li><p><strong>图模型</strong>：</p><ul><li>数据存储为节点（Nodes）、关系（Relationships）和属性（Properties）。</li><li>节点表示实体，关系表示实体之间的连接，属性用来描述节点和关系的详细信息。</li></ul></li><li><p><strong>查询语言：Cypher</strong>：</p><ul><li>专为图数据设计的一种声明性查询语言，类似 SQL，但更直观，适合复杂的图查询。</li></ul></li><li><p><strong>高效的图遍历</strong>：</p><ul><li>直接存储关系，使得在大量数据中查询连接关系（如路径、网络）非常高效。</li></ul></li><li><p><strong>弹性和可扩展性</strong>：</p><ul><li>支持单机和分布式部署，适合从小型应用到企业级应用的需求。</li></ul></li></ul><h4 id="2-应用场景">2. <strong>应用场景</strong></h4><ul><li><strong>推荐系统</strong>：基于社交关系或行为数据推荐内容。</li><li><strong>社交网络分析</strong>：分析用户间的交互和关系。</li><li><strong>知识图谱</strong>：存储和查询结构化知识。</li><li><strong>欺诈检测</strong>：通过关系模式检测可疑行为。</li><li><strong>供应链管理</strong>：优化复杂的物流和供应网络。</li></ul><h3 id="二、底层原理">二、底层原理</h3><h4 id="1-存储模型">1. <strong>存储模型</strong></h4><p>Neo4j 使用 <strong>原生图存储模型</strong>，直接存储节点和关系，避免了传统数据库中通过表关联的开销。</p><ul><li><p><strong>节点（Nodes）</strong>：</p><ul><li>存储实体数据，每个节点有唯一的 ID 和属性（键值对）。</li><li>例如：<code>User: &#123;name: 'Alice', age: 25&#125;</code>。</li></ul></li><li><p><strong>关系（Relationships）</strong>：</p><ul><li>直接存储连接节点的关系，包括关系类型和属性。</li><li>例如：<code>(Alice)-[:FRIENDS]-&gt;(Bob)</code> 表示 Alice 和 Bob 是朋友。</li></ul></li><li><p><strong>属性（Properties）</strong>：</p><ul><li>节点和关系可以包含多个属性，用于描述实体或连接的详细信息。</li></ul></li></ul><h4 id="2-索引与查找">2. <strong>索引与查找</strong></h4><ul><li><p><strong>索引</strong>：</p><ul><li>Neo4j 支持基于节点或关系属性的索引，用于快速定位图中的某些节点或关系。</li><li>索引底层通常采用 B+ 树或类似数据结构。</li></ul></li><li><p><strong>图遍历</strong>：</p><ul><li>Neo4j 的核心是基于深度优先（DFS）或广度优先（BFS）的图遍历算法。</li><li>与传统数据库的表扫描不同，Neo4j 通过直接访问存储的关系指针来实现高效遍历。</li></ul></li></ul><h4 id="3-事务与一致性">3. <strong>事务与一致性</strong></h4><ul><li><p><strong>ACID 事务</strong>：</p><ul><li>Neo4j 支持事务处理，确保数据的一致性。</li><li>每次操作（如添加节点或关系）都被记录在事务日志中，可支持回滚。</li></ul></li><li><p><strong>锁管理</strong>：</p><ul><li>使用细粒度的锁（如节点锁和关系锁），提高并发性能。</li></ul></li></ul><h4 id="4-查询与优化">4. <strong>查询与优化</strong></h4><ul><li><p><strong>Cypher 查询语言</strong>：</p><ul><li>Cypher 提供了简洁的语法，支持复杂的模式匹配和路径查询。</li><li>例如：查询所有好友的好友：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (user:Person)-[:FRIENDS]-&gt;(:Person)-[:FRIENDS]-&gt;(friend_of_friend)</span><br><span class="line">WHERE user.name = &#x27;Alice&#x27;</span><br><span class="line">RETURN friend_of_friend</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查询优化器</strong>：</p><ul><li>Cypher 查询在执行前会由优化器解析和优化，生成高效的执行计划。</li><li>例如，使用索引优先查找节点，再进行图遍历。</li></ul></li></ul><h4 id="5-存储与磁盘布局">5. <strong>存储与磁盘布局</strong></h4><ul><li><p><strong>存储文件</strong>：</p><ul><li>节点和关系被存储为分离的文件：<ul><li>节点存储文件：包含节点 ID 和属性。</li><li>关系存储文件：包含关系 ID、起点和终点节点的 ID 以及属性。</li></ul></li><li>通过这种分离，Neo4j 能快速定位和加载节点及其相关关系。</li></ul></li><li><p><strong>内存映射</strong>：</p><ul><li>使用内存映射文件（Memory-Mapped Files）技术将磁盘数据加载到内存，提高查询性能。</li></ul></li></ul><h4 id="6-分布式与扩展">6. <strong>分布式与扩展</strong></h4><ul><li><strong>分片（Sharding）</strong>：<ul><li>将图数据分片存储在不同的节点中，支持大规模图的存储。</li></ul></li><li><strong>复制（Replication）</strong>：<ul><li>支持主从复制，确保高可用性。</li></ul></li><li><strong>Raft 协议</strong>：<ul><li>Neo4j 4.x 及以上版本中，使用 Raft 协议管理分布式事务和数据一致性。</li></ul></li></ul><h3 id="三、Neo4j-的优势">三、Neo4j 的优势</h3><ol><li><p><strong>关系查询效率高</strong>：</p><ul><li>图存储和遍历使得关系密集型查询（如路径分析、模式匹配）效率远超关系型数据库。</li></ul></li><li><p><strong>直观的查询语言</strong>：</p><ul><li>Cypher 简洁易用，适合复杂的图模式匹配。</li></ul></li><li><p><strong>灵活的模式</strong>：</p><ul><li>图数据库无需固定模式（Schema-Free），支持动态更新。</li></ul></li><li><p><strong>可扩展性</strong>：</p><ul><li>适合从单机到分布式的各种部署需求。</li></ul></li></ol><h3 id="四、与传统关系型数据库的对比">四、与传统关系型数据库的对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Neo4j（图数据库）</strong></th><th><strong>关系型数据库</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>节点、关系、属性</td><td>表、行、列</td></tr><tr><td><strong>查询语言</strong></td><td>Cypher</td><td>SQL</td></tr><tr><td><strong>关系存储</strong></td><td>直接存储节点和关系</td><td>通过外键间接存储</td></tr><tr><td><strong>关系查询效率</strong></td><td>高效（基于指针）</td><td>相对较低（基于表连接）</td></tr><tr><td><strong>扩展性</strong></td><td>优秀，支持分布式图存储</td><td>通常需要复杂的分布式架构支持</td></tr><tr><td><strong>适用场景</strong></td><td>复杂连接查询（如社交网络分析）</td><td>面向事务处理的结构化数据管理</td></tr></tbody></table><h3 id="五、总结">五、总结</h3><p>Neo4j 是一种高效的图数据库，专注于存储和查询复杂连接数据，其底层基于原生图存储和高效的图遍历算法。无论是社交网络、推荐系统，还是知识图谱，Neo4j 都能提供直观的建模方法和高性能的查询能力，非常适合处理关系密集型数据。</p><h2 id="与GraphRAG结合">与GraphRAG结合</h2><p><strong>Neo4j</strong> 和 <strong>微软的 Graph RAG</strong>（Retrieval-Augmented Generation with Graphs）结合在一起，主要是通过将 Neo4j 提供的知识图谱功能与 RAG 的检索与生成流程集成，利用图数据库的高效关系查询能力增强 RAG 的性能。以下是它们结合的核心原理和流程：</p><h3 id="1-结合的动机">1. <strong>结合的动机</strong></h3><p>微软的 <strong>Graph RAG</strong> 是一种结合知识图谱的 RAG 方法，旨在通过知识图谱优化检索和生成的质量。Neo4j 提供了强大的图存储和查询能力，是 Graph RAG 的理想后端数据库。</p><p>结合的优势包括：</p><ul><li><strong>增强检索性能</strong>：Neo4j 能高效存储和查询复杂关系，支持从知识图谱中快速检索相关信息。</li><li><strong>支持复杂推理</strong>：通过知识图谱进行推理（如多跳推理），提升生成结果的准确性。</li><li><strong>实时更新和动态扩展</strong>：Neo4j 支持动态更新知识图谱，确保生成模型使用的是最新数据。</li></ul><h3 id="2-结合的工作流程">2. <strong>结合的工作流程</strong></h3><p>Neo4j 和 Graph RAG 的集成主要包括以下步骤：</p><h4 id="1-构建知识图谱"><strong>(1) 构建知识图谱</strong></h4><ul><li><p><strong>知识图谱的来源</strong>：</p><ul><li>通过数据预处理（如实体和关系抽取），从原始数据（如文档或数据库）中生成知识图谱。</li><li>这些知识被存储在 Neo4j 中，节点代表实体，边代表关系，属性包含附加信息。</li></ul></li><li><p><strong>存储到 Neo4j</strong>：</p><ul><li>使用 Cypher 查询语言或 Neo4j 提供的 API 将节点和关系存储到数据库中。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (a:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(b:Person &#123;name: &#x27;Bob&#x27;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-图谱增强的检索"><strong>(2) 图谱增强的检索</strong></h4><ul><li>在 Graph RAG 中，检索步骤会调用 Neo4j 来从知识图谱中查找相关信息。</li><li><strong>查询类型</strong>：<ul><li><strong>简单检索</strong>：基于实体或关系的直接匹配。例如，查找与特定实体相关的所有关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[r]-&gt;(other)</span><br><span class="line">RETURN r, other</span><br></pre></td></tr></table></figure></li><li><strong>多跳推理</strong>：查找多步关系链。例如，获取 Alice 的朋友的朋友：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS*2]-&gt;(friend_of_friend)</span><br><span class="line">RETURN friend_of_friend</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-生成阶段"><strong>(3) 生成阶段</strong></h4><ul><li>检索结果被格式化后传递给语言模型（LLM），作为生成上下文的一部分。</li><li>在生成阶段，Neo4j 的结构化信息可以作为事实验证的依据，增强生成的可靠性和相关性。</li></ul><h4 id="4-实时更新"><strong>(4) 实时更新</strong></h4><ul><li>Graph RAG 可以通过 Neo4j 动态更新知识图谱。例如，在新的数据被引入时，可以通过批量或实时更新将新知识存储到图谱中。</li></ul><h3 id="3-技术集成方式">3. <strong>技术集成方式</strong></h3><p>Neo4j 和 Graph RAG 的结合通过 API 或 SDK 实现，以下是常见的集成方法：</p><h4 id="1-Neo4j-驱动"><strong>(1) Neo4j 驱动</strong></h4><ul><li>使用 Neo4j 官方驱动（Python、Java、Node.js 等）与 Graph RAG 的后端交互。</li><li><strong>Python 示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> neo4j <span class="keyword">import</span> GraphDatabase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到 Neo4j 数据库</span></span><br><span class="line">driver = GraphDatabase.driver(<span class="string">&quot;bolt://localhost:7687&quot;</span>, auth=(<span class="string">&quot;neo4j&quot;</span>, <span class="string">&quot;password&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_related_entities</span>(<span class="params">tx, entity_name</span>):</span><br><span class="line">    query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    MATCH (e:Entity &#123;name: $name&#125;)-[:RELATED_TO]-&gt;(related)</span></span><br><span class="line"><span class="string">    RETURN related</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = tx.run(query, name=entity_name)</span><br><span class="line">    <span class="keyword">return</span> [record[<span class="string">&quot;related&quot;</span>] <span class="keyword">for</span> record <span class="keyword">in</span> result]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> driver.session() <span class="keyword">as</span> session:</span><br><span class="line">    related_entities = session.read_transaction(fetch_related_entities, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(related_entities)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-REST-API"><strong>(2) REST API</strong></h4><ul><li>如果 Neo4j 部署为服务，可以通过其 REST API 从 Graph RAG 后端发起 HTTP 请求获取数据。</li><li>示例请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:7474/db/data/transaction/commit \</span><br><span class="line">     -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">       &quot;statements&quot;: [</span></span><br><span class="line"><span class="string">         &#123;</span></span><br><span class="line"><span class="string">           &quot;statement&quot;: &quot;MATCH (n:Person &#123;name: &#x27;</span>Alice<span class="string">&#x27;&#125;) RETURN n&quot;</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">       ]</span></span><br><span class="line"><span class="string">     &#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Neo4j-LangChain"><strong>(3) Neo4j + LangChain</strong></h4><ul><li>LangChain 提供了与 Neo4j 集成的模块，允许直接在生成模型的工作流中调用 Neo4j 的图查询能力。</li><li>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.graphs <span class="keyword">import</span> Neo4jGraph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到 Neo4j</span></span><br><span class="line">graph = Neo4jGraph(url=<span class="string">&quot;bolt://localhost:7687&quot;</span>, username=<span class="string">&quot;neo4j&quot;</span>, password=<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询图数据库</span></span><br><span class="line">query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MATCH (a:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(b)</span></span><br><span class="line"><span class="string">RETURN b.name</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">result = graph.query(query)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-结合的优势">4. <strong>结合的优势</strong></h3><ol><li><strong>图结构优化检索</strong>：<ul><li>Neo4j 提供高效的图遍历算法，显著提高 RAG 系统的检索效率。</li></ul></li><li><strong>支持多跳推理</strong>：<ul><li>Graph RAG 可以通过 Neo4j 实现复杂的关系推理，例如多跳关系或路径查询。</li></ul></li><li><strong>增强生成质量</strong>：<ul><li>图数据库的结构化数据能够为 LLM 提供精准的上下文，减少生成内容中的幻觉现象。</li></ul></li><li><strong>动态知识更新</strong>：<ul><li>Neo4j 支持实时或批量更新图数据，确保 RAG 系统使用最新知识。</li></ul></li></ol><h3 id="5-应用场景">5. <strong>应用场景</strong></h3><ul><li><strong>知识图谱问答（Knowledge Graph QA）</strong>：基于图谱的精确问答。</li><li><strong>推荐系统</strong>：结合用户兴趣图谱推荐内容。</li><li><strong>事实验证（Fact Verification）</strong>：验证生成内容是否符合知识图谱的事实。</li><li><strong>多跳问答（Multi-Hop QA）</strong>：通过图谱实现复杂推理任务。</li></ul><h3 id="6-总结">6. <strong>总结</strong></h3><p>Neo4j 和微软的 Graph RAG 结合，通过 Neo4j 提供的高效图存储与查询能力，以及 Graph RAG 的检索增强生成架构，能够大幅提升生成质量和检索效率。这种结合适用于知识密集型任务，如知识图谱问答、复杂推理和实时数据更新场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Neo4j-图数据库简介&quot;&gt;Neo4j 图数据库简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Neo4j&lt;/strong&gt; 是一种基于 &lt;strong&gt;图模型&lt;/strong&gt; 的开源图数据库，专为存储和查询高度连接的数据而设计。与传统关系型数据库不同，Neo4j 的底层</summary>
      
    
    
    
    <category term="DataBase" scheme="https://kelinkong.github.io/categories/DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-编译相关</title>
    <link href="https://kelinkong.github.io/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    <id>https://kelinkong.github.io/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/</id>
    <published>2025-01-09T03:36:18.000Z</published>
    <updated>2025-07-17T10:45:37.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Jvm">Jvm</h2><h3 id="1-一次编写，处处运行（Write-Once-Run-Anywhere）">1. <strong>一次编写，处处运行（Write Once, Run Anywhere）</strong></h3><ul><li>Java 程序被编译成 <strong>字节码（<code>.class</code>）</strong>，不是平台相关的机器码。</li><li>字节码由 <strong>JVM 解释或编译执行</strong>，只要目标机器有 JVM，就能运行。</li><li>不需要为每个操作系统单独编译！</li></ul><p>举例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">你写了一个 HelloWorld.java</span><br><span class="line">→ 编译得到 HelloWorld.class</span><br><span class="line">→ Windows 装 JVM → 可以跑</span><br><span class="line">→ Linux 装 JVM → 也可以跑</span><br><span class="line">→ Mac 装 JVM → 继续跑</span><br></pre></td></tr></table></figure><h3 id="2-更强的安全性和隔离性">2. <strong>更强的安全性和隔离性</strong></h3><ul><li>Java 程序运行在 <strong>JVM 沙箱中</strong>，不会直接访问底层内存（不像 C++ 有指针）。</li><li>JVM 会做<strong>字节码校验、安全检查</strong>，减少恶意代码运行风险。</li></ul><h3 id="3-跨平台的标准化生态">3. <strong>跨平台的标准化生态</strong></h3><ul><li>JVM 提供统一的接口和行为定义，开发者不必关心 OS 差异。</li><li>Java 的生态（如 Spring、Hadoop、Spark）可以无缝运行在多种平台上。</li></ul><h3 id="4-JIT（即时编译）-GC（自动内存管理）">4. <strong>JIT（即时编译）+ GC（自动内存管理）</strong></h3><ul><li>JVM 运行时会监控热点代码，使用 JIT 将字节码编译为机器码，优化性能。</li><li>自动垃圾回收（GC）减轻了开发者的负担，减少内存泄漏风险。</li></ul><table><thead><tr><th>特性</th><th>Java JVM</th><th>C++ 编译器（g++/clang）</th></tr></thead><tbody><tr><td>编译方式</td><td>源码 → 字节码（跨平台中间码）</td><td>源码 → 机器码（平台绑定）</td></tr><tr><td>平台相关性</td><td>字节码不平台相关，但 JVM 是</td><td>编译结果是平台相关</td></tr><tr><td>编译时 vs 运行时</td><td>编译时平台无关，运行时需 JVM</td><td>编译时决定平台，运行时直接执行</td></tr></tbody></table><p>JVM 与 C++ 编译器最大不同是：</p><blockquote><p>JVM 将“平台相关性”推迟到运行时（由 JVM 屏蔽平台差异），而 C++ 是在编译时就决定目标平台。</p></blockquote><p>所以只需要：</p><ul><li>一次写 Java 程序 + 编译成 <code>.class</code></li><li>每个平台装对应的 JVM，就能<strong>不重编译地运行</strong></li></ul><p>但 C++：</p><ul><li>写完程序，如果要在不同平台运行，就要用不同的编译器重新编译成不同平台的机器码。</li></ul><p><strong>那 JVM 不就是额外多装一个运行环境？很麻烦？</strong></p><p>是的，这是它的“成本”。但：</p><ul><li>Java 项目往往是“部署一次、跑在任意云环境或服务器上”</li><li>JVM 可以预装在环境中，运行效率也越来越高（GraalVM、ZGC、JIT等）</li></ul><h2 id="Java的即时编译器">Java的即时编译器</h2><p>Java 的即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中的重要组成部分，它在程序运行时将 Java 字节码 (Bytecode) 转换为本地机器代码，从而提高程序运行效率。以下是关于 JIT 的详细科普：</p><h3 id="1-JIT-编译器的作用">1. <strong>JIT 编译器的作用</strong></h3><ul><li>Java 程序先被编译为字节码，这是一种中间代码，独立于底层硬件和操作系统。</li><li>JVM 通过<strong>解释器 (Interpreter)</strong> 将字节码逐行解释为机器代码执行，但逐行解释速度较慢。</li><li>为了优化性能，JVM 使用 JIT 将热代码段（执行频率高的代码）直接编译成机器码并缓存起来。之后再运行这些代码时，无需解释，直接执行机器码，极大提高了性能。</li></ul><h3 id="2-JIT-的工作原理">2. <strong>JIT 的工作原理</strong></h3><ol><li><strong>字节码加载</strong>：<ul><li>JVM 通过类加载器加载字节码到内存。</li></ul></li><li><strong>初始执行</strong>：<ul><li>字节码开始由解释器逐行解释执行。</li></ul></li><li><strong>热点代码检测</strong>：<ul><li>JIT 使用<strong>热点探测技术</strong>（如计数器）来识别频繁执行的代码（如循环体）。</li></ul></li><li><strong>即时编译</strong>：<ul><li>识别到热点代码后，JIT 将其编译为本地机器代码并优化执行。</li></ul></li><li><strong>缓存与复用</strong>：<ul><li>已编译的机器代码被缓存起来供后续直接使用。</li></ul></li></ol><h3 id="3-JIT-编译的优化技术">3. <strong>JIT 编译的优化技术</strong></h3><p>JIT 编译器除了简单地将字节码翻译为机器码，还会进行多种优化，如：</p><ul><li><strong>方法内联</strong>：将小方法的代码直接嵌入调用处，减少方法调用的开销。</li><li><strong>常量折叠</strong>：在编译时计算出常量表达式的结果。</li><li><strong>循环展开</strong>：减少循环中的控制逻辑，增加运行效率。</li><li><strong>消除冗余代码</strong>：去掉多余的、不必要的代码执行。</li><li><strong>逃逸分析</strong>：检测对象是否会逃出方法作用域，从而优化内存分配。</li></ul><h3 id="4-JIT-的类型">4. <strong>JIT 的类型</strong></h3><p>JVM 中的 JIT 编译器主要分为以下几种：</p><ol><li><strong>C1（Client Compiler）</strong>：<ul><li>针对客户端应用优化，启动速度快。</li><li>适用于需要快速响应的程序。</li></ul></li><li><strong>C2（Server Compiler）</strong>：<ul><li>针对服务器端应用优化，执行速度更快。</li><li>适用于长时间运行、对性能要求高的程序。</li></ul></li><li><strong>Graal JIT</strong>：<ul><li>新一代 JIT 编译器，基于 Java 实现，优化更为激进。</li><li>提供更好的性能和可扩展性。</li></ul></li></ol><h3 id="5-JIT-的优缺点">5. <strong>JIT 的优缺点</strong></h3><h4 id="优点：">优点：</h4><ul><li><strong>高性能</strong>：将热点代码编译为本地机器码，大幅提升执行效率。</li><li><strong>动态优化</strong>：根据运行时的实际情况进行优化（如分支预测、内存管理）。</li><li><strong>跨平台性</strong>：结合字节码和本地机器码，既实现跨平台，又提升性能。</li></ul><h4 id="缺点：">缺点：</h4><ul><li><strong>启动延迟</strong>：JIT 编译需要时间，可能导致程序启动较慢。</li><li><strong>内存占用</strong>：缓存的机器码会占用额外的内存。</li></ul><h3 id="6-JIT-和-AOT（Ahead-Of-Time）-编译的对比">6. <strong>JIT 和 AOT（Ahead-Of-Time） 编译的对比</strong></h3><table><thead><tr><th>特性</th><th>JIT 编译</th><th>AOT 编译</th></tr></thead><tbody><tr><td>编译时间</td><td>运行时动态编译</td><td>编译前静态完成</td></tr><tr><td>性能优化</td><td>基于运行时动态信息进行优化</td><td>基于编译时静态信息优化</td></tr><tr><td>启动速度</td><td>启动较慢，需等待编译完成</td><td>启动较快</td></tr><tr><td>可移植性</td><td>字节码跨平台，动态编译本地代码</td><td>编译后的本地代码与平台绑定</td></tr></tbody></table><h3 id="7-如何调整-JIT-设置">7. <strong>如何调整 JIT 设置</strong></h3><p>JVM 提供了一些参数用于调整 JIT 的行为：</p><ul><li><code>-Xint</code>：强制 JVM 只使用解释模式，禁用 JIT（通常用于调试）。</li><li><code>-Xcomp</code>：强制 JVM 编译所有代码（可能导致启动变慢）。</li><li><code>-Xmixed</code>：默认模式，解释与编译结合使用。</li></ul><h3 id="8-常见问题">8. <strong>常见问题</strong></h3><ul><li><strong>为什么程序启动时较慢？</strong><ul><li>因为 JIT 需要对热点代码进行编译，初期可能依赖解释器运行。</li></ul></li><li><strong>JIT 编译会带来性能下降吗？</strong><ul><li>在某些情况下（如频繁的代码编译或不适当的优化策略），可能会出现<strong>编译抖动</strong>（过多的编译开销）。</li></ul></li></ul><h2 id="AOT-编译">AOT 编译</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><h3 id="1-AOT-编译的基本概念">1. <strong>AOT 编译的基本概念</strong></h3><p>AOT 编译将源代码或中间代码（如 Java 字节码）编译为目标平台的机器代码，生成一个独立的、可以直接运行的本地二进制文件。编译后的程序无需依赖运行时解释器，直接运行在目标硬件上。</p><h3 id="2-AOT-编译的工作流程">2. <strong>AOT 编译的工作流程</strong></h3><ol><li><strong>源代码编写</strong>：<ul><li>开发者使用高级编程语言（如 Java、C#）。</li></ul></li><li><strong>编译为中间代码</strong>：<ul><li>像 Java 这样的语言通常会先编译为字节码（例如 <code>.class</code> 文件）。</li></ul></li><li><strong>AOT 编译</strong>：<ul><li>AOT 编译器（如 GraalVM 的 AOT 工具）将字节码转换为本地机器代码。</li></ul></li><li><strong>生成可执行文件</strong>：<ul><li>输出结果是一个可以直接运行的二进制文件，无需额外的运行时编译步骤。</li></ul></li></ol><h3 id="3-AOT-编译的优点">3. <strong>AOT 编译的优点</strong></h3><h4 id="1-启动速度快">(1) <strong>启动速度快</strong></h4><ul><li>编译在运行前完成，程序启动时不需要动态解释或即时编译，因此启动速度显著提高。</li></ul><h4 id="2-优化性能">(2) <strong>优化性能</strong></h4><ul><li>AOT 编译可以提前执行许多优化步骤，比如方法内联、循环优化和消除冗余代码。</li><li>特别适合对启动时间敏感的应用程序，比如微服务或 CLI 工具。</li></ul><h4 id="3-内存占用低">(3) <strong>内存占用低</strong></h4><ul><li>不需要运行时 JIT 编译缓存，因此内存占用更低。</li><li>适合内存受限的环境，如嵌入式设备和移动应用。</li></ul><h4 id="4-跨语言整合">(4) <strong>跨语言整合</strong></h4><ul><li>AOT 编译可以方便地将不同语言编写的模块编译成统一的本地代码，便于跨语言调用。</li></ul><h4 id="5-更容易分发">(5) <strong>更容易分发</strong></h4><ul><li>生成的可执行文件独立于编译器或运行时环境，可以轻松分发和部署。</li></ul><h3 id="4-AOT-编译的缺点">4. <strong>AOT 编译的缺点</strong></h3><h4 id="1-灵活性不足">(1) <strong>灵活性不足</strong></h4><ul><li>AOT 编译缺乏运行时动态优化的能力，无法基于实际运行情况调整性能。</li><li>某些优化（如分支预测、逃逸分析）需要运行时信息，AOT 无法完成。</li></ul><h4 id="2-编译时间长">(2) <strong>编译时间长</strong></h4><ul><li>编译过程通常比 JIT 更复杂，生成本地代码需要更多时间和资源。</li></ul><h4 id="3-平台绑定">(3) <strong>平台绑定</strong></h4><ul><li>AOT 编译生成的可执行文件与目标平台紧密绑定，跨平台能力不如字节码+JVM 的方案。</li></ul><h4 id="4-文件体积大">(4) <strong>文件体积大</strong></h4><ul><li>AOT 编译后的可执行文件可能包含额外的运行时支持代码，文件体积较大。</li></ul><h3 id="5-AOT-编译的应用场景">5. <strong>AOT 编译的应用场景</strong></h3><p>AOT 编译在以下场景中特别有用：</p><ol><li><strong>启动速度敏感的应用</strong>：<ul><li>微服务、命令行工具、图形用户界面（GUI）程序等需要快速启动的应用。</li></ul></li><li><strong>资源受限设备</strong>：<ul><li>嵌入式系统、物联网设备和移动设备等内存有限的平台。</li></ul></li><li><strong>无运行时环境的环境</strong>：<ul><li>部署时无法安装完整的虚拟机或运行时（如 JVM）的场景。</li></ul></li><li><strong>安全性要求高的应用</strong>：<ul><li>直接编译为本地代码可以减少对运行时的依赖，降低潜在的安全风险。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Jvm&quot;&gt;Jvm&lt;/h2&gt;
&lt;h3 id=&quot;1-一次编写，处处运行（Write-Once-Run-Anywhere）&quot;&gt;1. &lt;strong&gt;一次编写，处处运行（Write Once, Run Anywhere）&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ja</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-动手学深度学习-笔记</title>
    <link href="https://kelinkong.github.io/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-27T01:37:50.000Z</published>
    <updated>2024-12-31T02:23:47.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="张量">张量</h2><p>当张量的形状为 <code>(3, 4, 4)</code> 时，可以将其理解为一个 <strong>包含多个层的神经网络模型</strong>。让我们用 <strong>特征和权重</strong> 来比喻：</p><h3 id="比喻解释">比喻解释</h3><p>假设你有一个神经网络模型，输入层有 4 个特征（即 4 个特征值），并且你有 4 个权重值用于每个特征的计算。</p><ul><li><strong>3</strong>：表示神经网络中有 <strong>3 个不同的层</strong>（例如 3 个不同的神经网络中的权重矩阵）。</li><li><strong>4</strong>：每个层的 <strong>输入特征有 4 个</strong>（例如每一层有 4 个特征或神经元）。</li><li><strong>4</strong>：每个层的 <strong>每个特征有 4 个权重值</strong>（即每个特征都被 4 个不同的权重处理，或者每个神经元的连接数是 4）。</li></ul><h3 id="举个例子">举个例子</h3><p>假设你有一个多层感知机（MLP）神经网络模型，其中每一层的输入和输出都是 4 维的向量，而每一层的每个神经元的权重是一个 4 维的向量。张量的形状 <code>(3, 4, 4)</code> 就可以表示：</p><ul><li>第一维 <code>3</code> 代表神经网络中有 3 层（或 3 个不同的权重矩阵）。</li><li>第二维和第三维 <code>4</code> 代表每个矩阵（层）的大小是 4x4，这意味着每一层有 4 个输入特征，并且每个特征有 4 个对应的权重。</li></ul><h3 id="具体举例">具体举例</h3><p>假设你有以下模型：</p><ol><li><strong>层 1</strong>：输入是 4 个特征，输出是 4 个神经元。每个神经元有 4 个权重，意味着每个神经元的计算有 4 个权重与输入特征进行相乘。</li><li><strong>层 2</strong>：同样，输入是 4 个特征，输出也是 4 个神经元，每个神经元有 4 个权重。</li><li><strong>层 3</strong>：依然是 4 个输入特征，4 个神经元和 4 个权重。</li></ol><p>这样，总共有 3 个层，每层都有一个 4x4 的权重矩阵，表示每个特征在该层中如何与其他特征结合形成输出。</p><h3 id="代码示例">代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设这是一个 3 层的神经网络，每层有 4 个输入特征，4 个权重</span></span><br><span class="line">weights = torch.tensor([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]],</span><br><span class="line">                       [[<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>], [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>], [<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>], [<span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>]],</span><br><span class="line">                       [[<span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>], [<span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>], [<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>], [<span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(weights.shape)  <span class="comment"># 输出: torch.Size([3, 4, 4])</span></span><br></pre></td></tr></table></figure><h3 id="解释">解释</h3><ul><li>第一维 <code>3</code> 表示你有 <strong>3 个层</strong>，每层有一个 4x4 的权重矩阵。</li><li>第二维和第三维的 <code>4</code> 表示每个层的每个神经元的计算中使用了 4 个权重，每个权重都与输入特征相乘。</li></ul><h2 id="正则化">正则化</h2><p>正则化（Regularization）是机器学习中用来<strong>防止模型过拟合</strong>的一种技术。过拟合是指模型在训练数据上表现很好，但在新数据（测试数据）上表现差，通常是因为模型太复杂，学习到了数据中的噪音或不重要的细节。</p><h3 id="1-过拟合的原因">1. <strong>过拟合的原因</strong></h3><ul><li>模型在训练时过于“记住”了训练数据中的细节，而不是学到泛化规律（即如何处理新数据）。</li><li>复杂的模型（比如有很多参数）更容易过拟合。</li></ul><h3 id="2-正则化的目的">2. <strong>正则化的目的</strong></h3><p>正则化的目标是通过限制模型的复杂度，避免模型对训练数据的过度拟合。它通过给模型加上一些额外的约束，使得模型在学习时不能“随意”地调整参数，而是保持适度的简单性。</p><h3 id="3-如何实现正则化？">3. <strong>如何实现正则化？</strong></h3><p>正则化通常通过在损失函数中加入一个额外的项来实现，这个项通常与模型的<strong>权重</strong>（参数）大小有关。常见的正则化方法有两种：</p><h4 id="1-L1-正则化（Lasso）">(1) <strong>L1 正则化（Lasso）</strong></h4><ul><li>L1 正则化在损失函数中加入一个与<strong>权重的绝对值之和</strong>成比例的项。</li><li>它的作用是“惩罚”大权重，迫使模型学习到的特征更加简洁。</li><li><strong>L1 正则化的效果</strong>：它可以将某些权重变为零，相当于<strong>自动选择特征</strong>。</li></ul><p>公式：<br>$$<br>\text{L1 正则化} = \lambda \sum_{i=1}^{n} |w_i|<br>$$</p><ul><li>其中，$w_i$ 是模型的权重，$\lambda$ 是正则化的强度（越大，惩罚越强）。</li></ul><h4 id="2-L2-正则化（Ridge）">(2) <strong>L2 正则化（Ridge）</strong></h4><ul><li>L2 正则化在损失函数中加入一个与<strong>权重的平方和</strong>成比例的项。</li><li>它的作用是<strong>惩罚大权重</strong>，但不像 L1 那样将权重变为零，而是让权重变得更小，防止某些特征对模型的影响过大。</li><li><strong>L2 正则化的效果</strong>：它可以平滑模型，使模型更加稳健。</li></ul><p>公式：<br>$$<br>\text{L2 正则化} = \lambda \sum_{i=1}^{n} w_i^2<br>$$</p><h3 id="4-如何理解正则化？">4. <strong>如何理解正则化？</strong></h3><p><strong>举个简单的例子</strong>：<br>假设你在做一个学生的成绩预测模型，输入特征有 <strong>学习时间、上课出勤率、平时作业分数</strong> 等。如果模型过于复杂，可能会学习到一些不重要的特征，比如学生每天吃的零食种类。这样，模型会在训练集上表现很好，但在实际使用时可能表现差，因为这些不重要的特征对新数据没有帮助。</p><p>通过正则化，你给模型添加了一些<strong>惩罚</strong>，强迫它只关注重要的特征，并避免关注那些噪音和不重要的细节。这样，模型会学到更有用的规律，泛化能力更强。</p><h3 id="5-正则化的效果">5. <strong>正则化的效果</strong></h3><ul><li><strong>减少过拟合</strong>：通过限制模型复杂度，使得模型不仅能在训练数据上表现好，也能在新数据上表现好。</li><li><strong>提升模型的泛化能力</strong>：正则化可以帮助模型学到更为通用的规律，而不是记住训练数据中的细节。</li></ul><h2 id="如何理解L1-L2正则化？">如何理解L1/L2正则化？</h2><p>好的，我们再深入一点，详细计算一下 L1 正则化是如何惩罚权重的，以及它如何引导模型减少不重要特征的影响。</p><h3 id="假设情境">假设情境</h3><p>我们使用一个非常简单的线性回归模型，有 <strong>2 个特征</strong>$x_1$ 和$x_2$，目标是预测 <strong>y</strong>。模型的公式为：<br>$$<br>y = w_1 x_1 + w_2 x_2 + b<br>$$<br>其中：</p><ul><li>$w_1$ 和 $w_2$ 是特征 $x_1$ 和 $x_2$ 的权重。</li><li>$b$ 是偏置项（在这里我们忽略不讨论）。</li></ul><p>我们要最小化的是<strong>总损失</strong>，即：<br>$$<br>\text{总损失} = \text{MSE（均方误差）} + \text{L1 正则化损失}<br>$$<br>均方误差（MSE）用来衡量模型预测值与实际值之间的误差，而 L1 正则化损失用来惩罚权重，使它们尽可能小。</p><h3 id="1-没有正则化的情况">1. <strong>没有正则化的情况</strong></h3><p>假设我们没有正则化，只有 MSE 损失。对于一个简单的回归模型，损失函数可以表示为：<br>$$<br>\text{MSE} = \frac{1}{N} \sum_{i=1}^{N} (y_{\text{预测}, i} - y_{\text{实际}, i})^2<br>$$<br>其中，$y_{\text{预测}, i} = w_1 x_{1,i} + w_2 x_{2,i} + b$，是模型的预测值。</p><p>在没有正则化的情况下，模型的目标是尽量减小 MSE，但它不考虑特征权重的大小，可能会导致模型过度依赖某些特征。</p><h3 id="2-加入-L1-正则化">2. <strong>加入 L1 正则化</strong></h3><p>L1 正则化在损失函数中加入了对权重的惩罚项。对于每个权重，惩罚项是它的绝对值。损失函数现在变成了：<br>$$<br>\text{总损失} = \text{MSE} + \lambda \left( |w_1| + |w_2| \right)<br>$$<br>其中，$\lambda$ 是正则化系数，控制惩罚项的强度。如果 $\lambda$ 很大，惩罚就会更强，权重会被压缩得更小。</p><h3 id="3-例子：权重调整过程">3. <strong>例子：权重调整过程</strong></h3><p>假设我们训练了模型，得到了初始的权重：</p><ul><li>$w_1 = 5$</li><li>$w_2 = 0.1$</li><li>正则化系数 $\lambda = 0.1$</li></ul><p>我们还假设 MSE 损失部分的计算结果为 50（为了简化计算，不考虑具体的样本数据）。</p><h4 id="步骤-1：计算正则化损失">步骤 1：计算正则化损失</h4><p>L1 正则化损失是：<br>$$<br>\text{L1 正则化损失} = \lambda \left( |w_1| + |w_2| \right)<br>$$<br>代入权重值：<br>$$<br>\text{L1 正则化损失} = 0.1 \times (|5| + |0.1|) = 0.1 \times (5 + 0.1) = 0.1 \times 5.1 = 0.51<br>$$</p><h4 id="步骤-2：总损失">步骤 2：总损失</h4><p>现在，模型的总损失是：<br>$$<br>\text{总损失} = \text{MSE} + \text{L1 正则化损失}<br>$$<br>$$<br>\text{总损失} = 50 + 0.51 = 50.51<br>$$<br>所以，在这种情况下，L1 正则化的惩罚项增加了总损失。</p><h4 id="步骤-3：权重更新（梯度下降）">步骤 3：权重更新（梯度下降）</h4><p>模型通过梯度下降来最小化总损失。在梯度下降过程中，L1 正则化的惩罚项会影响梯度的计算，使得权重的更新不仅考虑误差，还考虑惩罚项。</p><p>在每次更新过程中，L1 正则化对每个权重的影响如下：</p><ul><li>对于 $w_1$，L1 正则化会迫使它变小。因为 $|w_1| = 5$，所以它的梯度下降会考虑惩罚项。</li><li>对于 $w_2$，L1 正则化会更加显著地影响它。由于 $|w_2| = 0.1$，惩罚项在 $w_2$ 上的效果更明显，权重会逐步变小。</li></ul><p><strong>因为较大的权重已经对模型的预测结果产生较大的影响，L1 正则化的惩罚项只是对这个权重施加一个适度的惩罚，导致它会被逐渐减小，但不至于过多压缩。较小的权重这是因为它本身的绝对值较小，正则化的惩罚就会占据更大的比重，迫使它迅速变小甚至归零。</strong>（模型总是在选择使得损失函数变小的参数）</p><h4 id="步骤-4：逐步更新">步骤 4：逐步更新</h4><p>假设我们计算出了梯度，并在一次更新后得到以下新的权重（梯度下降步长为 0.1）：</p><ul><li>$ w_1 = 4.8$</li><li>$w_2 = 0.05$</li></ul><p>这个更新过程说明了，<strong>L1 正则化会推动较小的权重变得更小</strong>，并让它们趋向于零。</p><h3 id="4-最终权重的变化">4. <strong>最终权重的变化</strong></h3><p>继续进行多次更新，L1 正则化会导致 $w_2$（那个较小的权重）逐渐减少，甚至变为零。假设经过足够多的训练步骤，最后我们得到：</p><ul><li>$w_1  = 4.5$</li><li>$w_2 = 0$</li></ul><p>此时，<strong>L1 正则化已经将不重要的特征（即 $w_2$）的权重压缩为零</strong>，表明模型已经“去除了”不重要的特征。</p><h2 id="自注意力机制">自注意力机制</h2><h3 id="自注意力机制-Self-Attention-Mechanism">自注意力机制 (Self-Attention Mechanism)</h3><p>自注意力机制是 Transformer 模型的核心，它帮助模型捕捉输入序列中不同位置之间的依赖关系。它的目的是使每个输入元素（例如一个词）能够与其他输入元素进行交互，从而更好地理解上下文信息。自注意力机制比传统的循环神经网络（RNN）和卷积神经网络（CNN）更强大，因为它能够同时考虑整个序列的信息，而不需要按顺序逐一处理。</p><h4 id="核心概念">核心概念</h4><ol><li><p><strong>输入表示</strong>：自注意力机制首先接收一个输入序列。对于文本输入，通常每个词被嵌入成一个向量，形成一个矩阵。</p></li><li><p><strong>查询（Query）、键（Key）和值（Value）</strong>：</p><ul><li><strong>查询（Q）</strong>：每个输入词（或词向量）都会映射为一个查询向量，用来与其他词进行“匹配”。</li><li><strong>键（K）</strong>：每个输入词也会映射为一个键向量，查询会与这些键进行匹配，以确定其相关性。</li><li><strong>值（V）</strong>：每个输入词也会有一个值向量，最终输出是基于查询和键的匹配得分加权得到的值向量的加权和。</li></ul></li><li><p><strong>计算注意力得分</strong>：<br>自注意力机制通过计算每个查询向量与所有键向量之间的相似度（通常使用点积）。相似度得分越高，表示查询和键之间的关联越强。通常，通过Softmax对得分进行归一化，得到注意力权重。</p><p>$$<br>\text{Attention Score} = Q \cdot K^T<br>$$<br>然后，使用 Softmax 函数将这些得分转化为概率，确保权重总和为1：</p><p>$$<br>\text{Attention Weight} = \text{Softmax}(Q \cdot K^T)<br>$$</p></li><li><p><strong>加权求和值</strong>：<br>通过对每个值（V）向量加权求和，生成最终的输出。具体来说，注意力权重会决定各个值向量在最终输出中的贡献。</p><p>$$<br>\text{Output} = \sum (\text{Attention Weight}_i \cdot V_i)<br>$$</p></li><li><p><strong>多头注意力</strong>：<br>Transformer 使用多头注意力机制，意味着查询、键和值向量会被拆分成多个子空间，分别计算注意力。这允许模型在不同的子空间中关注输入的不同方面。</p><p>最后，多个头的结果会被拼接起来，并通过一个线性层进行变换。</p></li></ol><h4 id="自注意力机制的作用">自注意力机制的作用</h4><ul><li><strong>捕获长距离依赖</strong>：传统的 RNN 和 CNN 主要通过局部邻域来获取信息，而自注意力机制可以通过计算所有词的相关性，捕获长距离依赖。</li><li><strong>并行处理</strong>：由于不依赖于序列的顺序，自注意力机制允许模型对输入进行并行处理，效率更高。</li><li><strong>灵活性</strong>：每个位置根据上下文信息调整其关注的焦点。</li></ul><h3 id="Transformer-中的自注意力层">Transformer 中的自注意力层</h3><p>Transformer 模型完全基于自注意力机制，它使用了多个自注意力层来处理序列数据。Transformer 模型中最重要的组件是 <strong>自注意力层</strong>（Self-Attention Layer）和 <strong>前馈神经网络</strong>（Feed-Forward Neural Networks）。我们来深入探讨自注意力层的工作原理。</p><h4 id="Transformer-模型架构">Transformer 模型架构</h4><p>Transformer 模型由多个堆叠的编码器（Encoder）和解码器（Decoder）组成。在每个编码器和解码器中，自注意力层都起着关键作用。</p><ol><li><p><strong>编码器（Encoder）</strong>：<br>每个编码器层有两个主要部分：</p><ul><li><strong>自注意力机制</strong>：编码器的每一层都包括一个自注意力层，它允许输入序列中的每个位置根据全局上下文来调整其表示。</li><li><strong>前馈神经网络</strong>：每个编码器还包含一个小型的前馈神经网络（Feed-Forward Neural Network），它通过线性变换和激活函数进一步处理输入。</li></ul></li><li><p><strong>解码器（Decoder）</strong>：<br>解码器的结构与编码器相似，但它在自注意力机制中加入了“遮蔽”（Masked）机制，以确保解码时每个位置仅能看到当前位置及之前的输入。此外，解码器中的每个自注意力层还会与编码器的输出交互，获取全局信息。</p></li></ol><h4 id="自注意力层的具体实现">自注意力层的具体实现</h4><p>自注意力层包括以下几个步骤：</p><ol><li><p><strong>输入嵌入和位置编码</strong>：<br>输入的每个词首先通过嵌入（embedding）层转换为向量，并加上位置编码，以捕捉序列的顺序信息。</p></li><li><p><strong>查询、键和值</strong>：<br>将输入的嵌入向量通过线性变换生成查询（Q）、键（K）和值（V）向量。</p></li><li><p><strong>计算注意力</strong>：<br>计算每个查询和所有键的点积，得到注意力分数，并通过 Softmax 得到归一化的权重。</p></li><li><p><strong>加权求和</strong>：<br>使用这些权重对值（V）向量加权求和，得到每个位置的加权表示。</p></li><li><p><strong>输出</strong>：<br>最后的输出通过多头注意力机制合并多个头的结果，然后通过一个线性层进行变换。</p></li></ol><h4 id="自注意力层的公式">自注意力层的公式</h4><p>假设我们有一个输入序列 $X = [x_1, x_2, \dots, x_n]$，每个 $x_i$ 是一个词的嵌入向量。通过训练，我们学习到查询（Q）、键（K）和值（V）矩阵，分别将输入映射为 $Q = XW_Q$、$K = XW_K$、$V = XW_V$。</p><ol><li><strong>计算注意力得分</strong>：</li></ol><p>$$<br>\text{Attention Score}(Q, K) = \frac{QK^T}{\sqrt{d_k}}<br>$$</p><ol start="2"><li><strong>归一化注意力得分</strong>：</li></ol><p>$$<br>\text{Attention Weight} = \text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)<br>$$</p><ol start="3"><li><strong>加权求和</strong>：</li></ol><p>$$<br>\text{Output} = \text{Attention Weight} \cdot V<br>$$</p><h2 id="多头注意力机制">多头注意力机制</h2><p>在 Transformer 中的 <strong>多头注意力</strong>（Multi-Head Attention）机制中，“拼接”（concatenation）指的是将多个注意力头的输出连接起来，以便能够捕获输入序列的更多信息。接下来，拼接后的结果会经过一个线性变换来得到最终的输出。</p><h3 id="多头注意力机制的步骤">多头注意力机制的步骤</h3><ol><li><p><strong>计算多个注意力头</strong>：<br>在多头注意力中，首先将输入的查询（Query）、键（Key）和值（Value）通过不同的线性变换分别映射到多个子空间，形成多个不同的查询、键和值的集合。每个头（head）对应于不同的查询、键、值子空间。</p><p>假设总的嵌入维度是 $C$，而有 $h$ 个注意力头。那么，每个注意力头的维度为 $A = \frac{C}{h}$，即每个头的维度是总维度 $C$ 除以头的数量 $h$。</p></li><li><p><strong>每个注意力头的计算</strong>：<br>对于每个注意力头，都会计算一个独立的自注意力输出。具体的计算过程如下：</p><ul><li>对每个头，使用自己的查询、键和值计算注意力得分并进行加权求和，得到该头的输出。</li></ul></li><li><p><strong>拼接所有头的输出</strong>：<br>每个头的输出维度是 $A$，所以如果有 $h$ 个头，那么拼接后的输出将是一个维度为 $h \times A = C$ 的向量。也就是说，拼接后的结果恢复了原始的输入维度 $C$。</p><p>这个拼接的过程非常简单，就是将每个头的输出按顺序连接在一起，得到一个大向量。</p></li><li><p><strong>线性变换</strong>：<br>将拼接后的多头注意力输出通过一个线性层（即一个权重矩阵）进行变换，得到最终的输出。</p></li></ol><h3 id="举个例子-2">举个例子</h3><p>假设输入的维度为 $C = 8$，有 $h = 2$ 个注意力头（即每个头的维度 $A = 4$）。我们来看看这个过程如何进行：</p><ol><li><p><strong>输入和映射</strong>：<br>输入是一个长度为 8 的向量，经过线性变换后，我们会得到两个查询（Query）、键（Key）和值（Value）的子空间，每个子空间的维度是 4。</p></li><li><p><strong>计算每个头的输出</strong>：<br>对于每个头（总共有 2 个头），计算它们的注意力输出（每个头的输出维度为 4）。</p><ul><li>头 1 的输出是一个 4 维向量。</li><li>头 2 的输出是另一个 4 维向量。</li></ul></li><li><p><strong>拼接</strong>：<br>将这两个头的输出拼接起来，得到一个 8 维的向量：</p><p>$$<br>\text{Concatenated Output} = [\text{Head 1 Output}, \text{Head 2 Output}]<br>$$</p><p>这就是拼接的过程。最终拼接结果的维度是 $C = 8$。</p></li><li><p><strong>线性变换</strong>：<br>将拼接后的输出通过一个线性变换，得到最终的多头注意力层输出。</p></li></ol><h3 id="总结">总结</h3><ul><li>多头注意力的拼接步骤其实是将每个注意力头计算出的输出向量沿着维度方向拼接起来，得到一个较大的向量。</li><li>这种拼接允许模型在不同的子空间中“并行”地学习不同类型的特征，而不是仅仅依赖于一个单一的注意力头。</li><li>最后，通过线性变换将拼接后的输出映射回原始维度 $C$，为后续的网络层提供输入。</li></ul><p>这个过程使得 Transformer 模型能够从多个角度和不同的子空间捕获序列中的信息，从而提高模型的表达能力。</p><h2 id="传统神经网络的输入和transform中的输入">传统神经网络的输入和transform中的输入</h2><h3 id="1-传统神经网络中的输入">1. <strong>传统神经网络中的输入</strong></h3><p>在传统的神经网络（如前馈神经网络）中，输入通常是一个固定维度的向量或矩阵，具体内容取决于任务类型：</p><ul><li><p><strong>结构化数据</strong>：<br>输入是一个包含多种特征的向量。例如，在房价预测中，输入可能是房屋面积、房间数量等数值型特征。</p></li><li><p><strong>图像数据</strong>：<br>输入是二维或三维矩阵。例如，在图像分类任务中，输入是像素值组成的矩阵，可能还有 RGB 通道。</p></li><li><p><strong>文本数据</strong>：<br>输入通常是经过嵌入的向量，例如词嵌入（word embedding）或句子嵌入。</p></li></ul><h4 id="特点：">特点：</h4><ul><li>输入是独立的，每个样本的输入没有显式的上下文关联。</li><li>输入的维度固定。</li><li>输入数据需要提前提取和处理为数值形式。</li></ul><hr><h3 id="2-Transformer-编码器中的前馈神经网络输入">2. <strong>Transformer 编码器中的前馈神经网络输入</strong></h3><p>在 Transformer 的编码器中，前馈神经网络（Feed-Forward Neural Network, FFN）的输入是 <strong>注意力层的输出</strong>，它是上下文相关的特征表示。以下是输入的主要特点：</p><ul><li><p><strong>来源</strong>：<br>输入是经过自注意力层处理后的输出，每个词（或序列位置）的表示已经包含了与其他词的上下文依赖关系。</p></li><li><p><strong>形状</strong>：<br>输入是一个三维张量，形状为 $[batch_size, sequence_length, embedding_dim]$。</p><ul><li><code>batch_size</code>：批量大小。</li><li><code>sequence_length</code>：序列的长度（例如一个句子中的词数）。</li><li><code>embedding_dim</code>：每个词的嵌入向量的维度。</li></ul></li><li><p><strong>内容</strong>：<br>每个位置的表示已经结合了该位置与其他位置之间的注意力权重（即上下文信息），所以它是 <strong>上下文相关的表示</strong>。</p></li></ul><h4 id="特点：-2">特点：</h4><ul><li>输入包含上下文依赖信息。</li><li>输入维度与嵌入维度一致，但输入每个位置的值已经经过注意力机制的加权。</li><li>输入可以表示整个序列的信息，而不是单个独立样本。</li></ul><hr><h3 id="3-传统神经网络输入与-Transformer-编码器中-FFN-输入的区别">3. <strong>传统神经网络输入与 Transformer 编码器中 FFN 输入的区别</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>传统神经网络的输入</strong></th><th><strong>Transformer 编码器中的 FFN 输入</strong></th></tr></thead><tbody><tr><td><strong>上下文依赖</strong></td><td>输入数据通常是独立的，每个样本相互无关。</td><td>输入每个位置的表示包含上下文相关信息。</td></tr><tr><td><strong>输入形状</strong></td><td>向量或矩阵，具体形状依赖任务。</td><td>三维张量，形状为 ([batch_size, sequence_length, embedding_dim])。</td></tr><tr><td><strong>维度</strong></td><td>固定的输入特征维度。</td><td>嵌入维度通常与序列的长度和批量大小相关联。</td></tr><tr><td><strong>表示方式</strong></td><td>特征通常是直接提取的原始数据特征。</td><td>输入是经过嵌入层和自注意力层处理的特征表示。</td></tr><tr><td><strong>上下文信息</strong></td><td>特征是独立的，不包含其他样本的信息。</td><td>特征表示已经包含序列中其他位置的相关性。</td></tr></tbody></table><hr><h3 id="4-总结">4. <strong>总结</strong></h3><ul><li><strong>传统神经网络</strong>：输入是独立的特征向量，通常没有上下文信息。网络依赖于层间权重来建模数据之间的关系。</li><li><strong>Transformer 编码器中的前馈神经网络</strong>：输入是注意力层输出的上下文相关表示，已经包含序列中各位置之间的依赖关系。FFN 的作用是在每个位置上进一步非线性地变换这些上下文相关的特征。</li></ul><p>这种区别使得 Transformer 特别适合处理序列数据，例如自然语言处理和时间序列建模，因为其输入已经通过自注意力层捕获了序列的全局信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;张量&quot;&gt;张量&lt;/h2&gt;
&lt;p&gt;当张量的形状为 &lt;code&gt;(3, 4, 4)&lt;/code&gt; 时，可以将其理解为一个 &lt;strong&gt;包含多个层的神经网络模型&lt;/strong&gt;。让我们用 &lt;strong&gt;特征和权重&lt;/strong&gt; 来比喻：&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-基于transformers的自然语言处理(NLP)入门</title>
    <link href="https://kelinkong.github.io/2024/12/24/AI-%E5%9F%BA%E4%BA%8Etransformers%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP-%E5%85%A5%E9%97%A8/"/>
    <id>https://kelinkong.github.io/2024/12/24/AI-%E5%9F%BA%E4%BA%8Etransformers%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP-%E5%85%A5%E9%97%A8/</id>
    <published>2024-12-24T00:55:44.000Z</published>
    <updated>2024-12-26T08:20:27.703Z</updated>
    
    <content type="html"><![CDATA[<p>教程地址：<a href="https://github.com/datawhalechina/learn-nlp-with-transformers">基于transformers的自然语言处理(NLP)入门</a></p><h2 id="常见的NLP任务">常见的NLP任务</h2><ul><li>文本分类：对单个、两个或者多段文本进行分类。举例：“这个教程真棒！”这段文本的情感倾向是正向的，“我在学习transformer”和“如何学习transformer”这两段文本是相似的。</li><li>序列标注：对文本序列中的token、字或者词进行分类。举例：“我在国家图书馆学transformer。”这段文本中的国家图书馆是一个地点，可以被标注出来方便机器对文本的理解。</li><li>问答任务——抽取式问答和多选问答：1、抽取式问答根据问题从一段给定的文本中找到答案，答案必须是给定文本的一小段文字。举例：问题“小学要读多久?”和一段文本“小学教育一般是六年制。”，则答案是“六年”。2、多选式问答，从多个选项中选出一个正确答案。举例：“以下哪个模型结构在问答中效果最好？“和4个选项”A、MLP，B、cnn，C、lstm，D、transformer“，则答案选项是D。</li><li>生成任务——语言模型、机器翻译和摘要生成：根据已有的一段文字生成（generate）一个字通常叫做语言模型，根据一大段文字生成一小段总结性文字通常叫做摘要生成，将源语言比如中文句子翻译成目标语言比如英语通常叫做机器翻译。</li></ul><h2 id="seq2seq框架">seq2seq框架</h2><p>seq2seq是一种常见的NLP模型结构，全称是：sequence to sequence，翻译为“序列到序列”。顾名思义：从一个文本序列得到一个新的文本序列。典型的任务有：机器翻译任务，文本摘要任务。</p><p>seq2seq模型由编码器（Encoder）和解码器（Decoder）组成。绿色的编码器会处理输入序列中的每个元素并获得输入信息，这些信息会被转换成为一个黄色的向量（称为context向量）。当我们处理完整个输入序列后，编码器把 context向量 发送给紫色的解码器，解码器通过context向量中的信息，逐个元素输出新的序列。</p><p>我们来看一下黄色的context向量是什么？本质上是一组浮点数。而这个context的数组长度是基于编码器RNN的隐藏层神经元数量的。上图展示了长度为4的context向量，但在实际应用中，context向量的长度是自定义的，比如可能是256，512或者1024。</p><p>那么RNN是如何具体地处理输入序列的呢？</p><ol><li><p>假设序列输入是一个句子，这个句子可以由$n$个词表示：$sentence = {w_1, w_2,…,w_n}$。</p></li><li><p>RNN首先将句子中的每一个词映射成为一个向量得到一个向量序列：$X = {x_1, x_2,…,x_n}$，每个单词映射得到的向量通常又叫做：word embedding。</p></li><li><p>然后在处理第$t \in [1,n]$个时间步的序列输入$x_t$时，RNN网络的输入和输出可以表示为：$h_{t} = RNN(x_t, h_{t-1})$</p></li></ol><ul><li>输入：RNN在时间步$t$的输入之一为单词$w_t$经过映射得到的向量$x_t$。</li><li>输入：RNN另一个输入为上一个时间步$t-1$得到的hidden state向量$h_{t-1}$，同样是一个向量。</li><li>输出：RNN在时间步$t$的输出为$h_t$ hidden state向量。</li></ul><h2 id="神经网络矩阵乘法">神经网络矩阵乘法</h2><p>参考视频：<a href="https://www.youtube.com/watch?v=UNmqTiOnRfg">A friendly introduction to Recurrent Neural Networks</a></p><p><img src="../imgs/image-84.png" alt=""></p><p>通过矩阵，将一个输入序列映射到输出序列。</p><p><img src="../imgs/image-85.png" alt=""></p><p>假设可以写为：<br>$$<br>A*a=b<br>$$<br>那么如何得到矩阵A呢？</p><p>当已知向量 $\mathbf{b}$ 和向量 $\mathbf{c}$，并且它们满足线性方程 $A\mathbf{b} = \mathbf{c}$ 时，求解矩阵 $A$ 的问题本质上是一个欠定问题（如果 $\mathbf{b}$ 不是零向量）。这是因为对于给定的 $\mathbf{b}$ 和 $\mathbf{c}$，通常存在无数个不同的矩阵 $A$ 可以使等式成立。为了获得一个唯一的解，我们需要额外的信息或约束条件。</p><h3 id="使用最小二乘法">使用最小二乘法</h3><p>如果我们有多个样本对 $(\mathbf{b}_i, \mathbf{c}_i)$，其中 $i = 1, 2, …, k$，那么可以通过最小化误差平方和来估计 $A$：</p><p>$$<br>\min_{A} \sum_{i=1}^{k} | A\mathbf{b}_i - \mathbf{c}_i |^2<br>$$</p><p>这可以通过构建一个更大的系统并求解正规方程来实现。例如，如果我们有 $k$ 对 $(\mathbf{b}_i, \mathbf{c}_i)$，则可以形成如下矩阵方程：</p><p>$$<br>B^T B A = B^T C<br>$$</p><p>这里 $B$ 是由所有 $\mathbf{b}_i$ 组成的大矩阵，每一列对应一个 $\mathbf{b}_i$，而 $C$ 同样是由所有 $\mathbf{c}_i$ 组成的大矩阵。通过解这个方程可以得到一个最佳拟合的 $A$。</p><p><strong>这里的矩阵$A$其实就是我们想要得到的权重矩阵。而$\mathbf{b}$就是输出向量。</strong></p><p>那么问题就转换为如何去求解权重矩阵。参考：<a href="https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/">AI-神经网络中的三个基本概念：梯度下降、反向传播、损失函数</a></p><p>考虑一个简单的全连接层（fully connected layer），它接收来自前一层的输出作为输入，并将其传递给下一层。假设前一层有<br>$n$个神经元，当前层有<br>$m$个神经元，那么每个输入特征都会对所有输出神经元产生影响。因此，我们需要定义一组参数来描述这种关系——这就是权重矩阵的作用所在。</p><p>所以说来说去，其实是一个东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;教程地址：&lt;a href=&quot;https://github.com/datawhalechina/learn-nlp-with-transformers&quot;&gt;基于transformers的自然语言处理(NLP)入门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的NLP任务&quot;&gt;常见的NL</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-GraphRAG</title>
    <link href="https://kelinkong.github.io/2024/12/20/AI-GraphRAG/"/>
    <id>https://kelinkong.github.io/2024/12/20/AI-GraphRAG/</id>
    <published>2024-12-20T02:38:54.000Z</published>
    <updated>2025-01-10T02:19:05.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphRAG">GraphRAG</h2><p>仓库地址：<a href="https://github.com/microsoft/graphrag">GraphRAG</a></p><p>GraphRAG（Graph-based Retrieval Augmented Generation，基于图的检索增强生成）是一种利用图结构来增强大型语言模型（LLM）检索能力的先进方法。它旨在解决传统 RAG 方法在处理复杂关系、全局性问题和多跳推理方面的局限性。以下是 GraphRAG 的一些实现原理和技术要点：</p><p><strong>核心思想：</strong></p><p>GraphRAG 的核心是将文本数据转化为知识图谱，利用图的结构化信息来指导检索过程，从而更有效地为 LLM 提供上下文信息。与传统的基于向量相似度的检索方法不同，GraphRAG 侧重于实体之间的关系和整个数据集的结构，这使得它能够回答需要综合理解和推理的问题。</p><p><strong>实现原理：</strong></p><ol><li><p><strong>文本分块与信息抽取：</strong> 首先将原始文本分割成较小的块（chunk），然后从每个文本块中提取实体、关系和属性等信息。这通常使用命名实体识别（NER）、关系抽取等 NLP 技术。</p></li><li><p><strong>构建知识图谱：</strong> 将提取出的实体作为图的节点，实体之间的关系作为图的边，构建知识图谱。这个图谱可以包含多种类型的关系，例如“属于”、“位于”、“是…的作者”等等。</p></li><li><p><strong>图社区检测：</strong> 使用图算法（例如 Louvain 算法、PageRank 算法）检测图中的社区或子图。这些社区通常代表了文本中相关的概念或主题。</p></li><li><p><strong>社区摘要：</strong> 为每个检测到的社区生成摘要，概述该社区的主要内容和关键信息。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询时，GraphRAG 首先将查询转化为图查询，例如查找与某个实体相关的其他实体或关系。然后，在知识图谱上执行图查询，检索相关的社区或子图。</p></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的社区摘要或子图信息作为上下文提供给 LLM，让 LLM 基于这些上下文生成最终的回答。</p></li></ol><p><strong>技术要点：</strong></p><ul><li><p><strong>知识图谱构建：</strong></p><ul><li><strong>信息抽取质量：</strong> 实体和关系的准确提取至关重要，直接影响图谱的质量和检索效果。</li><li><strong>图谱规模和稀疏性：</strong> 如何有效地处理大规模图谱和图谱中的稀疏性是一个挑战。</li><li><strong>图谱的动态更新：</strong> 如何随着新数据的加入动态更新图谱，保持其时效性。</li></ul></li><li><p><strong>图算法选择：</strong></p><ul><li><strong>社区检测算法：</strong> 选择合适的社区检测算法，以有效地发现图谱中的相关主题。</li><li><strong>图查询算法：</strong> 如何高效地在图谱上执行查询，检索相关信息。</li></ul></li><li><p><strong>上下文选择和融合：</strong></p><ul><li><strong>上下文的相关性：</strong> 如何选择与查询最相关的上下文信息。</li><li><strong>上下文的长度和格式：</strong> 如何将图结构的信息有效地融入到 LLM 的输入中。</li></ul></li><li><p><strong>与传统 RAG 的结合：</strong></p><ul><li><strong>混合检索策略：</strong> 将图检索和向量检索结合起来，充分利用两者的优势。</li><li><strong>多阶段检索：</strong> 先使用图检索缩小检索范围，再使用向量检索进行精细化检索。</li></ul></li></ul><p><strong>GraphRAG 的优势：</strong></p><ul><li><strong>处理复杂关系：</strong> 能够更好地理解和处理实体之间的复杂关系，例如多跳关系。</li><li><strong>回答全局性问题：</strong> 能够基于整个数据集的结构进行推理和总结，回答需要全局视野的问题。</li><li><strong>提高检索效率：</strong> 通过图结构的引导，可以更有效地检索相关信息，减少不必要的计算。</li></ul><p><strong>GraphRAG 的挑战：</strong></p><ul><li><strong>知识图谱构建的复杂性：</strong> 构建高质量的知识图谱需要大量的工程和技术投入。</li><li><strong>图算法的选择和优化：</strong> 选择合适的图算法并进行优化需要一定的专业知识。</li><li><strong>与 LLM 的有效集成：</strong> 如何将图结构的信息有效地传递给 LLM，并让 LLM 充分利用这些信息。</li></ul><h2 id="举个例子">举个例子</h2><p>为了帮助你更好地理解 GraphRAG，我将举一个具体的例子，并结合实际应用场景进行说明。</p><p><strong>场景：</strong> 假设我们有一个关于电影的数据库，其中包含电影的各种信息，例如电影名称、导演、演员、类型、上映日期、剧情简介等。我们希望构建一个问答系统，用户可以提出关于电影的各种问题，例如“克里斯托弗·诺兰导演的科幻电影有哪些？”或者“《盗梦空间》的主演是谁？”。</p><p><strong>传统 RAG 方法的局限性：</strong> 如果使用传统的 RAG 方法，我们可能会将电影信息分割成文本块，并使用向量相似度来检索与用户查询相关的文本块。这种方法在回答简单的问题时可能有效，但在回答需要多跳推理或全局信息的问题时就显得力不从心。例如，如果用户问“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”，传统 RAG 方法可能难以有效地回答，因为它需要检索多个电影的信息，并进行关联和统计。</p><p><strong>使用 GraphRAG 的解决方案：</strong></p><ol><li><p><strong>构建知识图谱：</strong></p><ul><li><strong>实体：</strong> 电影名称、导演、演员、类型等。</li><li><strong>关系：</strong> “导演”、“主演”、“属于类型”、“上映于”等。</li></ul><p>例如，《盗梦空间》可以表示为一个节点，“克里斯托弗·诺兰”和“莱昂纳多·迪卡普里奥”也分别表示为节点。“克里斯托弗·诺兰”和《盗梦空间》之间存在“导演”关系，《莱昂纳多·迪卡普里奥》和《盗梦空间》之间存在“主演”关系。</p></li><li><p><strong>图社区检测（可选）：</strong> 可以使用社区检测算法将相关的电影、导演和演员聚类成不同的社区。例如，可以将克里斯托弗·诺兰导演的电影聚类成一个社区，将某个类型的电影聚类成另一个社区。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 的处理步骤如下：</p><ul><li>将查询转化为图查询：查找与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计每个“导演”节点与“莱昂纳多·迪卡普里奥”节点之间边的数量（即合作次数）。</li><li>在知识图谱上执行图查询：遍历图谱，找到所有与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计它们之间的连接次数。</li><li>返回结果：返回合作次数超过两次的导演列表，例如“马丁·斯科塞斯”。</li></ul></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的导演列表以及相关的电影信息（例如电影名称、上映日期等）作为上下文提供给 LLM。LLM 基于这些上下文生成最终的回答，例如“莱昂纳多·迪卡普里奥与马丁·斯科塞斯合作过多次，包括《华尔街之狼》、《禁闭岛》等电影。”。</p></li></ol><p><strong>具体例子图示：</strong></p><p>假设我们的知识图谱包含以下信息：</p><ul><li>《盗梦空间》- 导演：克里斯托弗·诺兰</li><li>《盗梦空间》- 主演：莱昂纳多·迪卡普里奥</li><li>《禁闭岛》- 导演：马丁·斯科塞斯</li><li>《禁闭岛》- 主演：莱昂纳多·迪卡普里奥</li><li>《华尔街之狼》- 导演：马丁·斯科塞斯</li><li>《华尔街之狼》- 主演：莱昂纳多·迪卡普里奥</li></ul><p>当用户查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 会在图谱上找到以下路径：</p><ul><li>莱昂纳多·迪卡普里奥 -&gt; 《盗梦空间》-&gt; 克里斯托弗·诺兰</li><li>莱昂纳多·迪卡普里奥 -&gt; 《禁闭岛》-&gt; 马丁·斯科塞斯</li><li>莱昂纳多·迪卡普里奥 -&gt; 《华尔街之狼》-&gt; 马丁·斯科塞斯</li></ul><p>通过统计，发现马丁·斯科塞斯与莱昂纳多·迪卡普里奥合作了两次以上，因此将其返回。</p><p><strong>总结：</strong></p><p>通过这个例子可以看出，GraphRAG 利用知识图谱的结构化信息，能够有效地处理需要多跳推理和全局信息的问题，相比传统的 RAG 方法具有明显的优势。它将文本信息转化为图结构，使得 LLM 能够更好地理解和利用这些信息，从而生成更准确、更全面的回答。</p><p>希望这个例子能够帮助你更好地理解 GraphRAG 的实施原理和优势。如果你还有其他问题，欢迎继续提问。</p><h2 id="什么样的场景适合构建知识图谱？">什么样的场景适合构建知识图谱？</h2><p>构建知识图谱并非适用于所有场景。它是一种强大的工具，但也有其特定的适用范围。以下是一些适合构建知识图谱的场景，以及一些不适合的场景：</p><p><strong>适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据之间存在复杂关联：</strong> 如果数据之间存在大量的关系和连接，并且这些关系对于理解数据至关重要，那么知识图谱就非常适用。例如：</p><ul><li><strong>社交网络：</strong> 人与人之间的朋友关系、关注关系、共同参与的活动等。</li><li><strong>生物医药：</strong> 基因、蛋白质、疾病、药物之间的相互作用和关联。</li><li><strong>金融领域：</strong> 公司、股东、投资、交易等之间的关系。</li></ul></li><li><p><strong>需要进行推理和分析：</strong> 如果需要基于数据进行推理、分析和预测，知识图谱可以提供强大的支持。例如：</p><ul><li><strong>智能问答系统：</strong> 回答需要多步推理的问题，例如“与某人合作过两次以上的导演有哪些？”。</li><li><strong>风险评估：</strong> 分析金融交易中的潜在风险，例如欺诈检测。</li><li><strong>推荐系统：</strong> 基于用户的历史行为和兴趣，推荐相关的产品或服务。</li></ul></li><li><p><strong>数据来源多样且异构：</strong> 如果数据来自不同的来源，并且格式各异，知识图谱可以提供一种统一的表示方式，方便数据的整合和利用。例如：</p><ul><li><strong>企业级数据整合：</strong> 将来自不同部门、不同系统的数据整合到一个统一的知识图谱中。</li><li><strong>跨领域数据融合：</strong> 将来自不同领域的数据融合到一起，例如将医疗数据和社交数据结合起来进行健康管理。</li></ul></li><li><p><strong>需要可视化和探索：</strong> 知识图谱以图形化的方式呈现数据，方便用户进行可视化和探索，发现数据中隐藏的模式和规律。例如：</p><ul><li><strong>情报分析：</strong> 分析犯罪网络、恐怖组织等。</li><li><strong>科研探索：</strong> 探索科学研究中的新发现和新联系。</li></ul></li><li><p><strong>需要支持语义搜索：</strong> 传统的关键词搜索只能找到包含关键词的文档，而知识图谱可以支持基于语义的搜索，找到与用户查询相关的概念和实体。例如：</p><ul><li><strong>电商搜索：</strong> 用户搜索“适合跑步的鞋子”，可以返回各种类型的跑鞋，而不仅仅是包含“跑步”和“鞋子”这两个词的商品。</li></ul></li></ol><p><strong>不适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据结构简单且关系单一：</strong> 如果数据结构非常简单，并且数据之间只有简单的线性关系，那么使用传统的数据库或表格就足够了，不需要构建知识图谱。</p></li><li><p><strong>数据量小且变化频繁：</strong> 如果数据量非常小，并且变化非常频繁，那么维护知识图谱的成本可能会高于其带来的收益。</p></li><li><p><strong>对推理和分析的需求不高：</strong> 如果应用场景主要关注数据的存储和检索，而不需要进行复杂的推理和分析，那么使用传统的数据库就足够了。</p></li></ol><p><strong>总结：</strong></p><p>以下是一些判断是否适合构建知识图谱的关键因素：</p><ul><li><strong>数据之间的关联程度：</strong> 关联越复杂，越适合使用知识图谱。</li><li><strong>对推理和分析的需求：</strong> 需求越高，越适合使用知识图谱。</li><li><strong>数据来源的多样性和异构性：</strong> 来源越多，越适合使用知识图谱进行整合。</li><li><strong>对可视化和探索的需求：</strong> 需求越高，越适合使用知识图谱。</li></ul><h2 id="GraphRAG是如何构建知识图谱的？">GraphRAG是如何构建知识图谱的？</h2><p>微软的 <strong>GraphRAG</strong> 在构建知识图谱时，采用了一套结合自然语言处理（NLP）、图数据库（如 Neo4j）、以及大语言模型（LLMs）的系统化方法。这种方法的核心目标是将非结构化数据（如文档、文本）转换为结构化的图谱表示，并通过知识图谱增强检索与生成任务。</p><p>以下是 <strong>GraphRAG</strong> 构建知识图谱的核心步骤和技术实现：</p><h3 id="1-整体流程">1. <strong>整体流程</strong></h3><p><strong>GraphRAG</strong> 的知识图谱构建流程主要分为以下步骤：</p><ol><li><strong>数据预处理</strong>：从非结构化数据中抽取知识。</li><li><strong>实体和关系抽取</strong>：识别图谱的节点（实体）和边（关系）。</li><li><strong>图谱生成</strong>：将抽取的实体和关系组织为图结构，并存储到图数据库中。</li><li><strong>图谱优化与增强</strong>：通过推理、去噪和融合提高图谱质量。</li><li><strong>实时更新</strong>：动态将新知识添加到图谱中。</li></ol><h3 id="2-核心步骤">2. <strong>核心步骤</strong></h3><h4 id="1-数据预处理"><strong>(1) 数据预处理</strong></h4><ul><li><strong>目标</strong>：将原始数据（如文本、网页、文档）转换为可处理的格式。</li><li><strong>方法</strong>：<ul><li>文本分块：将长文档切分为逻辑段落或句子。</li><li>清理无关内容：去除非信息性内容（如广告、格式符号）。</li><li>NLP 预处理：对文本进行分词、词性标注和依存分析。</li></ul></li></ul><h4 id="2-实体和关系抽取"><strong>(2) 实体和关系抽取</strong></h4><ul><li><strong>目标</strong>：从文本中提取实体和实体间的语义关系。</li><li><strong>技术</strong>：<ol><li><strong>实体抽取（NER, Named Entity Recognition）</strong>：<ul><li>识别出文本中的实体（如人名、地点、组织、事件等）。</li><li>示例：<ul><li>输入：<code>Microsoft 在 2023 年发布了新产品。</code></li><li>输出：<code>实体：&#123;Microsoft, 2023&#125;</code></li></ul></li></ul></li><li><strong>关系抽取</strong>：<ul><li>识别实体间的语义关系。</li><li>示例：<ul><li>输入：<code>Microsoft 在 2023 年发布了新产品。</code></li><li>输出：<code>关系：&#123;Microsoft -&gt; 发布 -&gt; 新产品&#125;</code>。</li></ul></li></ul></li><li><strong>工具</strong>：<ul><li>基于规则：依赖语法分析器或知识库规则。</li><li>基于模型：使用预训练模型（如 BERT、T5）微调的关系抽取模型。</li></ul></li></ol></li></ul><h4 id="3-图谱生成"><strong>(3) 图谱生成</strong></h4><ul><li><strong>目标</strong>：将实体和关系组织为图结构。</li><li><strong>方法</strong>：<ul><li>图结构定义：<ul><li><strong>节点（Nodes）</strong>：实体（如“Microsoft”）。</li><li><strong>边（Edges）</strong>：关系（如“发布”）。</li><li><strong>属性（Properties）</strong>：附加信息（如时间戳、来源）。</li></ul></li><li>图存储：<ul><li>使用图数据库（如 Neo4j）存储生成的知识图谱。</li></ul></li><li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (a:Organization &#123;name: &#x27;Microsoft&#x27;&#125;)-[:RELEASED]-&gt;(b:Product &#123;name: &#x27;New Product&#x27;, year: 2023&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-图谱优化与增强"><strong>(4) 图谱优化与增强</strong></h4><ul><li><strong>目标</strong>：提升图谱的质量和推理能力。</li><li><strong>方法</strong>：<ol><li><strong>知识融合</strong>：<ul><li>合并重复实体，标准化数据表示。</li><li>示例：将 <code>MSFT</code> 和 <code>Microsoft</code> 统一为同一节点。</li></ul></li><li><strong>关系推理</strong>：<ul><li>使用规则或模型推断隐含关系。</li><li>示例：若 <code>A 是 B 的父亲</code> 且 <code>B 是 C 的父亲</code>，则推断 <code>A 是 C 的祖父</code>。</li></ul></li><li><strong>去噪</strong>：<ul><li>过滤低置信度的实体和关系。</li><li>基于置信分数或人工审核移除冗余或错误信息。</li></ul></li></ol></li></ul><h4 id="5-实时更新"><strong>(5) 实时更新</strong></h4><ul><li><strong>目标</strong>：使图谱始终包含最新知识。</li><li><strong>方法</strong>：<ul><li>增量更新：将新增数据中的实体和关系提取后动态添加到图谱中。</li><li>数据校验：对新增知识进行验证，避免图谱污染。</li></ul></li></ul><h3 id="3-技术与工具">3. <strong>技术与工具</strong></h3><h4 id="1-NLP-模型"><strong>(1) NLP 模型</strong></h4><ul><li><strong>预训练模型</strong>：如 BERT、GPT-4、T5，用于实体和关系抽取。</li><li><strong>微调模型</strong>：在特定领域数据上微调的模型提高精度。</li></ul><h4 id="2-图数据库"><strong>(2) 图数据库</strong></h4><ul><li><strong>Neo4j</strong>：作为存储和查询的后端，支持高效的图遍历和查询。</li><li><strong>图查询语言</strong>：使用 Cypher 查询语言实现图谱管理。</li></ul><h4 id="3-集成语言模型（LLMs）"><strong>(3) 集成语言模型（LLMs）</strong></h4><ul><li>通过 LLMs 提供上下文增强，确保在生成过程中充分利用图谱信息。</li><li>示例：<ul><li>生成模型会根据用户查询，结合知识图谱的结果生成回答。</li></ul></li></ul><h3 id="4-结合生成任务的工作流程">4. <strong>结合生成任务的工作流程</strong></h3><p>知识图谱不仅被用作静态存储，还用于 Graph RAG 的检索和生成流程：</p><ol><li><strong>查询图谱</strong>：<ul><li>用户问题触发对图谱的查询，通过图遍历找到相关实体和关系。</li><li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(friends)</span><br><span class="line">RETURN friends</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>检索结果传递给 LLM</strong>：<ul><li>将图谱的检索结果转化为语言模型的输入，作为上下文。</li></ul></li><li><strong>生成答案</strong>：<ul><li>使用 LLM 基于上下文生成最终答案，避免生成幻觉。</li></ul></li></ol><h3 id="5-应用场景">5. <strong>应用场景</strong></h3><ul><li><strong>开放域问答</strong>：<ul><li>用户问题通过知识图谱检索相关背景信息，提供准确回答。</li></ul></li><li><strong>知识图谱增强生成</strong>：<ul><li>用知识图谱的结构化数据补充生成内容。</li></ul></li><li><strong>多跳推理</strong>：<ul><li>基于图谱实现复杂的关系推理。</li></ul></li></ul><h3 id="6-总结">6. <strong>总结</strong></h3><p>微软的 <strong>Graph RAG</strong> 通过从非结构化数据中构建知识图谱，将知识存储为结构化的图数据，增强了检索和生成过程的效率与准确性。结合 Neo4j 等图数据库，Graph RAG 实现了高效的知识管理和利用，尤其适合知识密集型任务，如开放问答和多跳推理场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphRAG&quot;&gt;GraphRAG&lt;/h2&gt;
&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/microsoft/graphrag&quot;&gt;GraphRAG&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GraphRAG（Graph-based Retrieval A</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-神经网络中的三个基本概念：梯度下降、反向传播、损失函数</title>
    <link href="https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</id>
    <published>2024-12-19T02:05:45.000Z</published>
    <updated>2024-12-20T08:18:52.148Z</updated>
    
    <content type="html"><![CDATA[<!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><p>文章参考：<a href="https://github.com/microsoft/ai-edu/blob/master/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC1%E6%AD%A5%20-%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/02.0-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.md">神经网络中的三个基本概念</a></p><h2 id="2-0-通俗地理解三大概念">2.0 通俗地理解三大概念</h2><p>这三大概念是：反向传播，梯度下降，损失函数。</p><p>神经网络训练的最基本的思想就是：先“猜”一个结果，称为预测结果 $a$，看看这个预测结果和事先标记好的训练集中的真实结果 $y$ 之间的差距，然后调整策略，再试一次，这一次就不是“猜”了，而是有依据地向正确的方向靠近。如此反复多次，一直到预测结果和真实结果之间相差无几，亦即 $|a-y|\rightarrow 0$，就结束训练。</p><p>在神经网络训练中，我们把“猜”叫做初始化，可以随机，也可以根据以前的经验给定初始值。即使是“猜”，也是有技术含量的。</p><p>下面我们举几个例子来直观的说明下这三个概念。</p><h3 id="2-0-1-例一：猜数">2.0.1 例一：猜数</h3><p>甲乙两个人玩儿猜数的游戏，数字的范围是 $[1,50]$：</p><p>甲：我猜5</p><p>乙：太小了</p><p>甲：50</p><p>乙：有点儿大</p><p>甲：30</p><p>乙：小了</p><p>…</p><p>在这个游戏里：</p><ul><li>目的：猜到乙心中的数字；</li><li>初始化：甲猜5；</li><li>前向计算：甲每次猜的新数字；</li><li>损失函数：乙在根据甲猜的数来和自己心中想的数做比较，得出“大了”或“小了”的结论；</li><li>反向传播：乙告诉甲“小了”、“大了”；</li><li>梯度下降：甲根据乙的反馈中的含义自行调整下一轮的猜测值。</li></ul><p>这里的损失函数是什么呢？就是“太小了”，“有点儿大”，很不精确！这个“所谓的”损失函数给出了两个信息：</p><ol><li>方向：大了或小了</li><li>程度：“太”，“有点儿”，但是很模糊</li></ol><h3 id="2-0-2-例二：黑盒子">2.0.2 例二：黑盒子</h3><p>假设有一个黑盒子：</p><p>我们只能看到输入和输出的数值，看不到里面的样子，当输入1时，输出2.334，然后黑盒子有个信息显示：我需要输出值是4。然后我们试了试输入2，结果输出5.332，一下子比4大了很多。那么我们第一次的损失值是 $2.334-4=-1.666$，而二次的损失值是 $5.332-4=1.332$。</p><p>这里，我们的损失函数就是一个简单的减法，用实际值减去目标值，但是它可以告诉你两个信息：1）方向，是大了还是小了；2）差值，是0.1还是1.1。这样就给了我们下一次猜的依据。</p><ul><li>目的：猜到一个输入值，使得黑盒子的输出是4；</li><li>初始化：输入1；</li><li>前向计算：黑盒子内部的数学逻辑；</li><li>损失函数：在输出端，用输出值减4；</li><li>反向传播：告诉猜数的人差值，包括正负号和值；</li><li>梯度下降：在输入端，根据正负号和值，确定下一次的猜测值。</li></ul><h3 id="2-0-3-例三：打靶">2.0.3 例三：打靶</h3><p>小明拿了一支步枪，射击100米外的靶子。这支步枪没有准星，或者是准星有问题，或者是小明眼神儿不好看不清靶子，或者是雾很大，或者风很大，或者由于木星的影响而侧向引力场异常…反正就是遇到各种干扰因素。</p><p>第一次试枪后，拉回靶子一看，弹着点偏左了，于是在第二次试枪时，小明就会有意识地向右侧偏几毫米，再看靶子上的弹着点，如此反复几次，小明就会掌握这支步枪的脾气了。图2-2显示了小明的5次试枪过程。</p><p><img src="../imgs/image-72.png" alt="图2-2 打靶的弹着点记录"></p><p>在有监督的学习中，需要衡量神经网络输出和所预期的输出之间的差异大小。这种误差函数需要能够反映出当前网络输出和实际结果之间一种量化之后的不一致程度，也就是说函数值越大，反映出模型预测的结果越不准确。</p><p>这个例子中，小明预期的目标是全部命中靶子的中心，最外圈是1分，之后越向靶子中心分数是2，3，4分，正中靶心可以得10分。</p><ul><li>每次试枪弹着点和靶心之间的差距就叫做误差，可以用一个误差函数来表示，比如差距的绝对值，如图中的红色线。</li><li>一共试枪5次，就是迭代/训练了5次的过程 。</li><li>每次试枪后，把靶子拉回来看弹着点，然后调整下一次的射击角度的过程，叫做反向传播。注意，把靶子拉回来看和跑到靶子前面去看有本质的区别，后者容易有生命危险，因为还有别的射击者。一个不恰当的比喻是，在数学概念中，人跑到靶子前面去看，叫做正向微分；把靶子拉回来看，叫做反向微分。</li><li>每次调整角度的数值和方向，叫做梯度。比如向右侧调整1毫米，或者向左下方调整2毫米。如图中的绿色矢量线。</li></ul><p>上图是每次单发点射，所以每次训练样本的个数是1。在实际的神经网络训练中，通常需要多个样本，做批量训练，以避免单个样本本身采样时带来的误差。在本例中，多个样本可以描述为连发射击，假设一次可以连打3发子弹，每次的离散程度都类似，如图2-3所示。<br><img src="../imgs/image-73.png" alt="图2-3 连发弹着点记录"></p><ul><li>如果每次3发子弹连发，这3发子弹的弹着点和靶心之间的差距之和再除以3，叫做损失，可以用损失函数来表示。</li></ul><p>那小明每次射击结果和目标之间的差距是多少呢？在这个例子里面，用得分来衡量的话，就是说小明得到的反馈结果从差9分，到差8分，到差2分，到差1分，到差0分，这就是用一种量化的结果来表示小明的射击结果和目标之间差距的方式。也就是误差函数的作用。因为是一次只有一个样本，所以这里采用的是误差函数的称呼。如果一次有多个样本，就要叫做损失函数了。</p><p>其实射击还不这么简单，如果是远距离狙击，还要考虑空气阻力和风速，在神经网络里，空气阻力和风速可以对应到隐藏层的概念上。</p><p>在这个例子中：</p><ul><li>目的：打中靶心；</li><li>初始化：随便打一枪，能上靶就行，但是要记住当时的步枪的姿态；</li><li>前向计算：让子弹飞一会儿，击中靶子；</li><li>损失函数：环数，偏离角度；</li><li>反向传播：把靶子拉回来看；</li><li>梯度下降：根据本次的偏差，调整步枪的射击角度。</li></ul><p>损失函数的描述是这样的：</p><ol><li>1环，偏左上45度；</li><li>6环，偏左上15度；</li><li>7环，偏左；</li><li>8环，偏左下15度；</li><li>10环。</li></ol><p>这里的损失函数也有两个信息：</p><ol><li>距离；</li><li>方向。</li></ol><p><strong>所以，梯度，是个矢量！</strong> 它应该即告诉我们方向，又告诉我们数值。</p><h3 id="2-0-4-黑盒子的真正玩法">2.0.4 黑盒子的真正玩法</h3><p>以上三个例子比较简单，容易理解，我们把黑盒子再请出来：黑盒子这件事真正的意义并不是猜测当输入是多少时输出会是4。它的实际意义是：我们要破解这个黑盒子！于是，我们会有如下破解流程：</p><ol><li>记录下所有输入值和输出值，如表2-1。</li></ol><p>表2-1 样本数据表</p><table><thead><tr><th style="text-align:center">样本ID</th><th>输入(特征值)</th><th>输出(标签)</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>1</td><td>2.21</td></tr><tr><td style="text-align:center">2</td><td>1.1</td><td>2.431</td></tr><tr><td style="text-align:center">3</td><td>1.2</td><td>2.652</td></tr><tr><td style="text-align:center">4</td><td>2</td><td>4.42</td></tr></tbody></table><ol start="2"><li>搭建一个神经网络，给出初始权重值，我们先假设这个黑盒子的逻辑是：$z=x + x^2$；</li><li>输入1，根据 $z=x + x^2$ 得到输出为2，而实际的输出值是2.21，则误差值为 $2-2.21=-0.21$，小了；</li><li>调整权重值，比如 $z=1.5x+x^2$，再输入1.1，得到的输出为2.86，实际输出为2.431，则误差值为 $2.86-2.431=0.429$，大了；</li><li>调整权重值，比如 $z=1.2x+x^2$，再输入1.2……</li><li>调整权重值，再输入2……</li><li>所有样本遍历一遍，计算平均的损失函数值；</li><li>依此类推，重复3，4，5，6过程，直到损失函数值小于一个指标，比如 $0.001$，我们就可以认为网络训练完毕，黑盒子“破解”了，实际是被复制了，因为神经网络并不能得到黑盒子里的真实函数体，而只是近似模拟。</li></ol><p>从上面的过程可以看出，如果误差值是正数，我们就把权重降低一些；如果误差值为负数，则升高权重。</p><h3 id="2-0-5-总结">2.0.5 总结</h3><p>简单总结一下反向传播与梯度下降的基本工作原理：</p><ol><li>初始化；</li><li>正向计算；</li><li>损失函数为我们提供了计算损失的方法；</li><li>梯度下降是在损失函数基础上向着损失最小的点靠近而指引了网络权重调整的方向；</li><li>反向传播把损失值反向传给神经网络的每一层，让每一层都根据损失值反向调整权重；</li><li>Go to 2，直到精度足够好（比如损失函数值小于 $0.001$）。</li></ol><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-1-线性反向传播">2.1 线性反向传播</h2><h3 id="2-1-1-正向计算的实例">2.1.1 正向计算的实例</h3><p>假设有一个函数：</p><p>$$z = x \cdot y \tag{1}$$</p><p>其中:</p><p>$$x = 2w + 3b \tag{2}$$</p><p>$$y = 2b + 1 \tag{3}$$</p><p>计算图如图2-4。</p><p><img src="../imgs/image-74.png" alt="图2-4 简单线性计算的计算图"></p><p>注意这里 $x,y,z$ 不是变量，只是中间计算结果；$w,b$ 才是变量。因为在后面要学习的神经网络中，要最终求解的目标是 $w$ 和 $b$ 的值，所以在这里先预热一下。</p><p>当 $w = 3, b = 4$ 时，会得到图2-5的结果。</p><p><img src="../imgs/image-75.png" alt="图2-5 计算结果"></p><p>最终的 $z$ 值，受到了前面很多因素的影响：变量 $w$，变量 $b$，计算式 $x$，计算式 $y$。</p><h3 id="2-1-2-反向传播求解-w">2.1.2 反向传播求解 $w$</h3><h4 id="求-w-的偏导">求 $w$ 的偏导</h4><p>目前 $z=162$，如果想让 $z$ 变小一些，比如目标是 $z=150$，$w$ 应该如何变化呢？为了简化问题，先只考虑改变 $w$ 的值，而令 $b$ 值固定为 $4$。</p><p>如果想解决这个问题，最笨的办法是可以在输入端一点一点的试，把 $w$ 变成 $3.5$ 试试，再变成 $3$ 试试…直到满意为止。现在我们将要学习一个更好的解决办法：反向传播。</p><p>从 $z$ 开始一层一层向回看，图中各节点关于变量 $w$ 的偏导计算结果如下：</p><p>因为 $z = x \cdot y$，其中 $x = 2w + 3b, y = 2b + 1$</p><p>所以：</p><p>$$<br>\frac{\partial{z}}{\partial{w}}=\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}=y \cdot 2=18 \tag{4}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}=\frac{\partial{}}{\partial{x}}(x \cdot y)=y=9<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{w}}=\frac{\partial{}}{\partial{w}}(2w+3b)=2<br>$$</p><p><img src="../imgs/image-76.png" alt="图2-6 对 $w$ 的偏导求解过程"></p><p>图2-6其实就是链式法则的具体表现，$z$ 的误差通过中间的 $x$ 传递到 $w$。如果不是用链式法则，而是直接用 $z$ 的表达式计算对 $w$ 的偏导数，会怎么样呢？我们来试验一下。</p><p>根据公式1、2、3，我们有：</p><p>$$<br>z=x \cdot y=(2w+3b)(2b+1)=4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求 $w$ 的偏导：</p><p>$$<br>\frac{\partial z}{\partial w}=4b+2=4 \cdot 4 + 2=18 \tag{6}<br>$$</p><p>公式4和公式6的结果完全一致！所以，请大家相信链式法则的科学性。</p><h4 id="求-w-的具体变化值">求 $w$ 的具体变化值</h4><p><strong>公式4和公式6的含义是：当 $w$ 变化一点点时，$z$ 会产生 $w$ 的变化值18倍的变化</strong>。记住我们的目标是让 $z=150$，目前在初始状态时是 $z=162$，所以，问题转化为：当需要 $z$ 从 $162$ 变到 $150$ 时，$w$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z = 18 \cdot \Delta w<br>$$</p><p>则：</p><p>$$<br>\Delta w = {\Delta z \over 18}=\frac{162-150}{18}= 0.6667<br>$$</p><p>所以：</p><p>$$<br>w = w - 0.6667=2.3333<br>$$</p><p>$$<br>x=2w+3b=16.6667<br>$$</p><p>$$<br>z=x \cdot y=16.6667 \times 9=150.0003<br>$$</p><p>我们一下子就成功地让 $z$ 值变成了 $150.0003$，与 $150$ 的目标非常地接近，这就是偏导数的威力所在。</p><h4 id="【课堂练习】推导-z-对-b-的偏导数，结果在下一小节中使用">【课堂练习】推导 $z$ 对 $b$ 的偏导数，结果在下一小节中使用</h4><h3 id="2-1-3-反向传播求解-b">2.1.3 反向传播求解 $b$</h3><h4 id="求-b-的偏导">求 $b$ 的偏导</h4><p>这次我们令 $w$ 的值固定为 $3$，变化 $b$ 的值，目标还是让 $z=150$。同上一小节一样，先求 $b$ 的偏导数。</p><p>注意，在上一小节中，求 $w$ 的导数只经过了一条路：从 $z$ 到 $x$ 到 $w$。但是求 $b$ 的导数时要经过两条路，如图2-7所示：</p><ol><li>从 $z$ 到 $x$ 到 $b$；</li><li>从 $z$ 到 $y$ 到 $b$。</li></ol><p><img src="../imgs/image-77.png" alt="图2-7 对b的偏导求解过程"></p><p>从复合导数公式来看，这两者应该是相加的关系，所以有：</p><p>$$<br>\frac{\partial{z}}{\partial{b}}=\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}=y \cdot 3+x \cdot 2=63 \tag{7}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}=\frac{\partial{}}{\partial{x}}(x \cdot y)=y=9<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{y}}=\frac{\partial{}}{\partial{y}}(x \cdot y)=x=18<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{b}}=\frac{\partial{}}{\partial{b}}(2w+3b)=3<br>$$</p><p>$$<br>\frac{\partial{y}}{\partial{b}}=\frac{\partial{}}{\partial{b}}(2b+1)=2<br>$$</p><p>我们不妨再验证一下链式求导的正确性。把公式5再拿过来：</p><p>$$<br>z=x \cdot y=(2w+3b)(2b+1)=4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求b的偏导：</p><p>$$<br>\frac{\partial z}{\partial b}=4w+12b+3=12+48+3=63 \tag{8}<br>$$</p><p>结果和公式7的链式法则一样。</p><h4 id="求-b-的具体变化值">求 $b$ 的具体变化值</h4><p>公式7和公式8的含义是：当 $b$ 变化一点点时，$z$ 会发生 $b$ 的变化值 $63$ 倍的变化。记住我们的目标是让 $z=150$，目前在初始状态时是 $162$，所以，问题转化为：当我们需要 $z$ 从 $162$ 变到 $150$ 时，$b$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z = 63 \cdot \Delta b<br>$$</p><p>则：</p><p>$$<br>\Delta b = \frac{\Delta z}{63}=\frac{162-150}{63}=0.1905<br>$$</p><p>所以：<br>$$<br>b=b-0.1905=3.8095<br>$$</p><p>$$<br>x=2w+3b=17.4285<br>$$</p><p>$$<br>y=2b+1=8.619<br>$$</p><p>$$<br>z=x \cdot y=17.4285 \times 8.619=150.2162<br>$$</p><p>这个结果也是与 $150$ 很接近了，但是精度还不够。再迭代几次，直到误差不大于 <code>1e-4</code> 时，我们就可以结束迭代了，对于计算机来说，这些运算的执行速度很快。</p><h4 id="【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？">【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？</h4><p>这个问题用数学公式倒推求解一个二次方程，就能直接得到准确的b值吗？是的！但是我们是要说明机器学习的方法，机器并不会解二次方程，而且很多时候不是用二次方程就能解决实际问题的。而上例所示，是用机器所擅长的迭代计算的方法来不断逼近真实解，这就是机器学习的真谛！而且这种方法是普遍适用的。</p><h3 id="2-1-4-同时求解-w-和-b-的变化值">2.1.4 同时求解 $w$ 和 $b$ 的变化值</h3><p>这次我们要同时改变 $w$ 和 $b$，到达最终结果为 $z=150$ 的目的。</p><p>已知 $\Delta z=12$，我们不妨把这个误差的一半算在 $w$ 的账上，另外一半算在 $b$ 的账上：</p><p>$$<br>\Delta b=\frac{\Delta z / 2}{63} = \frac{12/2}{63}=0.095<br>$$</p><p>$$<br>\Delta w=\frac{\Delta z / 2}{18} = \frac{12/2}{18}=0.333<br>$$</p><ul><li>$w = w-\Delta w=3-0.333=2.667$</li><li>$b = b - \Delta b=4-0.095=3.905$</li><li>$x=2w+3b=2 \times 2.667+3 \times 3.905=17.049$</li><li>$y=2b+1=2 \times 3.905+1=8.81$</li><li>$z=x \times y=17.049 \times 8.81=150.2$</li></ul><h4 id="【课堂练习】用Python代码实现以上双变量的反向传播计算过程">【课堂练习】用Python代码实现以上双变量的反向传播计算过程</h4><p>容易出现的问题：</p><ol><li>在检查 $\Delta z$ 时的值时，注意要用绝对值，因为有可能是个负数</li><li>在计算 $\Delta b$ 和 $\Delta w$ 时，第一次时，它们对 $z$ 的贡献值分别是 $1/63$ 和 $1/18$，但是第二次时，由于 $b,w$ 值的变化，对 $z$ 的贡献值也会有微小变化，所以要重新计算。具体解释如下：</li></ol><p>$$<br>\frac{\partial{z}}{\partial{b}}=\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}=y \cdot 3+x \cdot 2=3y+2x<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{w}}=\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{w}}=y \cdot 2+x \cdot 0 = 2y<br>$$<br>所以，在每次迭代中，要重新计算下面两个值：<br>$$<br>\Delta b=\frac{\Delta z}{3y+2x}<br>$$</p><p>$$<br>\Delta w=\frac{\Delta z}{2y}<br>$$</p><p>以下是程序的运行结果。</p><p>没有在迭代中重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">003455</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">806068</span>,z=<span class="number">150</span>.<span class="number">007970</span>,delta_z=<span class="number">0</span>.<span class="number">007970</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000127</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805942</span>,z=<span class="number">150</span>.<span class="number">000294</span>,delta_z=<span class="number">0</span>.<span class="number">000294</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000011</span>,delta_z=<span class="number">0</span>.<span class="number">000011</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable new: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">714286</span>, delta_b=<span class="number">0</span>.<span class="number">003585</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805938</span>,z=<span class="number">150</span>.<span class="number">000077</span>,delta_z=<span class="number">0</span>.<span class="number">000077</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">671261</span>, delta_b=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>从以上两个结果对比中，可以看到三点：</p><ol><li><code>factor_b</code>第一次是<code>63</code>，以后每次都会略微降低一些</li><li>第二个函数迭代了3次就结束了，而第一个函数迭代了5次，效率不一样</li><li>最后得到的结果是一样的，因为这个问题只有一个解</li></ol><p>对于双变量的迭代，有同样的问题：</p><p>没有在迭代中重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都保持<code>63</code>和<code>18</code>)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">001440</span>, delta_w=<span class="number">0</span>.<span class="number">005039</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661628</span>,b=<span class="number">3</span>.<span class="number">903322</span>,z=<span class="number">150</span>.<span class="number">005526</span>,delta_z=<span class="number">0</span>.<span class="number">005526</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000044</span>, delta_w=<span class="number">0</span>.<span class="number">000154</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661474</span>,b=<span class="number">3</span>.<span class="number">903278</span>,z=<span class="number">150</span>.<span class="number">000170</span>,delta_z=<span class="number">0</span>.<span class="number">000170</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000001</span>, delta_w=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661469</span>,b=<span class="number">3</span>.<span class="number">903277</span>,z=<span class="number">150</span>.<span class="number">000005</span>,delta_z=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903277</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661469</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都变化)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable new: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, factor_w=<span class="number">18</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">523810</span>, factor_w=<span class="number">17</span>.<span class="number">619048</span>, delta_b=<span class="number">0</span>.<span class="number">001499</span>, delta_w=<span class="number">0</span>.<span class="number">005148</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661519</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000044</span>,delta_z=<span class="number">0</span>.<span class="number">000044</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">485234</span>, factor_w=<span class="number">17</span>.<span class="number">613053</span>, delta_b=<span class="number">0</span>.<span class="number">000000</span>, delta_w=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661517</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903263</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661517</span></span><br></pre></td></tr></table></figure><p>这个与第一个单变量迭代不同的地方是：这个问题可以有多个解，所以两种方式都可以得到各自的正确解，但是第二种方式效率高，而且满足梯度下降的概念。</p><h3 id="参考资料">参考资料</h3><p><a href="http://colah.github.io/posts/2015-08-Backprop/">http://colah.github.io/posts/2015-08-Backprop/</a></p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-2-非线性反向传播">2.2 非线性反向传播</h2><h3 id="2-2-1-提出问题">2.2.1 提出问题</h3><p>在上面的线性例子中，我们可以发现，误差一次性地传递给了初始值 $w$ 和 $b$，即，只经过一步，直接修改 $w$ 和 $b$ 的值，就能做到误差校正。因为从它的计算图看，无论中间计算过程有多么复杂，它都是线性的，所以可以一次传到底。缺点是这种线性的组合最多只能解决线性问题，不能解决更复杂的问题。这个我们在神经网络基本原理中已经阐述过了，需要有激活函数连接两个线性单元。</p><p>下面我们看一个非线性的例子，如图2-8所示。</p><p><img src="../imgs/image-78.png" alt="图2-8 非线性的反向传播"></p><p>其中$1&lt;x&lt;=10,0&lt;y&lt;2.15$。假设有5个人分别代表 $x,a,b,c,y$：</p><h4 id="正向过程">正向过程</h4><ol><li>第1个人，输入层，随机输入第一个 $x$ 值，$x$ 的取值范围 $(1,10]$，假设第一个数是 $2$；</li><li>第2个人，第一层网络计算，接收第1个人传入 $x$ 的值，计算：$a=x^2$；</li><li>第3个人，第二层网络计算，接收第2个人传入 $a$ 的值，计算：$b=\ln (a)$；</li><li>第4个人，第三层网络计算，接收第3个人传入 $b$ 的值，计算：$c=\sqrt{b}$；</li><li>第5个人，输出层，接收第4个人传入 $c$ 的值</li></ol><h4 id="反向过程">反向过程</h4><ol start="6"><li>第5个人，计算 $y$ 与 $c$ 的差值：$\Delta c = c - y$，传回给第4个人</li><li>第4个人，接收第5个人传回$\Delta c$，计算 $\Delta b = \Delta c \cdot 2\sqrt{b}$</li><li>第3个人，接收第4个人传回$\Delta b$，计算 $\Delta a = \Delta b \cdot a$</li><li>第2个人，接收第3个人传回$\Delta a$，计算 $\Delta x = \frac{\Delta}{2x}$</li><li>第1个人，接收第2个人传回$\Delta x$，更新 $x \leftarrow x - \Delta x$，回到第1步</li></ol><p>提出问题：假设我们想最后得到 $c=2.13$ 的值，$x$ 应该是多少？（误差小于 $0.001$ 即可）</p><h3 id="2-2-2-数学解析解">2.2.2 数学解析解</h3><p>$$<br>c=\sqrt{b}=\sqrt{\ln(a)}=\sqrt{\ln(x^2)}=2.13<br>$$</p><p>$$<br>x = 9.6653<br>$$</p><h3 id="2-2-3-梯度迭代解">2.2.3 梯度迭代解</h3><p>$$<br>\frac{da}{dx}=\frac{d(x^2)}{dx}=2x=\frac{\Delta a}{\Delta x} \tag{1}<br>$$</p><p>$$<br>\frac{db}{da} =\frac{d(\ln{a})}{da} =\frac{1}{a} = \frac{\Delta b}{\Delta a} \tag{2}<br>$$</p><p>$$<br>\frac{dc}{db}=\frac{d(\sqrt{b})}{db}=\frac{1}{2\sqrt{b}}=\frac{\Delta c}{\Delta b} \tag{3}<br>$$</p><p>因此得到如下一组公式，可以把最后一层 $\Delta c$ 的误差一直反向传播给最前面的 $\Delta x$，从而更新 $x$ 值：</p><p>$$<br>\Delta c = c - y \tag{4}<br>$$</p><p>根据式3</p><p>$$<br>\Delta b = \Delta c \cdot 2\sqrt{b}<br>$$</p><p>根据式2</p><p>$$<br>\Delta a = \Delta b \cdot a<br>$$</p><p>根据式1</p><p>$$<br>\Delta x = \Delta a / 2x<br>$$</p><p>我们给定初始值 $x=2$，$\Delta x=0$，依次计算结果如表2-2。</p><p>表2-2 正向与反向的迭代计算</p><table><thead><tr><th>方向</th><th>公式</th><th>迭代1</th><th>迭代2</th><th>迭代3</th><th>迭代4</th><th>迭代5</th></tr></thead><tbody><tr><td>正向</td><td>$x=x-\Delta x$</td><td>2</td><td>4.243</td><td>7.344</td><td>9.295</td><td>9.665</td></tr><tr><td>正向</td><td>$a=x^2$</td><td>4</td><td>18.005</td><td>53.934</td><td>86.404</td><td>93.233</td></tr><tr><td>正向</td><td>$b=\ln(a)$</td><td>1.386</td><td>2.891</td><td>3.988</td><td>4.459</td><td>4.535</td></tr><tr><td>正向</td><td>$c=\sqrt{b}$</td><td>1.177</td><td>1.700</td><td>1.997</td><td>2.112</td><td>2.129</td></tr><tr><td></td><td>标签值y</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td></tr><tr><td>反向</td><td>$\Delta c = c - y$</td><td>-0.953</td><td>-0.430</td><td>-0.133</td><td>-0.018</td><td></td></tr><tr><td>反向</td><td>$\Delta b = \Delta c \cdot 2\sqrt{b}$</td><td>-2.243</td><td>-1.462</td><td>-0.531</td><td>-0.078</td><td></td></tr><tr><td>反向</td><td>$\Delta a = \Delta b \cdot a$</td><td>-8.973</td><td>-26.317</td><td>-28.662</td><td>-6.698</td><td></td></tr><tr><td>反向</td><td>$\Delta x = \Delta a / 2x$</td><td>-2.243</td><td>-3.101</td><td>-1.951</td><td>-0.360</td><td></td></tr></tbody></table><p>表2-2，先看“迭代-1”列，从上到下是一个完整的正向+反向的过程，最后一行是 $-2.243$，回到“迭代-2”列的第一行，$2-(-2.243)=4.243$，然后继续向下。到第5轮时，正向计算得到的 $c=2.129$，非常接近 $2.13$ 了，迭代结束。</p><p>运行示例代码可以得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">how <span class="keyword">to</span> play: 1) input x, 2) calculate c, 3) input target number but <span class="keyword">not</span> faraway <span class="keyword">from</span> c</span><br><span class="line">input x as initial number(1.2,10), you can try 1.3:</span><br><span class="line">2</span><br><span class="line"><span class="attribute">c</span>=1.177410</span><br><span class="line">input y as target number(0.5,2), you can try 1.8:</span><br><span class="line">2.13</span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=2.000000,a=4.000000,b=1.386294,c=1.177410</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">delta_c</span>=-0.952590, <span class="attribute">delta_b</span>=-2.243178, <span class="attribute">delta_a</span>=-8.972712, <span class="attribute">delta_x</span>=-2.243178</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=9.655706,a=93.232666,b=4.535098,c=2.129577</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line">done!</span><br></pre></td></tr></table></figure><p>为节省篇幅只列出了第一步和最后一步（第5步）的结果，第一步时<code>c=1.177410</code>，最后一步时<code>c=2.129577</code>，停止迭代。</p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-3-梯度下降">2.3 梯度下降</h2><h3 id="2-3-1-从自然现象中理解梯度下降">2.3.1 从自然现象中理解梯度下降</h3><p>在大多数文章中，都以“一个人被困在山上，需要迅速下到谷底”来举例，这个人会“寻找当前所处位置最陡峭的地方向下走”。这个例子中忽略了安全因素，这个人不可能沿着最陡峭的方向走，要考虑坡度。</p><p>在自然界中，梯度下降的最好例子，就是泉水下山的过程：</p><ol><li>水受重力影响，会在当前位置，沿着最陡峭的方向流动，有时会形成瀑布（梯度下降）；</li><li>水流下山的路径不是唯一的，在同一个地点，有可能有多个位置具有同样的陡峭程度，而造成了分流（可以得到多个解）；</li><li>遇到坑洼地区，有可能形成湖泊，而终止下山过程（不能得到全局最优解，而是局部最优解）。</li></ol><h3 id="2-3-2-梯度下降的数学理解">2.3.2 梯度下降的数学理解</h3><p>梯度下降的数学公式：</p><p>$$\theta_{n+1} = \theta_{n} - \eta \cdot \nabla J(\theta) \tag{1}$$</p><p>其中：</p><ul><li>$\theta_{n+1}$：下一个值；</li><li>$\theta_n$：当前值；</li><li>$-$：减号，梯度的反向；</li><li>$\eta$：学习率或步长，控制每一步走的距离，不要太快以免错过了最佳景点，不要太慢以免时间太长；</li><li>$\nabla$：梯度，函数当前位置的最快上升点；</li><li>$J(\theta)$：函数。</li></ul><h4 id="梯度下降的三要素">梯度下降的三要素</h4><ol><li>当前点；</li><li>方向；</li><li>步长。</li></ol><h4 id="为什么说是“梯度下降”？">为什么说是“梯度下降”？</h4><p>“梯度下降”包含了两层含义：</p><ol><li>梯度：函数当前位置的最快上升点；</li><li>下降：与导数相反的方向，用数学语言描述就是那个减号。</li></ol><p>亦即与上升相反的方向运动，就是下降。</p><p><img src="../imgs/image-79.png" alt="图2-9 梯度下降的步骤"></p><p>图2-9解释了在函数极值点的两侧做梯度下降的计算过程，梯度下降的目的就是使得x值向极值点逼近。</p><h3 id="2-3-3-单变量函数的梯度下降">2.3.3 单变量函数的梯度下降</h3><p>假设一个单变量函数：</p><p>$$J(x) = x ^2$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$$J’(x) = 2x$$</p><p>假设初始位置为：</p><p>$$x_0=1.2$$</p><p>假设学习率：</p><p>$$\eta = 0.3$$</p><p>根据公式(1)，迭代公式：</p><p>$$x_{n+1} = x_{n} - \eta \cdot \nabla J(x)= x_{n} - \eta \cdot 2x$$</p><p>假设终止条件为 $J(x)&lt;0.01$，迭代过程是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">480000</span>, y=<span class="number">0</span>.<span class="number">230400</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">192000</span>, y=<span class="number">0</span>.<span class="number">036864</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">076800</span>, y=<span class="number">0</span>.<span class="number">005898</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">030720</span>, y=<span class="number">0</span>.<span class="number">000944</span></span><br></pre></td></tr></table></figure><p>上面的过程如图2-10所示。</p><p><img src="../imgs/image-80.png" alt="图2-10 使用梯度下降法迭代的过程"></p><h3 id="2-3-4-双变量的梯度下降">2.3.4 双变量的梯度下降</h3><p>假设一个双变量函数：</p><p>$$J(x,y) = x^2 + \sin^2(y)$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$${\partial{J(x,y)} \over \partial{x}} = 2x$$<br>$${\partial{J(x,y)} \over \partial{y}} = 2 \sin y \cos y$$</p><p>假设初始位置为：</p><p>$$(x_0,y_0)=(3,1)$$</p><p>假设学习率：</p><p>$$\eta = 0.1$$</p><p>根据公式(1)，迭代过程是的计算公式：</p><p>$$<br>(x_{n+1},y_{n+1}) = (x_n,y_n) - \eta \cdot \nabla J(x,y)<br>$$</p><p>$$<br>= (x_n,y_n) - \eta \cdot (2x,2 \cdot \sin y \cdot \cos y) \tag{1}<br>$$</p><p>根据公式(1)，假设终止条件为 $J(x,y)&lt;0.01$，迭代过程如表2-3所示。</p><p>表2-3 双变量梯度下降的迭代过程</p><table><thead><tr><th>迭代次数</th><th>x</th><th>y</th><th>J(x,y)</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>1</td><td>9.708073</td></tr><tr><td>2</td><td>2.4</td><td>0.909070</td><td>6.382415</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>15</td><td>0.105553</td><td>0.063481</td><td>0.015166</td></tr><tr><td>16</td><td>0.084442</td><td>0.050819</td><td>0.009711</td></tr></tbody></table><p>迭代16次后，$J(x,y)$ 的值为 $0.009711$，满足小于 $0.01$ 的条件，停止迭代。</p><p>上面的过程如表2-4所示，由于是双变量，所以需要用三维图来解释。请注意看两张图中间那条隐隐的黑色线，表示梯度下降的过程，从红色的高地一直沿着坡度向下走，直到蓝色的洼地。</p><p>表2-4 在三维空间内的梯度下降过程</p><p><img src="../imgs/image-81.png" alt=""></p><h3 id="2-3-5-学习率η的选择">2.3.5 学习率η的选择</h3><p>在公式表达时，学习率被表示为$\eta$。在代码里，我们把学习率定义为<code>learning_rate</code>，或者<code>eta</code>。针对上面的例子，试验不同的学习率对迭代情况的影响，如表2-5所示。</p><p>表2-5 不同学习率对迭代情况的影响</p><p><img src="../imgs/image-83.png" alt=""></p><h2 id="代码示例">代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Neural Network class</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, eta</span>):</span><br><span class="line">        self.eta = eta</span><br><span class="line">        self.w = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = self.w * x + self.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__backward</span>(<span class="params">self, x, y, z</span>):</span><br><span class="line">        dz = z - y  <span class="comment"># dz 表示预测值 z 和真实值 y 之间的误差</span></span><br><span class="line">        db = dz <span class="comment"># 因为偏置项 b 对于每个输入样本 x 都是相同的，所以误差 dz 直接反映了偏置项 b 的更新量。因此，db = dz 表示偏置项 b 的梯度（即偏导数）等于误差 dz。</span></span><br><span class="line">        dw = x * dz <span class="comment"># 损失函数对w求梯度（偏导数），损失函数为均方误差，所以损失函数对w求导，即dw = x * dz</span></span><br><span class="line">        <span class="keyword">return</span> dw, db</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度更新</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__update</span>(<span class="params">self, dw, db</span>):</span><br><span class="line">        self.w = self.w - self.eta * dw</span><br><span class="line">        self.b = self.b - self.eta * db</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, dataReader</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dataReader.num_train_data):</span><br><span class="line">            x, y = dataReader.get_train_data(i)  <span class="comment"># 获取第i个训练样本</span></span><br><span class="line">            z = self.__forward(x)  <span class="comment"># 前向计算得到z</span></span><br><span class="line">            dw, db = self.__backward(x, y, z) <span class="comment"># 反向传播得到dw和db</span></span><br><span class="line">            self.__update(dw, db) <span class="comment"># 更新参数w和b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__forward(x)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!--Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
</feed>
