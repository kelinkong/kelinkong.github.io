<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-11T05:32:56.895Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++代码调试</title>
    <link href="http://example.com/2023/10/10/C++%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/"/>
    <id>http://example.com/2023/10/10/C++%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/</id>
    <published>2023-10-10T08:15:48.000Z</published>
    <updated>2023-10-11T05:32:56.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCC-工作流程"><a href="#GCC-工作流程" class="headerlink" title="GCC 工作流程"></a>GCC 工作流程</h2><table><thead><tr><th>说明</th><th>文件后缀</th><th>参数</th></tr></thead><tbody><tr><td>预处理</td><td>.c</td><td>-</td></tr><tr><td>编译</td><td>.i</td><td>-E</td></tr><tr><td>汇编</td><td>.s</td><td>-S</td></tr><tr><td>链接</td><td>.o</td><td>-c</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预处理。 -o 参数是为了指定编译后的文件名</span></span><br><span class="line">gcc -E test.c -o test.i</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">gcc -S test.i -o test.s </span><br><span class="line"><span class="comment"># 汇编</span></span><br><span class="line">gcc -c test.s -o test.o</span><br><span class="line"><span class="comment">#链接</span></span><br><span class="line">gcc test.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>生成调试信息，即可调试</td></tr><tr><td>-D</td><td>指定一个宏</td></tr><tr><td>-l</td><td>指定链接库</td></tr><tr><td>-std</td><td>指定C++版本</td></tr><tr><td>-I</td><td>指定头文件路径</td></tr><tr><td>-Wall</td><td>打开所有警告信息</td></tr></tbody></table><p><strong><code>-D</code>参数应用场景：</strong><br>在发布程序的时候，一般会将所有log输出去掉，如果不去掉会影响程序的执行效率。这时候可以在编译的时候加上<code>-D</code>参数，定义一个宏，然后在程序中使用这个宏，如果是发布程序，就不定义这个宏，这样就可以在编译的时候去掉所有的log输出。</p><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> string.c main.c</span><br></pre></td></tr></table></figure><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p><strong>在编译阶段：</strong></p><ul><li>后缀为.c的文件，gcc会将其当做C语言源文件，g++会将其当做C++语言源文件。</li><li>后缀为.cpp的文件，两者都会将其当做C++语言源文件。</li><li>g++会调用gcc，对于C++代码，两者是等价的，也就是说gcc和g++都可以编译C&#x2F;C++代码</li></ul><p><strong>在链接阶段：</strong></p><ul><li>gcc和g++都可以自动连接到标准C库</li><li>g++会自动连接到标准C++库，gcc如果要链接到标准C++库需要加参数<code>-lstdc++</code></li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><strong>gdb调试的代码必须添加-g参数，-g的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行。</strong></p><p><em>使用CMake编译的，添加<code>-DCMAKE_BUILD_TYPE=Debug</code>参数</em>。</p><h3 id="启动和退出gdb"><a href="#启动和退出gdb" class="headerlink" title="启动和退出gdb"></a>启动和退出gdb</h3><p><strong>gdb进程启动之后，需要被调试的应用程序是没有执行的。</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb &lt;program&gt; <span class="comment"># 启动</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> args &lt;arg1&gt; &lt;arg2&gt; <span class="comment"># 设置参数,启动应用程序之前可能需要传参</span></span><br><span class="line"></span><br><span class="line">show args <span class="comment"># 查看参数</span></span><br></pre></td></tr></table></figure><p><strong>在gdb中启动程序：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">(gdb) start <span class="comment"># 会阻塞到main函数第一行</span></span><br></pre></td></tr></table></figure><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>run</td><td>启动程序</td><td></td></tr><tr><td>continue &#x3D; c</td><td>继续执行程序</td><td></td></tr><tr><td>quit &#x3D;&#x3D; q</td><td>退出gdb</td><td></td></tr><tr><td>list &#x3D;&#x3D; l</td><td>列出源代码</td><td>l 行号, l 函数名， l 文件名：行号</td></tr><tr><td>break &#x3D;&#x3D; b</td><td>设置断点</td><td>b 行号, b 函数名， b 文件名：行号， b 行数 if 变量名&#x3D;某个值</td></tr><tr><td>info &#x3D;&#x3D; i</td><td>查看信息</td><td>i breakpoints, i locals, i args</td></tr><tr><td>delete &#x3D; del &#x3D; d</td><td>删除断点</td><td>d 断点号</td></tr><tr><td>disable &#x3D; dis</td><td>禁用断点</td><td>disable 断点号</td></tr><tr><td>enable &#x3D; ena</td><td>启用断点</td><td>enable 断点号</td></tr><tr><td>print &#x3D; p</td><td>打印变量</td><td>p 变量名</td></tr><tr><td>ptype</td><td>打印变量类型</td><td>ptype 变量名</td></tr><tr><td>display</td><td>跟踪查看变量</td><td>display 变量名</td></tr><tr><td>step &#x3D; s</td><td>单步执行，进入函数</td><td></td></tr><tr><td>finish</td><td>执行到当前函数返回为止</td><td></td></tr><tr><td>next &#x3D; n</td><td>单步执行，不进入函数</td><td></td></tr><tr><td>until</td><td>跳出循环</td><td></td></tr><tr><td>set</td><td>修改变量值</td><td>set 变量名&#x3D;值</td></tr></tbody></table><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>参考<a href="https://www.hahack.com/codes/cmake/">Cmake快速入门</a></p><p>cmake的基本语法：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake &lt;<span class="keyword">option</span>&gt; &lt;path&gt;</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Debug ..</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><table><thead><tr><th>含义</th><th>指令</th></tr></thead><tbody><tr><td>编译</td><td>cmake <code>&lt;path&gt;</code>, 当前目录为<code>.</code>,上一级目录为<code>..</code></td></tr><tr><td>清理cmake缓存</td><td><code>rm -rf CMakeFiles/ CMakeCache.txt cmake_install.cmake Makefile</code></td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>每一个层级都需要写CMakeLists.txt文件</li><li>需要在父层级添加子层级的目录</li><li>需要在父层级添加子层级的库&#x2F;子目录包含可执行文件</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>文件结构：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── cmake_notes</span><br><span class="line">│   ├── build</span><br><span class="line">│   └── math</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">|       ├── myfunction.h</span><br><span class="line">│       └── myfunction.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── main.txt</span><br></pre></td></tr></table></figure><p>第一层级的CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目名称</span></span><br><span class="line"><span class="keyword">project</span>(Demo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否用自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">option</span>(USE_MYMATH <span class="string">&quot;Use provided math implementation&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自己的 MathFunctions库</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DUSE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否加入MathFunctions库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;</span>)</span><br><span class="line">    <span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_executable(Demo main.cpp print.cpp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件，保存到DIR_SRCS变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="comment"># add_subdirectory(math)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到库</span></span><br><span class="line"><span class="keyword">if</span> (USE_MYMATH)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br><span class="line"><span class="keyword">endif</span> (USE_MYMATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo -lpthread)</span><br></pre></td></tr></table></figure><p><strong>在源代码中使用：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use my math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;use system math&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// USE_MYMATH</span></span></span><br></pre></td></tr></table></figure><p><strong>子目录的CMakeLists文档，需要add_executable吗?</strong></p><p>子目录包含可执行文件：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_executable</span>(my_executable main.cpp other_source.cpp)</span><br></pre></td></tr></table></figure><p>子目录只包含库代码：</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子目录的 CMakeLists.txt 中</span></span><br><span class="line"><span class="keyword">add_library</span>(my_library my_source.cpp)</span><br></pre></td></tr></table></figure><p>这将创建一个库目标而不是可执行文件，以便在主目录的CMakeLists.txt文件中或其他子目录中使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GCC-工作流程&quot;&gt;&lt;a href=&quot;#GCC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;GCC 工作流程&quot;&gt;&lt;/a&gt;GCC 工作流程&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;文件后缀&lt;/th&gt;
&lt;t</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++多线程模型</title>
    <link href="http://example.com/2023/10/10/C++11-threads/"/>
    <id>http://example.com/2023/10/10/C++11-threads/</id>
    <published>2023-10-10T06:47:41.000Z</published>
    <updated>2023-10-10T07:53:21.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程同步和线程通信"><a href="#线程同步和线程通信" class="headerlink" title="线程同步和线程通信"></a>线程同步和线程通信</h2><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li>互斥锁</li><li>条件变量</li><li>互斥量</li><li>信号量</li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li>条件变量</li><li>队列</li><li>原子操作</li><li>条件变量和定时器</li></ol><h2 id="C-标准库提供了哪些锁？"><a href="#C-标准库提供了哪些锁？" class="headerlink" title="C++标准库提供了哪些锁？"></a>C++标准库提供了哪些锁？</h2><p><code>std::mutex</code>：互斥锁是最基本的锁类型，用于确保一次只有一个线程可以访问共享资源。你可以使用 std::mutex 来创建一个互斥锁对象，然后使用 lock() 和 unlock() 方法来手动锁定和解锁。</p><p><code>std::unique_lock：</code>std::unique_lock 是一个更加灵活的互斥锁包装器，它允许你在需要时手动锁定和解锁，也可以在构造函数和析构函数中自动锁定和解锁。</p><p><code>std::lock_guard：</code>std::lock_guard 是另一个互斥锁包装器，但它只支持自动锁定和解锁。一旦 std::lock_guard 对象被创建，它会自动锁定互斥锁，并在其生命周期结束时自动解锁。</p><p><code>std::recursive_mutex：</code>递归互斥锁允许同一线程多次获得锁。这对于某些特定的情况很有用，但要小心避免死锁。</p><p><code>std::shared_mutex：</code>共享互斥锁（C++17引入）允许多个线程同时读取共享资源，但只有一个线程可以写入资源。这有助于提高并发性能。</p><p><code>std::condition_variable：</code>条件变量用于线程之间的同步和通信。它们允许一个线程等待某个条件成立，然后另一个线程发出信号以通知等待线程。</p><h2 id="实现线程的交替打印："><a href="#实现线程的交替打印：" class="headerlink" title="实现线程的交替打印："></a>实现线程的交替打印：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_THREADS = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM_ITERATTIONS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">std::mutex mtx; <span class="comment">// 锁，用于线程同步</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量，用于线程通信</span></span><br><span class="line"><span class="type">int</span> current_thread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> thread_num, <span class="type">const</span> std::string&amp; messages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_ITERATTIONS; ++i) &#123;</span><br><span class="line">        <span class="comment">// 获取锁，进入临界区</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是当前线程，就等待</span></span><br><span class="line">        <span class="keyword">while</span> (current_thread != thread_num) &#123;</span><br><span class="line">            cv.<span class="built_in">wait</span>(lock); <span class="comment">// 释放锁，允许其他线程进入临界区</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        std::cout &lt;&lt; messages &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改当前线程的编号</span></span><br><span class="line">        current_thread = (current_thread + <span class="number">1</span>) % NUM_THREADS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知下一个线程开始打印</span></span><br><span class="line">        cv.<span class="built_in">notify_all</span>(); <span class="comment">// 这里并没有释放锁，当前线程仍然持有锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::thread threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i] = std::<span class="built_in">thread</span>(print, i, <span class="string">&quot;Thread &quot;</span> + std::<span class="built_in">to_string</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i) &#123;</span><br><span class="line">        threads[i].<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o <span class="built_in">test</span> -pthread</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么使用条件变量唤醒的时候要用while而不用if？"><a href="#为什么使用条件变量唤醒的时候要用while而不用if？" class="headerlink" title="为什么使用条件变量唤醒的时候要用while而不用if？"></a>为什么使用条件变量唤醒的时候要用while而不用if？</h3><p>条件变量在等待期间可能会收到虚假唤醒（spurious wakeups），也就是在条件尚未满足时，线程被唤醒。</p><p>虚假唤醒是由于操作系统或底层线程库的实现细节引起的，他们可能会偶尔导致条件变量的信号量被错误唤醒。所以要循环检查，直到条件不满足。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程同步和线程通信&quot;&gt;&lt;a href=&quot;#线程同步和线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程同步和线程通信&quot;&gt;&lt;/a&gt;线程同步和线程通信&lt;/h2&gt;&lt;h3 id=&quot;线程同步&quot;&gt;&lt;a href=&quot;#线程同步&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>CS50</title>
    <link href="http://example.com/2023/10/08/cs50/"/>
    <id>http://example.com/2023/10/08/cs50/</id>
    <published>2023-10-08T03:26:51.000Z</published>
    <updated>2023-10-08T09:08:20.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="Computational-Thinking"><a href="#Computational-Thinking" class="headerlink" title="Computational Thinking"></a>Computational Thinking</h3><ul><li>input –&gt; black box –&gt; output</li><li>binary&#x2F;bit: A bit is a zero or one</li><li>text: using ASCII</li><li>Emojis: Unicode</li><li>RGB: three numbers</li><li>Images, Video and Sound are simply collections of RGB values</li></ul><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><ul><li>Problem-solving is central to computer science and computer programming</li></ul><h3 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h3><ul><li>function：pick up</li><li>conditions：if elseif</li><li>Boolean expression</li><li>loops：for&#x2F;while</li></ul><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p><strong>command line interface</strong>：CLI， send commands to the computer</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">make hello</span><br><span class="line">./hello</span><br></pre></td></tr></table></figure><p><em>这里并没有写makefile文件，为什么可以直接编译呢？</em><br><em>make程序默认会根据源代码文件的后缀名，自动生成并使用一个默认的Makefile规则进行编译。对于c语言的源代码，会有一个默认规则，类似如下：</em></p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">%.o : %.c <span class="comment"># % 是通配符，匹配任意字符串，匹配所有.c结尾的文件，生成以.o结尾的目标文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="comment"># $(CC) 变量，使用CC编译器。 $(CFLAGS)编译参数， -c表示进行编译而不链接， $&lt; 取出第一个前置文件的名字，即.c文件，-o指定输出目标文件，&amp;@ 取出目标文件的名字，既.o文件</span></span><br></pre></td></tr></table></figure><p>这里提到一个进行编译而不链接。回顾一下c语言编译的过程</p><ol><li>预处理，生成扩展后的.i文件。删除所有注释、#define 宏展开、文件包含 #include&lt;文件名&gt;</li><li>编译，汇编代码文件.s。会进行语法检查</li><li>组装。将汇编文件转化为机器码。生成.o文件</li><li>链接。链接是将库文件包含在我们的程序中的过程。生成可执行文件.out</li></ol><p><strong>静态成员变量是在哪一个阶段被初始化的呢？</strong></p><p><em>我们都知道静态成员变量是在运行<code>main</code>函数前初始化，那么究竟是在编译的哪一个阶段呢？</em></p><ol><li>定义在类内部的静态成员变量,其初始化是在编译期初期完成的。</li><li>定义在类外部的静态成员变量,其初始化是在链接阶段完成的。</li></ol><p>区别在于:</p><p>对于类内部定义的静态成员变量,编译器可以在编译当前类的定义时直接初始化它。</p><p>而对于类外部定义的静态成员变量,需要到链接阶段不同的目标文件合并时,由链接器完成初始化操作。</p><p><strong>预编译阶段，编译器会把#include包含的头文件内容展开Inline，但是对于lib库的引用则不会展开，而是保留该引用。真正使用库里的目标文件是在链接阶段。由链接器解析引用，并从外部库获取目标代码进行连接。</strong></p><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>linear and binary search</li><li>data structures</li><li>sorting</li><li>recursion</li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><strong>内存地址为什么用16进制存放？</strong></p><ol><li>紧凑表示：使用尽可能少的数字来表示较大的内存空间</li><li>与CPU寻址匹配： CPU使用总线地址线表示内存地址，地址线数量是2的指数倍（如8条、16条），这与16进制表示是匹配的</li><li>转换为二进制方便，16进制中的每一个恰好对应2进制中的4位，可以非常方便的转换为二进制数。</li></ol><h3 id="pointer"><a href="#pointer" class="headerlink" title="pointer"></a>pointer</h3><p>指针的本质就是一个地址变量。指向的是操作系统给模拟出来的虚拟内存空间的地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a; <span class="comment">// p是一个指针，(*p)表示获取指针所指向的值，&amp;符合代表取地址</span></span><br></pre></td></tr></table></figure><p>在c语言中<br><code>string</code>类型本质就是一个指针，以<code>&#39;\0&#39;</code>位标识符结尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;HI!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">0</span>]); <span class="comment">// H</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">1</span>]); <span class="comment">// I</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">2</span>]); <span class="comment">// !</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">3</span>]); <span class="comment">// </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>,s[<span class="number">4</span>]); <span class="comment">// %</span></span><br></pre></td></tr></table></figure><p>为什么没有提示数组越界呢？</p><p><em>在c语言中数组边界检查并不是强制的。所以这访问越界并没有报错，但是可能会导致其他问题。当访问s[3]之后的值时，读取的是垃圾内存的值。</em></p><h3 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h3><p>valgrind是一个检查是否有内存泄漏的工具，比如使用malloc但是没有使用free。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    x[<span class="number">0</span>] = <span class="number">72</span>;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">73</span>;</span><br><span class="line">    x[<span class="number">2</span>] = <span class="number">33</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>make test</code></p><p><code>valgrind --leak-check=full ./test</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==61782== HEAP SUMMARY:</span><br><span class="line">==61782==     in use at exit: 12 bytes in 1 blocks</span><br><span class="line">==61782==   total heap usage: 1 allocs, 0 frees, 12 bytes allocated</span><br><span class="line">==61782== </span><br><span class="line">==61782== 12 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">==61782==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)</span><br><span class="line">==61782==    by 0x10915E: main (in /home/kelin/cs50/test)</span><br></pre></td></tr></table></figure><p><strong>valgind可以检查哪些类型的错误呢？</strong></p><ol><li>内存管理错误：访问越界、未释放、访问未初始化的内存等</li><li>线程错误：程序未正确join线程、线程同步错误（多个线程争用资源未加锁）</li><li>I&#x2F;O操作错误：文件描述符泄漏、socket使用错误</li><li>未定义行为：访问未初始化的变量</li></ol><h3 id="在c语言中，打开文件是如何实现的？"><a href="#在c语言中，打开文件是如何实现的？" class="headerlink" title="在c语言中，打开文件是如何实现的？"></a>在c语言中，打开文件是如何实现的？</h3><ol><li>open系统调用</li><li>分配文件描述符：文件描述符是内核用来标识这个文件打开状态的整数</li><li>更新文件表：将文件描述符放入进程的文件描述符表，该表维护了进程打开文件的状态</li><li>返回文件描述符：open系统调用返回文件描述符给应用程序</li><li>read&#x2F;write调用</li><li>关闭</li></ol><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p><strong><code>curl</code></strong></p><p>curl用来发送各种HTTP请求，获取或传输数据。</p><table><thead><tr><th>参数</th><th>作用</th><th>例子</th></tr></thead><tbody><tr><td>-X</td><td>指定http请求的方法</td><td>-X GET</td></tr><tr><td>-d</td><td>指定发送的数据体</td><td>-d ‘data&#x3D;test’</td></tr><tr><td>-I</td><td>只显示响应头信息，不显示响应内容</td><td></td></tr><tr><td>-w</td><td>将响应头信息保存到文件</td><td></td></tr><tr><td>-O</td><td>将服务器访问保存为文件</td><td>curl -O example.com&#x2F;file1.zip</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;&lt;h3 id=&quot;Computational-Thinking&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>执行一个程序的过程</title>
    <link href="http://example.com/2023/08/25/exec-program/"/>
    <id>http://example.com/2023/08/25/exec-program/</id>
    <published>2023-08-25T10:09:26.000Z</published>
    <updated>2023-10-11T05:33:07.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><ul><li>运算器</li><li>控制器</li><li>存储器</li><li>输入设备</li><li>输出设备</li></ul><p><img src="/../imgs/image-44.png" alt="图来源于小林coding"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>程序和数据都是存储在内存中，存储的区域是线性的。存储数据的基本单位是<strong>字节（byte）</strong>，一字节等于8位（bit），每一个字节对应着一个内存地址。</p><h3 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h3><p>32位和64位CPU最主要区别在于一次能计算多少字节的数据</p><ul><li>32位一次能计算4个字节，虚拟内存空间大小为$2^{32}$，4G</li><li>64位一次能计算8个字节</li></ul><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><ul><li>通用寄存器：用来存放需要进行运算的数据(执行单元)</li><li>程序计数器：用来存储CPU要执行下一条指令所在的内存地址（此时指令仍然在内存中）（控制单元）</li><li>指令寄存器：用来存放正在执行的指令（控制单元）</li></ul><h3 id="存储器接口-Memory-Interface"><a href="#存储器接口-Memory-Interface" class="headerlink" title="存储器接口(Memory Interface)"></a>存储器接口(Memory Interface)</h3><p>与内存交互,读写数据。</p><h4 id="控制单元"><a href="#控制单元" class="headerlink" title="控制单元"></a>控制单元</h4><p>提取指令、解析指令、产生控制信号。</p><h4 id="执行单元-Execution-Unit"><a href="#执行单元-Execution-Unit" class="headerlink" title="执行单元(Execution Unit)"></a>执行单元(Execution Unit)</h4><p>包含算术逻辑单元ALU和通用寄存器组,执行各种运算和数据处理。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li>地址总线：用于指定CPU将要操作的内存地址</li><li>数据总线：用于读写内存的数据</li><li>控制总线：用于发送和接收信号</li></ul><p>通过地址总线来指定内存内存的地址–&gt;通过控制总线控制是读或写命令–&gt;通过数据总线传输数据。</p><h2 id="程序是如何执行的？"><a href="#程序是如何执行的？" class="headerlink" title="程序是如何执行的？"></a>程序是如何执行的？</h2><p><img src="/../imgs/image-45.png"></p><p>指令：一串二进制数字的机器码，不同的CPU有不同的指令集</p><p><strong>指令是存放在虚拟内存里还是物理内存中？</strong></p><p>虚拟内存为每个进程提供一片连续的虚拟地址空间，各进程的虚拟地址空间是独立的，指令与数据位于不同进程的虚拟地址空间中，因此多个进程共同执行时，他们的指令集不会交叉。</p><p><strong>那么程序计数器加1的时候，是加的虚拟内存还是实际内存？CPU直接操作的是实际内存还是虚拟内存？</strong></p><p>程序计数器加1时,它加的都是虚拟地址。CPU在执行程序时,直接操作和访问的也都是虚拟地址,而不是实际物理地址。</p><ol><li>CPU送出的下一条指令虚拟地址到MMU</li><li>MMU根据页表查找虚拟地址到物理地址的映射</li><li>若对应页不在物理内存，则触发缺页中断，os将其从磁盘换入</li><li>MMU最终将虚拟地址翻译为物理地址，从物理地址中读取指令后，将指令发送至CPU</li><li>CPU执行该指令</li><li>程序计数器中的虚拟地址+1</li></ol><h3 id="对于一个C-程序而言，是如何把代码变成指令集的？"><a href="#对于一个C-程序而言，是如何把代码变成指令集的？" class="headerlink" title="对于一个C++程序而言，是如何把代码变成指令集的？"></a>对于一个C++程序而言，是如何把代码变成指令集的？</h3><h4 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing)"></a>预处理(Preprocessing)</h4><p>预编译器处理头文件包含、宏定义展开等预处理工作,生成扩展后的源代码。<code>#define</code></p><h4 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation)"></a>编译(Compilation)</h4><p>编译器将预处理后的C++源代码编译成汇编语言。这个过程包括词法分析、语法分析、语义分析、中间代码生成、目标代码生成等步骤。内联函数会被直接插入到每一个调用点，省去了函数调用的过程。</p><h4 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h4><p>汇编程序将汇编语言转换成机器语言,生成目标文件。</p><h4 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接(Linking)"></a>链接(Linking)</h4><p>链接器将多个目标文件和系统库链接生成完整的可执行程序。</p><p>在这个过程中,C++源代码经过编译器的编译和汇编程序的汇编,最终被转换成机器指令,这些指令保存在可执行文件的代码段,可以直接被CPU执行。</p><h3 id="编译前和编译后代码是存放在哪里？"><a href="#编译前和编译后代码是存放在哪里？" class="headerlink" title="编译前和编译后代码是存放在哪里？"></a>编译前和编译后代码是存放在哪里？</h3><h4 id="编译前"><a href="#编译前" class="headerlink" title="编译前:"></a>编译前:</h4><p>源代码以文本文件的形式存储在文件系统中,使用高级语言编写,对人更友好。</p><p>源代码包含了数据结构定义、算法流程、程序逻辑等信息。但不能直接被计算机执行。</p><h4 id="编译后："><a href="#编译后：" class="headerlink" title="编译后："></a>编译后：</h4><p>经过编译器编译后,会生成机器代码,存放在可执行文件的代码段中。</p><p>机器代码使用机器指令组成,可以直接被CPU执行。</p><p>举个例子：当我调用<code>new</code>关键字去为一个对象分配内存时，在编译前这仅仅是一个抽象的概念，<strong>内存分配是在运行时发生的</strong>。</p><h3 id="在编译的时候，编译顺序是怎么样的？"><a href="#在编译的时候，编译顺序是怎么样的？" class="headerlink" title="在编译的时候，编译顺序是怎么样的？"></a>在编译的时候，编译顺序是怎么样的？</h3><p>以下面的代码为例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> <span class="comment">// 预处理阶段</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val)&#123;&#125; <span class="comment">// 构造函数和析构函数机器码</span></span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;&#125; <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="type">static</span> <span class="title">sFunc</span><span class="params">()</span></span>; <span class="comment">// 没有this指针，所以只能调用静态成员变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_val = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_val = <span class="number">1</span>; <span class="comment">// 所有实例共享，不属于类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Node <span class="title">node</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    Node * node_ptr = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    node.<span class="built_in">func</span>();</span><br><span class="line">    node_ptr.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">delete</span> node_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="main函数执行之前，需要做什么？"><a href="#main函数执行之前，需要做什么？" class="headerlink" title="main函数执行之前，需要做什么？"></a>main函数执行之前，需要做什么？</h3><ol><li>设置栈指针</li><li>初始化静态static变量和global变量。静态类的构造函数在这里被调用</li><li>初始化全局变量，全局对象的构造函数也在main之前被调用</li><li>将main函数所需参数传递给main函数</li></ol><h3 id="在main函数之后，需要执行什么？"><a href="#在main函数之后，需要执行什么？" class="headerlink" title="在main函数之后，需要执行什么？"></a>在main函数之后，需要执行什么？</h3><ol><li>全局对象的析构函数</li><li>可以使用<code>atexit</code>注册一个函数，会在main之后执行</li></ol><h3 id="静态成员函数也是放在代码区的吗？"><a href="#静态成员函数也是放在代码区的吗？" class="headerlink" title="静态成员函数也是放在代码区的吗？"></a>静态成员函数也是放在代码区的吗？</h3><p>是的。编译器会为静态成员函数生成对应的机器代码，不需要实例化类就可以调用，机器代码独立生成，不依赖任何实例。</p><h3 id="函数调用时是如何传递参数的？"><a href="#函数调用时是如何传递参数的？" class="headerlink" title="函数调用时是如何传递参数的？"></a>函数调用时是如何传递参数的？</h3><ol><li>把参数的值从寄存器或内存加载到CPU的通用寄存器中。</li><li>调用指令将程序控制流跳转到函数代码地址。</li><li>在跳转前,调用指令会将返回地址等寄存器信息压入调用栈,用于保留调用环境。</li><li>跳转执行函数代码,函数中的局部变量也可能在栈上分配。</li><li>在函数执行前,根据调用约定从寄存器或栈空间中读取参数值。</li><li>函数执行完后,使用返回指令跳回调用点。</li><li>返回前依照调用约定将返回值写入寄存器或内存。</li><li>返回后,调用栈恢复,继续执行调用代码。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冯诺依曼模型&quot;&gt;&lt;a href=&quot;#冯诺依曼模型&quot; class=&quot;headerlink&quot; title=&quot;冯诺依曼模型&quot;&gt;&lt;/a&gt;冯诺依曼模型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;运算器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;输入设备&lt;/li&gt;</summary>
      
    
    
    
    
    <category term="os" scheme="http://example.com/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency Control</title>
    <link href="http://example.com/2023/08/21/Concurrency-Control/"/>
    <id>http://example.com/2023/08/21/Concurrency-Control/</id>
    <published>2023-08-21T04:39:32.000Z</published>
    <updated>2023-08-24T06:19:12.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="project4需要实现的内容"><a href="#project4需要实现的内容" class="headerlink" title="project4需要实现的内容"></a>project4需要实现的内容</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/project4/">project任务链接</a></p><h3 id="Lock-Manager："><a href="#Lock-Manager：" class="headerlink" title="Lock Manager："></a>Lock Manager：</h3><p><code>src/include/concurrency/lock_manager.h</code></p><p><code>concurrency/lock_manager.cpp</code></p><h4 id="Lock-Manager的作用是什么？"><a href="#Lock-Manager的作用是什么？" class="headerlink" title="Lock Manager的作用是什么？"></a>Lock Manager的作用是什么？</h4><p>Lock Manager 的作用是处理事务发送的锁请。事务在被允许访问某个数据项之前,需要先向锁管理器发出锁请求。锁管理器将向调用事务授予锁,阻塞该事务,或者中止它。</p><p>例如有一个 SeqScan 算子需要扫描某张表，其所在事务就需要对这张表加 S 锁。而加读锁这个动作需要由 Lock Manager 来完成。事务先对向 Lock Manager 发起加 S 锁请求，Lock Manager 对请求进行处理。如果发现此时没有其他的锁与这个请求冲突，则授予其 S 锁并返回。如果存在冲突，例如其他事务持有这张表的 X 锁，则 Lock Manager 会阻塞此请求（即阻塞此事务），直到能够授予 S 锁，再授予并返回。</p><p>整个系统将具有一个全局的锁管理器(类似于缓冲池管理器)。TableHeap和Executor类将使用你实现的锁管理器在事务想访问或修改一个元组记录时获取行锁(通过记录ID RID)。</p><p>这个任务要求实现一个支持三种常见隔离级别的表级锁和行级锁:READ_UNCOMMITTED, READ_COMMITTED和REPEATABLE_READ。锁管理器应该根据事务的隔离级别授予或释放锁。请参考课件复习隔离级别。</p><p>在代码库中,提供了一个Transaction上下文处理(transaction.h),其中包含隔离级别属性和它持有的锁的相关信息。锁管理器需要检查事务的隔离级别并公开在锁请求上的正确行为。任何失败的锁操作都应导致事务进入ABORTED状态(隐式中止)并抛出异常。事务管理器(transaction_manager.h)会进一步捕获这个异常并回滚事务执行的写操作。</p><h4 id="三种隔离级别的实现"><a href="#三种隔离级别的实现" class="headerlink" title="三种隔离级别的实现"></a>三种隔离级别的实现</h4><ul><li>READ_UNCOMMITED只有在需要时上写锁。</li><li>READ_COMMITTED要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。</li><li>REPEATABLE_READ进一步打造可重复读。同一事务读两次数据的中途不想被其他事务的写干扰，这就需要用到巧妙的二段封锁协议（2PL）了：事务分为两个阶段（不考虑commit&#x2F;abort），上锁阶段(GROWING)只上锁，解锁阶段(SHINKING)只解锁。这样，第二次读取时，前一次读取的读锁一定还在，避免了中途被修改。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REPEATABLE_READ:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   No locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_COMMITTED:</span><br><span class="line">   The transaction is required to take all locks.</span><br><span class="line">   All locks are allowed in the GROWING state</span><br><span class="line">   Only IS, S locks are allowed in the SHRINKING state</span><br><span class="line">   </span><br><span class="line">READ_UNCOMMITTED:</span><br><span class="line">   The transaction is required to take only IX, X locks.</span><br><span class="line">   X, IX locks are allowed in the GROWING state.</span><br><span class="line">   S, IS, SIX locks are never allowed</span><br></pre></td></tr></table></figure><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>由于对行添加S&#x2F;X锁时，需要对应的对行所在的表添加IS&#x2F;IX锁，所以需要记录每一个表里有哪些行被加锁。</p><p>这里用一个map来实现对应表id和行集合。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** LockManager: the set of row locks held by this transaction. */</span></span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; s_row_lock_set_;</span><br><span class="line">std::shared_ptr&lt;std::unordered_map&lt;<span class="type">table_oid_t</span>, std::unordered_set&lt;RID&gt;&gt;&gt; x_row_lock_set_;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/image-43.png"></p><p><strong>获取表锁</strong></p><ol><li>判断锁请求是否合理(如果当前事务Abort&#x2F;Commit，或者加锁类型与事务隔离级别不符合，抛异常)</li><li>从 <code>table_lock_map_</code> 中获取 table 对应的 <code>lock request queue</code>。注意需要对 map 加锁，并且为了提高并发性，在获取到 queue 之后立即释放 map 的锁。若 queue 不存在则创建。</li><li>判断之前该事务是否对这个表进行加过锁</li><li>如果之前加过锁，升级该锁（级别不能比当前的锁的级别要低且不能有另一个事务也在对这个表进行升级），创建一个新的LockRequest，加入到队列尾部</li><li>尝试获取锁，如果<code>GrantLock()</code>为真，可以获取锁，否则循环等待，这里使用条件变量<code>queue-&gt;cv_.wait(queue-&gt;latch_);</code>, 当这个锁被释放时，会唤醒当前线程，判断是否能获取锁。</li></ol><p><strong>GrantLock()</strong></p><ol><li>判断当前的锁请求是否与所有的<code>granted</code>的请求兼容</li><li>判断优先级</li></ol><p>tips：</p><p>使用条件变量去通知请求队列上等待的线程。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LockRequestQueue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** List of lock requests for the same resource (table or row) */</span></span><br><span class="line">  std::list&lt;LockRequest *&gt; request_queue_;</span><br><span class="line">  <span class="comment">/** For notifying blocked transactions on this rid */</span></span><br><span class="line">  std::condition_variable cv_;</span><br><span class="line">  <span class="comment">/** txn_id of an upgrading transaction (if any) */</span></span><br><span class="line">  <span class="type">txn_id_t</span> upgrading_ = INVALID_TXN_ID;</span><br><span class="line">  <span class="comment">/** coordination */</span></span><br><span class="line">  std::mutex latch_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解表锁：</strong></p><ol><li>判断可以不可以解锁：之前是否加过锁，如果是解锁表锁，要检测该表中有没有行被加过锁</li><li>检查在对应隔离级别下是否要进入Shrinking状态</li><li>删除锁</li></ol><p>行锁与表锁类似，解锁时不需要检查是否有表锁。</p><h3 id="Deadlock-Detection："><a href="#Deadlock-Detection：" class="headerlink" title="Deadlock Detection："></a>Deadlock Detection：</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/** Waits-for graph representation. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">txn_id_t</span>, std::vector&lt;<span class="type">txn_id_t</span>&gt;&gt; waits_for_;</span><br></pre></td></tr></table></figure><p>并不需要时刻维护wait for图，而是在死锁检测线程被唤醒的时候，根据当前请求队列构建的wait for图，再通过这个图去判断是否存在死锁。</p><ul><li>当检测到有圈时，这里采取的victim策略是找到事务ID最大的返回，因为这个事务是最年轻的。</li><li>默认的检测时间是50ms</li></ul><h3 id="Concurrent-Query-Execution"><a href="#Concurrent-Query-Execution" class="headerlink" title="Concurrent Query Execution"></a>Concurrent Query Execution</h3><p>这里需要修改之前的三个算子，顺序扫描、插入和删除。</p><p>tips：</p><ul><li>添加行锁之前需要对相应的表添加意向锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;project4需要实现的内容&quot;&gt;&lt;a href=&quot;#project4需要实现的内容&quot; class=&quot;headerlink&quot; title=&quot;project4需要实现的内容&quot;&gt;&lt;/a&gt;project4需要实现的内容&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://1</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Concurrency study note</title>
    <link href="http://example.com/2023/08/21/concurrency_notes/"/>
    <id>http://example.com/2023/08/21/concurrency_notes/</id>
    <published>2023-08-21T04:39:32.000Z</published>
    <updated>2023-08-25T10:10:17.049Z</updated>
    
    <content type="html"><![CDATA[<p>在做project4之前，最好是先学习课件内容。<br><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf">课件地址</a></p><p>Concurrency Control：avoid losting updates</p><p>Recovery： Durability</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>A transaction is the execution of a sequence of  one or more operations (e.g., SQL queries) on a database to perform some higher-level function.</p><p>Move $100 from Andy’s bank account to his bookie’s account.</p><p>Transaction:</p><ul><li>Check whether Andy has $100.</li><li>Deduct $100 from his account.</li><li>Add $100 to his bookie’s account</li></ul><p>一个事务包含了许多操作，如果是并发执行事务时，就可能会导致很多问题。</p><h4 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h4><p>A new txn starts with the <code>BEGIN</code> command.</p><p>The txn stops with either <code>COMMIT</code> or <code>ABORT</code></p><ul><li>If commit, the DBMS either saves all the txn’s changes<br>or aborts it.</li><li>If abort, all changes are undone so that it’s like as if the<br>txn never executed at all.</li></ul><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性：所有操作要么全部完成，要么全部不完成。undo log(回滚日志)</li><li>隔离性：多个事务并发修改，不会互相干扰。MVCC（多版本并发机制）</li><li>持久性：事务处理结束后，对事务的修改是永久的。redo log（重做日志）</li><li>一致性：事务操作前和操作后，数据库保持一致性</li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul><li>脏读：读取到未提交的</li><li>不可重复读：在一个事务内多次读取同一个数据，前后读取的数据不一致</li><li>幻读：在一个事务内多次查询某个符合查询条件的「记录数量」，前后读取的记录数量不一致</li></ul><p><strong>隔离级别：</strong></p><ul><li>读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>读提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；— 解决脏读问题</li><li>可重复读（repeatable read），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； — 解决不可重复读问题</li><li>串行化（serializable ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； — 解决幻读问题</li></ul><p><strong>五种锁：</strong></p><ul><li>意向共享锁(IS):表示事务想要获得共享锁,与其他意向锁兼容,与排它锁冲突。用共享锁锁了里面的某些记录</li><li>意向排它锁(IX):表示事务想要获得排它锁,与其他所有锁模式冲突。用排他锁锁了表里的某些记录</li><li>共享锁(S):允许多个事务同时持有同一资源的共享锁,相互兼容。</li><li>排它锁(X):只允许一个事务持有排它锁,与所有其他锁冲突。</li><li>共享意向排他锁(SIX):表示持有共享锁的同时,想要获得排它锁,与排它锁冲突。用共享锁锁了整个表，用排他锁锁了里面的某些记录</li></ul><h3 id="锁管理器"><a href="#锁管理器" class="headerlink" title="锁管理器"></a>锁管理器</h3><p>管理锁的请求<br><img src="/../imgs/image-30.png" alt="Alt text"></p><p><strong>过程：</strong></p><ol><li>Transactions request locks (or upgrades).</li><li>Lock manager grants or blocks requests.</li><li>Transactions release locks.</li><li>Lock manager updates its internal lock-table.<br> It keeps track of what transactions hold what locks and what transactions are waiting to acquire any locks.</li></ol><h3 id="两阶段锁-2PL"><a href="#两阶段锁-2PL" class="headerlink" title="两阶段锁 2PL"></a>两阶段锁 2PL</h3><h4 id="Growing"><a href="#Growing" class="headerlink" title="Growing"></a>Growing</h4><p>只能加锁</p><h4 id="Shrinking"><a href="#Shrinking" class="headerlink" title="Shrinking"></a>Shrinking</h4><p>只能解锁</p><p>示意图：</p><p><img src="/../imgs/image-32.png"></p><p>但是无法避免接连回滚问题：这里事务一进入Shrinking阶段后，并没有提交，而是ABORT，最终回滚，由于事务二用的是事务一修改后的数据，也需要跟着回滚。</p><p><img src="/../imgs/image-33.png"></p><p>粗暴的解决方法：所有的锁都在commit的时候解锁，能解决脏读问题。</p><p><strong>但是可能出现死锁：</strong></p><p><img src="/../imgs/image-34.png"></p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><p>使用waits-for graph</p><ul><li>node：事务</li><li>edge：Ti to Tj表示Ti在等到Tj释放锁</li></ul><p>如果图种产生了环，需要解开环。<br><img src="/../imgs/image-35.png"></p><p>解开环：选择一个事务victim(abort or restart)</p><ul><li>根据执行时间选择（执行时间短的）</li><li>执行的SQL语句的多少</li><li>已经加了多少把锁</li><li>被回滚过多少次</li></ul><p><strong>回滚策略：</strong> victim完全回滚 or 回滚某些语句</p><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h4><ul><li>独占资源</li><li>不可剥夺</li><li>占用并等待</li><li>循环引用</li></ul><h4 id="破坏其中的某一条"><a href="#破坏其中的某一条" class="headerlink" title="破坏其中的某一条"></a>破坏其中的某一条</h4><p>Assign priorities based on timestamps:</p><ul><li>Older Timestamp &#x3D; Higher Priority (e.g., T1 &gt; T2)</li></ul><p><img src="/../imgs/image-36.png"></p><p>两个事务不会互相等待。</p><p>为了避免饥饿，新的被kill掉之后，时间戳沿用以前的。</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>行锁？表锁？间隙锁？</p><ul><li>更少的锁的数量？粒度大，加锁的开销</li><li>更好的并发？粒度小</li></ul><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>并不是真的锁，只是一个意向。比如表A种某一个tuple被加了锁，此时需要对表A加意向锁，表示比表A粒度更细的内容被加了所，不能再对表A加表锁。</p><p><img src="/../imgs/image-38.png"></p><p>例如：要对Tuple1加S锁，需要先对Table R加IS锁</p><p><img src="/../imgs/image-39.png"> </p><p>两阶段锁是悲观锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><a href="https://15445.courses.cs.cmu.edu/fall2022/slides/17-timestampordering.pdf">课件地址</a></p><p>根据时间戳排序，如果A的时间戳小与B的时间戳，那么最后执行的效果等于A先执行完B再去执行。</p><p>时间戳来源：</p><ul><li>系统时钟（可能不准确）</li><li>逻辑计数器，比如从1递增，分布式校准难</li><li>Hybrid：结合</li></ul><p>每一个记录X都需要有两个时间戳：</p><ul><li><code>W-TS(x)</code> - 上一次被写的时间戳</li><li><code>R-TS(x)</code> - 上一次被读的时间戳</li></ul><p>基准：<strong>不能操作来自未来的数据</strong></p><p>读数据：</p><p><img src="/../imgs/image-40.png"></p><p>写数据：数据的任何操作都应该发生在过去</p><p><img src="/../imgs/image-41.png"></p><h3 id="THOMAS-WRITE-RULE"><a href="#THOMAS-WRITE-RULE" class="headerlink" title="THOMAS WRITE RULE"></a>THOMAS WRITE RULE</h3><p>如果我们当前要修改的数据A已经被未来的事务所修改，那么我们忽视写这个操作，因为现在写了一定会被未来写的数据所覆盖掉。</p><p><img src="/../imgs/image-42.png"></p><ul><li>乐观锁不存在死锁，因为没有锁也没有等待</li><li>长事务可能会饥饿，因为有可能碰到的所有数据都被未来的事务所修改</li><li>必须要保证所有的修改都是在已经提交的基础上</li></ul><p>可能会读取到别人未提交的。</p><h3 id="乐观的并发"><a href="#乐观的并发" class="headerlink" title="乐观的并发"></a>乐观的并发</h3><p>每一个事务都有一个workspace，所有的修改都在当前这个workspace进行，当事务提交时，DBMS对比workspace写集合，查看是否与其他事务冲突，没有冲突就写入原始数据库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在做project4之前，最好是先学习课件内容。&lt;br&gt;&lt;a href=&quot;https://15445.courses.cs.cmu.edu/fall2022/slides/15-concurrencycontrol.pdf&quot;&gt;课件地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Concurre</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 Query_Execution</title>
    <link href="http://example.com/2023/08/17/Query-Execution/"/>
    <id>http://example.com/2023/08/17/Query-Execution/</id>
    <published>2023-08-17T07:50:33.000Z</published>
    <updated>2023-08-25T10:10:23.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="执行引擎介绍"><a href="#执行引擎介绍" class="headerlink" title="执行引擎介绍"></a>执行引擎介绍</h2><p><strong>一条SQL语句进入到数据库中后是如何被执行的？</strong></p><p><img src="/../imgs/image-23.png" alt="来源于小林coding"></p><p>前两个project实现的buffer pool和index都是存储引擎的一部分。</p><p>执行计划可以看作一个有向无环图，由source开始到sink结束，中间是一个又一个的算子。这一个project实现的就是这些算子。</p><p>课件地址：<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/10-sorting.pdf</a></p><h2 id="processing-model"><a href="#processing-model" class="headerlink" title="processing model"></a>processing model</h2><p>A DBMS’s processing model defines how the system executes a query plan.</p><p>→ Different trade-offs for different workloads.</p><h3 id="Iterator-Model"><a href="#Iterator-Model" class="headerlink" title="Iterator Model"></a>Iterator Model</h3><p>每个运算符实现一个iterator接口,产生一行输出就调用下个运算符,逐行传递数据。或 Pipeline Model，或火山模型。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。</p><p>即时输出查询结果,不需要存储和载入大量中间状态。<br>易于实现,类似拉模式,但执行效率低。</p><h3 id="Materialization-Model"><a href="#Materialization-Model" class="headerlink" title="Materialization Model"></a>Materialization Model</h3><p>每个运算符将中间结果完全 Materialize 产生,存储在临时表中。<br>下个运算符从临时表中读取输入数据。<br>效率高,可最大化利用批处理,但需要更多存储空间。</p><h3 id="Vectorized-Batch-Model"><a href="#Vectorized-Batch-Model" class="headerlink" title="Vectorized&#x2F;Batch Model"></a>Vectorized&#x2F;Batch Model</h3><p>运算符以批(向量)为单位处理数据,减少解释器调度开销。<br>输入数据存放在列式存储中,易于向量化操作。<br>并行计算批数据,可利用现代CPU指令集。<br>兼具Iterator和Materialization方法的优点。现在大部分OLAP数据库使用这种方法。</p><p>在bustub中使用的是Iterator Model。</p><p>比如这个join的例子，查询时数据自下而上流动，通过父节点调用子节点的<code>Next()</code>方法。在根节点处得到最终值。</p><p><img src="/../imgs/image-27.png"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>对于每一个算子，我们需要补充构造函数、<code>Init()</code>函数和<code>Next()</code>函数，注意<code>Next()</code>函数如果返回值，这里只返回一条，通过传出参数实现，返回<code>Tuple</code>和<code>rid</code>。</p><p><strong>这些信息是如何得到的？</strong></p><p>在顺序扫描算子中，构造函数提供了两个参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SeqScanExecutor::<span class="built_in">SeqScanExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> SeqScanPlanNode *plan) : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>ExecutorContext和SeqScanPlanNode，首先要搞明白执行上下文都包括什么东西？</p><p><img src="/../imgs/exec_ctx.png"></p><p>最终的原始数据都在<code>Tuple</code>中，也代表着OLTP数据库中的一行数据。</p><p><strong>SeqScanPlanNode</strong>，执行计划的一个结点应该包含哪些东西？</p><p>output_schema是用来表示执行计划结点的输出模式。输出元组包含哪些列, 每列的类型和名称是什么。这为下游运算符解析和处理数据提供信息。</p><p><img src="/../imgs/plannode.png"></p><p>bustub提供了一个迭代器<code>TableIterator</code>，用来遍历<code>TableHeap</code>。根据上面的ctx包含的内容和plan包含的内容可以一层层拆解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_id = plan_-&gt;<span class="built_in">GetTableOid</span>();</span><br><span class="line">table_info = ctx-&gt;<span class="built_in">GetCatalog</span>()-&gt;<span class="built_in">GetTable</span>(table_id);</span><br><span class="line">table_heap = table_info-&gt;table_.<span class="built_in">get</span>();</span><br><span class="line">table_iter_ = table_heap_-&gt;<span class="built_in">Begin</span>(ctx-&gt;<span class="built_in">GetTransaction</span>());</span><br><span class="line">*table_iter_=tuple;</span><br><span class="line">rid=tuple-&gt;<span class="built_in">GetRid</span>();</span><br></pre></td></tr></table></figure><h2 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h2><h4 id="顺序扫描-src-execution-seq-scan-executor-cpp"><a href="#顺序扫描-src-execution-seq-scan-executor-cpp" class="headerlink" title="顺序扫描 src/execution/seq_scan_executor.cpp"></a>顺序扫描 <code>src/execution/seq_scan_executor.cpp</code></h4><p>在有了前面的铺垫后，顺序扫描的<code>Next()</code>实现就非常简单，只需要返回迭代器指向的<code>Tuple</code>即可。</p><h3 id="插入-src-execution-insert-executor-cpp"><a href="#插入-src-execution-insert-executor-cpp" class="headerlink" title="插入 src/execution/insert_executor.cpp"></a>插入 <code>src/execution/insert_executor.cpp</code></h3><p>insert和delete是唯二的写算子。<br>插入这里多了一个参数<code>child_executor</code>, 右值传入。插入直接将tuple插入到table尾部，然后更新index。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InsertExecutor::<span class="built_in">InsertExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> InsertPlanNode *plan,</span><br><span class="line">                               std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child_executor)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx) &#123;&#125;</span><br></pre></td></tr></table></figure><p>因为要更新index，可以通过<code>Catelog-&gt;GetTableIndexes()</code>来获取所有包含这个table的index，这里使用<code>std::vector&lt;IndexInfo *&gt; indexes_;</code> 遍历indexes数组，将每一个index插入B+树即可。<br><code>bpIndex = ... index_.get()</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bpIndex = <span class="keyword">reinterpret_cast</span>&lt;BPlusTreeIndex&lt;GenericKey&lt;<span class="number">8</span>&gt;, RID, GenericComparator&lt;<span class="number">8</span>&gt;&gt; (index-&gt;index_.<span class="built_in">get</span>());</span><br><span class="line">bpIndex-&gt;<span class="built_in">InsertEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()), *rid, txn); <span class="comment">// insert into B+tree</span></span><br></pre></td></tr></table></figure><p>然后从子计划获取kv, 插入表中 TableHeap, 调用TableHeap中的插入方法即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">table_heap_-&gt;<span class="built_in">InsertTuple</span>(*tuple, rid, txn);</span><br></pre></td></tr></table></figure><h3 id="删除-src-execution-insert-executor-cpp"><a href="#删除-src-execution-insert-executor-cpp" class="headerlink" title="删除 src/execution/insert_executor.cpp"></a>删除 <code>src/execution/insert_executor.cpp</code></h3><p>删除几乎和插入一样，唯一不同的是把写记录换成删除记录，调用TableHeap中的删除方法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">txn-&gt;<span class="built_in">AppendIndexWriteRecord</span>(delete_record);</span><br><span class="line">bpIndex-&gt;<span class="built_in">DeleteEntry</span>(tuple-&gt;<span class="built_in">KeyFromTuple</span>(tinf-&gt;schema_, index-&gt;key_schema_, index-&gt;index_-&gt;<span class="built_in">GetKeyAttrs</span>()),*rid, txn);</span><br></pre></td></tr></table></figure><h3 id="索引扫描-src-execution-index-scan-executor-cpp"><a href="#索引扫描-src-execution-index-scan-executor-cpp" class="headerlink" title="索引扫描 src/execution/index_scan_executor.cpp"></a>索引扫描 <code>src/execution/index_scan_executor.cpp</code></h3><p>同样的，bustub封装了<code>IndexIterator</code>指针，用来遍历B+树。指向一个<code>std::pair&lt;KeyType, ValueType&gt;</code>类型。这里的value也就是rid，再通过rid获取tuple。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BPlusTreeIndexForOneIntegerColumn *tree_;</span><br><span class="line">BPlusTreeIndexIteratorForOneIntegerColumn index_iter_;</span><br></pre></td></tr></table></figure><h2 id="Task2-aggr-and-join"><a href="#Task2-aggr-and-join" class="headerlink" title="Task2 aggr and join"></a>Task2 aggr and join</h2><h3 id="聚合-src-execution-aggregation-executor-cpp"><a href="#聚合-src-execution-aggregation-executor-cpp" class="headerlink" title="聚合 src/execution/aggregation_executor.cpp"></a>聚合 <code>src/execution/aggregation_executor.cpp</code></h3><p>在<code>AggregationPlanNode</code>中多了这些参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">* Construct a <span class="keyword">new</span> AggregationPlanNode.</span><br><span class="line">   * @param output_schema The output format of <span class="keyword">this</span> plan node</span><br><span class="line">   * @param child The child plan to aggregate data over</span><br><span class="line">   * @param group_bys The group by clause of the aggregation</span><br><span class="line">   * @param aggregates The expressions that we are aggregating</span><br><span class="line">   * @param agg_types The types that we are aggregating</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在聚合执行器中有以下参数</span></span><br><span class="line">  <span class="comment">/** The aggregation plan node */</span></span><br><span class="line">  <span class="type">const</span> AggregationPlanNode *plan_;</span><br><span class="line">  <span class="comment">/** The child executor that produces tuples over which the aggregation is computed */</span></span><br><span class="line">  std::unique_ptr&lt;AbstractExecutor&gt; child_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table */</span></span><br><span class="line">  SimpleAggregationHashTable aht_;</span><br><span class="line">  <span class="comment">/** Simple aggregation hash table iterator */</span></span><br><span class="line">  SimpleAggregationHashTable::Iterator aht_iterator_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 构造函数需要改为</span></span><br><span class="line"></span><br><span class="line">AggregationExecutor::<span class="built_in">AggregationExecutor</span>(ExecutorContext *exec_ctx, <span class="type">const</span> AggregationPlanNode *plan,</span><br><span class="line">                                         std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;child)</span><br><span class="line">    : <span class="built_in">AbstractExecutor</span>(exec_ctx),</span><br><span class="line">      <span class="built_in">plan_</span>(plan),</span><br><span class="line">      <span class="built_in">child_</span>(std::<span class="built_in">move</span>(child)),</span><br><span class="line">      <span class="built_in">aht_</span>(plan-&gt;<span class="built_in">GetAggregates</span>(), plan-&gt;<span class="built_in">GetAggregateTypes</span>()),</span><br><span class="line">      <span class="built_in">aht_iterator_</span>(aht_.<span class="built_in">Begin</span>())&#123;&#125;</span><br></pre></td></tr></table></figure><p>聚合需要根据<code>group by</code>分组的结果来计算吗，所以这里需要建立一个哈希表用来存储中间结果。和之前每一次只吐一条数据不一样的是，这里必须要在<code>Init()</code>函数中把所有结果计算出来，再在<code> Next()</code> 中一条一条地 emit。所以实际上计算过程是在<code>Init()</code>函数中，通过：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   aht_.<span class="built_in">InsertCombine</span>(<span class="built_in">MakeAggregateKey</span>(&amp;tuple), <span class="built_in">MakeAggregateValue</span>(&amp;tuple));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后注意在<code>Next()</code>函数中，一个tuple可能要返回多个聚集的值，例如查询”SELECT SUM(A), MAX(B), COUNT(C) FROM table”就需要返回一个包含三个聚合结果的元组。所以内部是一个<code>vector</code>。没有返回rid是因为聚集之后产生了新结果，而不是原有的记录。</p><h3 id="inner-join-left-join-src-execution-nested-loop-join-executor-cpp"><a href="#inner-join-left-join-src-execution-nested-loop-join-executor-cpp" class="headerlink" title="inner join &amp; left join src/execution/nested_loop_join_executor.cpp"></a>inner join &amp; left join <code>src/execution/nested_loop_join_executor.cpp</code></h3><p><code>join</code>的时候也是需要建立hash表的，这里是根据join的key来建立哈希表，至于是左表建表还是右表建表，需要看数据库的具体实现。</p><h4 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h4><p>嵌套循环连接是连接算法的一种,它的基本原理是:</p><ul><li>外表和内表,其中外表是驱动表,内表是被驱动表。</li><li>通过外表循环遍历每一行。</li><li>对于外表的每一行,遍历内表找到匹配的行。</li><li>将匹配的外表行和内表行组合,产生连接结果。</li><li>外表的循环嵌套内表的循环,逐行进行连接处理。</li></ul><p>相比其他连接算法如哈希连接和排序合并连接,嵌套循环连接简单直接,但是当表大小不均衡时性能较差。<br>它适用于外表很小而内表较大的情况,或者当连接条件非常复杂时。</p><p>提示： Note for 2022 Fall: You ONLY need to implement left join and inner join.</p><ul><li><p>left join：左表全匹配（没匹配上右表时右表用null填充），右表只匹配join上的</p></li><li><p>inner join： 左表和右表均只匹配能匹配上的</p></li></ul><h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>添加成员变量：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The NestedLoopJoin plan node to be executed. */</span></span><br><span class="line"><span class="type">const</span> NestedLoopJoinPlanNode *plan_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the left side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; left_executor_;</span><br><span class="line"><span class="comment">/** The child executor that produces tuple for the right side of join. */</span></span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; right_executor_;</span><br><span class="line"><span class="comment">/** The output tuple schema. */</span></span><br><span class="line">Schema left_schema_;</span><br><span class="line">Schema right_schema_;</span><br><span class="line"><span class="type">bool</span> is_inner_join_;</span><br><span class="line">std::vector&lt;Value&gt; right_tuples_;</span><br></pre></td></tr></table></figure><p><strong>这里为什么需要把右表的值先全部拿出来呢？</strong><br>假设我们的join逻辑是这样的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> outer_tuple in outer_table:</span><br><span class="line">    <span class="keyword">for</span> inner_tuple in inner_table:</span><br><span class="line">        <span class="keyword">if</span> inner_tuple matched outer_tuple:</span><br><span class="line">            emit</span><br></pre></td></tr></table></figure><p>右表的值会在左表的第一个值做匹配时就完全被消耗掉了。</p><p><strong>left join</strong><br>右值填充空值可以使用 <code>ValueFactory::GetNullValueByType(right_schema_.GetColumn(i).GetType())</code></p><p>比较右表和左表的tuple是否相等可以使用<code>EvaluateJoin(&amp;left_tuple_, &amp;left_schema_, &amp;right_tuple_, &amp;right_schema_);</code></p><h3 id="index-join-src-execution-nested-index-join-executor-cpp"><a href="#index-join-src-execution-nested-index-join-executor-cpp" class="headerlink" title="index join src/execution/nested_index_join_executor.cpp"></a>index join <code>src/execution/nested_index_join_executor.cpp</code></h3><p>索引连接(Index Join)是连接算法的一种优化技术,其主要思想是:</p><p>对于多个表的连接查询,通过在一个表上使用索引来加速连接处理。</p><p>例如对于一个多表连接查询:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> A <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id <span class="keyword">JOIN</span> C <span class="keyword">ON</span> B.id <span class="operator">=</span> C.id</span><br></pre></td></tr></table></figure><p>如果在表B的id列上存在索引,可以进行索引连接优化:</p><p>通过扫描表A,获取连接需要的id值。<br>对于表A的每一行,使用表B上的索引直接查找id值,得到B中的匹配行。<br>再扫描表C找到匹配B的行。<br>最终组合A,B,C的匹配行。<br>这样可以利用B表上的索引,避免对B进行全表扫描,从而加速连接查询。</p><p>具体实现和 NestedLoopJoin 差不多，只是在尝试匹配右表 tuple 时，会拿 join key 去 B+Tree Index 里进行查询。如果查询到结果，就拿着查到的 RID 去右表获取 tuple 然后装配成结果输出。</p><p>在构造函数中只有一个child_executor，不在是左右孩子的执行器，tuple来源：</p><ul><li>left tuple 来自 child_executor</li><li>right tuple 来自 table</li><li>index scan key 获取 rid, 用rid 获取right tuple</li></ul><h2 id="Task3-Sort-Limit-Executors-and-Top-N-Optimization"><a href="#Task3-Sort-Limit-Executors-and-Top-N-Optimization" class="headerlink" title="Task3  Sort + Limit Executors and Top-N Optimization"></a>Task3  Sort + Limit Executors and Top-N Optimization</h2><h3 id="src-execution-sort-executor-cpp"><a href="#src-execution-sort-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;sort_executor.cpp"></a>src&#x2F;execution&#x2F;sort_executor.cpp</h3><p>Sort 也是 pipeline breaker。在 Init() 中读取所有下层算子的 tuple，并按 ORDER BY 的字段升序或降序排序。</p><p>next 函数每次用迭代器返回一个值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> SortPlanNode *plan_;</span><br><span class="line">std::unique_ptr&lt;AbstractExecutor&gt; child_executor_;</span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt; tuples_; <span class="comment">// 存储所有的值用来排序</span></span><br><span class="line">std::vector&lt;std::pair&lt;Tuple, RID&gt;&gt;::iterator it_;</span><br></pre></td></tr></table></figure><p>根据order by的值来进行升序或者降序排序，这里使用匿名函数自定义排序。然后返回迭代器指向的tuple。</p><h3 id="src-execution-limit-executor-cpp"><a href="#src-execution-limit-executor-cpp" class="headerlink" title="src&#x2F;execution&#x2F;limit_executor.cpp"></a>src&#x2F;execution&#x2F;limit_executor.cpp</h3><p>使用一个成员变量 <code>limit_</code>来统计输出多少数据即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">limit_ = plan_-&gt;<span class="built_in">GetLimit</span>();</span><br><span class="line"><span class="comment">/// after emit </span></span><br><span class="line">limit_--</span><br></pre></td></tr></table></figure><h3 id="src-execution-topn-execution-cpp"><a href="#src-execution-topn-execution-cpp" class="headerlink" title="src&#x2F;execution&#x2F;topn_execution.cpp"></a>src&#x2F;execution&#x2F;topn_execution.cpp</h3><p>top_n函数：返回最大或者最小的n个tuple</p><p>也是 pipeline breaker，需要在<code>Init()</code>时，使用优先队列。最后每一次调用<code>Next()</code>就从栈中弹出一个。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(child_executor_-&gt;<span class="built_in">Next</span>(&amp;tuple, &amp;rid))&#123;</span><br><span class="line">   pq.<span class="built_in">push</span>(tuple);</span><br><span class="line">   <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; plan_-&gt;<span class="built_in">GetN</span>())&#123;</span><br><span class="line">      pq.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">   stack_.<span class="built_in">push</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">   pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;执行引擎介绍&quot;&gt;&lt;a href=&quot;#执行引擎介绍&quot; class=&quot;headerlink&quot; title=&quot;执行引擎介绍&quot;&gt;&lt;/a&gt;执行引擎介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一条SQL语句进入到数据库中后是如何被执行的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img s</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 B+tree</title>
    <link href="http://example.com/2023/08/17/B-tree/"/>
    <id>http://example.com/2023/08/17/B-tree/</id>
    <published>2023-08-17T07:07:54.000Z</published>
    <updated>2023-08-25T10:10:30.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树的介绍（以InnoDB为例）"><a href="#B-树的介绍（以InnoDB为例）" class="headerlink" title="B+树的介绍（以InnoDB为例）"></a>B+树的介绍（以InnoDB为例）</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>B+树只有叶子结点存储数据，内部节点和根结点只存储索引。</p><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><h2 id="bustub"><a href="#bustub" class="headerlink" title="bustub"></a>bustub</h2><p>在这这个实验中只需要实现三个接口：查询、插入和删除。</p><p>需要使用我们在 Project 1 中实现的 buffer pool manager 来获取 page。</p><p>internal page 中，KV 对的 K 是能够比较大小的索引，V 是 page id，用来指向下一层的节点。</p><p>leaf page 和 internal page 的内存布局基本一样，只是 leaf page 多了一个成员变量 <code>next_page_id</code>，指向下一个 leaf page（用于 range scan）</p><p>internal page 中储存 key 和 child page id，那么在拿到 page id 后如何获得对应的 page 指针？用 Project 1 中实现的 buffer pool。</p><p><code>Page *page = buffer_pool_manager_-&gt;FetchPage(page_id);</code></p><p>新建一个结点&#x2F;Page, 示例为新建root</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">page_id_t</span> page_id;</span><br><span class="line">Page *page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;page_id);</span><br><span class="line"><span class="keyword">auto</span> leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">leaf_node-&gt;<span class="built_in">Init</span>(page_id, INVALID_PAGE_ID, leaf_max_size_);</span><br><span class="line">root_page_id_ = page_id;</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page_id, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>找到leaf page，然后二分法找到key，就能够找到对应的record id。</p><p>唯一要注意的问题就是我们在拿到 page id 后，调用 buffer pool 的 FetchPage() 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，无法从 disk 读取其他的 page。比较合适的做法是，在本次操作中，找出 page 最后一次被使用的地方，并在最后一次使用后 unpin。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>假设叶子结点插入值之后满了，要考虑break的问题，要向父节点中插入break之后新的索引，假设父节点也满了，也要break（这是一个递归的过程），注意这里内部节点的第一个位置只存放value，而不存放key</p><p><img src="/../imgs/B+insert.png"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete的时候，如果当前节点小于最小size（Max size&#x2F;2），首先考虑从兄弟结点偷一个过来，如果兄弟结点投不了，就考虑merge。因为是一个向上递归删除的过程，所以merge的时候要区分是叶节点还是内部节点。</p><p>这里注意是先删除再做merge或者偷一个key</p><p><img src="/../imgs/b+delete.png"></p><h3 id="锁的问题："><a href="#锁的问题：" class="headerlink" title="锁的问题："></a>锁的问题：</h3><p>螃蟹式加锁（区分读锁和写锁）</p><p>参考课件:<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf</a></p><p>先给父节点加锁，然后给子节点加锁，如果确认子节点安全（不会发生merge或者break），此时解锁父节点</p><p><img src="/../imgs/image-22.png" alt="Alt text"></p><p>当寻找兄弟结点时，一个指针往前走，假设另一个进程在往后寻找兄弟结点，此时会不会发生死锁？</p><p>不会，因为当子节点需要寻找兄弟节点时，说明此时该节点不安全，所以父节点的锁不会释放，也就意味着另一个子进程拿不到父节点的锁，只会等待。</p><p>如何确定该page有没有被锁住？使用事务管理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树的介绍（以InnoDB为例）&quot;&gt;&lt;a href=&quot;#B-树的介绍（以InnoDB为例）&quot; class=&quot;headerlink&quot; title=&quot;B+树的介绍（以InnoDB为例）&quot;&gt;&lt;/a&gt;B+树的介绍（以InnoDB为例）&lt;/h2&gt;&lt;p&gt;InnoDB 的数据</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 buffer pool manager</title>
    <link href="http://example.com/2023/08/17/bufferpool/"/>
    <id>http://example.com/2023/08/17/bufferpool/</id>
    <published>2023-08-17T06:29:40.000Z</published>
    <updated>2023-08-25T10:10:34.372Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库中为什么需要buffer-pool？"><a href="#数据库中为什么需要buffer-pool？" class="headerlink" title="数据库中为什么需要buffer pool？"></a>数据库中为什么需要buffer pool？</h3><p>数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p><p>要想提升查询性能，添加缓存。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>通常存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在MySQL中，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页(<code>frame</code>)， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲(<code>free list</code>)的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><h3 id="Buffer-Pool-Manager-需要实现的功能："><a href="#Buffer-Pool-Manager-需要实现的功能：" class="headerlink" title="Buffer Pool Manager 需要实现的功能："></a>Buffer Pool Manager 需要实现的功能：</h3><p><code>auto NewPgImp(page_id_t *page_id) -&gt; Page * override</code><br>返回一个<code>Page</code>（首先检查free list中有没有空闲的Page，如果有从free list返回，如果没有使用LRU_K算法replace一个页面之后返回, 注意这里的<code>page_id</code>是一个传入参数）</p><p><code>auto FetchPgImp(page_id_t page_id) -&gt; Page * override;</code><br>在buffer pool中可能存在这个page_id, 标记为visit之后返回，不存在就和创建新的Page一样操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a>Extendible Hash Table</h3><h4 id="为什么这里需要一个hash表？"><a href="#为什么这里需要一个hash表？" class="headerlink" title="为什么这里需要一个hash表？"></a>为什么这里需要一个hash表？</h4><p>外部使用的参数为<code>page_id</code> , 内部转换为<code>frame_id</code>, 每一个frame对应着一个page。从<code>page_id</code>转换为<code>frame_id</code>通过hash表实现。</p><p><strong>重点在于如何去管理桶，当桶满了再插入时应该如何操作。</strong></p><p>每个桶（bucket）都有一个本地深度（local depth）和一个全局深度（global depth）</p><p>本地深度是指每个桶中存储的键值对的哈希值的前缀长度。例如，如果本地深度为2，则桶中存储的键值对的哈希值的前两位必须相同。</p><p>全局深度是指哈希表中所有桶的本地深度的最大值。它表示哈希表的索引空间的大小。</p><p>如果插入时全局深度等于本地深度，哈希目录扩展为两倍（左移一位）<br>此时针对桶的处理最简单的办法是也新建一倍的桶，每一个桶对应着每个索引，但是这样很浪费空间，当有数据插入的时候再考虑新建桶。<br>扩展目录为double，更新index，将桶中的数据重新插入到新的桶中。</p><p><img src="/../imgs/image-21.png" alt="Alt text"></p><h3 id="LRU-K算法"><a href="#LRU-K算法" class="headerlink" title="LRU_K算法"></a>LRU_K算法</h3><p>和传统的LRU不一样的地方在于，传统的LRU是淘汰最近未使用的，而LRU_K多维护了一个record链表，用于记录访问次数大于等于K的Page，当淘汰时优先淘汰访问次数小于K次的，若所有的Page访问次数都大于K次才从record链表中去淘汰。</p><p><img src="/../imgs/image-20.png" alt="Alt text"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/../imgs/bufferpool.png"></p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li><p>是否是dirty，是在Page内部用变量标识的，在buffer pool中没有使用额外的list管理脏页。</p></li><li><p>在buffer pool中的Page array的作用：<code>pages_</code>用来管理已经在bufferp pool中的Page</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">    pages_[frame_id].pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库中为什么需要buffer-pool？&quot;&gt;&lt;a href=&quot;#数据库中为什么需要buffer-pool？&quot; class=&quot;headerlink&quot; title=&quot;数据库中为什么需要buffer pool？&quot;&gt;&lt;/a&gt;数据库中为什么需要buffer pool？&lt;/</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
    <category term="CMU15-445" scheme="http://example.com/tags/CMU15-445/"/>
    
  </entry>
  
  <entry>
    <title>malloc是如何和物理地址关联上的？</title>
    <link href="http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/"/>
    <id>http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/</id>
    <published>2023-08-16T17:38:52.000Z</published>
    <updated>2023-08-16T09:49:33.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-19.png"></p><ol><li><p>malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。</p></li><li><p>操作系统维护着可用物理内存的信息,知道哪些内存地址 当前未被使用。当收到malloc的请求时,它会从可用物理内存中选择一块未使用的内存,将其标记为已分配,并返回给应用程序。</p></li><li><p>在32位系统中,malloc返回的地址是虚拟地址,需要经过MMU地址转换找到对应的物理地址。64位系统中,malloc的地址空间通常就直接对应物理地址空间。</p><p> a. 在32位系统中,CPU可以寻址的虚拟地址空间比较小,一般为4GB左右。而物理内存可能会超过4GB。为了让进程可以访问超过4GB的物理内存,操作系统会使用虚拟内存技术,将虚拟地址映射到物理地址上。malloc返回的虚拟地址需要通过MMU(内存管理单元)翻译成物理地址,才能真正访问到内存。</p><p> b. 而在64位系统中,虚拟地址空间巨大(16EB),远远大于当前的物理内存大小。所以操作系统可以选择把虚拟地址直接映射到物理地址上,这种称为平坦内存模型。在这种情况下,malloc返回的地址就是物理地址,不需要再做地址转换。应用程序把malloc返回的地址直接作为物理地址使用即可。</p></li></ol><h3 id="平坦内存模型-Flat-Memory-Model"><a href="#平坦内存模型-Flat-Memory-Model" class="headerlink" title="平坦内存模型(Flat Memory Model)"></a>平坦内存模型(Flat Memory Model)</h3><ol><li>在平坦内存模型下,进程的虚拟地址与物理地址是一一对应的。操作系统不会进行地址转换,进程使用的虚拟地址就是对应物理内存的物理地址。</li><li>由于虚拟地址直接对应物理地址,不需要进行地址转换,所以省去了地址转换所带来的性能开销。</li><li>程序直接使用虚拟地址访问物理内存,不需要区分逻辑地址和物理地址,编程模型简单。</li><li>64位系统拥有极其大的虚拟地址空间(16EB),使得直接映射成为可能。虚拟地址空间大于目前的物理内存容量。</li><li>由于省去了内存虚拟化,无法实现弹性调配物理页框,可能会出现较严重的内存碎片。</li><li>很多64位系统不会选择完全平坦的模型,而是在一定范围内做映射,同时配合页表实现虚拟内存。综合利用了平坦模型与传统虚拟内存的优点。</li></ol><h3 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU(Memory Management Unit)"></a>MMU(Memory Management Unit)</h3><p>有些系统MMU集成在CPU中，有些系统是单独芯片实现，通过地址总线和CPU连接。（地址总线、数据总线、控制总线–&gt;传递信号）</p><ol><li>地址转换 MMU负责将CPU产生的虚拟地址转换成物理地址。转换过程需要参考TLB,根据虚拟地址的高位找到对应的页表项,翻译出物理页号,与虚拟地址的低位组合成物理地址。</li><li>页面置换 当访问的页面不在物理内存时,MMU会触发页面置换（<em>页面置换算法通常不是由MMU(内存管理单元)直接实现的,而是由操作系统内核的虚拟内存管理子系统来实现。页表和地址转换是由MMU硬件来完成,但确定哪些页面需要换出、加载,以及页面替换策略则由操作系统内核的虚拟内存管理机制决定。</em>）,将内存中的某一页换出,将需要访问的页换入物理内存。</li><li>存取权限检查 MMU会检查每次地址转换后的物理内存访问权限,例如是否可读、可写、可执行,避免非法访问。</li><li>缓存一致性 MMU会与CPU缓存协同工作,实现缓存一致性,保证内存访问正确。</li><li>地址空间隔离 MMU为每个进程维护一个独立的地址空间,实现进程间的内存隔离。</li><li>中断与异常 若地址非法或者缺页等异常,MMU会触发中断信号,通知CPU进行异常处理。</li><li>硬件缓存 部分MMU集成了TLB等缓存结构,加速地址转换的速度。</li></ol><h3 id="为什么MMU可以解决内存碎片的问题？"><a href="#为什么MMU可以解决内存碎片的问题？" class="headerlink" title="为什么MMU可以解决内存碎片的问题？"></a>为什么MMU可以解决内存碎片的问题？</h3><ol><li>MMU实现了虚拟地址到物理地址的映射,程序只需要一个连续的虚拟地址空间。操作系统可以将不连续的物理内存片段映射到该连续虚拟地址空间上。通过这种映射,即使物理内存分布不连续,程序视图也是一个连续空间,可以任意使用而不会出现碎片。操作系统会负责这些不连续物理页的映射和调度,对上层应用透明。</li><li>当物理内存使用产生外部碎片时,虚拟存储技术可以进行碎片回收,将闲置的小块内存映射给其他程序使用。</li><li>同时,虚拟内存可以将暂时不用的内存页换出到磁盘,腾出物理内存空间供其他程序使用,减少内存碎片。</li><li>进而避免了严重的外部碎片,提高了物理内存的利用效率。</li></ol><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>一个计算系统通常包含多级缓存,任何两个存储层次之间都可能存在数据一致性的问题。</p><ol><li><p>CPU缓存与硬盘缓存</p></li><li><p>多核CPU之间</p></li><li><p>各级系统缓存之间</p><p> MMU与CPU缓存的一致性是通过以下几种方式实现的:<br> a. 缓存一致性协议 CPU和MMU之间通过一定的硬件协议(如Intel的MESI协议)来维持缓存和主存的数据一致性。当缓存数据被修改时,会根据协议规则通知MMU将主存更新。</p><p> b. 缓存锁定 针对一些关键数据,CPU缓存会被锁定,每次访问必须从MMU加载,而不是缓存中的拷贝。保证了这部分数据的一致性。</p><p> c. 地址翻译表同步 地址翻译表如TLB也存放在CPU高速缓存中,MMU会同步更新CPU中的翻译表缓存,保证访问获取的是最新翻译关系。</p><p> d. 缓存行注释 MMU可以向缓存中的缓存行添加标记信息,如是否可缓存、是否已修改等,方便缓存控制。</p></li><li><p>分布式缓存系统</p></li><li><p>存储设备之间</p></li><li><p>客户端缓存</p></li></ol><h3 id="malloc调用时什么时候用sys-mmap-什么时候用brk？"><a href="#malloc调用时什么时候用sys-mmap-什么时候用brk？" class="headerlink" title="malloc调用时什么时候用sys_mmap, 什么时候用brk？"></a>malloc调用时什么时候用sys_mmap, 什么时候用brk？</h3><p>在调用malloc时会产生系统调用，切换到内核态，然后执行系统调用<br>在malloc调用时,是否使用sys_mmap或brk分配内存,主要取决于请求的内存大小:</p><ol><li>对于较小的内存请求,malloc通常会使用brk系统调用去扩展程序的堆区。</li><li>当请求较大内存页(一般超过128KB)时,malloc会使用mmap系统调用去映射匿名内存页。</li></ol><p>mmap相比brk的优势在于:</p><ul><li>可以指定地址对齐,提高效率</li><li>可以随时释放不连续的大内存块</li><li>避免堆区碎片</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-19.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统维护着可用物理内存的信息,知道</summary>
      
    
    
    
    <category term="os" scheme="http://example.com/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-08-16T01:54:10.363Z</published>
    <updated>2023-08-16T08:49:05.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/../imgs/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed --save</code></p><h3 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h3><p>在vscode中预览是有图片的，生成和发布之后无法显示图片。<br><img src="/../imgs/image-4.png"></p><p>因为在源文件的 post 目录下新建了 img 子目录,然后在 markdown 中使用相对路径引用图片。</p><p>这在本地预览时可以正常显示,但是部署后会出错。</p><p>因为 Hexo 在生成时,会将 post 中的 markdown 和资源文件一起复制到 public 目录,相对位置不变。</p><p>但是 img 子目录不会自动复制过去。所以 public 中找不到 img 中的图片,导致无法显示。</p><p><strong>解决方法：</strong> 将img重命名为imgs(因为会和主题的img文件夹命名冲突)，然后将文件夹移动到<code>source</code>目录下，而不是放在<code>_posts</code>目录下，注意粘贴的设置也需要修改为imgs。</p><p><img src="/../imgs/image-6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo Cannot GET/</title>
    <link href="http://example.com/2023/08/15/hexo_Cannot_GET/"/>
    <id>http://example.com/2023/08/15/hexo_Cannot_GET/</id>
    <published>2023-08-15T07:33:02.000Z</published>
    <updated>2023-08-16T03:32:00.098Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>在hexo搭建博客的过程中，出现Cannot GET&#x2F;xxx的错误。</p><h3 id="查看是否缺少组件"><a href="#查看是否缺少组件" class="headerlink" title="查看是否缺少组件"></a>查看是否缺少组件</h3><ol><li><p>到public目录下找到xxx文件是否存在，我的错误是<code>Cannot GET/</code>，所以去找<code>index.html</code>是否存在。</p></li><li><p>不存在，执行<code>hexo clean &amp;&amp; hexo g</code>重新生成</p></li><li><p>还是不存在，执行<code>npm audit fix</code>或者是<code>npm ls --depth 0</code>，查看是否缺少组件。通过<code>npm install hexo-xxx-xxx</code>安装</p></li><li><p>执行完毕后发现我并不缺少组件。尝试其他解决办法。</p></li></ol><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p><code>config–&gt;index.js</code>中的 <code>assetsPublicPath: &#39;/&#39;</code>改成<code>assetsPublicPath: ‘./’</code></p><h3 id="没有文件"><a href="#没有文件" class="headerlink" title="没有文件"></a>没有文件</h3><p>在路径<code>\source\_posts\</code>中至少需要存放一篇文档，否则会出现<code>Cannot GET/</code>错误。</p><h3 id="nodejs等级太高"><a href="#nodejs等级太高" class="headerlink" title="nodejs等级太高"></a>nodejs等级太高</h3><p>官方文档参考链接：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><p><img src="/../imgs/image-1.png"></p><h3 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h3><p>将所有markdown文件的名称替换为英文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hexo搭建博客的过程中，出现Cannot GET&amp;#x2F;xxx的错误。&lt;/p&gt;
&lt;h3 id=&quot;查看是否缺少组件&quot;&gt;&lt;a href=&quot;#查看是否缺少组件&quot; class=&quot;headerlink&quot; title=&quot;查</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解合集</title>
    <link href="http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/</id>
    <published>2022-10-15T07:33:02.000Z</published>
    <updated>2023-08-24T06:19:12.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS&#x2F;回溯"></a>DFS&#x2F;回溯</h3><p><strong>以整数拆分为例：</strong><br><img src="/../imgs/image-5.png"></p><p><strong>剪枝条件</strong></p><ul><li>当和为n时，保存结果</li><li>当和大于n时，进行剪枝</li></ul><p>在DFS中，同一排的结点是在同一个函数调用中进行处理，如上图中的第一排，1、2、3、4、这4个结点是在第一次函数调用中进行处理。</p><p><strong>因此使用一个for循环来处理同一排的结点。</strong><br>因为元素可以重复取用，本来for循环的起始位置应该都为1，但是为了避免重复，我们可以假设for循环的起始位置为其父节点的值，这里用变量<code>index</code>表示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="comment">//n表示要拆分的数 index表示当前函数从哪个数开始拆 sum表示当前的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n) &#123;<span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">myPrint</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) <span class="keyword">return</span>;<span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; ++i) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//元素可以重复使用，下一次还是从i开始拆分，拆到n为止</span></span><br><span class="line">        <span class="built_in">split</span>(n, i, sum + i);</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combinations/">77 组合</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">216. 组合总和 III</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">39. 组合总和</a><br><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/c-hui-su-suan-fa-by-sdy-r-6soj/">17. 电话号码的字母组合</a><br><a href="https://leetcode.cn/problems/combination-sum-ii/solution/by-sdy-r-vecj/">40. 组合总和 II</a><br><a href="https://leetcode.cn/problems/subsets-ii/solution/by-sdy-r-nehc/">90. 子集 II</a><br><a href="https://leetcode.cn/problems/permutations-ii/solution/by-sdy-r-fiul/">47. 全排列 II</a><br><a href="https://blog.csdn.net/wenningker/article/details/124399435?spm=1001.2014.3001.5502">679. 24点游戏</a><br><a href="https://leetcode.cn/problems/longest-univalue-path/solution/by-sdy-r-0cz4/">687. 最长同值路径</a></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://www.bilibili.com/video/BV1X741127ZM/?spm_id_from=333.337.search-card.all.click&vd_source=59139a795dc5f3ee3da07683650b7b16">一个超级实用的视频</a><br><strong>状态表示：</strong><br>f 函数代表什么状态？<br>写出状态表示之后我们会有一个f函数的集合，代表递推到f(i)时，有多少种可能的状态。</p><p><strong>动态转移方程</strong><br>把集合中的每一种可能表示出来，对应要求的结果（求最大、最小、求和等）写出动态转移方程。</p><ul><li>状态表示</li><li>状态集，从状态集求出当前状态</li></ul><p><strong>思考当前状态对比前一个状态会有什么变化：</strong></p><ul><li>从前一步加1？</li><li>等于前一步？</li></ul><p><strong>如下图所示</strong><br><img src="/../imgs/image-7.png"></p><p><a href="https://blog.csdn.net/wenningker/article/details/124410311?spm=1001.2014.3001.5502">路径和有关的题目</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/by-sdy-r-6p9s/">714. 买卖股票的最佳时机含手续费</a></p><p><a href="https://leetcode.cn/problems/word-break/solution/by-sdy-r-cj3h/">139. 单词拆分</a></p><p><a href="https://leetcode.cn/problems/integer-break/solution/by-sdy-r-q33e/">343. 整数拆分</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/solution/by-sdy-r-9rnk/">337. 打家劫舍 III</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/by-sdy-r-hrxf/">300. 最长递增子序列</a></p><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/solution/by-sdy-r-atvj/">940. 不同的子序列 II</a></p><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/solution/by-sdy-r-g02s/">646. 最长数对链</a></p><p><a href="https://leetcode.cn/problems/triangle/solution/by-sdy-r-fuap/">120. 三角形最小路径和</a></p><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a></p><p><a href="https://leetcode.cn/problems/wildcard-matching/solution/by-sdy-r-pm4u/">44. 通配符匹配</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/by-sdy-r-boss/">72. 编辑距离</a></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><strong>每次选取局部最优解，得到最终的最优解。</strong><br><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a><br><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/by-sdy-r-3ec9/">406. 根据身高重建队列</a><br><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/by-sdy-r-17wh/">452. 用最少数量的箭引爆气球</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列 小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//降序队列  大顶堆 默认情况</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/meeting-rooms-iii/solution/by-sdy-r-xle0/">2402. 会议室 III</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124468136?spm=1001.2014.3001.5501">23. 合并k个有序链表</a></p><h4 id="数组-链表-哈希"><a href="#数组-链表-哈希" class="headerlink" title="数组&#x2F;链表&#x2F;哈希"></a>数组&#x2F;链表&#x2F;哈希</h4><p><strong>数组：</strong> 查找效率高，插入和删除效率低<br><strong>链表：</strong> 插入删除效率高，查找效率低</p><p><strong>哈希：</strong> </p><ul><li>思想：通过哈希函数得到的键值，使其能够高效查找</li><li>当键值重复时，处理哈希冲突</li><li>在C++中unordered_set 和unordered_map的底层实现时哈希表</li></ul><p><a href="https://leetcode.cn/problems/4sum-ii/solution/by-sdy-r-jlw2/">454. 四数相加 II</a><br><a href="https://leetcode.cn/problems/optimal-partition-of-string/solution/by-sdy-r-uq9h/">2405. 子字符串的最优划分</a><br><a href="https://leetcode.cn/problems/most-popular-video-creator/solution/by-sdy-r-tknt/">6221. 最流行的视频创作者</a></p><h4 id="栈-队列"><a href="#栈-队列" class="headerlink" title="栈&#x2F;队列"></a>栈&#x2F;队列</h4><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a><br><a href="https://leetcode.cn/problems/parsing-a-boolean-expression/solution/c-by-sdy-r-nxof/">1106. 解析布尔表达式</a></p><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。<br><a href="https://leetcode.cn/problems/daily-temperatures/solution/by-sdy-r-7za8/">739. 每日温度</a><br><a href="https://leetcode.cn/problems/next-greater-element-ii/solution/by-sdy-r-t3b7/">503. 下一个更大元素 II</a></p><h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p><a href="https://blog.csdn.net/wenningker/article/details/126799292?spm=1001.2014.3001.5502">前缀树</a></p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>并查集由两个部分构成：</strong></p><ul><li><code>find()</code>函数，发现x的根</li><li><code>Union()</code>函数，合并</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化，最初每个元素的根都是自己</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        parent.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//发现x的根</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfind</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] != x) &#123;</span><br><span class="line">        parent[x] = <span class="built_in">myfind</span>(parent,parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将y的根给x的根，将x和y合并为一堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myunion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    parent[<span class="built_in">myfind</span>(parent,x)] = <span class="built_in">myfind</span>(parent,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wenningker/article/details/124127763?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166597671316800186587518%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166597671316800186587518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-124127763-null-null.nonecase&utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2226.3001.4450">并查集</a></p><p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p><p><a href="https://leetcode.cn/problems/shortest-bridge/solution/by-sdy-r-ao55/">934. 最短的桥</a> BFS+DFS</p><p><a href="https://leetcode.cn/problems/redundant-connection/solutions/2401010/c-bing-cha-ji-tuo-bu-pai-xu-by-sdy-r-48sg/">684. 冗余连接</a> 并查集+拓扑排序</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h3 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针&#x2F;滑动窗口"></a>双指针&#x2F;滑动窗口</h3><p><strong>主要是考虑左指针往右走的条件。</strong><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/solution/by-sdy-r-yayj/">209. 长度最小的子数组</a></p><p><a href="https://leetcode.cn/problems/minimum-window-substring/solution/by-sdy-r-zwx8/">76. 最小覆盖子串</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124530777?spm=1001.2014.3001.5502">90. 水果成蓝</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/longest-nice-subarray/solution/by-sdy-r-glyh/">2401. 最长优雅子数组</a></p><p><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-sdy-r-sm3x/">915. 分割数组</a></p><p><a href="https://leetcode.cn/problems/sort-colors/solution/by-sdy-r-tg7s/">75. 颜色分类</a></p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/kuai-man-zhi-zhen-yi-bian-sao-miao-by-sd-pwps/">19. 删除链表的倒数第 N 个结点</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>对于二叉树来书，考虑遍历方式：</p><ul><li>前序遍历：先处理父节点，再处理孩子节点</li><li>中序遍历：先处理左孩子，再处理父节点，最后处理右孩子</li><li>后序遍历：先处理孩子结点，再处理父节点</li></ul><p><strong>大部分题目都是使用的后序遍历来求解：因为处理父节点时往往需要用到子节点的结果</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/by-sdy-r-307g/">106. 从中序与后序遍历序列构造二叉树</a></p><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/solution/by-sdy-r-6m2z/">98. 验证二叉搜索树</a></p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-sdy-r-n5e3/">236. 二叉树的最近公共祖先</a></p><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/by-sdy-r-vovn/">701. 二叉搜索树中的插入操作</a></p><p><a href="https://leetcode.cn/problems/maximum-binary-tree-ii/solution/by-sdy-r-96ic/">998. 最大二叉树 II</a></p><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/by-sdy-r-x7yd/">538. 把二叉搜索树转换为累加树</a></p><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution/c-by-sdy-r-osdi/">6242. 二叉搜索树最近节点查询</a><br>序列化二叉搜索树</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><table><thead><tr><th>操作</th><th>结果</th><th>特性</th></tr></thead><tbody><tr><td>~</td><td>取反，0变为1，1变为0</td><td></td></tr><tr><td>a&amp;b</td><td>且，ab同时为1时才取1</td><td>a &amp; b &lt;&#x3D; min(a,b)，交换律、结合律，越取越小</td></tr><tr><td>a 或 b</td><td>a和b其中有一个为1，最终结果就是1</td><td>越取越大</td></tr><tr><td>a ^ b</td><td>a和b相同时为1，不同为0</td><td></td></tr><tr><td>&lt;&lt; 和 &gt;&gt;</td><td>左移一位，相当于*2，右移一位，相当于&#x2F;2</td><td></td></tr></tbody></table><p><a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solution/by-sdy-r-6vt8/">2419. 按位与最大的最长子数组</a></p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p><strong>根据题意模拟，主要是代码细节要注意。</strong></p><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/by-sdy-r-g20f/">59. 螺旋矩阵 II</a></p><p><a href="https://leetcode.cn/problems/EXvqDp/solution/by-sdy-r-wlw0/">LCP 63. 弹珠游戏</a></p><p><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/by-sdy-r-yemm/">1441. 用栈操作构建数组</a></p><p><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/by-sdy-r-alxj/">779. 第K个语法符号</a></p><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/solution/by-sdy-r-a32l/">6222. 美丽整数的最小增量</a></p><p><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution/by-sdy-r-lrwi/">1620. 网络信号最好的坐标</a></p><p><a href="https://leetcode.cn/problems/global-and-local-inversions/solution/c-by-sdy-r-8gqu/">775. 全局倒置与局部倒置</a></p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>主要多考虑组合数学</p><p><strong>从起点到终点的所有路径：给定一个$n$和一个$k，n$代表要走的步数，$k$代表终点，从0出发，每次可以选择往左走或者往右走，走到$k$，有多少种路径？</strong></p><ol><li>假设$a$等于往右走的步数，往左走的步数为$k-a$,走到$n$时的步数为$a-(k-a)&#x3D;a$，$a&#x3D;(k+n)&#x2F;2$</li><li>当且仅当$(k+n)$为偶数时有解</li><li>等价于从$k$步里面选$a$步往右走，所以结果是$C^{(k+n)&#x2F;2}_k$</li></ol><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><strong>C++如何计算组合数？</strong></p><p>从<code>n</code>个里面选<code>m</code>个，当前这个选，就变为从<code>n-1</code>个里面选<code>m-1</code>个，当前不选，就变成从<code>n-1</code>个里面选<code>m</code>个。</p><p>根据公式:：$C_n^m&#x3D;C^m_{n-1}+C_{n-1}^{m-1}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span> || m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m] != <span class="number">0</span>)<span class="keyword">return</span> res[n][m];<span class="comment">//保存状态</span></span><br><span class="line">    <span class="keyword">return</span> res[n][m] = <span class="built_in">C</span>(n<span class="number">-1</span>,m)+ <span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);<span class="comment">//赋值给res[n][m]并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">C</span>(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排序不等式：</strong><br>$a_1 \leq a_2 \leq … \leq a_n$<br>$b_1 \leq b_2 \leq … \leq b_n$</p><p>最大值&#x3D; $a_1b_1+a_2b_2+…+a_nb_n$<br>最小值&#x3D; $a_1b_n+a_2b_{n-1}+…+a_nb_1$</p><p><strong>求解最大公约数和最小公倍数</strong></p><ul><li>最大公约数：数组中所有数都能整除的最大数</li><li>最小公倍数：数组中所有数的最小倍数</li></ul><p>$a和b的最小公倍数&#x3D;a*b&#x2F;(a和b的最大公约数)$<br>求解最大公约数使用<code>gcd(a,b)</code>函数</p><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution/-by-sdy-r-z1sc/">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/">6234. 最小公倍数为 K 的子数组数目</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">2447. 最大公因数等于 K 的子数组数目</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DFS-回溯&quot;&gt;&lt;a href=&quot;#DFS-回溯&quot; class=&quot;headerlink&quot; title=&quot;DFS&amp;#x2F;回溯&quot;&gt;&lt;/a&gt;DFS&amp;#x2F;回溯&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;以整数拆分为例：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/../i</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>C++实现一个简单的线程池</title>
    <link href="http://example.com/2022/09/15/C++%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/09/15/C++%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-09-15T07:33:02.000Z</published>
    <updated>2023-08-24T06:19:12.168Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-8.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="任务结构体"><a href="#任务结构体" class="headerlink" title="任务结构体"></a>任务结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务结构体</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Task</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Task</span>(callback function,<span class="type">void</span>* arg):</span><br><span class="line">    <span class="built_in">function</span>(function),<span class="built_in">arg</span>(arg)&#123;&#125;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    callback function;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//取出任务</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取当前任务的个数，内联函数不会进行压栈，通过代码替换实现</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">taskNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//添加互斥锁</span></span><br><span class="line">    queue&lt;Task&gt; m_taskQ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//给线程池添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBusyNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLiveNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//工作的线程任务函数</span></span><br><span class="line">    <span class="comment">//静态成员函数定义时就分配地址，普通成员函数只有实例化才有地址</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程任务函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//单个线程退出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQ;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadID;<span class="comment">//工作线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙的线程个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//存活的线程个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;<span class="comment">//锁定整个线程池</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列是否为空</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;<span class="comment">//每次创建线程的数量</span></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是不是要销毁线程池，销毁为1，不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(<span class="built_in">Task</span>(f,arg));</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">if</span>(!m_taskQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t = m_taskQ.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQ.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max)&#123;</span><br><span class="line">        <span class="comment">//实例化任务队列</span></span><br><span class="line">        taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(taskQ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat tackqueue error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        threadID = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line">        <span class="keyword">if</span>(threadID == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat threadpool error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(threadID,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;mutexPool,<span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty,<span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;mutex or condition init fail...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程，参数：线程，线程的属性，线程要执行的函数，该函数传入的参数</span></span><br><span class="line">        <span class="comment">//成功返回0，失败返回非0值</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID,<span class="literal">NULL</span>,manager,<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; minNum;++i)&#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadID[i],<span class="literal">NULL</span>,worker,<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    shutdown = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//回收管理者线程</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(managerID,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//唤醒阻塞的工作线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; liveNum;++i)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程和进程</span></span><br><span class="line">    <span class="keyword">if</span>(threadID) <span class="keyword">delete</span>[]threadID;</span><br><span class="line">    <span class="keyword">if</span>(taskQ) <span class="keyword">delete</span> taskQ;</span><br><span class="line">    <span class="comment">//销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutexPool);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给线程池添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里访问任务队列不需要再加锁，因为再任务队列的添加操作里已经加了锁</span></span><br><span class="line">    <span class="comment">//pthread_mutex_lock(&amp;mutexPool);</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    taskQ-&gt;<span class="built_in">addTask</span>(task);</span><br><span class="line">    <span class="comment">//有任务了唤醒工作线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="comment">//这里不能直接返回，否则会发生死锁</span></span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getLiveNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作的线程任务函数</span></span><br><span class="line"><span class="comment">//这里需要把pool传进来是因为这个函数是静态成员函数，无法访问非静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt; (arg);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//因为每一个线程都需要对这个线程池进行操作，所以这里要对线程池加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//当前任务队列是否为空，且线程池没有被关闭</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="comment">//阻塞工作线程</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">//判断是否要销毁线程(该线程被唤醒之后)</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断线程池是否关闭了</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从任务队列中取出一个任务</span></span><br><span class="line">        Task task = pool-&gt;taskQ-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line">        <span class="comment">//忙的线程数加一</span></span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="comment">//用完解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot;start working...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);</span><br><span class="line">        <span class="comment">//delete task.arg;</span></span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务执行完毕</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)&#123;</span><br><span class="line">        <span class="comment">//每隔三秒检测一次</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//取出线程池中的任务数量和当前线程的数量</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//任务数量</span></span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>();</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        <span class="comment">//取出忙的线程数量</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//添加线程</span></span><br><span class="line">        <span class="comment">//任务的个数大于存活的线程数&amp;&amp;存活的线程数小于最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;maxNum &amp;&amp;</span><br><span class="line">            i &lt; pool-&gt;NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadID[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadID[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁线程</span></span><br><span class="line">        <span class="comment">//忙的线程*2小于存活的线程数&amp;&amp;存活的线程数大于最小线程数</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = pool-&gt;NUMBER;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;NUMBER;++i)&#123;</span><br><span class="line">                <span class="comment">//唤醒线程，然后销毁,因为工作的线程没被阻塞，这里唤醒被阻塞的线程</span></span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单个线程退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程的ID</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; maxNum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(threadID[i] == tid)&#123;</span><br><span class="line">            threadID[i] = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;threadExit() called,&quot;</span>&lt;&lt;tid&lt;&lt;<span class="string">&quot;exiting...\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(arg);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>())&lt;&lt;<span class="string">&quot;working,number=&quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(i + <span class="number">100</span>);</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>(taskFunc,num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-8.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;任务结构体&quot;&gt;&lt;a href=&quot;#任务结构体&quot; c</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="http://example.com/2022/09/10/Trie%E6%A0%91/"/>
    <id>http://example.com/2022/09/10/Trie%E6%A0%91/</id>
    <published>2022-09-10T07:33:02.000Z</published>
    <updated>2023-08-16T08:57:35.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p></blockquote><p><strong>前缀树的3个基本性质：</strong></p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。 </li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p><strong>时间复杂度：</strong> $O(L)$, $L$是字符串的长度<br><strong>空间复杂度：</strong>$O(n^2)$,最差情况下每个字符串都不相同。</p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-lfool-k6hb/">leetcode208 实现前缀树</a></p><p><img src="/../imgs/image-9.png" alt="Alt text"></p><p><strong>如何去实现一个前缀树？</strong></p><ul><li>每个结点包含的东西：该节点是否是最后一个、该节点的子节点有哪些。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">isEnd</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        child.<span class="built_in">resize</span>(<span class="number">26</span>);<span class="comment">//小写字母最多有26个</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch : child)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch)<span class="keyword">delete</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记当前结点是否是字符串最后一位</span></span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="comment">//有哪些孩子节点</span></span><br><span class="line">    vector&lt;Node*&gt; child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><strong>这里为什么不用存储当前结点代表的字符呢？</strong><br>因为当查到到当前节点时，说明查找的这个一个字符已经存在。换句话说，该节点的字符存储在父节点中。</li></ul><p><strong>实现初始化、查找某一个字符串是否在该树中、查找某一个前缀是否在该树中、插入一个字符串。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Trie</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某一个字符串是否在该树中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某一个前缀是否在该树中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : prefix)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意内存泄漏问题</strong></p><ul><li>在构造函数里构造新的结点，在析构函数中释放</li><li>孩子结点每一个都要释放</li></ul><p><code>vector&lt;Node*&gt; child</code>，也可以用哈希表替代，<code>unordered_set&lt;Node*&gt;  child</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字</summary>
      
    
    
    
    <category term="data_structure" scheme="http://example.com/categories/data-structure/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++刷题常用技巧（自用）</title>
    <link href="http://example.com/2022/08/30/%E3%80%90c++%E3%80%91%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2022/08/30/%E3%80%90c++%E3%80%91%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-08-30T07:33:02.000Z</published>
    <updated>2023-08-16T09:14:23.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N = INT_MIN;</span><br><span class="line"><span class="type">int</span> N = INT_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出</span></span><br></pre></td></tr></table></figure><h3 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h3 id="字符串和数值之间的转换"><a href="#字符串和数值之间的转换" class="headerlink" title="字符串和数值之间的转换"></a>字符串和数值之间的转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="type">int</span> number = <span class="built_in">stoi</span>(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h3 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">56</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">56</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h3 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::<span class="built_in">tolower</span>());</span><br></pre></td></tr></table></figure><h3 id="小根堆和大根堆"><a href="#小根堆和大根堆" class="headerlink" title="小根堆和大根堆"></a>小根堆和大根堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//greater比较器</span></span><br></pre></td></tr></table></figure><h3 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="c-11的特性"><a href="#c-11的特性" class="headerlink" title="c++11的特性"></a>c++11的特性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).<span class="built_in">to_string</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).<span class="built_in">to_ulong</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>将字符串按照空格分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(a.<span class="built_in">c_str</span>()));</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">cout&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class="line"><span class="comment">//12 59 36</span></span><br></pre></td></tr></table></figure><h3 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="comment">//将num存储到str中</span></span><br><span class="line">string s = str;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; node_)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;node&gt; tt;</span><br><span class="line">    tt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(tt.<span class="built_in">begin</span>(), tt.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        cout&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; node_)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout&lt;&lt;pq.<span class="built_in">top</span>().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.<span class="built_in">top</span>().b&lt;&lt;endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组按列排序"><a href="#二维数组按列排序" class="headerlink" title="二维数组按列排序"></a>二维数组按列排序</h3><p><strong>按照第一列排序，如果第一列相等按照第二列排序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](vector&lt;<span class="type">int</span>&gt;&amp;v1,vector&lt;<span class="type">int</span>&gt;&amp;v2)&#123;<span class="keyword">if</span>(v1[<span class="number">0</span>] != v2[<span class="number">0</span>])<span class="keyword">return</span> v1[<span class="number">0</span>]&lt;v2[<span class="number">0</span>];<span class="keyword">else</span> <span class="keyword">return</span> v1[<span class="number">1</span>]&lt;v2[<span class="number">1</span>];&#125;);</span><br></pre></td></tr></table></figure><h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>要包含头文件<code>#include&lt;algorithm&gt;</code>，该函数没有返回值。<br>如果是二维数组，按照行翻转，比如第一行翻转之后到最后一行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reverse[first,last);</span><br></pre></td></tr></table></figure><h3 id="的区别"><a href="#的区别" class="headerlink" title=".,-&gt;的区别"></a><code>.</code>,<code>-&gt;</code>的区别</h3><p>实例和指针的区别。<br><code>A.B</code>则A为对象或者结构体； 点号（<code>.</code>）：左边必须为实体。<br><code>A-&gt;B</code>则A为指针，<code>-&gt;</code>是成员提取，<code>A-&gt;B</code>是提取<code>A</code>中的成员<code>B</code>，<code>A</code>只能是指向类、结构、联合的指针； 箭头（<code>-&gt;</code>）：左边必须为指针。</p><h3 id="排序，同时保留原坐标"><a href="#排序，同时保留原坐标" class="headerlink" title="排序，同时保留原坐标"></a>排序，同时保留原坐标</h3><p><code>sort(ids.begin(),ids.end(),[&amp;](int i,int j)&#123;return nums2[i] &lt; nums2[j];&#125;);</code><br>此时ids[0]就是原数组中最小数的坐标<br>或者是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="comment">//第一个位置放数值，第二个位置放坐标</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="function-函数的用法"><a href="#function-函数的用法" class="headerlink" title="function 函数的用法"></a>function 函数的用法</h3><p>std::function是一个通用的多态函数包装器，可以调用普通函数、Lambda函数、仿函数、bind对象、类的成员函数和指向数据成员的指针，function定义在名为<code>function.h</code>头文件中。是一个模板，在创建function实例时，必须指明类型，如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func<span class="comment">//表示接受两个int，返回一个int的可调用函数</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func = [&amp;](<span class="type">int</span> a,<span class="type">int</span> b)&#123;&#125;;<span class="comment">//可以等于某个匿名函数</span></span><br></pre></td></tr></table></figure><p>使用function函数可以不需要将主函数中的参数传入，直接以引用的方式捕获就可以。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;自带的宏常量&quot;&gt;&lt;a href=&quot;#自带的宏常量&quot; class=&quot;headerlink&quot; title=&quot;自带的宏常量&quot;&gt;&lt;/a&gt;自带的宏常量&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数和虚函数表</title>
    <link href="http://example.com/2022/08/26/%E3%80%90c++%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/"/>
    <id>http://example.com/2022/08/26/%E3%80%90c++%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/</id>
    <published>2022-08-26T07:33:02.000Z</published>
    <updated>2023-10-10T06:44:00.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>静态多态</strong>：静态多态是指在编译时实现的多态，比如函数重载，看似是调用同一个函数其实是在调用不同的。</p><p><em>函数重载为什么不能通过返回值实现？</em></p><p>因为函数重载的解析是在编译阶段进行的。编译器根据函数名和参数列表来确定要调用哪一个函数。</p><p><strong>动态多态</strong>：动态多态是在运行中实现的，当一个父类对象的引用或者指针接收不同的对象(父类对象or子类对象)后，调用相同的函数会调用不同的函数。</p><h4 id="重载、重写、重定义"><a href="#重载、重写、重定义" class="headerlink" title="重载、重写、重定义"></a>重载、重写、重定义</h4><p><img src="/../imgs/image-10.png"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>虚函数和纯虚函数的作用</strong></p><ul><li>定义一个函数为虚函数，不代表函数为不被实现的函数。<code>virtual void foo() ;</code></li><li>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li><li>定义一个函数为纯虚函数，才代表函数没有被实现。<code>virtual void foo() = 0;</code></li><li>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>:<span class="keyword">public</span> Base  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Son</span>();  </span><br><span class="line">    base-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，base虽然是指向Base的指针，但是被调用的函数(foo)却是Son的!  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><h4 id="空类的大小为1"><a href="#空类的大小为1" class="headerlink" title="空类的大小为1"></a>空类的大小为1</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl; <span class="comment">// cout 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>空类的大小为什么要为1？</em></p><p>是为了确保每一个实例都有一个唯一的地址，如果大小为0，有可能会导致几个类的地址一样。</p><h4 id="成员函数并不占用类的内存空间"><a href="#成员函数并不占用类的内存空间" class="headerlink" title="成员函数并不占用类的内存空间"></a>成员函数并不占用类的内存空间</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl; <span class="comment">// cout 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果有虚函数，编译器会在类中添加一个虚函数指针"><a href="#如果有虚函数，编译器会在类中添加一个虚函数指针" class="headerlink" title="如果有虚函数，编译器会在类中添加一个虚函数指针"></a>如果有虚函数，编译器会在类中添加一个虚函数指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">v_func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base B; <span class="comment">// 此时B中有一个成员__vptr，指向虚函数表</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl; <span class="comment">// cout 8, 这个大小就是虚函数指针vtpr的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">v_func1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">v_func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val_; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl; <span class="comment">// cout 4</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Base) &lt;&lt; endl; <span class="comment">// cout 16，这里涉及到内存对齐</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++编译系统中，数据和函数是分开存放的(函数放在代码区；数据主要放在栈区或堆区，静态&#x2F;全局区以及文字常量区也有)，实例化不同对象时，只给数据分配空间，各个对象调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行，可以节省拷贝多份代码的空间</p><p><img src="/../imgs/%E8%99%9A%E5%87%BD%E6%95%B0-1.png"></p><p>在进行多重继承时，<em>子类对象会包含每个父类的成员变量和虚函数表指针</em>。如果每个父类都有虚函数，那么每个父类都会有一个虚函数表，子类对象会包含每个父类的虚函数表指针，因此子类对象会有多个虚函数表指针，每个指针指向相应的虚函数表。如果某个父类没有虚函数，那么子类对象就不会包含该父类的虚函数表指针，只会包含其他父类的虚函数表指针和成员变量。</p><h3 id="虚函数指针最多有多少个？"><a href="#虚函数指针最多有多少个？" class="headerlink" title="虚函数指针最多有多少个？"></a>虚函数指针最多有多少个？</h3><ul><li>属于自己的只有一个，全局共享</li><li>从父类那里继承来的，理论上可以有很多个</li></ul><h3 id="如何通过虚函数表查到到所要执行的虚函数？"><a href="#如何通过虚函数表查到到所要执行的虚函数？" class="headerlink" title="如何通过虚函数表查到到所要执行的虚函数？"></a>如何通过虚函数表查到到所要执行的虚函数？</h3><ol><li>类中的每个包含虚函数的对象都有一个自己的虚函数表，这个虚函数表存储了该对象所有继承而来的虚函数地址，有虚函数指针去指向</li><li>在虚函数表中通过索引的偏移量去找到该虚函数在表中的地址</li></ol><h3 id="析构函数和构造函数可以是虚函数吗？"><a href="#析构函数和构造函数可以是虚函数吗？" class="headerlink" title="析构函数和构造函数可以是虚函数吗？"></a>析构函数和构造函数可以是虚函数吗？</h3><p><strong>答案是构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong><br>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。<strong>那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。</strong><br>那么为什么析构函数推荐最好设置为虚函数呢？当我们delete()的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员进行析构。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> data) :<span class="built_in">data</span>(data) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(data);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用A类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用A类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//using A::A;//使用基类的构造函数</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> data) :<span class="built_in">A</span>(data) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用B类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(data);</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用B类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用结果如下：</p><p><img src="/../imgs/image-14.png"></p><p>基类指针指向子类，调用基类的析构函数，导致内存泄漏。</p><p>改为：<code>virtual ~A()</code></p><p><img src="/../imgs/image-15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态多态&lt;/strong&gt;：静态多态是指在编译时实现的多态，比如函数重载，看似是调用同一个函数其实是在调用不同的。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载的一些规则</title>
    <link href="http://example.com/2022/08/16/%E3%80%90c++%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/2022/08/16/%E3%80%90c++%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99/</id>
    <published>2022-08-16T07:33:02.000Z</published>
    <updated>2023-08-24T06:19:12.168Z</updated>
    
    <content type="html"><![CDATA[<ol><li>C++规定重载后的运算符的操作对象必须至少有一个使用户定义的类型</li><li>使用运算符不能违反运算符原来的语法规则</li><li>不能修改运算符的优先级</li><li>不能进行重载的运算符：成员运算符<code>.</code>、作用域运算符<code>::</code>, 条件运算符，<code>sizeof</code>运算符等</li></ol><p><strong>&lt;&lt;运算符的重载</strong></p><p>使用全局函数(友元函数)进行重载</p><p><code>s.operator&lt;&lt;(cout);</code>可以简写为：<code>s&lt;&lt;out;</code></p><p><code>MyClass&amp; operator+(MyClass&amp; s1,MyClass&amp; s2)</code>：调用时：</p><p><code>s1+s2</code>等价于<code>s1.operator+(s2)</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> data):<span class="built_in">data</span>(data)&#123;&#125;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os)&#123;</span><br><span class="line">os&lt;&lt;data&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(MyClass&amp; s,ostream&amp; os)&#123;</span><br><span class="line">os&lt;&lt;data&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> os;<span class="comment">//为了重复调用所以必须要返回os</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">MyClass <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">s.<span class="keyword">operator</span>&lt;&lt;(cout);<span class="comment">//s&lt;&lt;out;</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>=,[],-&gt;,()</code>这几个符号只能在成员函数中进行重载，即有一个默认参数一定是类。</strong><br>为什么？<br><a href="https://blog.csdn.net/u014610226/article/details/47679323">为什么不能在类外重载</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;C++规定重载后的运算符的操作对象必须至少有一个使用户定义的类型&lt;/li&gt;
&lt;li&gt;使用运算符不能违反运算符原来的语法规则&lt;/li&gt;
&lt;li&gt;不能修改运算符的优先级&lt;/li&gt;
&lt;li&gt;不能进行重载的运算符：成员运算符&lt;code&gt;.&lt;/code&gt;、作用域运算符&lt;c</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>左值和右值</title>
    <link href="http://example.com/2022/08/15/%E3%80%90c++%E3%80%91%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://example.com/2022/08/15/%E3%80%90c++%E3%80%91%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</id>
    <published>2022-08-15T07:33:02.000Z</published>
    <updated>2023-08-16T09:14:17.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p><strong>左值：有地址的值</strong></p><p><strong>右值：只能放在等式右边的值</strong></p><ul><li>常量</li><li>将亡值</li><li>算术表达式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;<span class="comment">//i左值，10右值</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">f</span>();<span class="comment">//将亡值，用完即销</span></span><br></pre></td></tr></table></figure><strong>函数返回值为左值引用，就可以放在等式左边</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">GetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">GetValue</span>();</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line"><span class="built_in">GetValue</span>() = <span class="number">5</span>;<span class="comment">//左值引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">GetValue</span>() &lt;&lt; endl;<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>非const引用，只能引用左值</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; value)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);<span class="comment">//报错,正确 f(const int&amp; value);</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><p><code>const</code>加左值引用，可以兼容右值，相当于创建了一个临时变量，然后进行左值引用。<code>int tmp = 10;f(tmp);</code><br>左值引用仅仅接受左值，右值引用仅仅接受右值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span>&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;兼容左值和右值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">MyPrint</span>(a);<span class="comment">//左值引用</span></span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="number">10</span>);<span class="comment">//右值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>移动语义用来传递所有权，仅仅移动对象，而不进行复制</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递所有权</span></span><br><span class="line"><span class="comment">//仅仅移动对象，而不复制，提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* data) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Creat!\n&quot;</span>);</span><br><span class="line">m_size = <span class="built_in">strlen</span>(data);</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_data, data,m_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;copy\n&quot;</span>);</span><br><span class="line">m_size = other.m_size;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_data, other.m_data, m_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动语义</span></span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;move\n&quot;</span>);</span><br><span class="line">m_size = other.m_size;</span><br><span class="line">m_data = other.m_data;</span><br><span class="line">other.m_size = <span class="number">0</span>;</span><br><span class="line">other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String的析构函数\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_data;</span><br><span class="line"><span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENT</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ENT</span>(String&amp;&amp; data):<span class="built_in">m_data</span>(<span class="built_in">move</span>(data))&#123;</span><br><span class="line"><span class="comment">//这里要将data转换成一个右值才会调用移动构造函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;R Printf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ENT</span>(<span class="type">const</span> String&amp; data):<span class="built_in">m_data</span>(data)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ENT Printf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">String m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;abd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ENT <span class="title">t1</span><span class="params">(s)</span></span>;<span class="comment">//调用了Creat和copy</span></span><br><span class="line"><span class="function">ENT <span class="title">t2</span><span class="params">(<span class="string">&quot;abd&quot;</span>)</span></span>;<span class="comment">//调用了Creat和move</span></span><br><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function">String <span class="title">str1</span><span class="params">(move(str))</span></span>;</span><br><span class="line">cout &lt;&lt; str.m_size &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;左值和右值&quot;&gt;&lt;a href=&quot;#左值和右值&quot; class=&quot;headerlink&quot; title=&quot;左值和右值&quot;&gt;&lt;/a&gt;左值和右值&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;左值：有地址的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右值：只能放在等式右边的值&lt;/st</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>计算复杂性原理学习笔记</title>
    <link href="http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/"/>
    <id>http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/</id>
    <published>2022-06-15T16:38:52.000Z</published>
    <updated>2023-08-16T03:47:35.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><ul><li><p>一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上的一个单元。</p></li><li><p>一个图灵机是根据它的读写头所在的单元进行操作的，它或者改变单元中的字符，或者移动它的读写头到相邻的一个单元，也就是说，图灵机的复杂性度量是由比特运算决定的。</p></li></ul><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p><strong>随着问题规模的增大，算法执行时间增长的快慢。它可以用来表示一个算法运行的时间效率。大</strong>$O$用来表示算法执行的最坏时间复杂度。</p><p>多项式时间：$O(n^{O(1)})$ </p><h3 id="问题分类："><a href="#问题分类：" class="headerlink" title="问题分类："></a>问题分类：</h3><p><strong>P（polynominal）</strong>：确定性图灵机在多项式时间内可解决的问题</p><p><strong>NP（Nondeterministic polynominal 非确定多项式）</strong>：多项式时间内可验证</p><ul><li><p>非确定算法是可以做非确定运算的算法，在非确定算法的一个步骤中，算法可以不确定地对一个变量赋值0或者1，在这样的赋值以后，算法的计算过程分解成两个分开的计算路径，每一条对应一种可能的赋值。假设非确定性算法进行k次非确定性运算，那么可以产生$2^k$种不同的确定性计算路径。如果存在至少一条导致判定的结论为“是”的计算路径，那么我们称这个非确定算法接受这个输入，如果不存在，那么这个算法就拒绝这个输入。</p></li><li><p>一个非确定性算的时间复杂度是所有导致判定结论为“是”的计算路径种最短运行时间。</p></li></ul><p><strong>EXP</strong>：指数时间内能解决</p><p><strong>R</strong>：有限时间内解决</p><ul><li><p>$P \subseteq NP$：存在多项式时间算法问题，总能在多项式时间内验证。</p></li><li><p>$NP\subseteq  EXP \subseteq R$</p></li></ul><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><p>该类问题不知道存不存在一个多项式时间的算法，但是给出一个解S，我们可以在多项式时间内验证S是否是问题P的一个解。</p><p><strong>NP-hard问题：</strong> 比所有的NP问题都要难的问题。所有的NP问题都可以多项式<strong>归约</strong>到NP-hard问题。如果NP-hard问题存在多项式时间算法，那么所有的NP问题都会存在多项式时间算法。</p><p><strong>NP-complete问题：</strong> 既属于NP又属于NP-hard的问题</p><p><img src="/../imgs/image-2.png"></p><p><mark>P &#x3D; NP</mark>   or <mark>P ≠ NP</mark> ？</p><blockquote><p><strong>有没有什么问题属于NP-hard，但是不属于NP？</strong></p><p>停机问题：给定一个程序和输入，判定运行是否终止，不可判定，所以不属于NP。</p><p><strong>图同构问题和因数问题，既没有结果表明属于P，也没有结果表明属于NP-完全</strong></p></blockquote><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p><strong>定义：</strong> 语言$L \subseteq {0,1}^*$多项式时间卡普归约到语言$L’ \subseteq {0,1}^*$，记为$L \leq_p L’$，如果存在多项式时间可计算的函数$f:{0,1}^* \to {0,1}^*  $使得对任意的$x \in {0,1}^*$均有$x\in L$当且仅当$f(x)\in L’$。多项式时间卡普规约也可以简称为多项时间规约。</p><p>如果$L \leq_p L’$对任意的$L\in NP$成立，则称$L’$是NP-难的，如果$L’$是NP-难的且$L’\in NP$，则称$L’$是NP-完全的。</p><p>换句话说，如果A问题是一个NP-hard问题，我们想要得到B问题也是一个NP-hard问题，假设$x$是A问题的一个解，那么我们能在多项式时间内从$x$推出B问题的一个解$f(x)$，反过来，如果我们有B问题的一个解$y$，那么我们能在多项式时间内从$y$推出A问题的一个解$x$。从而有B问题是NP-hard问题。</p><h3 id="针对NP-hard问题我们有什么解决方法"><a href="#针对NP-hard问题我们有什么解决方法" class="headerlink" title="针对NP-hard问题我们有什么解决方法"></a>针对NP-hard问题我们有什么解决方法</h3><p><strong>判定问题：</strong> 一个问题的解只有“是”或者“否”。</p><p><strong>最优化问题：</strong> 求最优解（最大或者最小）。</p><p>同一个问题的判定问题和最优化问题在计算复杂性方面是<mark>等价</mark>的。</p><p>因为假设判定问题是多项式可解，那么只需要枚举n次解，即可得到最优化问题的解。<br>总有某一个解k是可满足的，k+1(最大值问题)是不可满足的，此时k就是解。</p><h4 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h4><ol><li>当一个问题被证实为NP-完全问题，其精确算法多半使用分支界定、动态规划等算法设计，时间复杂度为指数级。</li><li>对于每一个问题，可以先假设其有多项式时间算法，并去设计该算法。</li></ol><h4 id="参数算法"><a href="#参数算法" class="headerlink" title="参数算法"></a>参数算法</h4><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><p>NP-hard问题求最优解比较困难（从算法运行时间角度），所以可以考虑设计近似算法求解。近似算法不花费指数时间寻找优化问题的最优解，而是在多项式时间内求得一个近似最优解。</p><blockquote><p><strong>启发式算法和近似算法</strong></p><ul><li><p>近似算法性能比一般是可以通过严格的理论证明得到或者估计出范围的，而启发式算法不存在这样的理论分析结果，评价启发式算法性能的好换往往是依靠对问题的不同实例输入所进行数值模拟。</p></li><li><p>近似算法通常是用来求解优化问题，而启发式算法不仅可用于求解优化问题，还可以用于处理判定问题。</p></li></ul><p><strong>比如，设计一个可满足性问题近似算法没有意义，相关的启发式算法可以有效处理可满足问题的一大部分实例，但是不能保证可以在多项式时间内处理问题的所有实例。</strong></p></blockquote><p><strong>近似性能比：</strong> $r(A)&#x3D;max{A(I)&#x2F;opt(I),opt(I)&#x2F;A(I)}$。$A(I),opt(I)$分别表示算法A输出的一个问题P的解，和问题P的最优解。</p><p><strong>不可近似性：</strong> 求解某一个优化问题的任意一个近似算法性能比的下界。</p><p><strong>依据不可近似性，优化问题可以分为：</strong></p><ul><li><p>PTAS：近似性能比可以无限逼近于1</p></li><li><p>APX：有常数近似性能比</p></li><li><p>APX-C：某些问题的近似性能比无法突破一个界</p></li></ul><h5 id="如何求解不可近似性："><a href="#如何求解不可近似性：" class="headerlink" title="如何求解不可近似性："></a>如何求解不可近似性：</h5><ul><li><p>从NP-完全问题去规约</p><ul><li>如果优化问题A具有NP-难间隙$[\alpha,\beta],0 \leq \alpha \leq \beta$，那么问题A不存在多项式时间$(\beta&#x2F;\alpha)$-近似算法，除非$P&#x3D;NP$。</li></ul></li><li><p>间隙放大与保持</p></li></ul><p><img src="/../imgs/image-3.png"></p><h5 id="APX-完全性"><a href="#APX-完全性" class="headerlink" title="APX-完全性"></a>APX-完全性</h5><p>对于某些问题，存在求解他们的具有常数性能比的近似算法（APX），去证明他们的某种程度的不可以近似性。</p><blockquote><p>顶点覆盖问题不存在一个近似性能比小于2的近似算法，即MVC问题近似性能比下界为2，那么我们为什么要去证明其APX-完全性质呢？上诉说的某种程度往往是限定于度，且度越小越好，从解决问题的角度考虑，在小度图上都无法近似，大度图上一般也是无法近似的。</p></blockquote><p><strong>L规约的定义</strong></p><p>Let two $NP$ optimization problems $\Lambda$ and $\Pi$ and there are two polynomial-time transformation $h$ and $g$ satisfying the following conditions:</p><ol><li><p>$h$ maps an instance $x$ of $\Lambda$ to an instance $h(x)$ of $\Pi$ such that:<br>$opt_{\Pi}(h(x)) \leq \alpha \cdot opt_{\Lambda}(x)$</p></li><li><p>$g$ maps solutions of $\Pi$ for instance $h(x)$ to solutions of $\Lambda$ for instance $x$. For every feasible solution $y$ of $h(x)$ with objective value $m_{\Pi}(h(x),y)&#x3D; c_{2}$, we can find a solution $g(y)$ of $x$ in polynomial time with $m_{\Lambda}(x,g(y))&#x3D; c_{1}$ such that:<br>$|opt_{\Lambda}(x)-c_{1}| \leq \beta \cdot |opt_{\Pi}(h(x)) - c_{2}|$</p></li></ol><h5 id="rho-ln-n-不可近似性"><a href="#rho-ln-n-不可近似性" class="headerlink" title="$(\rho ln n)$-不可近似性"></a>$(\rho ln n)$-不可近似性</h5><p>有一类组合优化问题，对其中的每一个问题都存在一个正实数$\rho$，使得它没有多项式时间$(\rho ln n)$-近似算法。如，最小集合覆盖问题。</p><h5 id="n-c-不可近似性"><a href="#n-c-不可近似性" class="headerlink" title="$n^c$-不可近似性"></a>$n^c$-不可近似性</h5><p>图着色问题和最大团问题都不存在$n^c$-近似算法，$c&gt;0$。</p><p><strong>针对近似算法，我们通常是找到近似算法的下界，然后去设计近似算法不断去逼近下界。</strong></p><h3 id="backgroud"><a href="#backgroud" class="headerlink" title="backgroud"></a>backgroud</h3><ol><li><p>Introduction</p><p>Computational complexity theory studies the inherent difficulty of computational problems. It analyzes and classifies problems based on the computational resources required to solve them, such as time and space. Understanding problem complexity helps computer scientists design efficient algorithms and determine theoretical limitations of computation.</p></li><li><p>Time Complexity</p><p>Time complexity refers to the number of computation steps required for an algorithm to solve a problem as a function of input size n. Common time complexity functions include constant O(1), logarithmic O(log n), linear O(n), quadratic O(n^2), and exponential O(2^n).</p></li><li><p>Space Complexity</p><p>Space complexity analyzes the auxiliary memory space needed by an algorithm, in addition to its input. Space complexity is commonly expressed using Big O notation as well.</p></li><li><p>P vs. NP Problem</p><p>P represents complexity class of problems solvable in polynomial time by a deterministic Turing machine. NP consists of problems verifiable in polynomial time given the right solution. The P vs NP problem asks whether P &#x3D; NP, i.e. are efficiently verifiable problems also efficiently solvable. It is considered one of the most important open problems in computer science and mathematics.</p></li><li><p>NP-complete and NP-hard</p><p>NP-complete problems are the most difficult problems in NP. NP-hard problems are at least as difficult as NP-complete ones. No efficient solutions are known for NP-complete or NP-hard problems.</p></li><li><p>Reductions</p><p>Reduction shows equivalence between computational problems. Polynomial time reductions are often used to prove NP-completeness.</p></li><li><p>Major Complexity Classes</p><p>Some key complexity classes are:</p><ul><li>P: polynomial time solvable problems</li><li>NP: verifiable in polynomial time</li><li>co-NP: complement of NP</li><li>PSPACE: solvable with polynomial space</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图灵机&quot;&gt;&lt;a href=&quot;#图灵机&quot; class=&quot;headerlink&quot; title=&quot;图灵机&quot;&gt;&lt;/a&gt;图灵机&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上</summary>
      
    
    
    
    <category term="tcs" scheme="http://example.com/categories/tcs/"/>
    
    
  </entry>
  
</feed>
