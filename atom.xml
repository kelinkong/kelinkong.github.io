<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2024-10-22T08:48:22.061Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot：事务处理</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2024-10-22T07:09:09.000Z</published>
    <updated>2024-10-22T08:48:22.061Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>@Transactional</code>注解，Spring就会知道在哪里启动事务。其约定流程如图：<br><img src="/../imgs/image-58.png"></p><p>@Transactional注解的一些配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = true,                          // 是否只读</span></span><br><span class="line"><span class="meta">        timeout = 30,                             // 超时时间</span></span><br><span class="line"><span class="meta">        isolation = Isolation.READ_COMMITTED,      // 隔离级别</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED,        // 传播行为</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;SQLException.class&#125;,        // 指定回滚异常</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;IllegalStateException.class&#125;  // 指定不回滚异常</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先引入事务的隔离级别：</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务的隔离级别（Transaction Isolation Level）用于定义并发事务之间的相互影响，避免因并发执行而引发数据不一致的问题。数据库中的隔离级别定义了一个事务在执行时可以看到其他事务的修改情况，常见的隔离级别有以下四种，按隔离强度从低到高排列：</p><h3 id="1-READ-UNCOMMITTED（读未提交）"><a href="#1-READ-UNCOMMITTED（读未提交）" class="headerlink" title="1. READ UNCOMMITTED（读未提交）"></a>1. <strong>READ UNCOMMITTED（读未提交）</strong></h3><ul><li><strong>描述</strong>：在此隔离级别下，事务可以读取到其他事务尚未提交的数据（脏数据）。</li><li><strong>问题</strong>：<ul><li><strong>脏读</strong>（Dirty Read）：一个事务可以读到其他事务尚未提交的数据。如果这个事务回滚了，那么读到的数据就是无效的。</li><li><strong>不可重复读</strong>（Non-repeatable Read）：同一事务在不同时间读取相同数据时，可能得到不同结果。</li><li><strong>幻读</strong>（Phantom Read）：一个事务多次查询时可能会发现新的数据插入。</li></ul></li><li><strong>适用场景</strong>：对数据一致性要求极低的场景（很少使用）。</li></ul><h3 id="2-READ-COMMITTED（读已提交）"><a href="#2-READ-COMMITTED（读已提交）" class="headerlink" title="2. READ COMMITTED（读已提交）"></a>2. <strong>READ COMMITTED（读已提交）</strong></h3><ul><li><strong>描述</strong>：一个事务只能读取到其他事务已经提交的数据，避免脏读。</li><li><strong>问题</strong>：<ul><li><strong>不可重复读</strong>：同一事务在不同时间读取相同数据时，可能得到不同的结果。如果另一个事务在两次读取之间修改了数据，就会出现这种现象。</li><li><strong>幻读</strong>：如果一个事务在读取时，另一个事务插入了新的行，第一次查询时看不到这些行，下一次查询时就看到了。</li></ul></li><li><strong>适用场景</strong>：多数数据库（如 SQL Server 和 Oracle）默认的隔离级别，适用于读一致性要求不高但需要避免脏读的场景。</li></ul><h3 id="3-REPEATABLE-READ（可重复读）"><a href="#3-REPEATABLE-READ（可重复读）" class="headerlink" title="3. REPEATABLE READ（可重复读）"></a>3. <strong>REPEATABLE READ（可重复读）</strong></h3><ul><li><strong>描述</strong>：在整个事务期间，无论其他事务是否提交，当前事务的所有读操作都能保证是相同的数据。避免了脏读和不可重复读的问题。</li><li><strong>问题</strong>：<ul><li><strong>幻读</strong>：在同一事务中，如果另一个事务插入了新行，这些行可能会在事务的后续查询中出现。</li></ul></li><li><strong>适用场景</strong>：MySQL 默认的隔离级别，适合需要确保数据在一个事务中多次读取一致性的场景。</li></ul><h3 id="4-SERIALIZABLE（可串行化）"><a href="#4-SERIALIZABLE（可串行化）" class="headerlink" title="4. SERIALIZABLE（可串行化）"></a>4. <strong>SERIALIZABLE（可串行化）</strong></h3><ul><li><strong>描述</strong>：最高的隔离级别，强制事务串行化执行，即一个事务必须等其他事务完成后才能执行，避免了所有并发问题，包括脏读、不可重复读和幻读。</li><li><strong>问题</strong>：<ul><li>并发性能最差，多个事务几乎不能并发执行，适合数据一致性要求极高但并发量较低的场景。</li></ul></li><li><strong>适用场景</strong>：极端情况下使用，适合金融交易等需要绝对数据一致性的场景。</li></ul><h3 id="事务隔离级别总结："><a href="#事务隔离级别总结：" class="headerlink" title="事务隔离级别总结："></a>事务隔离级别总结：</h3><ul><li><strong>脏读（Dirty Read）</strong>：读取到了其他未提交事务修改的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：同一事务中，前后两次读取相同数据得到不同的结果，通常是由于其他事务更新了数据。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，如果其他事务插入了新行，这些行在事务后续查询中可能会出现。</li></ul><h3 id="四种隔离级别对问题的防护表："><a href="#四种隔离级别对问题的防护表：" class="headerlink" title="四种隔离级别对问题的防护表："></a>四种隔离级别对问题的防护表：</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>否</td><td>是</td><td>是</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>否</td><td>否</td><td>是</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>注意</strong>：隔离级别越高，事务之间的并发性越差，但数据一致性更强。选择合适的隔离级别需要权衡并发性能和数据一致性。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>假设有批量任务在处理时，如果其中一个任务出现异常，是否需要回滚整个批量任务？这就需要用到事务的传播行为。<br>通常我们只希望回滚出现异常的错误任务，而不是回滚整个批量任务。<br><img src="/../imgs/image-59.png"></p><p>事务的传播行为（Transaction Propagation Behavior）决定了当一个事务方法调用另一个事务方法时，如何处理新旧事务之间的关系。Spring 提供了多种事务传播机制，允许开发人员根据业务需求选择适当的事务行为。主要的传播行为有以下几种：</p><h3 id="1-REQUIRED"><a href="#1-REQUIRED" class="headerlink" title="1. REQUIRED"></a>1. <strong>REQUIRED</strong></h3><ul><li><p><strong>描述</strong>：如果当前已经存在事务，则加入到这个事务中。如果当前没有事务，则新建一个事务。</p></li><li><p><strong>场景</strong>：默认的传播行为，适合大部分业务场景。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 调用methodA，将在同一个事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodB()</code>调用<code>methodA()</code>时，它们共享同一个事务。如果事务成功，则一起提交；如果抛出异常，则一起回滚。</p><h3 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <strong>REQUIRES_NEW</strong></h3><ul><li><p><strong>描述</strong>：总是新建一个事务。如果当前有事务，先挂起当前事务，等新事务执行完再恢复。</p></li><li><p><strong>场景</strong>：适用于需要在事务中执行独立的操作，无论外部事务的状态如何，该事务都要独立提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将开启新事务，不依赖methodB的事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>将启动一个新的事务，与<code>methodB()</code>的事务独立。如果<code>methodB()</code>回滚，<code>methodA()</code>的事务依然可以成功提交。</p><h3 id="3-SUPPORTS"><a href="#3-SUPPORTS" class="headerlink" title="3. SUPPORTS"></a>3. <strong>SUPPORTS</strong></h3><ul><li><p><strong>描述</strong>：支持当前事务。如果当前有事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p></li><li><p><strong>场景</strong>：适用于需要根据调用者上下文决定是否在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>被<code>methodB()</code>调用时，存在事务，它将加入事务；否则，它将以非事务方式执行。</p><h3 id="4-NOT-SUPPORTED"><a href="#4-NOT-SUPPORTED" class="headerlink" title="4. NOT_SUPPORTED"></a>4. <strong>NOT_SUPPORTED</strong></h3><ul><li><p><strong>描述</strong>：总是以非事务方式执行。如果当前有事务，则将其挂起。</p></li><li><p><strong>场景</strong>：适用于某些操作不需要事务，甚至不能在事务中执行。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将以非事务方式执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>会以非事务方式执行，且不受<code>methodB()</code>事务的影响。</p><h3 id="5-MANDATORY"><a href="#5-MANDATORY" class="headerlink" title="5. MANDATORY"></a>5. <strong>MANDATORY</strong></h3><ul><li><p><strong>描述</strong>：强制要求当前存在事务。如果没有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于必须在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 必须在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>只能在已有事务的上下文中执行。如果直接调用<code>methodA()</code>时没有事务，会抛出异常。</p><h3 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. <strong>NEVER</strong></h3><ul><li><p><strong>描述</strong>：强制不允许存在事务。如果有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于不允许事务存在的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 将抛出异常，因为methodB有事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>在事务中执行，则会抛出异常。</p><h3 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. <strong>NESTED</strong></h3><ul><li><p><strong>描述</strong>：如果当前有事务，则在当前事务中嵌套一个子事务；如果当前没有事务，则新建一个事务。嵌套事务可以单独回滚，而不影响外部事务。</p></li><li><p><strong>场景</strong>：适用于希望在主事务中有嵌套事务，子事务可以单独提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将作为methodB的嵌套事务执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>作为<code>methodB()</code>的嵌套事务执行，可以独立回滚，但如果<code>methodB()</code>回滚，<code>methodA()</code>也会回滚。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>当前有事务则加入，没有则创建新事务（默认）。</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>总是新建一个事务，挂起当前事务。</td></tr><tr><td><strong>SUPPORTS</strong></td><td>当前有事务则加入，没有事务则以非事务方式执行。</td></tr><tr><td><strong>NOT_SUPPORTED</strong></td><td>总是以非事务方式执行，挂起当前事务。</td></tr><tr><td><strong>MANDATORY</strong></td><td>当前有事务则加入，没有则抛出异常。</td></tr><tr><td><strong>NEVER</strong></td><td>总是以非事务方式执行，当前有事务则抛出异常。</td></tr><tr><td><strong>NESTED</strong></td><td>嵌套事务，允许回滚子事务但不影响父事务。</td></tr></tbody></table><h3 id="示例项目中使用-Transactional："><a href="#示例项目中使用-Transactional：" class="headerlink" title="示例项目中使用 @Transactional："></a>示例项目中使用 <code>@Transactional</code>：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建订单的逻辑</span></span><br><span class="line">        paymentService.processPayment(); <span class="comment">// 调用另一个事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 处理支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>createOrder()</code>使用<code>REQUIRED</code>传播行为，而<code>processPayment()</code>使用<code>REQUIRES_NEW</code>，即<code>processPayment()</code>将运行在一个独立的事务中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;@Transactional&lt;/code&gt;注解，Spring就会知道在哪里启动事务。其约定流程如图：&lt;br&gt;&lt;img src=&quot;/../imgs/image-58.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;@Transactional注解的一些配置：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-MyBatis</title>
    <link href="https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/"/>
    <id>https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/</id>
    <published>2024-10-22T06:46:45.000Z</published>
    <updated>2024-10-22T08:48:39.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDBC代码和参数的手动设置以及结果集的检索。</p><ol><li><p>首先添加依赖(pom.xml)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据库连接(application.yml)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/demo?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.example.entity</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建XML映射文件(<code>resources/mapper/UserMapper.xml</code>)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这个示例展示了MyBatis在Spring Boot中的基本使用，包括：</p><ol><li>Maven依赖配置</li><li>数据库连接配置</li><li>实体类定义</li><li>Mapper接口定义</li><li>XML映射文件</li><li>Service层实现</li><li>Controller层实现</li></ol><p>使用这个示例，可以：</p><ul><li>通过 GET &#x2F;users&#x2F;{id} 查询用户</li><li>通过 POST &#x2F;users 创建新用户</li></ul><p>在使用前需要确保：</p><ol><li>创建对应的数据库和表</li><li>修改数据库连接配置</li><li>启动类添加 <code>@MapperScan(&quot;com.example.mapper&quot;)</code> 注解</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的示例&quot;&gt;&lt;a href=&quot;#一个简单的示例&quot; class=&quot;headerlink&quot; title=&quot;一个简单的示例&quot;&gt;&lt;/a&gt;一个简单的示例&lt;/h2&gt;&lt;p&gt;MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDB</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：全注解下的IoC</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/</id>
    <published>2024-10-22T01:39:29.000Z</published>
    <updated>2024-10-22T08:48:39.127Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。</p><p>Spring 中把每一个<br>需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器） 。 IoC 容器需要具备两个基本的功能：</p><ul><li>通过描述管理 Bean，包括发布和获取 Bean;</li><li>通过描述完成 Bean 之间的依赖关系</li></ul><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>要求所有的 IoC 容器都需要实现接口 BeanFactory，其中定义了获取 Bean 的基本方法。</p><p>BeanFactory源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; required</span></span><br><span class="line"><span class="params">    Type)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    Boolean <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 默认情况下，Spring IoC 容器是单例的，每次返回都是同一个对象</span></span><br><span class="line">    Boolean <span class="title function_">isSingleton</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 原型模式，每次返回都是一个新的对象</span></span><br><span class="line">    Boolean <span class="title function_">isPrototype</span><span class="params">(String name)</span>;</span><br><span class="line">    Boolean <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BeanFactory中，有多个<code>getBean</code>方法，其中最常用的是：</p><ul><li><code>getBean(String name)</code>：根据 Bean 的名称获取 Bean 对象</li><li><code>getBean(Class&lt;T&gt; requiredType)</code>：根据 Bean 的类型获取 Bean 对象</li></ul><p>Spring 提供了一个更高级的 IoC 容器接口 ApplicationContext，它是 BeanFactory 的子接口，提供了更多的功能。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="/../imgs/image-53.png"></p><p>ApplicationContext 接口通过实现多个接口，提供了更多的功能，如国际化、事件传播、资源加载等。</p><p> Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中。</p><h3 id="使用AnnotationConfigApplicationContext"><a href="#使用AnnotationConfigApplicationContext" class="headerlink" title="使用AnnotationConfigApplicationContext"></a>使用AnnotationConfigApplicationContext</h3><p>AnnotationConfigApplicationContext 是一个 IoC 容器，它可以通过注解来装配 Bean 到 Spring IoC 容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建了一个基于注解的Spring IoC容器AnnotationConfigApplicationContext，并将AppConfig类作为配置类传递给它。</span></span><br><span class="line"><span class="comment">         * AppConfig.class是一个包含Spring配置的类，使用了<span class="doctag">@Configurable</span>注解，表明这是一个配置类。</span></span><br><span class="line"><span class="comment">         * 通过这种方式，Spring会扫描AppConfig类中的<span class="doctag">@Bean</span>注解，并将这些方法返回的对象注册为Spring容器中的Bean。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Spring容器中获取一个类型为User的Bean对象。</span></span><br><span class="line"><span class="comment">         * ctx.getBean(User.class)方法会根据类型查找并返回一个User类型的Bean实例。</span></span><br><span class="line"><span class="comment">         * 这个User实例是由AppConfig类中的initUser方法创建并注册到Spring容器中的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(User.class);</span><br><span class="line">        log.info(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"><a href="#在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别" class="headerlink" title="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"></a>在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别</h2><p>在 Spring 中，<code>@Bean</code> 注解通常用于定义和注册 Bean 到 IoC 容器中，而它可以出现在不同的地方。主要有两种常见的方式：</p><ol><li><strong>在配置类中使用 <code>@Bean</code> 注解</strong>（如在你的 <code>AppConfig</code> 类中）  </li><li><strong>在实体类（如 <code>User</code> 类）上使用 <code>@Component</code> 或其他派生注解</strong>，例如 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等。</li></ol><p>这两种方式的不同点主要体现在 <strong>Bean 定义和管理的灵活性、配置的集中化以及依赖管理的差异</strong>：</p><h3 id="1-在配置类中使用-Bean-注解"><a href="#1-在配置类中使用-Bean-注解" class="headerlink" title="1. 在配置类中使用 @Bean 注解"></a>1. <strong>在配置类中使用 <code>@Bean</code> 注解</strong></h3><p>使用 <code>@Bean</code> 注解在一个配置类中（如 <code>AppConfig</code>）定义 Bean 具有以下特点：</p><ul><li><p><strong>集中配置</strong>：你可以在一个地方（配置类）集中管理所有的 Bean 定义。这可以使得配置代码更加清晰和集中，尤其是在需要配置复杂依赖的场景中。</p></li><li><p><strong>灵活性</strong>：配置类中的 <code>@Bean</code> 方法可以让你灵活地定义 Bean，比如在 Bean 创建时通过方法参数注入依赖，或根据某些条件决定返回的对象。这种方式更加灵活，可以使用逻辑控制返回哪个 Bean 实例。</p></li><li><p><strong>可定制性</strong>：通过 <code>@Bean</code>，你可以完全控制对象的创建过程，甚至可以在创建时执行一些逻辑，或者根据应用的某些条件配置不同的 Bean 实例。</p></li><li><p><strong>多实例管理</strong>：你可以在配置类中通过不同的方法名或 <code>@Bean</code> 注解的 <code>name</code> 属性来为同一个类型注册多个不同的 Bean。</p></li><li><p><strong>明确的生命周期控制</strong>：在配置类中，你还可以使用 <code>@PostConstruct</code>, <code>@PreDestroy</code> 等注解来明确控制 Bean 的生命周期。</p></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">initUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;kelin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setGender((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在-User-类中使用-Component-或其他注解"><a href="#2-在-User-类中使用-Component-或其他注解" class="headerlink" title="2. 在 User 类中使用 @Component 或其他注解"></a>2. <strong>在 <code>User</code> 类中使用 <code>@Component</code> 或其他注解</strong></h3><p>如果你直接在实体类（如 <code>User</code> 类）上使用 <code>@Component</code>（或 <code>@Service</code>, <code>@Controller</code> 等注解），Spring 会自动扫描并将这个类注册为 Bean。特点如下：</p><ul><li><p><strong>自动扫描与装配</strong>：<code>@Component</code> 是一个基于类的注解，意味着只要这个类被 Spring 的组件扫描路径扫描到，它就会自动注册为 Bean。你不需要手动在配置类中定义它。</p></li><li><p><strong>简单且自动化</strong>：适合简单的类，只需要标记类为组件即可，通常用于那些不需要复杂配置或初始化逻辑的 Bean。</p></li><li><p><strong>依赖注入</strong>：当使用 <code>@Component</code> 时，通常配合 <code>@Autowired</code> 注解实现自动依赖注入。虽然 <code>@Bean</code> 也可以做到类似的依赖注入，但是 <code>@Component</code> 配合自动扫描更适合规模较大的项目。</p></li><li><p><strong>更少控制权</strong>：与 <code>@Bean</code> 相比，<code>@Component</code> 提供的控制力更少。例如，你无法在定义 Bean 时动态决定返回什么实例，因为 <code>@Component</code> 只是简单地注册类到 IoC 容器中。</p></li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h3><table><thead><tr><th>特点</th><th><code>@Bean</code> 在配置类中使用</th><th><code>@Component</code> 在类中使用</th></tr></thead><tbody><tr><td><strong>注册方式</strong></td><td>手动在配置类中定义并注册 Bean</td><td>自动通过类扫描注册为 Bean</td></tr><tr><td><strong>灵活性</strong></td><td>高，方法中可以有逻辑控制 Bean 的创建</td><td>低，只能通过注解标记类为 Bean</td></tr><tr><td><strong>依赖注入</strong></td><td>可以通过方法参数手动注入依赖</td><td>使用 <code>@Autowired</code> 自动注入依赖</td></tr><tr><td><strong>配置复杂度</strong></td><td>适合复杂或条件性 Bean 定义</td><td>适合简单 Bean 自动化管理</td></tr><tr><td><strong>Bean 名称控制</strong></td><td>可以通过 <code>@Bean(name = &quot;xxx&quot;)</code> 自定义</td><td>默认 Bean 名称为类名，首字母小写</td></tr><tr><td><strong>生命周期控制</strong></td><td>可以通过 <code>@PostConstruct</code>, <code>@PreDestroy</code></td><td>需要配合额外注解管理生命周期</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>@Bean</code> 适用于更复杂、需要灵活控制的 Bean 配置</strong>。例如，需要根据某些条件创建 Bean 或者配置依赖的场景。</li><li><strong><code>@Component</code> 更适合那些不需要复杂配置、依赖自动装配的类</strong>。它的作用类似于自动注册类作为 Spring 管理的组件，适合小型组件或服务类。</li></ul><p>两者都可以实现依赖注入，但适用场景不同，使用时需要根据具体需求选择。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p><code>@ComponentScan</code> 注解是 Spring 提供的一个用于自动扫描和注册 Bean 的注解。它可以指定一个包路径，Spring 会自动扫描这个包路径下的所有类，并将标记了 <code>@Component</code> 及其派生注解的类注册为 Bean。</p><p><code>@ComponentScan</code> 注解通常与 <code>@Configuration</code> 注解一起使用，用于配置 Spring IoC 容器的自动扫描路径。</p><p>可以排除特定的 Bean 类型，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3&quot; &#125; ,</span></span><br><span class="line"><span class="meta">excludeFilters = &#123;@Filter(classes = Service.class) )</span>)</span><br></pre></td></tr></table></figure><p>以上大致是将Bean注入到Spring IoC容器中的方法。</p><h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 根据属性的类型找到对应的Bean进行注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p><code>@Autowired</code>的注入机制最基本的一条是通过类型进行注入。在IoC容器的顶级接口<code>Factory</code>中，有一个<code>getBean</code>方法，这个方法是通过类型来获取<code>Bean</code>的。</p><p>但是在Spring中，有时候我们会有多个实现类，这时候就需要通过<code>@Qualifier</code>注解来指定具体的实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;v8Engine&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被注入的Bean带有参数的构造函数，如何把参数传入呢？<br>使用@Value注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Value 注解注入参数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Engine</span><span class="params">(<span class="meta">@Value(&quot;$&#123;engine.type&#125;&quot;)</span> String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动注入 Engine Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving with engine type: &quot;</span> + engine.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><img src="/../imgs/image-54.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;kelin.com.springnotes.chapter3&quot;, lazyInit = true)</span></span><br></pre></td></tr></table></figure><p>使用lazyInit &#x3D; true，可以延迟初始化Bean，即在第一次使用Bean时才初始化。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../imgs/image-55.png"></p><h2 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h2><p><code>@Profile</code>注解可以根据不同的环境来选择不同的Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for DEV environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for PROD environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。&lt;/p&gt;
&lt;p&gt;Spring 中把每一个&lt;br&gt;需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 S</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm学习-人工神经网络</title>
    <link href="https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2024-10-18T00:47:24.000Z</published>
    <updated>2024-10-21T06:07:05.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？</p><p>我们现在假设要训练的模型是一个函数，首先考虑，这个函数的作用是什么？这个函数的输入是什么？输出是什么？</p><p>人工神经网络可以用来做分类、预测、生成等任务，现在假设我们的函数是一个分类函数，那么输入就是一个数据，输出就是这个数据属于哪个类别。</p><p>所以，训练神经网络，就是训练这个函数，让这个函数能够准确地对数据进行分类。</p><p>所谓训练，有点太拟人化了，听起来比较抽象，其实就是调整函数的参数，使得函数的输出尽可能接近真实值。</p><p>参数又是什么？这里先介绍一下神经网络的基本结构。</p><h2 id="人工神经网络的基本结构"><a href="#人工神经网络的基本结构" class="headerlink" title="人工神经网络的基本结构"></a>人工神经网络的基本结构</h2><p>人工神经网络是一种模拟人脑神经元网络的计算模型，它由多个神经元（Neuron）组成，每个神经元接收多个输入，经过加权和激活函数处理后，输出一个值。</p><h3 id="神经元（Neuron）"><a href="#神经元（Neuron）" class="headerlink" title="神经元（Neuron）"></a>神经元（Neuron）</h3><p><img src="/../imgs/image-51.png" alt="图来源于维基百科"></p><p>一个神经元的结构可以分为三个主要部分：<strong>输入</strong>、<strong>处理单元</strong>、<strong>输出</strong>。如果用前文的函数来描述，每一个神经元就是一个函数，这个函数的输入就是一个特征向量和一个权重向量，这个向量经过某种计算后，输出一个值（一个神经元的输出通常是一个标量）。</p><p>经过了什么处理呢？</p><p>对于单个神经元，其数学表达可以写为：<br>   $$<br>   y &#x3D; \text{activation}(w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b)<br>   $$</p><p>具体来看：</p><h4 id="1-输入层（Input-Layer）："><a href="#1-输入层（Input-Layer）：" class="headerlink" title="1. 输入层（Input Layer）："></a>1. <strong>输入层（Input Layer）</strong>：</h4><ul><li>神经元的输入来自前一层的神经元，或者在网络的第一层，输入是来自外部的数据。</li><li>输入信号（即特征）通过**权重(Weights)**传递到神经元。每个输入信号都有一个权重值，权重表示输入的重要性。</li></ul><p>   <strong>示例</strong>：<br>   如果我们有三个输入特征 $( a_1, a_2, a_3 )$，每个输入都有一个对应的权重 $( w_1, w_2, w_3 )$。<br>   $$<br>   z &#x3D; w_1 \cdot a_1 + w_2 \cdot a_2 + w_3 \cdot a_3 + b<br>   $$<br>   其中，$b$ 是偏置项。</p><h4 id="2-加权求和（Weighted-Sum）："><a href="#2-加权求和（Weighted-Sum）：" class="headerlink" title="2. 加权求和（Weighted Sum）："></a>2. <strong>加权求和（Weighted Sum）</strong>：</h4><ul><li>输入通过权重后，神经元会将这些加权输入进行加和，再加上一个<strong>偏置（Bias）</strong>项。</li><li>偏置用于调整激活函数的输出，让神经元的输出更加灵活，帮助网络更好地拟合数据。</li></ul><p>   <strong>数学表示</strong>：<br>   $$<br>   z &#x3D; \sum (w_i \cdot x_i) + b<br>   $$</p><p>   其中，$z$ 是加权求和的结果，$w_i$ 是权重，$x_i$ 是输入，$b$是偏置。</p><h4 id="3-激活函数（Activation-Function）："><a href="#3-激活函数（Activation-Function）：" class="headerlink" title="3. 激活函数（Activation Function）："></a>3. <strong>激活函数（Activation Function）</strong>：</h4><ul><li>加权求和后的结果$z$ 会通过一个<strong>激活函数</strong>，以增加神经元的非线性能力。</li><li>激活函数的目的是引入非线性，以便神经网络能够学习复杂的模式。常见的激活函数有 Sigmoid、ReLU、Tanh 等。</li></ul><h4 id="4-输出（Output）："><a href="#4-输出（Output）：" class="headerlink" title="4. 输出（Output）："></a>4. <strong>输出（Output）</strong>：</h4><ul><li>经过激活函数处理后的输出 $t$ 是神经元的最终结果，这个结果可以作为下一层神经元的输入，或者作为最终输出（例如分类结果或回归值）。</li><li>在输出层，输出值可以是一个分类标签（如Softmax输出的类别）或一个回归值（如预测的数值）。</li></ul><p>我们现在已经知道单个神经元（函数）做了什么工作，那么，为什么要经过加权求和、偏置又是什么、为什么要有激活函数？</p><h3 id="加权求和和偏置"><a href="#加权求和和偏置" class="headerlink" title="加权求和和偏置"></a>加权求和和偏置</h3><h4 id="1-加权求和："><a href="#1-加权求和：" class="headerlink" title="1. 加权求和："></a>1. <strong>加权求和</strong>：</h4><ul><li>加权求和是为了给不同的输入信号赋予不同的重要性。</li><li>通过调整权重，神经元可以学习到不同特征的重要性，从而更好地拟合数据。</li></ul><p>比如说，判断一个人是男人还是女人，我们可以用身高、体重、声音等特征。但是，不同的特征对性别的判断重要性是不同的，比如身高可能比声音更重要，所以我们需要通过权重来调整这些特征的重要性。</p><h4 id="2-偏置："><a href="#2-偏置：" class="headerlink" title="2. 偏置："></a>2. <strong>偏置</strong>：</h4><p>偏置的作用是让神经网络的输出有更多的灵活性，即使输入的值为零，偏置也能确保神经元的激活函数能产生非零的输出。这有助于模型更好地拟合数据。</p><p>为什么要有偏置：如果没有偏置，神经网络的输出完全依赖于输入数据。如果输入为零，输出会总是零，这样模型的表达能力受到限制。通过加入偏置，神经网络可以更好地学习复杂的模式和关系。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>目的：激活函数的主要作用是引入非线性，从而让神经网络能够处理复杂的非线性问题。</p><p>没有激活函数，神经网络只会进行线性变换，加权求和的输出只是输入的线性组合。线性模型的能力有限，无法拟合复杂的非线性数据。因此，激活函数通过对加权和进行非线性处理，使网络可以处理高度复杂的任务，如图像识别、自然语言处理等。</p><h4 id="1-ReLU（Rectified-Linear-Unit）："><a href="#1-ReLU（Rectified-Linear-Unit）：" class="headerlink" title="1. ReLU（Rectified Linear Unit）："></a>1. <strong>ReLU（Rectified Linear Unit）</strong>：</h4><p>   ReLU 是最简单的激活函数之一。它的数学表达式为：<br>   $$<br>   \text{ReLU}(z) &#x3D; \max(0, z)<br>   $$</p><ul><li>当 $z &gt; 0$，输出 $z$。</li><li>当 $z \leq 0$，输出 0。</li></ul><h4 id="2-Sigmoid："><a href="#2-Sigmoid：" class="headerlink" title="2. Sigmoid："></a>2. <strong>Sigmoid</strong>：</h4><p>   Sigmoid 是一种常用的激活函数，尤其适用于二分类任务。它的数学表达式为：<br>   $$<br>   \sigma(z) &#x3D; \frac{1}{1 + e^{-z}}<br>   $$</p><ul><li>该函数将输入 $z$ 映射到区间 (0, 1) 之间。</li><li>当 $z \to \infty$，Sigmoid 函数的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 0。</li></ul><h4 id="3-Tanh（Hyperbolic-Tangent）："><a href="#3-Tanh（Hyperbolic-Tangent）：" class="headerlink" title="3. Tanh（Hyperbolic Tangent）："></a>3. <strong>Tanh（Hyperbolic Tangent）</strong>：</h4><p>   Tanh 是另一个常用的激活函数，它将输入映射到 -1 到 1 之间。其数学表达式为：<br>   $$<br>   \tanh(z) &#x3D; \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>   $$</p><ul><li>该函数将 $z$ 映射到区间 (-1, 1)。</li><li>当 $z \to \infty$，Tanh 的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 -1。</li></ul><h4 id="这三个激活函数的行为："><a href="#这三个激活函数的行为：" class="headerlink" title="这三个激活函数的行为："></a>这三个激活函数的行为：</h4><ul><li><strong>ReLU</strong>：输出非负的值，有助于解决梯度消失问题，但可能会导致“死亡ReLU”问题（即神经元在某些区域永远输出0）。</li><li><strong>Sigmoid</strong>：适用于二分类，但在极值区域梯度容易消失。</li><li><strong>Tanh</strong>：输出范围为 (-1, 1)，通常比 Sigmoid 更有效，但仍可能存在梯度消失问题。</li></ul><p>偏置让模型产生非零输出，激活函数引入非线性，这两个因素使得神经网络能够学习复杂的模式和关系。那什么是线性模型，什么是非线性模型呢？</p><h3 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h3><p>我们先从“线性模型”的概念开始，然后再解释为什么它的能力有限，以及它为什么不能拟合复杂的非线性数据。</p><h4 id="1-线性模型是什么？"><a href="#1-线性模型是什么？" class="headerlink" title="1. 线性模型是什么？"></a>1. <strong>线性模型是什么？</strong></h4><ul><li>线性模型是一种简单的数学模型，它通过输入变量（特征）的线性组合来进行预测。</li><li>公式形式为：<br>$$<br>y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b<br>$$<br>其中：<ul><li>$y$ 是模型的输出（预测结果），</li><li>$x_1, x_2, …, x_n$ 是输入特征，</li><li>$w_1, w_2, …, w_n$ 是每个特征的权重，</li><li>$b$ 是偏置项。</li></ul></li></ul><p>   这个公式表明输出 $y$ 是输入特征的<strong>加权求和</strong>。这种模型在数据的所有关系都是线性时，表现得很好。</p><h4 id="2-线性模型的局限性"><a href="#2-线性模型的局限性" class="headerlink" title="2. 线性模型的局限性"></a>2. <strong>线性模型的局限性</strong></h4><ul><li>线性模型可以很好地处理简单的任务，比如预测身高和体重的关系，如果这两个变量之间的关系是线性的。</li><li><strong>线性关系</strong>意味着，输入特征的变化会导致输出以固定比例变化（即没有复杂的交互或非线性效应）。</li></ul><p>   例如，如果我们在二维平面上绘制一条直线，直线可以通过简单的线性方程来表示，适用于处理两个变量之间的简单比例关系。但在现实世界中，很多问题不是这样简单的线性关系。</p><h4 id="3-什么是非线性数据？"><a href="#3-什么是非线性数据？" class="headerlink" title="3. 什么是非线性数据？"></a>3. <strong>什么是非线性数据？</strong></h4><ul><li>非线性数据是指输入与输出之间的关系无法用简单的直线表示。它可能是弯曲的、复杂的、有多个转折点，或者数据之间存在高度的交互。</li><li>比如，如果想预测一个人的年收入，可能会涉及教育背景、工作经验、职位、技能等多个复杂因素，它们之间的关系是高度复杂的，这样的数据就是<strong>非线性的</strong>。</li></ul><p>   例如，如果我们用简单的线性模型来处理这个问题，它只能画出一条直线，但现实中这些因素的关系是复杂而非线性的，可能是一个波动的曲线。线性模型无法正确表达这种复杂的关系。</p><h4 id="4-为什么线性模型不能拟合复杂的非线性数据？"><a href="#4-为什么线性模型不能拟合复杂的非线性数据？" class="headerlink" title="4. 为什么线性模型不能拟合复杂的非线性数据？"></a>4. <strong>为什么线性模型不能拟合复杂的非线性数据？</strong></h4><ul><li>线性模型的核心在于它只会根据输入特征进行简单的加权和。因此，它无法捕捉到变量之间复杂的交互关系或弯曲的趋势。</li><li>举个简单的例子，假设要预测物体在抛出后的运动轨迹。物体的轨迹是抛物线（非线性），如果你用线性模型去拟合这个轨迹，结果只能是一条直线，完全无法准确描述抛物线的运动。</li><li>现实中的大多数数据，比如图像、语音、自然语言等，往往存在复杂的非线性关系，输入特征之间的交互也很复杂，线性模型无法有效捕捉这些关系。</li></ul><h4 id="5-如何解决这个问题？"><a href="#5-如何解决这个问题？" class="headerlink" title="5. 如何解决这个问题？"></a>5. <strong>如何解决这个问题？</strong></h4><ul><li>为了解决这个问题，我们需要引入<strong>非线性模型</strong>。神经网络就是一种非常强大的非线性模型，它通过<strong>激活函数</strong>（如 ReLU、Sigmoid）引入非线性，使得神经网络能够处理和拟合复杂的非线性数据。</li><li>每一层神经元通过权重和偏置计算出加权和，并通过激活函数引入非线性，逐层递进地学习输入数据的复杂模式，从而对复杂任务做出准确预测。</li></ul><p>用大白话说就是线性模型是拟合为直线的，非线性模型可以拟合为曲线的。</p><p><img src="/../imgs/image-52.png"></p><p><strong>那么，为什么加入激活函数后，神经网络就能处理非线性数据了呢？</strong></p><blockquote><p>当我们给神经网络加入激活函数后，它就能够处理复杂的非线性数据，原因很简单：</p><p>打破线性限制：如果没有激活函数，神经网络每一层的计算都是线性的（像画直线一样），无论堆叠多少层，最终的输出也只是线性组合，无法处理弯曲、复杂的模式。</p><p>激活函数引入变化：激活函数就像给网络“加了个弯”，不再只产生直线关系。比如 ReLU 会把负数变成 0，而正数保持不变，这种变化让网络能处理更复杂的情况，不再是简单的线性相加。<br>层层递进：每一层加上激活函数后，输出的结果会经过更多复杂的非线性处理。最终，网络能学会从数据中找到隐藏的复杂关系，甚至是一些人类看不到的特征。<br>简单来说，激活函数让网络能够画“曲线”，而不是只能画“直线”，这就是它能处理非线性数据的原因。</p></blockquote><p>前面提到：输出非负的值，有助于解决梯度消失问题。</p><p><strong>那么，梯度是什么？梯度消失又是什么？</strong></p><h3 id="梯度和梯度消失"><a href="#梯度和梯度消失" class="headerlink" title="梯度和梯度消失"></a>梯度和梯度消失</h3><p>我们先从<strong>梯度</strong>的概念开始，接着解释什么是<strong>梯度消失</strong>。</p><h4 id="1-什么是梯度？"><a href="#1-什么是梯度？" class="headerlink" title="1. 什么是梯度？"></a>1. <strong>什么是梯度？</strong></h4><ul><li>在神经网络中，梯度指的是损失函数（模型预测的误差）对模型参数（权重和偏置）的导数。</li><li>梯度告诉我们如何调整权重才能让损失减少，也就是说，它指示了优化方向。</li><li>比如，假设我们在爬山，梯度就像告诉我们当前所处位置的坡度和方向，帮助我们找到“山顶”（即最小的损失值）。</li></ul><h4 id="2-梯度消失是什么？"><a href="#2-梯度消失是什么？" class="headerlink" title="2. 梯度消失是什么？"></a>2. <strong>梯度消失是什么？</strong></h4><ul><li><strong>梯度消失</strong>是指当神经网络的某些层的梯度变得非常小时，网络更新参数的速度变得非常慢，甚至无法继续学习。</li><li>在训练深层神经网络时，随着误差从输出层逐层向前传播回输入层，梯度会逐渐变小。尤其是当使用像 Sigmoid 或 Tanh 这样的激活函数时，它们的导数很容易变得接近 0，导致梯度消失。</li></ul><h4 id="3-为什么梯度消失是个问题？"><a href="#3-为什么梯度消失是个问题？" class="headerlink" title="3. 为什么梯度消失是个问题？"></a>3. <strong>为什么梯度消失是个问题？</strong></h4><ul><li>梯度消失意味着，神经网络前面几层的权重几乎没有更新。这会导致这些层的学习速度非常慢，网络无法有效学习数据中的复杂特征。</li><li>如果梯度消失，模型在训练过程中就会变得“卡住”，无法通过反向传播有效优化权重，这样模型的表现也就无法提高。</li></ul><h4 id="4-为什么输出非负值可以帮助解决梯度消失？"><a href="#4-为什么输出非负值可以帮助解决梯度消失？" class="headerlink" title="4. 为什么输出非负值可以帮助解决梯度消失？"></a>4. <strong>为什么输出非负值可以帮助解决梯度消失？</strong></h4><ul><li><strong>ReLU激活函数</strong>输出非负值（即当输入大于 0 时，输出等于输入；否则输出 0）。ReLU 的导数是常数 1（对于正数部分），不会像 Sigmoid 或 Tanh 那样迅速衰减为接近 0。这意味着通过 ReLU，网络的梯度不容易消失，前面几层的学习速度也能得到保证。</li><li>换句话说，<strong>输出非负的值</strong>，特别是通过 ReLU 这样的激活函数，可以避免导数过小，从而缓解梯度消失问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-RAG学习</title>
    <link href="https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-12T03:18:19.000Z</published>
    <updated>2024-10-12T03:46:40.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h2><p>RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）和生成（Generation）相结合的技术，常用于自然语言处理任务，特别是在问答和文档生成场景中。</p><h3 id="RAG-的工作原理"><a href="#RAG-的工作原理" class="headerlink" title="RAG 的工作原理"></a>RAG 的工作原理</h3><p>RAG 将两个主要组件结合起来：</p><ul><li><p>信息检索（Retrieval）：当系统接收到问题时，首先会从一个大型的文档数据库或知识库中检索出与问题最相关的文档片段。通常会使用像 ElasticSearch 或基于 BERT 的检索模型来找到最相关的内容。</p></li><li><p>生成模型（Generation）：接下来，生成模型（通常是一个大型语言模型，如 GPT）会将检索到的文档片段作为输入，然后基于这些片段生成答案。这使得生成模型不必完全依赖其自身的训练数据，而是可以利用外部知识库中的信息来生成更准确和上下文相关的响应。</p></li></ul><p>RAG技术虽然有以上显著的优势，但它不是万能的，只是锦上添花的一种手段，因为它主<strong>要是优化了模型的输入过程，通过丰富输入信息的方式，来增强模型的输出质量。但这项技术并不改变模型本身的推理能力，不会改变模型任何的参数</strong>。</p><h2 id="RAG的实现"><a href="#RAG的实现" class="headerlink" title="RAG的实现"></a>RAG的实现</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成）的实现涉及两个关键组件：<strong>检索模块</strong>和<strong>生成模块</strong>。这两者结合起来使得模型可以利用外部知识库动态生成高质量的答案。下面是RAG的典型实现步骤：</p><h3 id="1-构建知识库（Knowledge-Base）"><a href="#1-构建知识库（Knowledge-Base）" class="headerlink" title="1. 构建知识库（Knowledge Base）"></a>1. <strong>构建知识库（Knowledge Base）</strong></h3><p>   RAG的一个关键组件是知识库。这个知识库通常包含与特定领域相关的文档、条目、百科等。它可以是各种形式的文本，比如：</p><ul><li>结构化数据（数据库条目、文档片段等）</li><li>非结构化数据（文章、书籍、PDF等）</li></ul><p>   知识库的构建可以从公开资源获取，或者从特定的领域文档中自动化提取。</p><h3 id="2-检索模块（Retriever）"><a href="#2-检索模块（Retriever）" class="headerlink" title="2. 检索模块（Retriever）"></a>2. <strong>检索模块（Retriever）</strong></h3><p>   检索模块的作用是从知识库中找到与用户问题相关的内容。RAG的检索过程通常分为以下几步：</p><ul><li><p><strong>问题向量化</strong>：当用户提出问题时，首先将问题转化为向量表示（Embedding）。通常使用预训练的语言模型（如BERT、RoBERTa）将问题编码为一个固定大小的向量。</p></li><li><p><strong>文档向量化</strong>：在准备阶段，知识库中的每个文档片段（通常是小的段落或句子）也会被提前转化为向量表示，并保存在向量数据库中。</p></li><li><p><strong>检索相关文档</strong>：通过计算用户问题的向量与知识库中所有文档片段向量之间的相似度（例如余弦相似度），从知识库中找到与问题最相关的文档片段。这通常使用近似最近邻搜索算法（如FAISS）来加速检索。</p></li></ul><p>   <strong>典型检索工具</strong>：</p><ul><li><strong>BM25</strong>：一种经典的信息检索算法，基于词频和逆文档频率（TF-IDF）来衡量文档与查询的相关性。</li><li><strong>Dense Retrieval</strong>：基于深度学习的检索方式，使用语言模型（如BERT）生成的稠密向量表示进行检索。</li></ul><h3 id="3-生成模块（Generator）"><a href="#3-生成模块（Generator）" class="headerlink" title="3. 生成模块（Generator）"></a>3. <strong>生成模块（Generator）</strong></h3><p>   在检索到相关文档片段后，生成模块负责结合这些片段生成最终的答案。生成模块通常基于预训练的大型语言模型（如GPT、T5等）。具体步骤如下：</p><ul><li><p><strong>输入拼接</strong>：将原始用户问题和检索到的文档片段一起作为输入，拼接成一个完整的输入序列，提供给生成模型。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户问题：&quot;什么是机器学习？&quot;</span><br><span class="line">检索到的文档片段：</span><br><span class="line">1. &quot;机器学习是一种通过数据训练算法的技术，用于预测和分类。&quot;</span><br><span class="line">2. &quot;常见的机器学习算法包括线性回归、决策树、神经网络等。&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>生成答案</strong>：生成模型接收这个拼接后的输入，然后基于它生成一个回答。由于检索到的片段为模型提供了上下文，生成的答案将更加准确和领域相关。例如，生成模型可能会输出：“机器学习是一种通过数据训练算法以进行预测和分类的技术，常用算法有线性回归和神经网络。”</p></li></ul><h3 id="4-训练RAG模型"><a href="#4-训练RAG模型" class="headerlink" title="4. 训练RAG模型"></a>4. <strong>训练RAG模型</strong></h3><p>   训练RAG模型的过程中，使用标准的生成任务损失函数（如交叉熵）对生成模块进行优化，并对检索和生成过程进行端到端的联合训练。具体来说：</p><ul><li><strong>监督学习</strong>：训练集通常由问题和答案对组成，同时包含一些相关的文档片段。模型在训练过程中不仅学习如何生成高质量的答案，还会优化检索阶段，使其能选择最相关的文档。</li><li><strong>检索优化</strong>：通过将检索模块与生成模块结合在一起，可以通过生成模块的反馈来优化检索阶段，从而逐步改进文档选择的相关性。</li><li><strong>联合训练</strong>：在一些实现中，检索器和生成器可以联合训练，从而使得检索器学习到更适合生成器的相关文档。</li></ul><h3 id="5-推理过程（Inference-Pipeline）"><a href="#5-推理过程（Inference-Pipeline）" class="headerlink" title="5. 推理过程（Inference Pipeline）"></a>5. <strong>推理过程（Inference Pipeline）</strong></h3><p>   在实际推理过程中，RAG系统通常按以下步骤执行：</p><ul><li><strong>问题输入</strong>：用户提出问题（如“人工智能的主要应用是什么？”）。</li><li><strong>检索文档</strong>：检索模块从知识库中找到与该问题相关的文档片段（如从AI相关文档中找到有关AI应用的片段）。</li><li><strong>生成答案</strong>：将用户问题和检索到的文档片段传递给生成模块，生成基于这些片段的答案。</li><li><strong>返回结果</strong>：最终，RAG系统将生成的答案返回给用户。</li></ul><h3 id="6-RAG的架构图示意"><a href="#6-RAG的架构图示意" class="headerlink" title="6. RAG的架构图示意"></a>6. <strong>RAG的架构图示意</strong></h3><p>RAG的架构可以简要表示为如下流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+    用户问题     +------------------+</span><br><span class="line">|  文档知识库      |  -------------&gt;  |   检索模块（Retriever） |</span><br><span class="line">+------------------+                   +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                      检索到的文档片段</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                     |  生成模块（Generator） |</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                          最终答案</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                           用户</span><br></pre></td></tr></table></figure><h3 id="7-RAG的实际应用"><a href="#7-RAG的实际应用" class="headerlink" title="7. RAG的实际应用"></a>7. <strong>RAG的实际应用</strong></h3><p>RAG的架构非常适合需要结合外部知识生成回答的任务，如：</p><ul><li><strong>领域问答系统</strong>：在法律、医学、金融等特定领域，RAG可以利用专业文档库进行高质量回答。</li><li><strong>文档生成和扩展</strong>：RAG可以根据输入问题生成具有参考资料的文档内容。</li><li><strong>对话系统</strong>：通过结合知识库，RAG能够在对话中生成更加丰富的内容和背景信息。</li></ul><p>通过以上过程，RAG可以有效结合知识库和生成模型，增强生成任务的知识性和准确性，同时灵活处理领域知识扩展问题。</p><h2 id="大模型微调和RAG对比"><a href="#大模型微调和RAG对比" class="headerlink" title="大模型微调和RAG对比"></a>大模型微调和RAG对比</h2><p>将通用大模型调整为某个特定领域的大模型可以通过两种常见的方法来实现：<code>RAG（Retrieval-Augmented Generation）</code>和大模型微调。两者有不同的侧重点和应用场景。以下是它们的区别：</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a>RAG（检索增强生成）</h3><p>核心思路：<br>RAG通过结合外部知识库与生成模型来增强模型的知识能力，而不改变原有的大模型参数。它会先从特定领域的知识库中检索与问题相关的信息，再基于这些检索到的内容由生成模型生成答案。这种方法不需要直接修改模型本身。</p><p>适用场景：RAG特别适用于知识动态更新较快或知识领域非常广泛的场景。它允许你快速将大模型应用于特定领域，而无需重新训练模型。例如：</p><ul><li>医学、法律、金融等领域，可以通过检索领域文档来增强模型的特定领域能力。</li><li>实时问答或需要最新知识时，RAG可以通过检索更新的知识库提供答案。</li></ul><p>优点：</p><ul><li>不需要重新训练大模型，降低计算成本。</li><li>可以即时应用于不同领域，只需准备领域特定的知识库。</li><li>动态扩展模型的知识，知识库可随时更新，增强模型的实时性和灵活性。</li></ul><p>缺点：</p><ul><li>模型仍依赖于外部知识库的质量和准确性。</li><li>检索部分可能导致效率低下，尤其在大型知识库中。</li></ul><h3 id="大模型微调"><a href="#大模型微调" class="headerlink" title="大模型微调"></a>大模型微调</h3><p>核心思路：大模型微调（Fine-tuning）是通过在特定领域的数据上对通用大模型进行进一步训练，来调整其权重，使其更适合该领域的任务。这种方法会直接改变模型的参数，使模型在特定领域表现更好。</p><p>适用场景：微调适合那些希望模型能够在特定领域有深度理解或执行特定任务的情况。微调后的模型可以直接生成该领域的高质量内容，而无需依赖外部检索。例如：</p><ul><li>某些领域的文本生成、分类、或者预测任务需要模型具备细致的专业知识，微调能够提高模型在这些任务中的表现。</li><li>特定领域的对话系统或写作助手。</li></ul><p>优点：</p><ul><li>通过专门的数据进行训练，模型可以深度适应某个领域，提升其在该领域的表现。</li><li>模型的响应可以是自主生成的，不依赖外部资源，具有更高的效率。</li></ul><p>缺点：</p><ul><li>需要大量的领域特定数据进行训练，数据收集成本高。</li><li>微调模型的计算开销大，尤其是大型模型。</li><li>一旦领域知识发生变化，模型需要重新微调，更新过程相对繁琐。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要使用Java实现场景化的RAG（检索增强生成），每个场景对应不同的知识库，底层采用OpenAI大模型，文档检索数据库使用Elasticsearch，开发工作可以分为以下几步：</p><h3 id="1-管理不同场景的知识库"><a href="#1-管理不同场景的知识库" class="headerlink" title="1. 管理不同场景的知识库"></a>1. <strong>管理不同场景的知识库</strong></h3><ul><li><p><strong>场景区分</strong>：每个场景的知识库可能包含不同的数据集。因此，你需要在Elasticsearch中为每个场景创建单独的索引，便于检索时知道该查询对应哪个知识库。</p></li><li><p><strong>Elasticsearch索引创建</strong>：</p><ul><li>针对每个场景创建不同的索引。例如，你可以为“医学场景”和“法律场景”分别创建索引<code>medical_documents</code>和<code>legal_documents</code>。</li><li>在索引中插入文档片段，并将场景信息作为元数据存储，以便后续检索时区分不同场景。</li></ul></li></ul><p>   <strong>示例：为不同场景创建索引并插入文档</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Elasticsearch client 初始化</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">    RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建医学场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">medicalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>);</span><br><span class="line">client.indices().create(medicalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建法律场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">legalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;legal_documents&quot;</span>);</span><br><span class="line">client.indices().create(legalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文档到医学场景的索引</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">medicalDocRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>).id(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    .source(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Medical Document&quot;</span>, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;This is a medical document about diseases.&quot;</span>);</span><br><span class="line">client.index(medicalDocRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure></p><h3 id="2-实现检索模块（Retriever）"><a href="#2-实现检索模块（Retriever）" class="headerlink" title="2. 实现检索模块（Retriever）"></a>2. <strong>实现检索模块（Retriever）</strong></h3><ul><li><p><strong>场景选择</strong>：在用户提问时，根据问题确定使用哪个场景的知识库进行检索。可以通过用户输入的特定关键词或上下文来选择相应的场景。例如，如果用户问的是法律相关问题，就选择“法律场景”的知识库。</p></li><li><p><strong>检索文档</strong>：根据用户的输入，从指定场景的知识库中检索相关文档。可以使用Elasticsearch的Java API，根据用户问题在特定索引中进行查询，提取与问题最相关的文档片段。</p></li></ul><p>   <strong>示例：根据场景进行检索</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">retrieveDocuments</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexName</span> <span class="operator">=</span> scene.equals(<span class="string">&quot;medical&quot;</span>) ? <span class="string">&quot;medical_documents&quot;</span> : <span class="string">&quot;legal_documents&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(indexName);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;content&quot;</span>, userQuery));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">    List&lt;String&gt; retrievedDocs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">        retrievedDocs.add(hit.getSourceAsMap().get(<span class="string">&quot;content&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retrievedDocs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-生成模块的实现（OpenAI-大模型调用）"><a href="#3-生成模块的实现（OpenAI-大模型调用）" class="headerlink" title="3. 生成模块的实现（OpenAI 大模型调用）"></a>3. <strong>生成模块的实现（OpenAI 大模型调用）</strong></h3><ul><li><p><strong>OpenAI 模型调用</strong>：当检索到相关的文档片段后，接下来要调用OpenAI的大模型生成答案。你需要将用户问题和检索到的文档片段拼接，作为模型的输入，让模型基于这些片段生成相关的答案。</p></li><li><p><strong>API 集成</strong>：使用Java的HTTP客户端（例如HttpClient）发送请求到OpenAI的API，并获取生成的答案。</p></li></ul><p>   <strong>示例：调用OpenAI大模型API生成答案</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateAnswer</span><span class="params">(String userQuery, List&lt;String&gt; retrievedDocs)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(userQuery);</span><br><span class="line">    <span class="keyword">for</span> (String doc : retrievedDocs) &#123;</span><br><span class="line">        prompt.append(<span class="string">&quot;\n&quot;</span>).append(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">    <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://api.openai.com/v1/completions&quot;</span>))</span><br><span class="line">        .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_OPENAI_API_KEY&quot;</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;&#123;\&quot;model\&quot;: \&quot;gpt-3.5-turbo\&quot;, \&quot;prompt\&quot;: \&quot;&quot;</span> + prompt.toString() + <span class="string">&quot;\&quot;, \&quot;max_tokens\&quot;: 100&#125;&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    <span class="keyword">return</span> response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-实现RAG逻辑"><a href="#4-实现RAG逻辑" class="headerlink" title="4. 实现RAG逻辑"></a>4. <strong>实现RAG逻辑</strong></h3><ul><li><p><strong>场景选择与文档检索</strong>：根据用户问题选择场景，调用相应场景的知识库，检索相关的文档片段。</p></li><li><p><strong>生成答案</strong>：将用户问题与检索到的文档片段拼接，通过OpenAI大模型生成最终答案。</p></li></ul><p>   <strong>示例：综合检索与生成</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processRAGPipeline</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 根据场景检索文档</span></span><br><span class="line">    List&lt;String&gt; retrievedDocs = retrieveDocuments(userQuery, scene);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用生成模块</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> generateAnswer(userQuery, retrievedDocs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-支持不同场景的用户接口"><a href="#5-支持不同场景的用户接口" class="headerlink" title="5. 支持不同场景的用户接口"></a>5. <strong>支持不同场景的用户接口</strong></h3><ul><li><p><strong>API设计</strong>：你可以为外部应用提供一个统一的接口，支持不同场景的知识库选择。用户可以在请求中指定场景，或让系统根据用户输入自动选择合适的场景。</p></li><li><p><strong>Spring Boot API集成</strong>：使用Spring Boot开发REST API，接收用户请求，并根据请求中的场景信息来调用相应的检索和生成模块。</p></li></ul><p>   <strong>示例：Spring Boot REST API</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RagController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/ask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">askQuestion</span><span class="params">(<span class="meta">@RequestBody</span> QuestionRequest request)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scene</span> <span class="operator">=</span> request.getScene();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userQuery</span> <span class="operator">=</span> request.getQuery();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行RAG流程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> processRAGPipeline(userQuery, scene);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuestionRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String scene;</span><br><span class="line">    <span class="keyword">private</span> String query;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-监控和优化"><a href="#6-监控和优化" class="headerlink" title="6. 监控和优化"></a>6. <strong>监控和优化</strong></h3><ul><li><strong>检索效率优化</strong>：通过优化Elasticsearch查询、配置向量检索或提升索引结构来提高检索效率。</li><li><strong>生成性能优化</strong>：对OpenAI生成的答案进行适当的后处理，例如剪短生成结果，或者通过上下文增强生成效果。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了实现一个基于Java语言、OpenAI大模型和Elasticsearch的RAG系统，你需要完成以下开发工作：</p><ol><li><strong>管理不同场景的知识库</strong>：为每个场景建立不同的Elasticsearch索引。</li><li><strong>实现检索模块</strong>：根据场景检索知识库中的文档片段。</li><li><strong>实现生成模块</strong>：通过调用OpenAI的API生成最终答案。</li><li><strong>实现综合RAG逻辑</strong>：将检索和生成模块结合，构建统一的流程。</li><li><strong>开发用户接口</strong>：通过REST API为用户提供对不同场景的RAG支持。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是RAG&quot;&gt;&lt;a href=&quot;#什么是RAG&quot; class=&quot;headerlink&quot; title=&quot;什么是RAG&quot;&gt;&lt;/a&gt;什么是RAG&lt;/h2&gt;&lt;p&gt;RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>大模型API封装学习</title>
    <link href="https://kelinkong.github.io/2024/10/10/%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/10/%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-10T10:28:42.000Z</published>
    <updated>2024-10-11T08:30:45.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现背景"><a href="#实现背景" class="headerlink" title="实现背景"></a>实现背景</h2><p>假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理异步请求。</p><p>为什么要做API封装？</p><blockquote><ol><li>保护模型：避免直接暴露模型，保护模型的安全性。</li><li>降低耦合：将模型与业务逻辑分离，降低耦合度。</li><li>与原有的系统对接：将模型封装成API，方便与其他系统对接。</li></ol></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>以下是一个基于 Spring WebFlux 封装 OpenAI API 的完整实现例子，使用 Gradle 管理，项目目录结构为 vo、client 和 biz。</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> └── main</span><br><span class="line">     ├── java</span><br><span class="line">     │    └── com</span><br><span class="line">     │         └── example</span><br><span class="line">     │              ├── controller</span><br><span class="line">     │              │    └── OpenAIController.java</span><br><span class="line">     │              ├── biz</span><br><span class="line">     │              │    └── OpenAIService.java</span><br><span class="line">     │              ├── client</span><br><span class="line">     │              │    └── WebClientConfig.java</span><br><span class="line">     │              └── vo</span><br><span class="line">     │                   ├── PromptRequest.java</span><br><span class="line">     │                   └── CompletionResponse.java</span><br><span class="line">     └── resources</span><br><span class="line">          └── application.yml</span><br></pre></td></tr></table></figure><p><strong>配置 WebClient 类 (client&#x2F;WebClientConfig.java)</strong></p><p>WebClientConfig 用于配置 WebClient，这个类将负责与 OpenAI API 的连接。</p><p><strong>业务逻辑 (biz&#x2F;OpenAIService.java)</strong></p><p>OpenAIService 类用于封装调用 OpenAI API 的逻辑，并且通过 WebClient 处理流式响应，返回 <code>Flux&lt;String&gt;</code>。</p><p><strong>数据传输对象 (DTO) (<code>vo/PromptRequest.java</code> 和 <code>vo/CompletionResponse.java</code>)</strong></p><p><code>PromptRequest.java</code>：定义发送给 OpenAI API 的请求体数据结构。</p><p><code>CompletionResponse.java</code>：定义从 OpenAI API 接收到的响应数据结构</p><h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><h3 id="响应的数据结构"><a href="#响应的数据结构" class="headerlink" title="响应的数据结构"></a>响应的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Choice&gt; choices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Choice</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private List&lt;Choice&gt; choices;</code> 在<code>CompletionResponse</code>类中扮演以下几个重要角色：</p><ol><li>表示响应中的数据结构：</li></ol><ul><li>choices 字段表示 OpenAI API 响应中的一个重要部分。根据 OpenAI API 的响应格式，生成的文本是以 choices 的形式返回的，每一个 Choice 对象包含一段生成的文本。</li></ul><ol start="2"><li>封装多个 Choice 对象：</li></ol><ul><li>由于 OpenAI API 可以生成多个结果（多个选择），因此需要用 List<Choice> 来封装这些生成的结果。List 是一个集合类，允许存储多个 Choice 对象，每个对象代表一个生成的文本。</li></ul><ol start="3"><li>将 JSON 映射为 Java 对象：</li></ol><ul><li>当 OpenAI API 返回一个包含 choices 的 JSON 数组时，Spring WebFlux 的 WebClient 会将 JSON 映射为 Java 对象。List<Choice> 对应的是 JSON 中的数组，Choice 类中的 text 字段对应 JSON 中每个选项的文本内容。</li></ul><p>假设 OpenAI API 的响应如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the first generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the second generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据这个 JSON 结构：</p><p><code>choices</code> 是一个数组（List），每个数组元素对应一个 Choice 对象。<br><code>Choice</code> 对象中有一个 text 字段，存储生成的文本。<br><code>private List&lt;Choice&gt; choices</code>; 在这里就是用来存储和处理这个数组，代表生成的多个文本结果。</p><p><strong>在程序中的作用</strong></p><p>当调用 OpenAI 的 API 并接收响应时，Spring 的反序列化机制会将 JSON 数据自动映射到 <code>CompletionResponse</code> <code>中。choices</code> 字段将包含多个生成的文本，每个文本存储在一个 <code>Choice</code> 对象中。</p><p>可以通过以下方式访问生成的文本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompletionResponse</span> <span class="variable">response</span> <span class="operator">=</span> ... <span class="comment">// 从 API 获取响应</span></span><br><span class="line">List&lt;CompletionResponse.Choice&gt; choices = response.getChoices();</span><br><span class="line"><span class="keyword">for</span> (CompletionResponse.Choice choice : choices) &#123;</span><br><span class="line">    System.out.println(choice.getText());  <span class="comment">// 输出每个生成的文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以逐个处理生成的文本结果。</p><h3 id="请求的数据结构"><a href="#请求的数据结构" class="headerlink" title="请求的数据结构"></a>请求的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromptRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String model; <span class="comment">// text-davinci-003  gpt-3.5-turbo  code-davinci-002</span></span><br><span class="line">    <span class="keyword">private</span> String prompt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max_tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top_p;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebClient-配置"><a href="#WebClient-配置" class="headerlink" title="WebClient 配置"></a>WebClient 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.openai.com/v1&quot;</span>)  <span class="comment">// OpenAI API base URL</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_API_KEY&quot;</span>)  <span class="comment">// 替换为你的 OpenAI API Key</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 WebClient？</strong></p><p><code>WebClient</code> 是 Spring WebFlux 提供的一个响应式、非阻塞的 HTTP 客户端，允许应用程序与外部服务进行交互。相比于传统的 RestTemplate，<code>WebClient</code> 能更好地支持异步操作，特别适合处理高并发、低延迟的应用场景。</p><p><code>WebClient </code>允许我们以编程的方式发起 HTTP 请求并处理响应。可以发送 GET、POST、PUT、DELETE 等各种 HTTP 请求，且可以处理 JSON、XML 或其他格式的数据。</p><h4 id="WebClient-的使用步骤"><a href="#WebClient-的使用步骤" class="headerlink" title="WebClient 的使用步骤"></a>WebClient 的使用步骤</h4><ol><li>创建 <code>WebClient</code> 实例：通过 <code>WebClient.Builder</code> 创建 <code>WebClient</code> 实例，可以配置 <code>baseUrl</code>、<code>header</code> 等信息。</li><li>发起请求：使用 <code>WebClient</code> 实例发起请求，可以发送 GET、POST 等请求。</li><li>处理响应：通过 <code>retrieve()</code> 方法获取响应，可以处理响应数据。</li></ol><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WebClient 实例</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望只返回一个结果（比如从 API 返回的单个 JSON 对象），使用 Mono 来处理</span></span><br><span class="line">Mono&lt;String&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/endpoint&quot;</span>)</span><br><span class="line">    .retrieve()  <span class="comment">// 提取响应体</span></span><br><span class="line">    .bodyToMono(String.class);  <span class="comment">// 将响应体转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望返回多个结果（比如从 API 返回的 JSON 数组），使用 Flux 来处理</span></span><br><span class="line">Flux&lt;MyResponseObject&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/stream-endpoint&quot;</span>)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToFlux(MyResponseObject.class);  <span class="comment">// 将响应体映射为多个对象</span></span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.subscribe(res -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Response: &quot;</span> + res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mono 或 Flux：</p><p>Mono 和 Flux 是响应式编程模型中的核心部分，分别表示单个元素（Mono）或多个元素（Flux）的异步序列。</p><p>这些序列是“惰性”的，意味着它们不会在定义时立刻执行。只有当你“订阅”它们时，数据才会开始流动，或者说，操作才会被真正执行。<br><code>subscribe()</code> 方法：</p><p><code>subscribe() </code>是触发响应式流的关键操作。当你调用 <code>subscribe()</code>，整个请求流程才会被激活和执行。</p><p><code>subscribe()</code> 的参数是一个 Consumer，表示当有数据发出时，你可以定义如何处理这些数据。在这个例子中，res 就是 HTTP 响应体的结果。</p><h3 id="假设和前端进行交互，controller如下"><a href="#假设和前端进行交互，controller如下" class="headerlink" title="假设和前端进行交互，controller如下"></a>假设和前端进行交互，controller如下</h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/openai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIController</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/generate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">generateText</span><span class="params">(<span class="meta">@RequestBody</span> PromptRequest request)</span> &#123;</span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 OpenAIService，并逐步推送生成的文本内容</span></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(request);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(</span><br><span class="line">            <span class="comment">// 这是一个 Lambda 表达式，表示每当 Flux&lt;String&gt; 中有新的文本片段 result，服务器会执行这个代码块：</span></span><br><span class="line">                result -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        emitter.send(SseEmitter.event().data(result));  <span class="comment">// 将生成的文本片段作为 SSE 事件发送到客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        emitter.completeWithError(e);  <span class="comment">// 处理异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="comment">// 每次 Flux 产生新文本段时，调用这个回调函数，将该段文本发送给客户端。</span></span><br><span class="line">                emitter::completeWithError,  <span class="comment">// 处理错误</span></span><br><span class="line">                emitter::complete  <span class="comment">// 完成</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端发送请求后，服务器返回一个 SseEmitter 对象，告诉客户端这将是一个持续的数据流。</span></span><br><span class="line"><span class="comment">         * SseEmitter 用于推送多次数据（在文本逐步生成的过程中）。</span></span><br><span class="line"><span class="comment">         * 当推送完毕后，SseEmitter 会通过 complete() 方法关闭连接。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SseEmitter"><a href="#SseEmitter" class="headerlink" title="SseEmitter"></a>SseEmitter</h4><p><code>SseEmitter</code> 是 Spring 提供的一个类，用于处理 <code>Server-Sent Events (SSE)</code>，一种服务器端推送技术。<br>通过 <code>SseEmitter</code>，服务器可以持续向客户端发送事件，而客户端只需要建立一次连接即可接收多个事件。<br>SSE 是基于 HTTP 协议的持久连接，这使它在实时数据更新场景中非常有用，例如股票价格、社交媒体通知、实时聊天消息等。</p><h3 id="服务类-biz-OpenAIService-java"><a href="#服务类-biz-OpenAIService-java" class="headerlink" title="服务类 (biz/OpenAIService.java)"></a>服务类 (<code>biz/OpenAIService.java</code>)</h3><ul><li>连接是单向的，服务器推送数据，客户端接收数据。</li><li>客户端通过 <code>EventSource API</code> 来接收服务器推送的事件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给其他组件调用，发送请求到 OpenAI API 并流式返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promptRequest 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flux&lt;String&gt; 返回流式响应的每一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">generateText</span><span class="params">(PromptRequest promptRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/completions&quot;</span>)</span><br><span class="line">                .bodyValue(promptRequest)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToFlux(CompletionResponse.class)  <span class="comment">// 将响应映射为 CompletionResponse 对象</span></span><br><span class="line">                .flatMap(response -&gt; Flux.just(response.getChoices().get(<span class="number">0</span>).getText()));  <span class="comment">// 获取响应的文本部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的组件如何调用这个服务类？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.anothercomponent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.biz.OpenAIService;</span><br><span class="line"><span class="keyword">import</span> com.example.vo.PromptRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherComponent</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPrompt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PromptRequest</span> <span class="variable">promptRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PromptRequest</span>();</span><br><span class="line">        promptRequest.setModel(<span class="string">&quot;text-davinci-003&quot;</span>);</span><br><span class="line">        promptRequest.setPrompt(<span class="string">&quot;Explain quantum physics in simple terms.&quot;</span>);</span><br><span class="line">        promptRequest.setMax_tokens(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(promptRequest);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(response -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理每一个返回的文本块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Generated Text: &quot;</span> + response);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现背景&quot;&gt;&lt;a href=&quot;#实现背景&quot; class=&quot;headerlink&quot; title=&quot;实现背景&quot;&gt;&lt;/a&gt;实现背景&lt;/h2&gt;&lt;p&gt;假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-gradle</title>
    <link href="https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/"/>
    <id>https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/</id>
    <published>2024-10-10T03:30:04.000Z</published>
    <updated>2024-10-10T06:11:54.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h3><p>Gradle是一个强大的、基于JVM的构建自动化工具。它使用Groovy或Kotlin语言来编写构建脚本，相较于传统的XML配置方式，更加灵活和易于阅读。</p><h3 id="Gradle核心概念"><a href="#Gradle核心概念" class="headerlink" title="Gradle核心概念"></a>Gradle核心概念</h3><ul><li>项目（Project）：一个Gradle构建的最小单位。</li><li>任务（Task）：构建过程中的具体操作，如编译、测试、打包等。</li><li>构建文件（build.gradle）：定义项目配置和任务的脚本文件。</li><li>插件（Plugin）：扩展Gradle功能的模块，如Java插件、Android插件等。</li></ul><p>Gradle 里的任何东西都是基于这两个基础概念: <code>projects</code> ( 项目 ) 和 <code>tasks</code> ( 任务 ) 。每一个构建都是由一个或多个 <code>projects</code> 构成的，每一个 <code>project</code> 是由一个或多个 <code>tasks</code> 构成的。一个 <code>project</code> 可以代表一个 JAR ，一个网页应用，一个发布的 ZIP 压缩包等。一个<code>tasks</code>就是一段可执行的代码，比如编译代码、运行测试、打包等。</p><p>gradle命令行基本格式：<code>gradle 任务名称</code> ，比如 <code>gradle clean</code>（清空所有编译、打包生成的文件） ，<code>gradle build -x test</code>（跳过测试构建构建）</p><p><code>build.gradle</code>文件是 Gradle 构建脚本的核心，它可以用来定义项目的构建逻辑、依赖管理、插件管理等内容。 该文件通常位于项目根目录下。<br>执行Gradle命令的时候，会默认加载当前目录下的<code>build.gradle</code>脚本文件，你也可以通过 -b 参数指定想要加载执行的文件。</p><p><code>Gradle插件</code>是一种可重用的构建逻辑，它可以提供各种功能来简化构建过程。Gradle中有丰富的插件，例如：application 插件可以打包可执行的Java应用程序,war 插件可以打包Web应用程序。除了官方插件之外，还有很多第三方插件。</p><p><code>Gradle Wrapper</code>是Gradle的一个特性，它能够让我们在不安装Gradle的情况下运行Gradle构建。它是一个shell脚本和一个二进制文件，可以自动下载指定版本的Gradle，并使用该版本运行Gradle构建。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="Project（项目）"><a href="#Project（项目）" class="headerlink" title="Project（项目）"></a>Project（项目）</h3><p>定义: Gradle构建的最小单位，代表一个需要构建的软件系统。</p><p>组成:</p><ul><li>build.gradle文件: 定义项目配置和任务的脚本文件。</li><li>子项目: 一个项目可以包含多个子项目。</li></ul><p>作用:</p><ul><li>组织构建逻辑：将整个构建过程划分成不同的项目，方便管理。</li><li>定义依赖关系：不同项目之间可以存在依赖关系。</li></ul><h3 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h3><p>定义: 构建过程中的具体操作，是构建的原子单位。</p><p>作用:</p><ul><li>编译源代码</li><li>运行测试</li><li>生成jar包</li><li>打包war包</li><li>自定义任务</li></ul><p>特点:</p><ul><li>有序执行：任务之间可以有依赖关系，确保执行顺序。</li><li>可配置：可以通过参数来配置任务的行为。</li><li>可复用：可以将任务定义为公共任务，在多个项目中共享。</li></ul><h3 id="Plugin（插件）"><a href="#Plugin（插件）" class="headerlink" title="Plugin（插件）"></a>Plugin（插件）</h3><p>定义: 扩展Gradle功能的模块，提供特定领域的构建支持。</p><p>作用:</p><ul><li>添加新的任务：比如Java插件添加了compileJava、test等任务。</li><li>提供新的配置项：比如Java插件提供了sourceSets配置。</li><li>定义新的约定：比如Java插件定义了源代码和资源的默认目录结构。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">//  通过应用这个插件，Gradle知道这是一个Java项目，并会自动配置一些默认的任务和约定。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123; <span class="comment">// 配置仓库。</span></span><br><span class="line">    mavenCentral() <span class="comment">// mavenCentral() 表示使用Maven中央仓库。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">// 声明依赖。</span></span><br><span class="line">    implementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Hello, Gradle!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项目"><a href="#多项目" class="headerlink" title="多项目"></a>多项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-project</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── core</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── web</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">└── build.gradle</span><br></pre></td></tr></table></figure><p>类似cmake的多项目构建，每个项目都有自己的<code>build.gradle</code>文件，根目录下的<code>settings.gradle</code>文件用来定义项目的结构。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;core&#x27;</span>, <span class="string">&#x27;web&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多个脚本"><a href="#多个脚本" class="headerlink" title="多个脚本"></a>多个脚本</h3><p>当依赖项过多时，可以将依赖项提取到一个单独的文件中，然后在<code>build.gradle</code>中引入（<code>dependencies.gradle</code>）。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;dependencies.gradle&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>脚本包含: apply from语句告诉Gradle去包含另一个脚本文件，就好像把那个脚本文件的内容直接复制粘贴到当前脚本中一样。</li><li>执行顺序: apply from语句通常放在 plugins 块之后，这样被包含的脚本就可以访问插件提供的功能。</li></ul><p>在build脚本中引用 <code>gradle.properties</code></p><ul><li>直接使用属性: Gradle会自动将 <code>gradle.properties</code> 中定义的属性加载到当前构建脚本的上下文中，可以直接使用 <code>$propertyName</code> 的方式引用。</li><li>使用 <code>ext</code> 对象: Gradle提供了一个 <code>ext</code> 对象，可以用来存储自定义的属性。可以在 <code>build.gradle</code> 中将 g<code>radle.properties</code> 中的属性赋值给 <code>ext</code> 对象，然后通过 <code>ext.propertyName</code> 的方式引用。</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gradle.properties</span></span><br><span class="line">version=<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">myProperty=value</span><br><span class="line"></span><br><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">println <span class="string">&quot;Project version: $version&quot;</span></span><br><span class="line"></span><br><span class="line">ext.myCustomProperty = <span class="string">&quot;custom value&quot;</span></span><br><span class="line">println <span class="string">&quot;Custom property: $&#123;ext.myCustomProperty&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="buildscript"><a href="#buildscript" class="headerlink" title="buildscript"></a>buildscript</h3><p>在Gradle构建脚本中，buildscript 块主要用于配置构建脚本本身的依赖和环境。它定义了构建脚本在执行过程中所需要的资源。</p><p>ext {} 和 repositories {} 是 buildscript 块中的两个重要的配置块：</p><ul><li>ext {}： 用于定义扩展属性。这些属性可以在整个构建脚本中被引用，提供了一种灵活的方式来存储和共享配置信息。</li><li>repositories {}： 用于配置仓库地址。这些仓库是 Gradle 下载插件和依赖的来源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Gradle&quot;&gt;&lt;a href=&quot;#什么是Gradle&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Axios学习笔记</title>
    <link href="https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-08T06:57:00.000Z</published>
    <updated>2024-10-08T07:38:18.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。</p><p>教程参考：<a href="https://www.axios-http.cn/docs/intro">Axios教程</a></p><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p><strong>promise是什么？</strong>(简要理解，详细理解放到后面)</p><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这里还是以项目中的实际使用为例。</p><p>首先看一个完整的HTTP请求示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /login <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>   <span class="comment">// 请求行</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span>    <span class="comment">// 请求头</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json <span class="comment">// 指明请求体的格式</span></span><br><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt; <span class="comment">// 指明身份验证信息</span></span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">// 请求体</span></span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john_doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;secret123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中，需要发送请求到后端，所以需要配置一个axios实例，这样可以统一配置请求头等信息。<a href="https://www.axios-http.cn/docs/req_config">请求配置参考</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE_URL</span> = <span class="string">&#x27;http://localhost:8080/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义实例的默认配置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="参数传递位置"><a href="#参数传递位置" class="headerlink" title="参数传递位置"></a>参数传递位置</h3><p><strong>Query参数</strong>：在URL中传递参数，如<code>/project?userId=1</code>，后端使用<code>@RequestParam</code>接收</p><ul><li>位置：参数作为查询字符串附加在 URL 之后，例如：&#x2F;project?userId&#x3D;12345。</li><li>用途：通常用于 GET 请求，适合传递简单的键值对参数。</li></ul><p><strong>路径参数</strong>：在URL中传递参数，如<code>/project/1</code>, 后端使用<code>@PathVariable</code>接收</p><ul><li>位置：参数作为 URL 路径的一部分，例如：&#x2F;project&#x2F;12345。</li><li>用途：通常用于 RESTful API 中的资源标识，适合传递资源 ID 等信息</li></ul><p><strong>请求体参数</strong>：在请求体中传递参数，如<code>&#123;userId: 1&#125;</code>, 后端使用<code>@RequestBody</code>接收</p><ul><li>位置：参数作为请求体的一部分，例如：{userId: 12345}。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Query 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getProjectsByUserId</span> = (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">get</span>(<span class="string">`/project`</span>, &#123; </span><br><span class="line">        <span class="attr">params</span>: &#123;</span><br><span class="line">            <span class="attr">userId</span>: userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路径参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">deleteProjectById</span> = (<span class="params">projectId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">delete</span>(<span class="string">`/project/<span class="subst">$&#123;projectId&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用请求体参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addProject</span> = (<span class="params">project</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">post</span>(<span class="string">`/project/add`</span>, project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以在请求或响应被 then 或 catch 处理前拦截它们。</p><p>在项目中使用到了请求拦截器，每次请求时自动将 token 添加到请求头中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>响应拦截器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>Axios返回的是一个Promise对象，所以可以使用<code>then</code>和<code>catch</code>方法处理响应。</p><p>一个响应结构应该包含如下信息：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是服务器响应头</span></span><br><span class="line">  <span class="comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是 `axios` 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>.then()</code>方法处理响应：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在项目中没有使用统一的错误处理机制，所以错误处理参考：<a href="https://www.axios-http.cn/docs/handling_errors">错误处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。&lt;/p&gt;
&lt;p&gt;教程参考：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="frontend" scheme="https://kelinkong.github.io/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-JWT</title>
    <link href="https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/"/>
    <id>https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/</id>
    <published>2024-10-08T02:00:10.000Z</published>
    <updated>2024-10-08T03:56:44.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java实战项目中，对于登陆操作，想要达到下面的效果：</p><ul><li>登陆成功后，登陆的状态保持一段时间，不需要重复登陆</li></ul><p>实现登陆保持功能可以使用session和cookie，但是这种方式有一些问题：</p><ul><li>session和cookie是存储在服务端的，如果服务端重启，session和cookie会丢失</li><li>对于分布式系统，session和cookie需要做共享，增加了复杂度</li></ul><p>所以在该项目中，我使用JWT做登陆保持。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JWT（JSON Web Token）是一种基于JSON的开放标准（RFC 7519），用于在网络上传输声明的一种方式。JWT是一种轻量级的身份验证和授权的方式，可以在用户和服务器之间传递安全可靠的信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>一旦 JWT 签发了，就不能撤回，除非改密钥。（在到期时间之前，都是有效的）</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>用户登录时，服务器验证用户身份。</li><li>如果验证通过，服务器生成一个包含用户信息的 JWT 并返回给客户端。</li><li>客户端将 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。(可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。)</li><li>服务器每次根据 Token 验证用户身份，无需存储任何会话信息。</li></ul><h3 id="前端需要做什么？"><a href="#前端需要做什么？" class="headerlink" title="前端需要做什么？"></a>前端需要做什么？</h3><p>前端需要在用户登录成功后，将服务器返回的 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。</p><p>用户登陆成功后，将服务器返回的 Token 存储在本地存储中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, token);</span><br></pre></td></tr></table></figure><p>后续请求时，需要在请求头携带token。</p><p>如果每一个请求都手动去携带 Token，会很麻烦，所以可以使用 Axios 拦截器来实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><p>后端需要实现以下功能：</p><ul><li>JWT工具类，用于生成和解析（验证）Token</li><li>过滤器，用于过滤前端所有的请求，验证Token的有效性</li><li>Web配置，将过滤器注册到Spring容器中</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h4><p>生成和解析Token的工具类，使用了 jjwt 库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//设置密钥（要想非对称加密这里换成私钥）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收业务数据,生成token并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;claims&quot;</span>, claims) <span class="comment">//token中加入用户信息</span></span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>)) <span class="comment">//设置超时时间</span></span><br><span class="line">                .sign(Algorithm.HMAC256(KEY)); <span class="comment">//设置加密类型及密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收token,验证token,并返回业务数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">//去除token的前缀标记&quot;Bearer &quot;</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">newToken</span> <span class="operator">=</span> token.contains(<span class="string">&quot;Bearer &quot;</span>)?token.substring(<span class="string">&quot;Bearer &quot;</span>.length()):token;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(KEY))</span><br><span class="line">                .build()</span><br><span class="line">                .verify(newToken)</span><br><span class="line">                .getClaim(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">                .asMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器用于过滤前端所有的请求，验证Token的有效性。</p><p>创建一个认证对象，将用户信息放入认证对象中，然后将认证对象放入SecurityContextHolder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is called by the filter chain to filter the request.</span></span><br><span class="line"><span class="comment">        * 所有的请求都会经过这个方法，我们可以在这里进行token的解析和用户的认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getTokenFromRequest(request);</span><br><span class="line">        logger.info(<span class="string">&quot;Token: &quot;</span> + token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">                <span class="keyword">if</span> (claims != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> getAuthentication(claims);</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                response.getWriter().write(<span class="string">&quot;Token expired&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to extract the token from the request.</span></span><br><span class="line"><span class="comment">        * 从请求中提取token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTokenFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bearerToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bearerToken != <span class="literal">null</span> &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to create an authentication object.</span></span><br><span class="line"><span class="comment">        * 创建一个认证对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// Implement token parsing and authentication creation logic</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(claims, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web配置"><a href="#Web配置" class="headerlink" title="Web配置"></a>Web配置</h4><ul><li>将过滤器注册到Spring容器中。</li><li>跨域配置。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Configures the security filter chain that carries out authentication and authorization.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http the HttpSecurity object to configure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the SecurityFilterChain object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if an error occurs during configuration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/api/user/login&quot;</span>).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))</span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:9000&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(List.of(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setAllowedHeaders(List.of(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWT结构示例"><a href="#JWT结构示例" class="headerlink" title="JWT结构示例"></a>JWT结构示例</h2><p>JWT 由三部分组成，分别是 Header、Payload 和 Signature，它们之间使用 . 分隔。</p><p><strong>示例</strong></p><ol><li>Header：头部包含 JWT 的类型和使用的签名算法<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Header 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li><li>Payload：它包含用户的声明信息，例如用户的 ID、用户名等。这些信息通常包括注册声明、自定义声明等<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Payload 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure></li><li>Signature：签名是对 Header 和 Payload 的签名，防止数据被篡改<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Signature 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure>最终生成的 JWT 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure></li></ol><p>解码后的结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header: &#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">Payload: &#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">Signature: HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java实战项目中，对于登陆操作，想要达到下面的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登陆成功后，登陆的状态保持一段时间，不需要重复登陆&lt;/l</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>包管理器相关</title>
    <link href="https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2024-09-30T03:14:49.000Z</published>
    <updated>2024-09-30T03:39:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。</p><p>到现在已经接触到很多包管理器，比如 <code>npm</code>、<code>yarn</code>、<code>pip</code>、<code>brew</code>、<code>apt</code>、<code>yum</code>、<code>docker</code>、<code>composer</code> 等等。</p><p>于是想到，这些包管理器都是怎么实现的呢？它们之间有什么区别呢？</p><h2 id="什么是包管理器"><a href="#什么是包管理器" class="headerlink" title="什么是包管理器"></a>什么是包管理器</h2><p>包管理器是一种工具，用于自动化管理软件包（libraries, dependencies）的下载、安装、更新和卸载。它帮助开发人员轻松处理项目所需的依赖项，确保不同的库和工具能够正确地协同工作。</p><p>如果不使用包管理器，那么就需要手动下载、安装、更新和卸载软件包，这样会导致很多问题，比如版本冲突、依赖关系、安装路径等等。</p><h2 id="包管理器的包是从哪里来的呢？"><a href="#包管理器的包是从哪里来的呢？" class="headerlink" title="包管理器的包是从哪里来的呢？"></a>包管理器的包是从哪里来的呢？</h2><p>包管理器的包通常存储在一个或多个远程仓库中，开发人员可以从这些仓库中下载所需的软件包。这些仓库通常由软件的开发者或维护者维护，确保软件包的安全性和可靠性。</p><p>有些包管理的仓库服务器在国外，下载速度可能会比较慢，所以有些国内的公司会搭建自己的镜像仓库，比如淘宝的 <code>npm</code> 镜像、阿里云的 <code>docker</code> 镜像等等。（这里涉及到更换源）</p><p>那么理论上来说，也可以在本地搭建一个仓库，然后使用包管理器从本地仓库下载软件包。</p><h2 id="包管理器的作用"><a href="#包管理器的作用" class="headerlink" title="包管理器的作用"></a>包管理器的作用</h2><ul><li>安装依赖项：根据项目的配置文件（如<code>package.json</code>、<code>pom.xml</code>等），自动下载并安装项目所需的依赖包。</li><li>版本管理：包管理器能够处理依赖包的版本，确保项目使用兼容的版本，避免版本冲突。</li><li>更新：可以检查并更新到某个包的最新版本，或者锁定在特定版本。</li><li>卸载：移除不再需要的依赖包。</li></ul><h2 id="包管理器的分类"><a href="#包管理器的分类" class="headerlink" title="包管理器的分类"></a>包管理器的分类</h2><h3 id="1-操作系统级别的包管理器"><a href="#1-操作系统级别的包管理器" class="headerlink" title="1. 操作系统级别的包管理器"></a>1. 操作系统级别的包管理器</h3><p>这些包管理器用于管理操作系统中的软件包和库，通常用于安装和管理操作系统级别的应用程序和工具。它们主要处理的是操作系统中的二进制文件或预编译的软件包</p><ul><li>APT (Advanced Package Tool)：Debian 和 Ubuntu 系统上常用的包管理器。</li><li>YUM (Yellowdog Updater, Modified)：CentOS、RHEL 系统上的包管理器。</li><li>brew：macOS 上的包管理器。</li><li>Chocolatey：Windows 上的包管理器。</li></ul><h3 id="2-编程语言级别的包管理器"><a href="#2-编程语言级别的包管理器" class="headerlink" title="2. 编程语言级别的包管理器"></a>2. 编程语言级别的包管理器</h3><p>这些包管理器用于管理编程语言中的软件包和库，通常用于安装和管理项目级别的依赖项。它们主要处理的是源代码或库文件，通常会下载源代码并编译安装。</p><ul><li>npm (Node Package Manager)：JavaScript 的包管理器，用于 Node.js 项目。</li><li>yarn：JavaScript 的包管理器，用于 Node.js 项目。</li><li>pip：Python 的包管理器。</li><li>Maven：管理 Java 项目的依赖项和构建的工具。</li><li>Gradle：更灵活的构建和依赖管理工具，适用于多种编程语言，包括 Java。</li></ul><h2 id="版本管理器"><a href="#版本管理器" class="headerlink" title="版本管理器"></a>版本管理器</h2><p>这里的版本管理器指conda、nvm、rbenv、pyenv等，它们用于管理不同版本的编程语言或工具。</p><ul><li>conda：Python 的版本管理器，用于创建和管理 Python 环境。</li><li>nvm (Node Version Manager)：Node.js 的版本管理器，用于管理 Node.js 的不同版本。</li></ul><p>在踩坑之前，我觉得conda、nvm都很麻烦，我使用一个版本的python就好了，为什么还需要去做多个版本管理？</p><p>但是在实际开发中，有一次是安装别的工具，这个工具自己下载了一个合适的python版本，并且将我默认的python版本改成了这个版本，导致我之前的项目无法运行，当时的解决方式是更换环境变量，但是这种手动的切换十分麻烦，所以版本管理器就显得很有必要了。</p><p>像node.js也是一样，不同的版本就会出现各种问题，所以本地配置往往需要很多个版本去适应不同的项目。</p><blockquote><p>使用 <code>pip</code> 在不同的 <code>Python</code> 版本（如 Python 3.10 和 Python 3.11）下安装包时，包不能直接在另一个版本下使用，因为每个 <code>Python</code> 版本有自己独立的环境和库安装路径。切换 <code>Python</code> 版本后，之前为另一个版本安装的包不会自动可用。</p><p>正确的做法是为每个 <code>Python</code> 项目指定一个独立的虚拟环境。这样可以确保每个项目拥有独立的依赖项，避免不同项目之间产生冲突或兼容性问题。虚拟环境允许隔离项目的 <code>Python</code> 版本和包管理，使得每个项目可以使用其特定的 <code>Python</code> 版本和依赖库。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>CMake算是一个包管理器吗？</strong></p><p>我们都知道Cmake的功能是用于管理项目的构建过程，它可以生成Makefile、Visual Studio项目文件等，但是它并不是一个包管理器，它只是一个构建工具。</p><p><strong>CMake并不能自动下载和安装依赖项，需要提前安装好，并且在CMakeLists.txt 中指定依赖项</strong></p><p>那么，C++是如何做包管理的呢？（程序员手动管理哈哈）</p><p>C++没有像Java、Python、JavaScript那样有一个统一的包管理器，不过有一些第三方的包管理器，比如：</p><ul><li>Conan：C++ 的包管理器，用于管理 C++ 项目的依赖项。</li><li>vcpkg：微软开发的 C++ 包管理器，用于管理 C++ 项目的依赖项。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。&lt;/p&gt;
&lt;p&gt;到现在已经接触到很多包管理器，比如</summary>
      
    
    
    
    
    <category term="architecture" scheme="https://kelinkong.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记-AOP</title>
    <link href="https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/"/>
    <id>https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/</id>
    <published>2024-09-30T02:19:44.000Z</published>
    <updated>2024-10-22T06:46:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业务逻辑和横切关注点分离开来，提高代码的可维护性和可扩展性。</p><p>这里他举了一个例子，例如每个方法都需要统计运行时间，如果不使用AOP，那么每个方法都需要添加统计时间的代码，这样会导致代码冗余，可维护性差。使用AOP，只需要在一个地方添加统计时间的代码，就可以实现所有方法的统计时间。</p><p>这个思想和设计模式中的装饰器模式有点类似，都是在不改变原有代码的情况下，添加新的功能。</p><p>假设用装饰器模式来实现，应该怎么实现呢？</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式是面向对象的思想</strong>，它允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是继承关系的一个替代方案。</p><ol><li>定义 Service 接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>原始实现 ServiceImpl：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 原始任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Performing the task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义装饰器类 ServiceDecorator：</li></ol><p>装饰器类实现了 Service 接口，并组合了一个 Service 实例。我们通过组合模式，将对原始对象的调用进行包装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service decoratedService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceDecorator</span><span class="params">(Service decoratedService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedService = decoratedService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用装饰器类：</li></ol><p>现在，可以使用装饰器模式为 ServiceImpl 添加统计运行时间的功能，而无需修改原始 ServiceImpl 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用装饰器包装原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">decoratedService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceDecorator</span>(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法，自动统计运行时间</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用AOP又该怎么实现呢？</p><h2 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h2><p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p><p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p><p>以上是我搜索到的内容，但是“面向切面编程”确实抽象，难以理解。</p><p>如果核心是不侵入原始代码去增加一些功能。</p><p>那么这里很容易联想到C++中的函数指针、回调函数以及后面出现的Lambda表达式，这些都是在函数调用时，传递的是函数的地址，而不是函数的返回值。这样就可以在函数调用前后，执行一些操作。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>这里都以Lambda表达式为例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lambda传递行为</span></span><br><span class="line">        performTask(() -&gt; System.out.println(<span class="string">&quot;Task executed!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">performTask</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者在形式上没有什么很大的区别。</p><p>但在实现上还是有一些区别：</p><table><thead><tr><th>特性</th><th>Java AOC</th><th>C++ 函数作为参数传入</th></tr></thead><tbody><tr><td>传递方式</td><td>通过实现接口或继承类创建匿名类实例</td><td>通过函数指针、函数对象、lambda 传递函数</td></tr><tr><td>类型要求</td><td>必须实现接口或继承类</td><td>直接传递函数，使用函数指针或 lambda</td></tr><tr><td>语法简洁性</td><td>Java 8 之前语法较冗长，Java 8 后可用 lambda 简化</td><td>Lambda 语法较简洁，函数指针较底层</td></tr><tr><td>捕获上下文</td><td>只能捕获 final 或 effectively final 变量</td><td>可以捕获任意上下文变量，提供闭包特性</td></tr><tr><td>灵活性</td><td>必须依赖接口或类</td><td>不需要接口，函数指针和 lambda 都可以使用</td></tr><tr><td>性能</td><td>由于会生成匿名内部类的实例，可能开销较大</td><td>函数指针直接传递，效率更高</td></tr></tbody></table><p><strong>尽管思想上相似，但两者在实现上有所不同：</strong></p><ul><li><p>Java 更加面向对象。Java 中，匿名内部类和 Lambda 本质上是依赖接口或者类的实现，体现了 Java 面向对象的特性。即便在 Java 8 之后使用 Lambda，依然是函数式接口的简化语法。这意味着 Java 的行为参数化是通过类或接口来进行的。</p></li><li><p>C++ 更加底层。C++ 允许更直接地操作函数本身，既可以通过函数指针传递行为，也可以通过 Lambda 捕获上下文变量，并将其作为参数传递。这种设计体现了 C++ 语言的灵活性，不需要依赖面向对象的设计。C++ 中的函数传递更接近于函数式编程的思想</p></li></ul><h2 id="使用AOP来实现开头提到的统计时间功能"><a href="#使用AOP来实现开头提到的统计时间功能" class="headerlink" title="使用AOP来实现开头提到的统计时间功能"></a>使用AOP来实现开头提到的统计时间功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声明这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 让 Spring 容器能够管理这个切面。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点：匹配所有在 com.example.service 包下的类和它们的所有方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印方法执行时间</span></span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配所有在 <code>com.example.service</code> 包下的类和它们的所有方法，所以当执行 <code>com.example.service</code> 包下的任意方法时，都会执行 <code>logExecutionTime</code> 方法。</p><h2 id="AOP的关键术语"><a href="#AOP的关键术语" class="headerlink" title="AOP的关键术语"></a>AOP的关键术语</h2><ul><li><strong>切面（Aspect）</strong>：切面是一个类，它包含了一些横切关注点（例如日志记录、事务管理）。在 Spring AOP 中，切面是通过 <code>@Aspect</code> 注解声明的 Java 类。</li><li><strong>连接点（Join Point）</strong>：连接点是在应用执行过程中能够插入切面的点。这些点可以是方法的调用、方法的执行、异常的处理等。在 Spring AOP 中，连接点总是表示方法的执行。</li><li><strong>通知（Advice）</strong>：通知是切面在特定连接点（Join Point）执行的动作。在 Spring AOP 中，有以下几种类型的通知：<ul><li><strong>前置通知（Before Advice）</strong>：在连接点之前执行的通知。</li><li><strong>后置通知（After Advice）</strong>：在连接点之后执行的通知，无论连接点是否正常执行。</li><li><strong>返回通知（After Returning Advice）</strong>：在连接点正常执行后执行的通知。</li><li><strong>异常通知（After Throwing Advice）</strong>：在连接点抛出异常后执行的通知。</li><li><strong>环绕通知（Around Advice）</strong>：在连接点之前和之后执行的通知。</li></ul></li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，它定义了哪些连接点应该被通知。在 Spring AOP 中，切点使用 <code>@Pointcut</code> 注解定义。</li><li><strong>目标对象（Target Object）</strong>：被一个或多个切面通知的对象。</li><li><strong>代理对象（Proxy Object）</strong>：在 Spring AOP 中，代理对象是 Spring 框架创建的对象，它包含了目标对象的增强方法。</li><li><strong>织入（Weaving）</strong>：织入是将切面应用到目标对象并创建代理对象的过程。织入可以发生在编译时、类加载时、运行时。</li><li><strong>引入（Introduction）</strong>：引入允许向现有的类添加新方法和属性。Spring AOP 不支持引入。</li></ul><h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们有一个 <code>UserService</code> 类，它有一个 <code>login</code> 方法，登录时我们希望记录这个方法的执行时间。</p><ol><li>目标对象 (Target Object):<br>这是我们想要增强的对象，也就是 <code>UserService</code> 类中的 <code>login</code> 方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟登录逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging in.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>切面 (Aspect):我们创建一个切面，用于记录方法执行时间的逻辑。</li></ol><p>当以@Aspect作为注解时，Spring就会知道这是一个切面，然后就可以通过各类注解来进行通知了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 切点 (Pointcut) - 指定在哪些方法上应用增强逻辑</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allUserServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 通知 (Advice) - 具体的增强逻辑，这里使用环绕通知来记录执行时间</span></span><br><span class="line">    <span class="meta">@Around(&quot;allUserServiceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + executionTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>当我们调用 login 方法时，增强逻辑（记录执行时间）会自动插入：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">userService.login(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;password123&quot;</span>);</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User Alice is logging in.</span><br><span class="line">void UserService.login(String, String) executed in 50ms</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用AOP实现数据库操作"><a href="#使用AOP实现数据库操作" class="headerlink" title="使用AOP实现数据库操作"></a>使用AOP实现数据库操作</h2><p>在AOP出现之前，使用JDBC操作数据库，往往需要：<br><img src="/../imgs/image-56.png"><br>但其中的，获取数据库连接、回滚、提交、释放连接，其实都是通用的。</p><p><img src="/../imgs/image-57.png"></p><p>使用注解<code>@Transactional</code>，就表明了该方法需要事物执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-单元测试</title>
    <link href="https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2024-09-26T02:18:29.000Z</published>
    <updated>2024-09-26T02:59:50.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Mockito和JUnit5进行单元测试。</p><p>需要注入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>使用@Test注解标记测试方法。</li><li>测试代码和被测试代码放到同一个包中。</li></ul><h3 id="示例背景"><a href="#示例背景" class="headerlink" title="示例背景"></a>示例背景</h3><ul><li>假设有一个服务类<code>MockService</code>，其中有一个<code>serviceMethod</code>方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个临时类<code>MockTmp</code>，其中有一个<code>tmpMethod</code>方法。<code>MockTmp</code>的构造器需要传入一个<code>MockService</code>对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个被测试类<code>MockUser</code>，其中包含了<code>MockService</code>类、一个私有方法、一个静态方法、一个公有方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试将会覆盖：私有方法测试、静态方法测试、公有方法测试、构造器测试。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建Mock对象"><a href="#创建Mock对象" class="headerlink" title="创建Mock对象"></a>创建Mock对象</h3><ol><li>使用<code>@Mock</code>注解或<code>Mockito.mock</code>方法创建Mock对象。</li><li>使用<code>@Spy</code>注解或<code>Mockito.spy</code>方法创建Mock对象。</li><li>使用<code>MockBean</code>注解创建Mock对象。</li><li>使用<code>@InjectMocks</code>注解或<code>MockitoAnnotations.initMocks</code>方法注入Mock对象。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line"><span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>@Mock</code>和<code>@Spy</code>注解的区别：</p><ul><li><code>@Mock</code>注解创建的对象是一个真正的Mock对象，它会覆盖被Mock的方法。</li><li><code>@Spy</code>注解创建的对象是一个真实的对象，它会保留被Mock的方法的原始实现。</li></ul><h3 id="Mock方法"><a href="#Mock方法" class="headerlink" title="Mock方法"></a>Mock方法</h3><ol><li>使用<code>Mockito.when</code>方法模拟方法调用。</li><li>使用<code>Mockito.doReturn</code>方法模拟方法调用。</li><li>使用<code>Mockito.doThrow</code>方法模拟方法调用。</li><li>使用<code>Mockito.doNothing</code>方法模拟方法调用。</li><li>使用<code>Mockito.doAnswer</code>方法模拟方法调用。<br>…</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)).thenReturn(<span class="string">&quot;Hello, Tom!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doReturn(<span class="string">&quot;Hello, Tom!&quot;</span>).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doNothing().when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="verify方法和assert方法"><a href="#verify方法和assert方法" class="headerlink" title="verify方法和assert方法"></a>verify方法和assert方法</h3><ol><li>使用<code>Mockito.verify</code>方法验证方法调用。</li><li>使用<code>Assert.assertEquals</code>方法断言方法调用。</li><li>使用<code>Assert.assertTrue</code>方法断言方法调用。<br>…<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(mockService, Mockito.times(<span class="number">1</span>)).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;Hello, Tom!&quot;</span>, mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">Assert.assertTrue(<span class="string">&quot;Hello, Tom!&quot;</span>.equals(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过反射调用私有方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mockito无法直接模拟私有方法，需要通过反射调用。</p><h3 id="测试静态方法"><a href="#测试静态方法" class="headerlink" title="测试静态方法"></a>测试静态方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试公有方法"><a href="#测试公有方法" class="headerlink" title="测试公有方法"></a>测试公有方法</h3><p>被调用的所有方法都mock掉，只测试公有方法。这样可以保证测试的是公有方法的逻辑，而不是依赖的其他方法。<br><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">        <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">        <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">        <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">    Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">    <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">    <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">    <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">        MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">        mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果是<code>test test private test test test</code>。</p><p>可以看出，只有<code>privateMethod</code>方法没有被<code>mock</code>掉，其他方法都被<code>mock</code>掉了。</p><p>目前还没有找到方法去<code>mock</code>类内私有方法（基于不能修改源代码、也不能使用powerMockito）。（如果有大佬看到，求教，邮箱<a href="mailto:&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>）</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">    assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><code>MockService</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;serviceMethod&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; service&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockTmp</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; tmp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUser</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">            <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">            <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">            <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUserTest</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.ArgumentMatchers.anyString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockUserTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Spy</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">        Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">        <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">        <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">        <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">            MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            )&#123;</span><br><span class="line"></span><br><span class="line">            mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">            assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">        assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用Mockito和JUnit5进行单元测试。&lt;/p&gt;
&lt;p&gt;需要注入依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xm</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-组合、继承、接口</title>
    <link href="https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-09-25T01:30:55.000Z</published>
    <updated>2024-09-25T08:43:26.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合和聚合"><a href="#组合和聚合" class="headerlink" title="组合和聚合"></a>组合和聚合</h2><ul><li><p>组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。例如，“汽车拥有引擎”</p></li><li><p>聚合（Aggregation）动态的组合。</p></li></ul><p><strong>组合</strong>：表示整体与部分的关系，整体和部分的生命周期一样，整体不存在了，部分也不存在了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine starting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>聚合</strong>：表示整体与部分的关系，整体和部分的生命周期不一样，整体不存在了，部分还存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departments; <span class="comment">// Company 聚合多个 Department</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.departments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        departments.add(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDepartments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Department department : departments) &#123;</span><br><span class="line">            System.out.println(department.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">hr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;HR&quot;</span>);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.addDepartment(hr); <span class="comment">// Company 聚合 Department</span></span><br><span class="line">        company.addDepartment(it);</span><br><span class="line"></span><br><span class="line">        company.showDepartments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么推荐使用组合而不是继承"><a href="#为什么推荐使用组合而不是继承" class="headerlink" title="为什么推荐使用组合而不是继承"></a>为什么推荐使用组合而不是继承</h2><ul><li>继承在某些特定情况下是有用的，比如实现“是一个”的关系（如 Dog 是一种 Animal），但由于它带来的耦合问题、封装性破坏以及灵活性不足，推荐尽可能优先使用组合。</li><li>组合更加灵活、可维护性更好，能够在不破坏现有代码结构的情况下进行修改和扩展。因此，在大多数情况下，推荐使用组合而不是继承。</li></ul><blockquote><p>组合和继承都可以实现在不修改源代码的情况下，扩张已有的类的功能。但是组合更加灵活，因为它可以在运行时动态地改变对象的行为。</p><p>组合是一种包含关系，一个类的对象包含另一个类的对象，通过调用另一个类的方法来实现功能。</p></blockquote><h2 id="继承和接口的区别"><a href="#继承和接口的区别" class="headerlink" title="继承和接口的区别"></a>继承和接口的区别</h2><p>继承：</p><ul><li>继承是面向对象编程中的一种机制，允许一个类（子类）从另一个类（父类）继承其属性和方法。</li><li>继承表示的是 “is-a” 关系，比如 Dog 继承自 Animal，意味着狗是一种动物。</li><li>在继承关系中，子类继承父类的非私有（private）的成员变量和方法，并且可以重写父类方法。</li><li>Java 中类的继承是单继承的，一个类只能有一个父类。</li></ul><p>接口：</p><ul><li>接口是一种抽象类型，定义了类必须实现的行为，但不提供具体实现。</li><li>接口表示的是 “can-do” 或者 “contract-based” 关系，意味着类必须实现接口中声明的方法。</li><li>一个类可以实现多个接口，这使得接口在多态设计中非常有用。</li><li>Java 支持多接口实现，一个类可以实现多个接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java中的接口和C-中的抽象类的区别"><a href="#Java中的接口和C-中的抽象类的区别" class="headerlink" title="Java中的接口和C++中的抽象类的区别"></a>Java中的接口和C++中的抽象类的区别</h2><h3 id="语法和定义"><a href="#语法和定义" class="headerlink" title="语法和定义"></a>语法和定义</h3><p>Java 的接口：</p><ul><li>接口使用 interface 关键字定义。</li><li>接口中的方法默认是抽象的（不提供实现），并且所有字段默认是 public static final（常量）。</li><li>Java 8 及之后，接口可以有 default 和 static 方法，这些方法可以有实现。</li><li>接口中的所有方法默认是 public，即使没有显式声明。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">prepareForFlight</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing for flight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>C++ 的抽象类：</p><ul><li>抽象类使用 class 关键字定义。</li><li>抽象类可以包含抽象方法（纯虚函数）和具体方法（有实现的方法）。</li><li>抽象类可以包含成员变量，并且可以是各种访问级别：private、protected 或 public。</li><li>纯虚函数在 C++ 中用 &#x3D; 0 标记，表示该方法没有实现，必须由子类实现。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareForFlight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Preparing for flight&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和成员变量"><a href="#构造函数和成员变量" class="headerlink" title="构造函数和成员变量"></a>构造函数和成员变量</h3><p>Java 的接口：</p><p>接口中不能有构造函数，因为接口不能直接实例化。<br>接口不能包含实例变量，只有 static 和 final 常量。</p><p>C++ 的抽象类：</p><p>抽象类可以有构造函数，尽管不能直接实例化抽象类，但它可以用来初始化子类。<br>抽象类可以包含实例变量，这些变量可以在子类中继承。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Java 的接口：</p><p>接口的方法调用通过虚拟机的动态分派机制来实现，通常比直接调用类中的方法略慢。<br>随着 JVM 优化，接口的性能已经非常接近普通类的方法调用。</p><p>C++ 的抽象类：</p><p>C++ 使用虚函数表（vtable）来处理多态调用，性能相对较高，因为是在编译时确定虚函数表，运行时通过指针查找。<br>由于虚函数机制的直接性，C++ 抽象类的多态调用在许多情况下比 Java 的接口实现更快</p><h2 id="Java是如何实现多态的"><a href="#Java是如何实现多态的" class="headerlink" title="Java是如何实现多态的"></a>Java是如何实现多态的</h2><h3 id="编译时多态（静态多态）"><a href="#编译时多态（静态多态）" class="headerlink" title="编译时多态（静态多态）"></a>编译时多态（静态多态）</h3><p>方法重载（Method Overloading）：</p><p>方法重载是指同一个类中可以有多个方法名相同，但参数类型或参数数量不同的方法。根据传入参数的不同，编译器会在编译时决定调用哪个版本的重载方法。</p><p>这是静态多态的表现形式，因为在编译阶段就确定了调用的方法。</p><h3 id="运行时多态（动态多态）"><a href="#运行时多态（动态多态）" class="headerlink" title="运行时多态（动态多态）"></a>运行时多态（动态多态）</h3><p>方法重写（Method Overriding）：</p><p>运行时多态的核心在于方法重写。当一个子类继承父类，并在子类中提供了对父类方法的不同实现时，Java 会在运行时根据对象的实际类型决定调用哪一个方法。</p><p>通过父类引用指向子类对象，调用重写的方法时，实际执行的是子类的实现。这是在运行时根据对象的实际类型动态决定的，因此称为动态多态。<br>实现方式：虚方法机制：</p><p>Java 中的所有非 final 和 private 方法都被认为是虚方法。虚方法是可以被子类重写的方法，Java 使用虚方法表（vtable）来实现多态。</p><p>当调用一个方法时，JVM 会通过对象的实际类型在运行时决定调用哪个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();  <span class="comment">// Animal 类型引用</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        myAnimal.sound();  <span class="comment">// 调用的是 Animal 的 sound() 方法</span></span><br><span class="line">        myDog.sound();     <span class="comment">// 调用的是 Dog 的 sound() 方法</span></span><br><span class="line">        myCat.sound();     <span class="comment">// 调用的是 Cat 的 sound() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>Java 通过接口也可以实现多态。当一个类实现了某个接口时，接口引用可以指向该类的实例，并且在运行时会根据对象的实际类型执行具体的方法实现。</p><h3 id="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"><a href="#当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？" class="headerlink" title="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"></a>当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？</h3><p>如何确定调用的是哪一个接口的实现？</p><ul><li>编译时：当你传入一个接口类型的参数时，编译器只会检查这个对象是否实现了该接口，但不会关心具体是哪一个实现类。</li><li>运行时：在程序运行时，JVM 会根据<strong>传入对象</strong>的实际类型决定调用具体实现类的方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合和聚合&quot;&gt;&lt;a href=&quot;#组合和聚合&quot; class=&quot;headerlink&quot; title=&quot;组合和聚合&quot;&gt;&lt;/a&gt;组合和聚合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm中的temperature</title>
    <link href="https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/"/>
    <id>https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/</id>
    <published>2024-09-23T07:32:39.000Z</published>
    <updated>2024-09-25T01:59:43.925Z</updated>
    
    <content type="html"><![CDATA[<p>$$<br>\begin{aligned}<br>\text { for } i &amp; &#x3D;1, \ldots, L: \<br>x_i &amp; \sim p\left(x_i \mid x_{1: i-1}\right)^{1 &#x2F; T},<br>\end{aligned}<br>$$</p><p>其中  $T≥0$  是一个控制我们希望从语言模型中得到多少随机性的温度参数：</p><ul><li>T&#x3D;0：确定性地在每个位置 i 选择最可能的词元 $x_{i}$</li><li>T&#x3D;1：从纯语言模型“正常（normally）”采样</li><li>T&#x3D;∞：从整个词汇表上的均匀分布中采样</li></ul><p>这个公式和描述与语言模型的温度调节（temperature scaling）有关，常用于生成任务（如文本生成、语言建模）中，控制模型生成的随机性。它影响从模型的概率分布中采样的方式，使生成的文本更加多样化或更加确定。</p><p><img src="/../imgs/image-48.png" alt="alt text"><br><img src="/../imgs/image-49.png" alt="alt text"><br><img src="/../imgs/image-50.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$$&lt;br&gt;&#92;begin{aligned}&lt;br&gt;&#92;text { for } i &amp;amp; &amp;#x3D;1, &#92;ldots, L: &#92;&lt;br&gt;x_i &amp;amp; &#92;sim p&#92;left(x_i &#92;mid x_{1: i-1}&#92;right)^{1 &amp;#x2F; T},&lt;br</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>LLVM中的编码器和解码器</title>
    <link href="https://kelinkong.github.io/2024/09/23/LLVM%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E8%A7%A3%E7%A0%81%E5%99%A8/"/>
    <id>https://kelinkong.github.io/2024/09/23/LLVM%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E5%92%8C%E8%A7%A3%E7%A0%81%E5%99%A8/</id>
    <published>2024-09-23T06:22:51.000Z</published>
    <updated>2024-10-18T00:32:09.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要编码和解码？"><a href="#为什么需要编码和解码？" class="headerlink" title="为什么需要编码和解码？"></a>为什么需要编码和解码？</h2><p>在机器学习中，算法通常无法直接处理文字或类别，需要先将它们转化为数值才能输入模型。</p><p>编码器的作用是接收输入序列，并将其转换成固定长度的上下文向量（context vector）。这个向量是输入序列的一种内部表示，捕获了输入信息的关键特征。在自然语言处理的应用中，输入序列通常是一系列词语或字符。</p><h2 id="Embedding-编码-和-One-hot-编码的比较"><a href="#Embedding-编码-和-One-hot-编码的比较" class="headerlink" title="Embedding 编码 和 One-hot 编码的比较"></a>Embedding 编码 和 One-hot 编码的比较</h2><p><strong>One-hot编码</strong>和<strong>Embedding编码</strong>是机器学习和深度学习中常用的两种数据表示方法，主要用于将类别数据或离散数据转换成神经网络可以处理的数值向量。</p><h3 id="1-One-hot编码"><a href="#1-One-hot编码" class="headerlink" title="1. One-hot编码"></a>1. <strong>One-hot编码</strong></h3><p><strong>One-hot编码</strong>是一种简单的、常用于处理分类变量的表示方法。每个类别被表示为一个只有一个位置为1，其余位置全为0的二进制向量。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>稀疏表示</strong>：对于有 ( N ) 个类别的分类变量，每个类别都会被编码为一个长度为 ( N ) 的向量，只有该类别对应的位置是1，其它位置是0。</li><li><strong>无嵌入信息</strong>：不同类别之间没有相似性或顺序上的信息，所有类别被认为是完全独立的。</li></ul><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>假设你有三个类别：“苹果”、“橙子”和“香蕉”，用One-hot编码如下表示：</p><ul><li>“苹果” &#x3D; [1, 0, 0]</li><li>“橙子” &#x3D; [0, 1, 0]</li><li>“香蕉” &#x3D; [0, 0, 1]</li></ul><p>如果有1000个类别，One-hot编码的向量长度就是1000，虽然每个向量只有一个1，但需要存储很多0，这使得它在大规模分类问题中效率较低。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>简单直观</strong>：One-hot编码很容易理解和实现。</li><li><strong>适用于小型分类问题</strong>：如果类别数较少，One-hot编码是一个不错的选择。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>向量维度高</strong>：随着类别数量的增加，One-hot编码的维度会非常高，导致内存占用增加。</li><li><strong>没有表达类别之间的关系</strong>：所有类别被认为是独立的，没有任何相似性信息。</li></ul><hr><h3 id="2-Embedding编码"><a href="#2-Embedding编码" class="headerlink" title="2. Embedding编码"></a>2. <strong>Embedding编码</strong></h3><p><strong>Embedding编码</strong>是一种密集的、低维度的表示方法，通常用于表示高维度的类别数据或者词汇。Embedding是通过将离散的类别映射到连续的实数向量空间中，使得类别之间的相似性可以通过向量之间的距离表示。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>密集表示</strong>：每个类别被编码为一个长度相对较小的实数向量，而不是一个高维的稀疏向量。</li><li><strong>学习得到的表示</strong>：Embedding通常是通过模型训练得到的，模型会根据任务的目标自动调整Embedding向量，使得相似的类别会有相似的向量表示。</li><li><strong>适合大规模数据</strong>：Embedding编码能够处理大规模的类别数据，特别适合用于处理文本数据中的词汇表示。</li></ul><h4 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h4><p>假设我们仍然有“苹果”、“橙子”和“香蕉”这三个类别，经过Embedding编码，它们可能被映射到一个2维的向量空间中：</p><ul><li>“苹果” &#x3D; [0.25, 0.78]</li><li>“橙子” &#x3D; [0.31, 0.81]</li><li>“香蕉” &#x3D; [0.15, 0.67]</li></ul><p>这些向量不再是稀疏的0和1的表示，而是实数值。模型通过学习这些向量，使得相似的类别（如“苹果”和“橙子”）可能在向量空间中距离较近。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>低维度和密集表示</strong>：Embedding向量维度较低，适合处理类别数量非常大的数据集，如词汇表。</li><li><strong>表达类别之间的关系</strong>：Embedding能够捕捉类别之间的相似性和关系，使得相似类别在向量空间中距离较近。</li><li><strong>灵活性强</strong>：Embedding可以通过模型进行优化，使其适应具体的任务需求。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>需要训练</strong>：Embedding通常需要通过模型训练来得到，如果训练数据不足，Embedding可能无法有效表达类别之间的关系。</li><li><strong>解释性较差</strong>：相比One-hot编码，Embedding向量的物理意义不直观，难以解释具体维度的含义。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>One-hot编码</strong>是一种简单的、易于实现的高维稀疏表示，适合类别数量较少且没有类别关系的场景。</li><li><strong>Embedding编码</strong>是一种低维密集表示，通过模型训练可以捕捉类别之间的相似性，适合类别数量多、存在复杂关系的场景，如自然语言处理中的词向量表示。</li></ul><p>在实际应用中，One-hot编码多用于简单分类任务，而Embedding编码通常用于处理复杂的、高维度的类别数据，比如文本、推荐系统等领域。</p><h2 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h2><p><strong>词向量（Word Vector）</strong>：<br>词向量是一种深度学习技术，旨在将词语映射到一个高维空间中，使得相似的词语在空间中距离较近。词向量可以捕捉到词语之间的语义关系和相似度。例如，如果我们有三个词语 [“cat”, “dog”, “bird”]，词向量后的结果将是：</p><ul><li>cat: [0.1, 0.2, 0.3, …] (维度为 100)</li><li>dog: [0.4, 0.5, 0.6, …] (维度为 100)</li><li>bird: [0.7, 0.8, 0.9, …] (维度为 100)</li></ul><p>词向量的优点是：</p><ul><li>能够捕捉到词语之间的语义关系和相似度。</li><li>可以减少维度灾难，因为词向量的维度可以远小于 One-Hot 编码。</li></ul><p>词向量的缺点是：</p><ul><li>需要大量的计算资源和数据来训练模型。</li><li>训练时间较长。</li></ul><h3 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h3><p><strong>Word2Vec</strong>是一个常用的词嵌入（word embedding）技术，用来将文本中的词转换成连续的、低维的向量。它通过捕捉词汇的上下文关系，学习到能够表示词语语义的向量。这种向量能反映出词汇之间的相似性，例如“苹果”和“橙子”可能会有相似的向量，因为它们都是水果。</p><h3 id="Word2Vec的核心思想"><a href="#Word2Vec的核心思想" class="headerlink" title="Word2Vec的核心思想"></a>Word2Vec的核心思想</h3><p>Word2Vec的基本理念是：<strong>“相似上下文中的词应该有相似的向量表示”</strong>。它的原理可以简单理解为：如果两个词经常出现在相似的上下文中，那么它们的向量应该在向量空间中距离很近。</p><p>Word2Vec有两种主要的模型：</p><ol><li><strong>CBOW（Continuous Bag of Words）</strong>：根据上下文来预测中间的词。</li><li><strong>Skip-gram</strong>：根据一个词来预测它的上下文。</li></ol><h4 id="1-CBOW模型"><a href="#1-CBOW模型" class="headerlink" title="1. CBOW模型"></a>1. <strong>CBOW模型</strong></h4><ul><li><strong>目标</strong>：给定上下文，预测中心词。</li><li><strong>举例</strong>：假设句子是“我喜欢吃苹果”，在CBOW模型中，我们会使用“我”、“喜欢”和“吃”作为上下文来预测“苹果”这个词。</li></ul><p>这个模型通过考虑上下文中的多个词来训练，使得模型能更好地预测中心词，从而学到每个词的语义表示。</p><h4 id="2-Skip-gram模型"><a href="#2-Skip-gram模型" class="headerlink" title="2. Skip-gram模型"></a>2. <strong>Skip-gram模型</strong></h4><ul><li><strong>目标</strong>：给定一个词，预测它的上下文。</li><li><strong>举例</strong>：同样的句子“我喜欢吃苹果”，在Skip-gram模型中，我们使用“苹果”这个词来预测它周围的词“我”、“喜欢”和“吃”。</li></ul><p>Skip-gram适用于小数据集并且效果较好，因为它能够更好地捕捉到稀有词汇的上下文。</p><h3 id="Word2Vec的训练过程"><a href="#Word2Vec的训练过程" class="headerlink" title="Word2Vec的训练过程"></a>Word2Vec的训练过程</h3><p>无论是CBOW还是Skip-gram，它们的训练目标都是通过神经网络将词汇映射到一个低维的向量空间。在训练的过程中，Word2Vec会不断调整这些向量，使得相似的词语在向量空间中距离更近。</p><ul><li><strong>输入层</strong>：输入的是词汇的One-hot编码（即每个词都表示为一个高维稀疏向量）。</li><li><strong>隐藏层</strong>：这层是我们希望学习到的词嵌入向量的维度，通常为100到300维。</li><li><strong>输出层</strong>：CBOW模型的输出是词汇表中的所有词的概率分布，模型会尝试预测出正确的中心词。</li></ul><p>经过训练后，模型会学到一个嵌入矩阵，每个词的嵌入向量就保存在这个矩阵中。这个嵌入向量就是Word2Vec的输出，能够捕捉到词语的语义。</p><h3 id="Word2Vec的优点"><a href="#Word2Vec的优点" class="headerlink" title="Word2Vec的优点"></a>Word2Vec的优点</h3><ul><li><strong>低维表示</strong>：将词语表示为密集的向量，而不是高维的One-hot编码。</li><li><strong>捕捉语义关系</strong>：学到的向量能够捕捉到词汇之间的语义相似性，例如“国王 - 男人 + 女人 &#x3D; 女王”。</li></ul><p><code>model = Word2Vec(sentences, vector_size=100, window=5, min_count=1, workers=4) </code></p><ul><li><code>sentences</code>：输入的句子列表。</li><li><code>vector_size</code>：词向量的维度。</li><li><code>window</code>：窗口大小，表示在训练时考虑的上下文词语的数量</li><li><code>min_count</code>: 最小词语频率。只有频率大于或等于这个值的词语才会被纳入模型。默认值为 1</li><li><code>workers</code>: 并行处理的 worker 数量。默认值为 3。</li></ul><h2 id="Transformer编码器和Word2Vec的对比"><a href="#Transformer编码器和Word2Vec的对比" class="headerlink" title="Transformer编码器和Word2Vec的对比"></a>Transformer编码器和Word2Vec的对比</h2><p><strong>Transformer编码器</strong>和<strong>Word2Vec</strong>虽然都是自然语言处理中的重要技术，但它们在设计理念、功能和应用上有显著差异。让我们逐步对比它们的不同点：</p><h3 id="1-静态-vs-动态嵌入"><a href="#1-静态-vs-动态嵌入" class="headerlink" title="1. 静态 vs 动态嵌入"></a>1. <strong>静态 vs 动态嵌入</strong></h3><ul><li><strong>Word2Vec</strong>：生成的是<strong>静态嵌入</strong>。也就是说，训练完模型后，每个词都会有一个固定的向量表示，词的含义不随上下文变化。例如，“bank”在所有场景中都对应相同的向量，无论它指的是“银行”还是“河岸”。</li><li><strong>Transformer编码器</strong>：生成的是<strong>动态上下文嵌入</strong>。Transformer通过自注意力机制，使得词的表示能够根据它在句子中的上下文动态变化。例如，“bank”在不同上下文中会生成不同的嵌入表示，反映出它的不同含义。</li></ul><h3 id="2-上下文处理能力"><a href="#2-上下文处理能力" class="headerlink" title="2. 上下文处理能力"></a>2. <strong>上下文处理能力</strong></h3><ul><li><strong>Word2Vec</strong>：仅能捕捉<strong>局部上下文信息</strong>。Word2Vec的模型（例如CBOW或Skip-gram）使用了固定的窗口大小，意味着它只能利用词汇前后有限的几个词进行预测。模型没有全局视角，无法很好地处理长距离依赖关系。</li><li><strong>Transformer编码器</strong>：使用<strong>全局上下文信息</strong>。Transformer的<strong>自注意力机制</strong>能够让每个词都能与句子中的所有其他词交互，从而捕捉到长距离依赖关系。这样，Transformer能够更好地理解句子的整体含义，尤其是在复杂的语言现象中。</li></ul><h3 id="3-训练方式"><a href="#3-训练方式" class="headerlink" title="3. 训练方式"></a>3. <strong>训练方式</strong></h3><ul><li><strong>Word2Vec</strong>：是基于<strong>浅层神经网络</strong>的模型，通常使用类似于Skip-gram或CBOW这样的简单架构来预测词与上下文之间的关系。模型只关注词汇和其局部上下文之间的关系，没有更深层次的网络结构。</li><li><strong>Transformer编码器</strong>：是基于<strong>深层神经网络</strong>的架构，通常包含多个层级的编码器。每个编码器层都有多头自注意力机制和前馈神经网络，可以通过层层叠加的方式，逐步学习到更复杂的特征和表示。</li></ul><h3 id="4-处理序列的方式"><a href="#4-处理序列的方式" class="headerlink" title="4. 处理序列的方式"></a>4. <strong>处理序列的方式</strong></h3><ul><li><strong>Word2Vec</strong>：使用的模型没有内置的位置感知机制，也就是说，Word2Vec无法捕捉词序信息。虽然它能够学习到词与词之间的语义关系，但不能很好地区分词的前后顺序。</li><li><strong>Transformer编码器</strong>：采用了<strong>位置编码</strong>（Positional Encoding）来处理词序信息。因为Transformer不依赖于序列结构，它通过位置编码将位置信息显式添加到词嵌入中，帮助模型理解词序对句子意义的重要性。</li></ul><h3 id="5-模型的输出"><a href="#5-模型的输出" class="headerlink" title="5. 模型的输出"></a>5. <strong>模型的输出</strong></h3><ul><li><strong>Word2Vec</strong>：输出的是每个词的<strong>静态向量表示</strong>，不随着任务或上下文变化。它的输出在某种程度上表示了词的全局语义相似性。</li><li><strong>Transformer编码器</strong>：输出的是每个词的<strong>动态向量表示</strong>，这些表示不仅与词的本身有关，还包含它在上下文中的关系。因此，Transformer的输出是针对特定句子上下文的嵌入，捕捉到了句子层次的语义信息。</li></ul><h3 id="6-计算复杂度"><a href="#6-计算复杂度" class="headerlink" title="6. 计算复杂度"></a>6. <strong>计算复杂度</strong></h3><ul><li><strong>Word2Vec</strong>：由于是浅层网络，计算量较小，训练速度较快，适用于快速生成词嵌入。它的计算复杂度与词汇量和嵌入维度成线性关系。</li><li><strong>Transformer编码器</strong>：由于有多层自注意力机制，其计算复杂度较高，尤其是当处理长序列时，自注意力的计算复杂度是**O(n^2)**（n是序列长度）。因此，Transformer虽然功能强大，但对硬件要求较高。</li></ul><h3 id="7-语义表达能力"><a href="#7-语义表达能力" class="headerlink" title="7. 语义表达能力"></a>7. <strong>语义表达能力</strong></h3><ul><li><strong>Word2Vec</strong>：虽然能够捕捉词语的语义相似性，但由于它是静态的，不能处理多义词和上下文变化。因此，它的语义表达能力有限，特别是在处理复杂句子结构时。</li><li><strong>Transformer编码器</strong>：能够通过自注意力机制捕捉句子中每个词的上下文关系，因此语义表达能力更强，能够处理多义词以及更复杂的句法和语义结构。</li></ul><hr><h3 id="具体对比总结"><a href="#具体对比总结" class="headerlink" title="具体对比总结"></a>具体对比总结</h3><table><thead><tr><th>特性</th><th>Word2Vec</th><th>Transformer编码器</th></tr></thead><tbody><tr><td><strong>嵌入类型</strong></td><td>静态嵌入（同一词的向量固定）</td><td>动态上下文嵌入（根据上下文生成不同向量）</td></tr><tr><td><strong>上下文处理能力</strong></td><td>局部上下文</td><td>全局上下文</td></tr><tr><td><strong>训练模型</strong></td><td>浅层神经网络</td><td>深层神经网络，多层自注意力</td></tr><tr><td><strong>位置信息</strong></td><td>无法处理词序</td><td>使用位置编码捕捉词序</td></tr><tr><td><strong>模型输出</strong></td><td>词的固定向量表示</td><td>词在特定上下文中的动态向量表示</td></tr><tr><td><strong>计算复杂度</strong></td><td>较低，训练快速</td><td>较高，计算复杂，尤其是在长序列下</td></tr><tr><td><strong>语义表达能力</strong></td><td>较弱，无法处理多义词</td><td>强大，能处理多义词和复杂语义</td></tr></tbody></table><hr><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>Word2Vec</strong>是一种静态的词嵌入方法，适用于简单的NLP任务，如相似度计算和分类，但它不能处理上下文变化或长距离依赖。</li><li><strong>Transformer编码器</strong>通过自注意力机制，生成动态的上下文敏感嵌入，能够更好地捕捉词汇在句子中的语义关系，是现代语言模型（如BERT、GPT等）的基础架构。</li></ul><p>因此，Transformer编码器可以看作是词嵌入技术的发展和延伸，提供了比Word2Vec更丰富、更上下文相关的词语表示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要编码和解码？&quot;&gt;&lt;a href=&quot;#为什么需要编码和解码？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要编码和解码？&quot;&gt;&lt;/a&gt;为什么需要编码和解码？&lt;/h2&gt;&lt;p&gt;在机器学习中，算法通常无法直接处理文字或类别，需要先将它们转化为数值</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>提示工程</title>
    <link href="https://kelinkong.github.io/2024/09/23/llvm-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/"/>
    <id>https://kelinkong.github.io/2024/09/23/llvm-%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-09-23T02:24:55.000Z</published>
    <updated>2024-10-14T08:35:21.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h3><p>参考<a href="https://www.promptingguide.ai/zh">提示工程指南</a></p><ul><li>Temperature：准确度和发散程度</li><li>Top_p：准确度和发散程度</li><li>Max Length：回复的最大token数</li><li>Stop Sequences：组织模型生成token</li><li>Frequency Penalty</li><li>Presence Penalty</li></ul><h3 id="提示词格式"><a href="#提示词格式" class="headerlink" title="提示词格式"></a>提示词格式</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><p>提示词可以包含以下任意要素：</p><p>指令：想要模型执行的特定任务或指令。  例如：请将文本分为中性、否定或肯定.</p><p>上下文：包含外部信息或额外的上下文信息，引导语言模型更好地响应。 </p><p>输入数据：用户输入的内容或问题。  例如：我觉得食物还可以。</p><p>输出指示：指定输出的类型或格式。 例如：情绪：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请将文本分为中性、否定或肯定</span><br><span class="line">文本：我觉得食物还可以。</span><br><span class="line">情绪：</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>你可以使用命令来指示模型执行各种简单任务，例如“写入”、“分类”、“总结”、“翻译”、“排序”等，从而为各种简单任务设计有效的提示。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提取以下文本中的地名。</span><br><span class="line"></span><br><span class="line">所需格式：</span><br><span class="line">地点：&lt;逗号分隔的公司名称列表&gt;</span><br><span class="line"></span><br><span class="line">输入：“虽然这些发展对研究人员来说是令人鼓舞的，但仍有许多谜团。里斯本未知的香帕利莫德中心的神经免疫学家 Henrique Veiga-Fernandes 说：“我们经常在大脑和我们在周围看到的效果之间有一个黑匣子。”“如果我们想在治疗背景下使用它，我们实际上需要了解机制。””</span><br></pre></td></tr></table></figure><h4 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h4><ul><li>避免不明确，尽量数字化，如几句话：2～3句话</li><li>避免说不要做什么，而要说要做什么</li></ul><h4 id="一些示例"><a href="#一些示例" class="headerlink" title="一些示例"></a>一些示例</h4><p>Explain the above in one sentence</p><p>Mention the large language model based product mentioned in the paragraph above:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classify the text into neutral, negative or positive. </span><br><span class="line"></span><br><span class="line">Text: I think the vacation is okay.</span><br><span class="line">Sentiment: neutral </span><br><span class="line"></span><br><span class="line">Text: I think the food was okay. </span><br><span class="line">Sentiment:</span><br></pre></td></tr></table></figure><h3 id="少样本提示"><a href="#少样本提示" class="headerlink" title="少样本提示"></a>少样本提示</h3><p><strong>零样本提示：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Q: &lt;问题&gt;?</span><br><span class="line">A: </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“whatpu”是坦桑尼亚的一种小型毛茸茸的动物。一个使用whatpu这个词的句子的例子是：</span><br><span class="line">我们在非洲旅行时看到了这些非常可爱的whatpus。</span><br><span class="line">“farduddle”是指快速跳上跳下。一个使用farduddle这个词的句子的例子是：</span><br></pre></td></tr></table></figure><p><strong>标签</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这太棒了！// Negative</span><br><span class="line">这太糟糕了！// Positive</span><br><span class="line">哇，那部电影太棒了！// Positive</span><br><span class="line">多么可怕的节目！//</span><br></pre></td></tr></table></figure><h3 id="链式思考"><a href="#链式思考" class="headerlink" title="链式思考"></a>链式思考</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这组数中的奇数加起来是偶数：4、8、9、15、12、2、1。</span><br><span class="line">A：将所有奇数相加（9、15、1）得到25。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、10、19、4、8、12、24。</span><br><span class="line">A：将所有奇数相加（17、19）得到36。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：16、11、14、4、8、13、24。</span><br><span class="line">A：将所有奇数相加（11、13）得到24。答案为True。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：17、9、10、12、13、4、2。</span><br><span class="line">A：将所有奇数相加（17、9、13）得到39。答案为False。</span><br><span class="line"></span><br><span class="line">这组数中的奇数加起来是偶数：15、32、5、13、82、7、1。</span><br><span class="line">A：</span><br></pre></td></tr></table></figure><p><strong>自动思维链</strong><br>Auto-CoT 主要由两个阶段组成：</p><ul><li>阶段1：问题聚类：将给定问题划分为几个聚类</li><li>阶段2：演示抽样：从每组数组中选择一个具有代表性的问题，并使用带有简单启发式的 Zero-Shot-CoT 生成其推理链</li></ul><h2 id="chat、agent、workflow、text-generation"><a href="#chat、agent、workflow、text-generation" class="headerlink" title="chat、agent、workflow、text generation"></a>chat、agent、workflow、text generation</h2><p>大模型场景中的 <strong>Chat</strong>、<strong>文本生成应用</strong>、<strong>Agent</strong> 和 <strong>工作流</strong> 具有不同的功能和应用目标，以下是对它们的详细区分：</p><h3 id="1-Chat（对话）"><a href="#1-Chat（对话）" class="headerlink" title="1. Chat（对话）"></a>1. <strong>Chat（对话）</strong></h3><ul><li><strong>定义</strong>：基于大模型的 <strong>Chat</strong> 应用允许用户与模型进行对话互动。它通常是一个文本输入&#x2F;输出的界面，用户可以提问或输入文本，模型则生成对应的回复或对话内容。</li><li><strong>特点</strong>：<ul><li>注重即时、交互式的对话体验。</li><li>对用户输入进行实时处理并生成相应的回答。</li><li>对话可以是上下文敏感的，模型会根据对话历史调整回答。</li></ul></li><li><strong>应用场景</strong>：<ul><li>客户支持或虚拟助手：如客服机器人。</li><li>教育类对话：提供与学习者的互动，如语言学习助手。</li><li>一般对话生成工具：如ChatGPT。</li></ul></li></ul><p>   <strong>示例</strong>：<br>   用户：”今天的天气怎么样？”<br>   模型：”今天阳光明媚，温度在20°C左右。”</p><h3 id="2-文本生成应用"><a href="#2-文本生成应用" class="headerlink" title="2. 文本生成应用"></a>2. <strong>文本生成应用</strong></h3><ul><li><strong>定义</strong>：文本生成应用是使用大模型生成完整文本的工具，通常不涉及对话，而是基于用户提供的提示生成特定类型的长文本，如文章、报告、新闻或故事。</li><li><strong>特点</strong>：<ul><li>生成的文本往往是单向的，即用户提供输入，模型生成一次性输出，通常不涉及交互。</li><li>文本生成的长度较长，侧重于特定的主题或任务，如写作辅助、总结或内容创作。</li></ul></li><li><strong>应用场景</strong>：<ul><li>文章或报告生成：为博客、新闻或论文生成内容。</li><li>创意写作：生成小说、短篇故事或剧本。</li><li>文本摘要：从长篇文本中提取关键内容。</li></ul></li></ul><p>   <strong>示例</strong>：<br>   用户：”请为我生成一篇关于人工智能的文章。”<br>   模型：生成一篇多段落的关于人工智能历史和未来发展的文章。</p><h3 id="3-Agent（智能代理）"><a href="#3-Agent（智能代理）" class="headerlink" title="3. Agent（智能代理）"></a>3. <strong>Agent（智能代理）</strong></h3><ul><li><strong>定义</strong>：<strong>Agent</strong> 是一种具有更高自主性和执行力的智能系统。基于大模型，智能代理不仅可以进行对话或生成文本，还能主动执行任务、决策和与其他系统进行交互。它们通常能够访问外部工具或系统，并基于用户需求做出复杂的操作。</li><li><strong>特点</strong>：<ul><li>具备自主性，能够根据上下文或外部信息做出决定。</li><li>可以与多个系统（如API、数据库等）交互，执行复杂的任务。</li><li>具备持续对话和任务管理能力，能够跨多个步骤完成一个复杂任务。</li></ul></li><li><strong>应用场景</strong>：<ul><li>任务自动化：如个人助理，安排会议、发送邮件、处理日常任务。</li><li>智能问答系统：结合外部数据源或工具执行复杂查询，如财务报表生成或系统监控。</li><li>机器人：与环境互动的物理或虚拟机器人。</li></ul></li></ul><p>   <strong>示例</strong>：<br>   用户：”请帮我预订下周三的航班，并在日历中添加日程。”<br>   Agent：调用API预订航班，确认航班信息，并在用户的日历中添加行程。</p><h3 id="4-工作流（Workflow）"><a href="#4-工作流（Workflow）" class="headerlink" title="4. 工作流（Workflow）"></a>4. <strong>工作流（Workflow）</strong></h3><ul><li><strong>定义</strong>：工作流指的是一系列预定义的步骤或任务序列，通常是自动化的，允许模型或系统根据一套规则或条件执行多个任务。这种应用不仅涉及生成文本或回答问题，还可能涉及多个步骤和过程的自动化执行。</li><li><strong>特点</strong>：<ul><li>任务自动化：多个任务按顺序或并行执行。</li><li>触发机制：工作流通常由特定事件或条件触发，按步骤执行各项任务。</li><li>更强的结构化和自动化，通常与后台系统或企业流程集成。</li></ul></li><li><strong>应用场景</strong>：<ul><li>企业流程自动化：如合同审批流程、订单处理。</li><li>数据处理管道：如自动化数据清洗、模型训练和部署流程。</li><li>事件驱动的任务管理：如自动化报告生成，定期执行任务的调度。</li></ul></li></ul><p>   <strong>示例</strong>：<br>   用户提交申请表后，工作流自动执行以下步骤：1. 验证信息，2. 向相关人员发送通知，3. 生成批准文件。</p><hr><h3 id="区别总结"><a href="#区别总结" class="headerlink" title="区别总结"></a>区别总结</h3><table><thead><tr><th>应用类型</th><th>主要功能</th><th>典型场景</th><th>特点</th></tr></thead><tbody><tr><td><strong>Chat</strong></td><td>与用户进行互动对话</td><td>客户支持、教育助手</td><td>实时互动、上下文敏感</td></tr><tr><td><strong>文本生成应用</strong></td><td>基于提示生成较长文本或内容</td><td>文章写作、总结生成、创意写作</td><td>生成一次性输出，通常不涉及交互</td></tr><tr><td><strong>Agent</strong></td><td>自动化任务执行和智能交互</td><td>任务自动化、智能助手、复杂决策</td><td>具备自主性，能够调用外部系统并执行多步骤操作</td></tr><tr><td><strong>工作流</strong></td><td>自动化执行多个步骤或任务的预定义流程</td><td>企业流程、任务自动化、数据处理管道</td><td>结构化、自动化，触发机制，依赖于系统或条件驱动</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;模型设置&quot;&gt;&lt;a href=&quot;#模型设置&quot; class=&quot;headerlink&quot; title=&quot;模型设置&quot;&gt;&lt;/a&gt;模型设置&lt;/h</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-开发实战一</title>
    <link href="https://kelinkong.github.io/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>https://kelinkong.github.io/2024/09/05/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</id>
    <published>2024-09-05T03:47:07.000Z</published>
    <updated>2024-09-25T01:31:26.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>开发一个通用项目管理项目，前端使用react，后端使用Spring Boot</p><h2 id="开发中遇到的知识点"><a href="#开发中遇到的知识点" class="headerlink" title="开发中遇到的知识点"></a>开发中遇到的知识点</h2><h3 id="Spring-Boot的开发框架"><a href="#Spring-Boot的开发框架" class="headerlink" title="Spring Boot的开发框架"></a>Spring Boot的开发框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">project-root/</span><br><span class="line">│</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/</span><br><span class="line">│   │   │   └── com/example/project/</span><br><span class="line">│   │   │       ├── controller/ # 存放控制器类,处理HTTP请求</span><br><span class="line">│   │   │       ├── service/ # 存放业务逻辑类</span><br><span class="line">│   │   │       ├── repository/ #  存放数据访问层的接口和实现</span><br><span class="line">│   │   │       ├── model/ # 存放实体类和数据传输对象(DTO)</span><br><span class="line">│   │   │       ├── └── dto/ </span><br><span class="line">│   │   │       └── ProjectApplication.java # Spring Boot的主应用类,包含main()方法</span><br><span class="line">│   │   │</span><br><span class="line">│   │   └── resources/</span><br><span class="line">│   │       ├── static/ # 存放静态资源如CSS、JavaScript、图片等。</span><br><span class="line">│   │       ├── templates/ # 存放模板文件(如Thymeleaf模板)。</span><br><span class="line">│   │       ├── db/ # 存放sql文件，scheme.sql  data.sql</span><br><span class="line">│   │       └── application.properties # 主配置文件,用于设置应用程序属性。</span><br><span class="line">│   │</span><br><span class="line">│   └── test/  # 存放测试代码。</span><br><span class="line">│       └── java/</span><br><span class="line">│           └── com/example/project/</span><br><span class="line">│</span><br><span class="line">├── target/ # Maven构建生成的目录,包含编译后的类文件和可执行JAR</span><br><span class="line">├── pom.xml # Maven项目配置文件,定义项目依赖和构建过程。</span><br><span class="line">└── README.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p><a href="https://javabetter.cn/springboot/lombok.html">Spring Boot 整合 Lombok，用注解简化 Java 代码，比如说 getter和setter | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>Lombok可以更方便的生成set、get方法，在Maven管理的Java项目中，需要添加：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.6&lt;/version&gt;   # 在jdk21以上的版本，需要设置版本为1.18.30以上</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>其中<code> scope=provided</code>，就说明 Lombok 只在编译阶段生效。也就是说，Lombok 会在编译期静悄悄地将带 Lombok 注解的源码文件正确编译为完整的 class 文件。</p><p>SpringBoot 2.1.x 版本后不需要再显式地添加 Lombok 依赖了。之后，还需要为 Intellij IDEA 安装 Lombok 插件，否则 Javabean 的 getter &#x2F; setter 就无法自动编译，也就不能被调用。不过，新版的 Intellij IDEA 也已经内置好了，不需要再安装。</p><h4 id="常用的Lombok注解"><a href="#常用的Lombok注解" class="headerlink" title="常用的Lombok注解"></a>常用的Lombok注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="meta">@Getter</span> <span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Setter</span> <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span>. <span class="comment">// @Data 注解可以生成 getter / setter、equals、hashCode，以及 toString，是个总和的选项。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CmowerLombok</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> BigDecimal money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p><a href="https://javabetter.cn/springboot/jpa.html">Spring Boot 整合 JPA | 二哥的Java进阶之路 (javabetter.cn)</a></p><p>JPA（Java Persistence API）是一种Java对象持久化技术，它提供了一种将Java对象映射到关系数据库表的机制。当我们定义一个实体类时，JPA会根据类上的注解（如@Entity、@Table、@Column等）来生成对应的数据库表结构。</p><p>可以使用JPA创建：</p><ul><li>Entity（User）</li><li>Repository（UserRepository）</li></ul><p>JPA可以通过实体类来生成数据库表（spring.jpa.hibernate.ddl-auto），常见的配置有：（在生成环境中，不建议使用create、create、drop、update）</p><ul><li>create: 每次应用程序启动时，都会删除现有的数据库表，并根据实体类重新创建。</li><li>create-drop: 与create类似，但是在应用程序关闭时会删除所有表。</li><li>update: 每次应用程序启动时，会根据实体类的定义来更新数据库表结构。</li><li>validate: 仅验证数据库表结构与实体类是否匹配，不会做任何修改。</li><li>none：不做任何操作。</li></ul><p>在<code>application.properties</code>中设置：<code>spring.jpa.hibernate.ddl-auto=update</code></p><p><strong>更新数据库表时，不会自动更新实体类</strong></p><p>JPA生成Repository内置了一些方法，但是也可以通过注解的方式来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TeamRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Team, Integer&gt;, JpaSpecificationExecutor&lt;Team&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all teams</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t&quot;)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findAllTeams</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find a team by its ID</span></span><br><span class="line">    <span class="meta">@Query(&quot;SELECT t FROM Team t WHERE t.id = :id&quot;)</span></span><br><span class="line">    Team <span class="title function_">findTeamById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Custom SQL query to find teams by name</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;SELECT * FROM teams WHERE name = :name&quot;, nativeQuery = true)</span></span><br><span class="line">    List&lt;Team&gt; <span class="title function_">findTeamsByName</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Query注解的nativeQuery属性作用：</p><ul><li>nativeQuery&#x3D;false：使用HQL，JPA会根据实体类和关联关系自动生成SQL。</li><li>nativeQuery&#x3D;true：使用原生SQL，JPA直接执行你写的SQL语句</li></ul><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p>在Spring Boot中，<code>@RequestMapping</code> 是一个非常基础且强大的注解，用于将HTTP请求映射到特定的处理方法上。它可以配置请求路径、HTTP方法（GET、POST、PUT、DELETE等）、参数等信息。</p><p>为了简化开发，Spring Boot提供了几个更具体的注解，它们都是<code>@RequestMapping</code>的缩写形式：</p><ul><li><strong>@GetMapping:</strong> 通常用于获取数据，比如查询列表、获取详情等。</li><li><strong>@PostMapping:</strong> 通常用于创建新的资源，比如添加用户、提交表单等。</li><li><strong>@PutMapping:</strong> 通常用于更新整个资源，比如修改用户信息。</li><li><strong>@DeleteMapping:</strong> 通常用于删除资源，比如删除用户。</li><li><strong>@PatchMapping:</strong> 通常用于部分更新资源，比如修改用户的部分信息。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/teams&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TeamService teamService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TeamController</span><span class="params">(TeamService teamService)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.teamService = teamService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;teamId&#125;/members/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteMember</span><span class="params">(<span class="meta">@PathVariable</span> Integer teamId, <span class="meta">@PathVariable</span> Integer userId)</span> &#123;</span><br><span class="line">    teamService.deleteMember(teamId, userId);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@RequestMapping</code>注解可以接受多个参数，如<code>value</code>、<code>method</code>、<code>params</code>、<code>headers</code>等，用于指定请求路径、HTTP方法、请求参数、请求头等信息。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/api/teams&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Team&gt; <span class="title function_">getTeams</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> teamService.getTeams();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用到的注解"><a href="#用到的注解" class="headerlink" title="用到的注解"></a>用到的注解</h3><h4 id="注解是什么？"><a href="#注解是什么？" class="headerlink" title="注解是什么？"></a>注解是什么？</h4><p>注解（Annotation）是一种提供元数据（metadata）的机制。它可以用于标记类、方法、字段等程序元素，从而为编译器或运行时环境提供额外的信息。注解本身不会影响程序的执行逻辑，但可以被编译器、IDE、框架等工具读取并进行相应的处理。</p><h4 id="注解的实现原理"><a href="#注解的实现原理" class="headerlink" title="注解的实现原理"></a>注解的实现原理</h4><p>注解本质上是一个接口。当我们定义一个注解时，实际上是在定义一个接口，并且这个接口继承自<code>java.lang.annotation.Annotation</code>接口。</p><ul><li><strong>注解处理器：</strong><ul><li>注解处理器是实现注解功能的关键。它们在编译时或运行时读取注解信息，并根据注解的定义执行相应的操作。</li><li>常用的注解处理器有：<ul><li><strong>编译时注解处理器：</strong> 在编译时处理注解，如APT（Annotation Processing Tool）。</li><li><strong>运行时注解处理器：</strong> 在运行时处理注解，如反射机制。</li></ul></li></ul></li><li><strong>反射机制：</strong><ul><li>通过反射机制，可以在运行时获取类、方法、字段的注解信息，并动态地调用这些元素。</li></ul></li></ul><h4 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h4><p>注解在Java开发中发挥着重要的作用，主要有以下几个方面：</p><ul><li><strong>提供元数据：</strong> 为编译器、IDE、框架等工具提供额外的信息，如：<ul><li><strong>生成代码：</strong> 比如Lombok注解可以自动生成getter、setter、构造方法等。</li><li><strong>配置信息：</strong> 比如Spring框架中的<code>@Autowired</code>注解用于自动装配Bean。</li><li><strong>验证：</strong> 比如Hibernate Validator中的<code>@NotNull</code>注解用于验证字段不能为空。</li></ul></li><li><strong>减少重复代码：</strong> 通过注解可以减少重复的代码编写，提高开发效率。</li><li><strong>提高代码可读性：</strong> 注解可以明确地表达代码的意图，提高代码的可维护性。</li><li><strong>实现AOP：</strong> 注解可以作为AOP切入点，实现横切关注点。</li></ul><h4 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h4><ul><li><strong>内置注解：</strong> Java内置了一些注解，如<code>@Override</code>、<code>@Deprecated</code>等。</li><li><strong>元注解：</strong> 用于定义注解的注解，如<code>@Target</code>、<code>@Retention</code>、<code>@Documented</code>等。</li><li><strong>自定义注解：</strong> 开发者可以自定义注解，以满足特定的需求</li></ul><h4 id="用到的注解-1"><a href="#用到的注解-1" class="headerlink" title="用到的注解"></a>用到的注解</h4><ul><li>声明 Bean 的注解<br>@Component：通用注解，可以标注任何类为 Spring 组件。<br>@Repository：专用于数据访问层（DAO）的组件。<br>@Service：专用于业务逻辑层（Service）的组件。<br>@Controller：专用于表现层（Controller）的组件。</li><li>注入 Bean 的注解@Autowired：根据类型自动装配 Bean，可以用于字段、方法参数和构造函数。<br>@Qualifier：配合 @Autowired 使用，根据 Bean 的名称进行注入。<br>@Resource：来自 JSR-250，也可以用于注入 Bean，功能类似于 @Autowired。</li><li>配置类相关的注解<br>@Configuration：声明一个配置类，等同于 XML 配置文件。<br>@ComponentScan：指定 Spring 在创建容器时要扫描的包。<br>@Bean：把方法的返回值作为 Bean 对象存入 Spring 容器。</li><li>切面（AOP）相关的注解<br>@Aspect：声明一个切面。<br>@Before、@After、@Around：定义切面中的增强方法。<br>@Pointcut：声明切点，用于定义拦截规则。</li><li>其他常用注解<br>@Value：注入配置文件中的值。<br>@RequestMapping：用于处理 Web 请求。<br>@ResponseBody：将方法的返回值直接写入 HTTP 响应体。<br>@RequestBody：将 HTTP 请求中的 JSON 数据绑定到 Java 对象。<br>@PathVariable：用于获取路径变量的值。<br>@Transactional：声明事务。</li></ul><h2 id="工具-技巧使用"><a href="#工具-技巧使用" class="headerlink" title="工具&#x2F;技巧使用"></a>工具&#x2F;技巧使用</h2><p>Intellj idea快速创建某个接口的实现类：<code>alt+enter</code></p><h3 id="接口类和实现类的调用"><a href="#接口类和实现类的调用" class="headerlink" title="接口类和实现类的调用"></a>接口类和实现类的调用</h3><p>Java中的接口类类似C++中的抽象类。</p><p>我的tokenServiceImpl是tokenService接口的实现，我在别的class中调用这个服务时，我应该使用tokenService还是tokenServiceImpl？</p><blockquote><p>应该使用tokenService。</p><ul><li><strong>依赖注入（Dependency Injection）：</strong> 当 Spring 容器管理你的 Bean 时，它会将 <code>TokenServiceImpl</code> 的实例注入到需要使用 token 服务的类中，但是注入的变量名通常是接口名 <code>tokenService</code>，而不是实现类名 <code>tokenServiceImpl</code>。</li><li><strong>面向接口编程：</strong> 面向接口编程是一种良好的编程习惯。通过使用接口 <code>tokenService</code>，你的代码与具体的实现类解耦，提高了代码的可维护性、可测试性和扩展性。</li><li><strong>多态：</strong> 由于 Java 的多态特性，当你使用 <code>tokenService</code> 时，实际上调用的是 <code>TokenServiceImpl</code> 中实现的方法。这样，如果你以后想更换 <code>TokenServiceImpl</code> 的实现，只需要修改 Spring 配置，而不需要修改调用代码。</li></ul></blockquote><p><strong>Service的注解应该放到实现类上，而不是接口类。</strong></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>为什么要使用JUnit4、mock和verify？</p><ul><li><strong>JUnit4</strong> 是Java中最流行的单元测试框架，提供了丰富的断言和测试注解。</li><li><strong>mock</strong> （模拟对象）可以让我们在测试中替换掉真实对象，从而隔离被测代码，方便测试。</li><li><strong>verify</strong> 用于验证模拟对象的方法调用情况，确保代码的正确性。</li></ul><p>示例，测试一个简单的<code>UserService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 依赖注入,在单元测试中，使用mock模拟</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建UserDao的模拟对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> mock(UserDao.class);</span><br><span class="line">        <span class="comment">// 创建期望的User对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">expectedUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>); </span><br><span class="line">        <span class="comment">// 设置模拟对象的行为，当userDao调用getUserById(1)时，返回期望的User对象</span></span><br><span class="line">        when(userDao.getUserById(<span class="number">1</span>)).thenReturn(expectedUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UserService实例，这是我们要测试的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>(userDao);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用UserService的方法，这是我们要测试的方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">actualUser</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证UserDao的getUserById方法被调用了一次</span></span><br><span class="line">        verify(userDao, times(<span class="number">1</span>)).getUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断言实际的User对象和期望的User对象相等</span></span><br><span class="line">        assertEquals(expectedUser, actualUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"><a href="#在-RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？" class="headerlink" title="在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？"></a>在@RequestMapping注解中添加了url参数后，为什么前端就可以通过url传递参数？</h3><p>@RequestMapping 注解在 Spring MVC 中起着至关重要的作用，它建立了 HTTP 请求与控制器方法之间的映射关系。当前端发送一个 HTTP 请求时，Spring MVC 框架会根据请求的 URL，去寻找匹配的 @RequestMapping 注解，然后调用对应的控制器方法来处理这个请求。</p><p>整个过程可以简化为以下几步：</p><ol><li><strong>前端发送请求:</strong> 用户在浏览器中输入 URL，浏览器将这个请求发送到服务器。</li><li><strong>Spring MVC 拦截请求:</strong> Spring MVC 作为 Web 框架，会拦截所有的 HTTP 请求。</li><li><strong>匹配 @RequestMapping:</strong> Spring MVC 会根据请求的 URL，去容器中查找所有被<code>@RequestMapping</code> 注解标注的方法，并尝试匹配。</li><li><strong>执行控制器方法:</strong> 如果找到了匹配的方法，Spring MVC 就会调用这个方法，并把请求参数传递给方法。</li><li><strong>返回响应:</strong> 控制器方法执行完成后，会返回一个 ModelAndView 对象，Spring MVC 会将这个对象转换为 HTTP 响应，返回给前端。</li></ol><h3 id="Spring-MVC-与-Socket-的关系"><a href="#Spring-MVC-与-Socket-的关系" class="headerlink" title="Spring MVC 与 Socket 的关系"></a>Spring MVC 与 Socket 的关系</h3><ul><li>Spring MVC 的工作原理： Spring MVC 作为一款基于 Servlet 的 Web 框架，其核心是处理 HTTP 请求。当一个 HTTP 请求到达服务器时，Servlet 容器会将请求封装成 HttpServletRequest 和 HttpServletResponse 对象，然后交给 DispatcherServlet 处理。<ul><li>Servlet 和 Socket： Servlet 本质上是运行在 Servlet 容器中的一个 Java 类，它提供了处理 HTTP 请求和响应的接口。Servlet 容器（如 Tomcat、Jetty）则是基于 Socket 实现的，负责监听网络端口，接收客户端的 HTTP 请求，并将其传递给 Servlet。</li></ul></li><li>Spring MVC 与 Socket 的关系：<ul><li>间接依赖： Spring MVC 依赖于 Servlet 容器，而 Servlet 容器直接基于 Socket 工作。因此，Spring MVC 可以说是间接地利用了 Socket 的功能。</li><li>抽象层级： Spring MVC 提供了一层更高级的抽象，将开发者从底层的 Socket编程细节中解放出来。开发者只需要关注业务逻辑，而不需要关心如何处理网络连接、协议解析等。</li></ul></li><li>Socket 的作用：<ul><li>建立连接： Socket 用于在客户端和服务器之间建立网络连接。</li><li>数据传输： 通过 Socket 进行数据传输，实现客户端和服务器之间的通信。</li><li>协议解析： Socket 负责解析 HTTP 协议，将请求和响应数据进行编码和解码。</li></ul></li></ul><h3 id="当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？"><a href="#当我在使用Spring-boot开发时，我还需要手动建立数据库连接池吗？" class="headerlink" title="当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？"></a>当我在使用Spring boot开发时，我还需要手动建立数据库连接池吗？</h3><p><strong>一般情况下，在 Spring Boot 中，我们不需要手动创建数据库连接池。</strong> Spring Boot 默认集成了 HikariCP 这个高性能的数据库连接池，并提供了自动配置。只需在配置文件（如 application.properties 或 application.yml）中配置数据库连接信息，Spring Boot 就会自动创建并管理连接池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql:<span class="comment">//localhost:3306/mydatabase</span></span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=yourpassword</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver <span class="comment">// 这个配置项在 Spring Boot 中用于指定连接数据库的 JDBC 驱动类的全限定名。</span></span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-如何处理多个用户请求"><a href="#Spring-Boot-如何处理多个用户请求" class="headerlink" title="Spring Boot 如何处理多个用户请求?"></a>Spring Boot 如何处理多个用户请求?</h3><p>通常情况下，不需要手动创建线程池。 Spring Boot 已经为您内置了许多自动配置，其中就包括线程池的创建和管理。</p><p>Spring Boot 默认的线程池</p><ul><li>Tomcat线程池: 对于传统的 Servlet 容器 Tomcat，Spring Boot 会默认使用 Tomcat 的线程池来处理 HTTP 请求。</li><li>Undertow线程池: 如果您使用的是 Undertow 作为嵌入式 Servlet 容器，那么 Spring Boot 会使用 Undertow 的线程池。</li></ul><p>这些线程池通常已经经过优化，可以满足大多数应用的并发处理需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a&gt;项目背景&lt;/h2&gt;&lt;p&gt;开发一个通用项目管理项目，前端使用react，后端使用Spring Boot&lt;/p&gt;
&lt;h2 id=&quot;开发中遇到的知识点&quot;&gt;</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-代码规范</title>
    <link href="https://kelinkong.github.io/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://kelinkong.github.io/2024/09/04/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2024-09-04T01:56:31.000Z</published>
    <updated>2024-09-25T01:31:32.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h3><table><thead><tr><th align="center">类型</th><th>风格</th><th>示例</th></tr></thead><tbody><tr><td align="center">变量名</td><td>驼峰</td><td>localValue</td></tr><tr><td align="center">方法名</td><td>驼峰</td><td>getValue</td></tr><tr><td align="center">类名</td><td>首字母大写</td><td>JavaServer</td></tr><tr><td align="center">包名</td><td>小写，分隔符之间有且仅有一个自然语义的单词</td><td>com.excample.demo</td></tr><tr><td align="center">枚举类型&#x2F;常量</td><td>全大写，单词间用下划线隔开</td><td>MAX_STOCK_COUNT</td></tr></tbody></table><p><strong>禁止的命名：</strong></p><ul><li>不能以下划线&#x2F;&amp;开始或结束</li><li>禁止中英文混合</li><li>布尔类型不要加is前缀<ul><li>统一使用 xxx&#x2F;setXxx&#x2F;getXxx</li></ul></li></ul><h3 id="推荐的代码风格"><a href="#推荐的代码风格" class="headerlink" title="推荐的代码风格"></a>推荐的代码风格</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><ol><li>如果变量值仅在一个固定范围内变化，使用enum类型来定义。如SRTING、SUMMER、AUTUMN、WINTER</li><li>如果大括号内为空，简洁地写成{},无需换行和空格，如果是非空代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">getUserID</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>小括号和字符间不留空格，与保留字需要有空格（if&#x2F;while&#x2F;for）</li><li>锁进为4个空格、注释的双斜线和内容之间有且仅有一个空格</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>类、类属性、类方法注释使用Javadoc的规范，使用<code>/* xxx */</code></li><li>所有抽象方法（包括接口）都必须要用Javadoc注释，除了返回值、参数、异常说明外，还必须指出什么方法做什么事情</li><li>枚举类型需要注释</li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li>每行最多包含一条语句</li><li>当switch括号内的变量类型为String时，必须先进行null判断</li><li>在高并发场景中，避免使用等于作为中断或退出的条件，应该用大于等于或者小于等于</li><li>不要在表达式中插入赋值语句</li><li>避免使用取反逻辑运算符</li></ol><h2 id="高级编码规范"><a href="#高级编码规范" class="headerlink" title="高级编码规范"></a>高级编码规范</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li>使用类名直接引用<strong>静态</strong>类型和<strong>静态方法</strong></li><li>避免使用构造函数创建字符串对象</li><li>所有的覆写方法都必须要加<code>@Override</code>注解</li><li>尽量不使用可变参数编程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h2&gt;&lt;h3 id=&quot;命名风格&quot;&gt;&lt;a href=&quot;#命名风格&quot; class=&quot;headerlink&quot; title=&quot;命名风格&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-语法基础篇</title>
    <link href="https://kelinkong.github.io/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"/>
    <id>https://kelinkong.github.io/2024/08/28/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</id>
    <published>2024-08-28T06:13:28.000Z</published>
    <updated>2024-09-26T03:31:52.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="扫盲，Java和C-的一些区别"><a href="#扫盲，Java和C-的一些区别" class="headerlink" title="扫盲，Java和C++的一些区别"></a>扫盲，Java和C++的一些区别</h3><p><strong>Java项目需要编译吗？底层编译原理和C++有什么不同？</strong></p><ol><li>   编译输出：</li></ol><ul><li>Java：编译输出的是平台无关的字节码文件（.class 文件），这些字节码可以在任何安装了 JVM 的平台上运行。</li><li>C++：编译输出的是特定平台的机器码文件（如 .exe 文件），这些文件只能在编译时指定的平台上运行。</li></ul><ol start="2"><li>   跨平台性：</li></ol><ul><li>Java：通过 JVM 的跨平台特性，Java 程序可以“一次编写，到处运行”（Write Once, Run Anywhere）。</li><li>C++：需要为每个平台分别编译代码才能生成可以执行的文件，不具备 Java 那样的跨平台能力。</li></ul><ol start="3"><li>   运行时性能：</li></ol><ul><li>Java：由于字节码需要在运行时通过 JVM 翻译为机器码，可能会在启动时稍慢，但 JIT 编译可以在运行期间优化代码，提高性能。</li><li>C++：由于是直接编译为机器码，C++ 程序的启动和运行速度通常会比 Java 程序快，尤其是在性能关键的应用中。</li></ul><ol start="4"><li>   编译速度：</li></ol><ul><li>Java 编译通常更快，因为编译器只需将代码编译为字节码，而不需要生成机器码。</li><li>C++ 编译通常更慢，尤其是在大型项目中，因为编译器需要生成并优化特定平台的机器码。</li></ul><p><strong>Java编译是否需要再单独安装编译器？</strong></p><p>在编写 Java 程序时，不需要单独安装编译器，因为 Java 编译器是包含在 JDK（Java Development Kit）中</p><p><strong>JDK包含了什么？</strong></p><p>JDK 是 Java 开发的核心工具包，它包含了一整套开发 Java 应用程序所需的工具和库。JDK 的主要组成部分包括：</p><ol><li>   Java 编译器 (javac)：</li></ol><ul><li>这是用于将 Java 源代码（.java 文件）编译成字节码（.class 文件）的工具。</li><li>javac 是 JDK 中最重要的组件之一，负责将人类可读的 Java 代码转换为 JVM 可执行的字节码。</li></ul><ol start="2"><li>   Java 运行时环境 (JRE, Java Runtime Environment)：</li></ol><ul><li>JRE 是运行 Java 程序所需的环境，包括 JVM、Java 类库和其他资源。</li><li>JRE 包含了 Java 虚拟机（JVM）、核心类库和支持文件，但不包括编译器和调试工具。</li><li>JDK 本身包含了一个完整的 JRE，所以在安装 JDK 时也会获得 JRE。</li></ul><ol start="3"><li>   Java 虚拟机 (JVM)：</li></ol><ul><li>JVM 是一个平台独立的虚拟机，负责解释和执行编译后的字节码。</li><li>JVM 使得 Java 程序可以在任何支持 JVM 的操作系统上运行。</li></ul><ol start="4"><li>   核心类库：</li></ol><ul><li>这是 Java 标准库（API），包含了大量的预定义类和接口，用于执行各种常见的编程任务（如数据结构、网络通信、文件操作、并发处理等）。</li><li>核心类库是 Java 程序构建的基础，几乎所有 Java 程序都会使用其中的类和方法。</li></ul><ol start="5"><li>   开发工具：</li></ol><ul><li>java：用于启动 Java 应用程序的命令行工具，它调用 JVM 来执行字节码。</li><li>javadoc：用于生成 Java 代码文档的工具，可以从源码中的注释生成 API 文档。</li><li>jdb：Java 调试工具，允许开发者在运行时调试 Java 应用程序。</li><li>jar：用于创建和管理 Java Archive（JAR）文件的工具，这些文件通常用于打包 Java 类库和应用程序。</li><li>javap：Java 类文件反汇编工具，用于查看编译后的字节码。</li></ul><ol start="6"><li>   其他工具：</li></ol><ul><li>javah：用于生成 C 头文件和源文件，支持 JNI（Java Native Interface）。</li><li>jarsigner：用于对 JAR 文件进行签名和验证的工具。</li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>在Java中，每个源文件都是一个类，类名必须与文件名相同。Java程序的入口是<code>main</code>方法，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</span></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个源码文件只能包含一个public类型的类。</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Java的数据类型分为两大类：基本数据类型和引用数据类型。</p><ol><li>   基本数据类型：byte、short、int、long、float、double、char、boolean。<strong>基本类型的变量直接存储值。</strong></li><li>   引用数据类型：类、接口、数组、String等。<strong>引用类型变量存储的是对象的内存地址（引用）</strong>。</li></ol><p>引用类型变量通常通过 <code>new</code> 关键字创建对象（但也有例外，比如字符串常量池），而基本类型变量则直接赋值。</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>Java中的字符串是不可变的，即一旦创建，就不能再修改。字符串的比较要使用<code>equals()</code>方法，而不是<code>==</code>运算符。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接</strong>：</p><ul><li>使用<code>+</code>运算符拼接字符串。</li><li>使用<code>StringBuilder</code>类进行字符串拼接，它是可变的字符串，效率更高。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">1024</span>);</span><br><span class="line">sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">  .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(s); <span class="comment">// Hello, Mr Bob!</span></span><br></pre></td></tr></table></figure><p>多行字符串可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SELECT * FROM</span></span><br><span class="line"><span class="string">    users</span></span><br><span class="line"><span class="string">    WHERE id = 1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="输出和输入"><a href="#输出和输入" class="headerlink" title="输出和输入"></a>输出和输入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, Java!&quot;</span>); <span class="comment">// 输出并换行</span></span><br><span class="line">System.out.print(<span class="string">&quot;Hello, &quot;</span>); <span class="comment">// 输出不换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;Hello, %s&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// 格式化输出</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;  <span class="comment">// 导入某个类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>在Java的类中，有构造函数，但是没有析构函数。Java的垃圾回收器会自动回收不再使用的对象。</p><p><strong>但是Java同样会有内存泄漏的问题，比如静态变量、集合类等。</strong></p><p>在Java的类中，也有一个this关键字，表示当前实例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123; <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用extends关键字实现继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123; … &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScore</span><span class="params">(<span class="type">int</span> score)</span> &#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>在Java中一个子类只能继承一个父类，子类继承后无法访问父类的私有字段和方法，可以将父类的字段和方法设置为<code>protected</code>。</strong></p></li><li><p>子类不会继承父类的构造方法，但是可以通过<code>super()</code>调用父类的构造方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和C++一样，在Java中可以使用父类的引用指向子类的实例。</li><li>Java中的方法可以被子类覆写，使用<code>@Override</code>注解可以让编译器检查是否正确覆写了父类的方法。</li><li>在Java中 ，同样存在抽象类，使用<code>abstract</code>关键字修饰，抽象类不能被实例化，只能被继承。<code>abstract class Person &#123;&#125;</code></li></ul><p><strong>实例化子类时，会调用父类的构造器，Java是单继承，且所有的类都继承于Object类，那么是这条线上的所有父类、祖父类的构造器都会被调用吗？</strong></p><blockquote><p>是的，在 Java 中，当实例化一个子类时，父类、祖父类乃至更高层次的所有父类的构造函数都会被依次调用，直到根类 Object 的构造函数。这个过程是通过构造函数链实现的。</p></blockquote><p><strong>在Java中，继承是一棵树，构造函数的调用是从下往上的，即先调用子类的构造函数，再调用父类的构造函数，直到根类的构造函数。</strong></p><p><strong>在C++中，继承是一个图。</strong></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p><a href="https://liaoxuefeng.com/books/java/oop/basic/interface/index.html">接口-参考文献</a></p><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以把该抽象类改写为接口：interface。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个具体的class去实现一个interface时，需要使用implements关键字。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>, Hello &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface。</p><h4 id="包"><a href="#包" class="headerlink" title="包"></a>包</h4><p>  在定义class的时候，我们需要在第一行声明这个class属于哪个包。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> example; <span class="comment">// 定义包名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有Java文件对应的目录层次要和包的层次一致。</p><h3 id="和C-作对比："><a href="#和C-作对比：" class="headerlink" title="和C++作对比："></a>和C++作对比：</h3><table><thead><tr><th align="center">关键字</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">常量</td><td align="center">final</td><td align="right">const</td></tr><tr><td align="center">自动类型推导</td><td align="center">var</td><td align="right">auto</td></tr><tr><td align="center">空指针</td><td align="center">null</td><td align="right">nullptr</td></tr><tr><td align="center">字符串</td><td align="center">String</td><td align="right">std::string</td></tr><tr><td align="center">静态方法</td><td align="center">static</td><td align="right">static</td></tr><tr><td align="center">继承</td><td align="center">extends</td><td align="right">: public</td></tr><tr><td align="center">实现</td><td align="center">implements</td><td align="right">: public</td></tr><tr><td align="center">抽象类</td><td align="center">abstract class</td><td align="right">class</td></tr><tr><td align="center">接口</td><td align="center">interface</td><td align="right">class</td></tr><tr><td align="center">包</td><td align="center">package</td><td align="right">namespace</td></tr><tr><td align="center">异常处理</td><td align="center"><a href="https://liaoxuefeng.com/books/java/exception/java-exception/index.html">try-catch-finally</a></td><td align="right">try-catch</td></tr><tr><td align="center">泛型</td><td align="center">List&lt;String&gt;</td><td align="right">vector&lt;string&gt; 模版</td></tr></tbody></table><h4 id="Java和C-中的STL容器区别"><a href="#Java和C-中的STL容器区别" class="headerlink" title="Java和C++中的STL容器区别"></a>Java和C++中的STL容器区别</h4><table><thead><tr><th align="center">容器</th><th align="center">Java</th><th align="right">C++</th></tr></thead><tbody><tr><td align="center">动态数组</td><td align="center">ArrayList</td><td align="right">vector</td></tr><tr><td align="center">链表</td><td align="center">LinkedList</td><td align="right">list</td></tr><tr><td align="center">栈</td><td align="center">Stack</td><td align="right">stack</td></tr><tr><td align="center">队列</td><td align="center">Queue</td><td align="right">queue</td></tr><tr><td align="center">双端队列</td><td align="center">Deque</td><td align="right">deque</td></tr><tr><td align="center">集合</td><td align="center">Set</td><td align="right">set</td></tr><tr><td align="center">映射</td><td align="center">Map</td><td align="right">map</td></tr><tr><td align="center">哈希表</td><td align="center">HashMap</td><td align="right">unordered_map</td></tr><tr><td align="center">哈希集合</td><td align="center">HashSet</td><td align="right">unordered_set</td></tr><tr><td align="center">优先队列</td><td align="center">PriorityQueue</td><td align="right">priority_queue</td></tr></tbody></table><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>Java的反射机制是指在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法。</p><p>如果要实现一个通用的对象<code>拷贝</code>方法，就必须要用反射机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        person.age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        copyProperties(person, employee);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Name: &quot;</span> + employee.name); <span class="comment">// 输出: Employee Name: John</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Employee Age: &quot;</span> + employee.age);   <span class="comment">// 输出: Employee Age: 30</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取源对象的所有字段</span></span><br><span class="line">        Field[] fields = source.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 获取字段的值</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(source);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取目标对象中同名的字段</span></span><br><span class="line">            Field targetField;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetField = target.getClass().getField(field.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 如果目标对象中没有这个字段，则跳过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查字段类型是否匹配</span></span><br><span class="line">            <span class="keyword">if</span> (targetField.getType().equals(field.getType())) &#123;</span><br><span class="line">                <span class="comment">// 将值设置到目标对象中</span></span><br><span class="line">                targetField.set(target, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ol><li>注解的作用</li></ol><ul><li>标注和说明: 注解通常用来标注或说明代码中的某些元素。例如，@Override注解表明一个方法是重写父类或接口的方法，这是一种对代码的说明。</li><li>代码行为的调整: 某些注解会影响代码的行为。例如，@Deprecated注解标注某个方法已经过时，编译器会在使用该方法时发出警告。</li><li>与框架和工具的集成: 许多框架（如Spring、Hibernate）和工具（如JUnit、编译器）使用注解来配置和控制代码的行为。例如，@Autowired注解用于在Spring中自动注入依赖。</li></ul><ol start="2"><li>注解的使用场景</li></ol><ul><li>编译时处理: 注解可以在编译时被处理，例如生成额外的代码、文档，或进行代码校验。例如，@SuppressWarnings注解可以告诉编译器忽略特定的警告。</li><li>运行时反射: 注解可以在运行时通过反射机制读取和使用。例如，JUnit在运行时通过反射读取@Test注解来识别哪些方法是测试方法。</li><li>框架配置: 许多Java框架通过注解来配置和管理对象的行为，这种配置方式比传统的XML配置更加直观和简洁。</li></ul><p><strong>Java的注解和Python的装饰器有什么不同？</strong></p><ol><li>功能与用途：</li></ol><ul><li>Java注解主要用于提供元数据，标记类、方法、字段等。主要用于配置和框架集成，如依赖注入、ORM映射等。</li><li>Python装饰器用于动态改变函数或方法的行为，可以在运行时修改代码逻辑，常用于日志记录、权限控制等。</li></ul><ol start="2"><li>   实现方式：</li></ol><ul><li>Java注解是静态的，不能直接改变代码逻辑，通过编译器或框架在编译时或运行时处理。</li><li>Python装饰器是高阶函数，可以在运行时动态生成、修改或应用，具有更强的灵活性。</li></ul><ol start="3"><li>   使用场景：</li></ol><ul><li>Java注解常见于企业级应用中的配置和元数据标注。</li><li>Python装饰器用于简化代码、提高复用性，特别是在Web开发和数据处理领域。</li></ul><p>两者虽然都是用于增强代码的功能性，但Java注解偏向于静态配置，而Python装饰器偏向于动态行为修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;扫盲，Java和C-的一些区别&quot;&gt;&lt;a href=&quot;#扫盲，Java和C-的一些区别&quot; class=&quot;headerlink&quot; title=&quot;扫盲，Java和C++的一些区别&quot;&gt;&lt;/a&gt;扫盲，Java和C++的一些区别&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Java项目需要</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的网络攻击方式</title>
    <link href="https://kelinkong.github.io/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
    <id>https://kelinkong.github.io/2024/04/03/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</id>
    <published>2024-04-03T04:54:28.000Z</published>
    <updated>2024-05-18T01:53:38.853Z</updated>
    
    <content type="html"><![CDATA[<p>学习网站：<a href="https://xss-game.appspot.com/level1">https://xss-game.appspot.com/level1</a></p><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>XSS（Cross Site Scripting）跨站脚本攻击，是一种代码注入攻击。攻击者在目标网站植入恶意脚本，当用户访问目标网站时，恶意脚本会被执行，从而达到攻击目的。</p><p>假设有一个简单的网页，用于用户输入评论，然后显示在页面上。如果用户输入的内容没有经过过滤，那么用户可以输入一段恶意脚本，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>评论页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>留言板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;post_comment.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;50&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交评论&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端代码没有进行恰当的输入过滤和输出转义，导致用户输入的恶意脚本被执行。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;评论结果&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;评论结果&lt;/h2&gt;</span><br><span class="line">    &lt;p&gt;您的评论是：<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;comment&#x27;</span>]; <span class="meta">?&gt;</span>&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当用户输入如下内容时，就会弹出一个对话框：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert()<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果尝试在<code>&lt;script&gt;</code>标签中输入恶意代码失败了，那么可以尝试使用带有JavaScript属性的HTML元素来执行XSS攻击。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span></span><br><span class="line">&#x27;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;invalid&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;alert()&quot;</span>&gt;</span>&#x27;</span><br><span class="line">0&#x27;); alert(&#x27;XSS&#x27;); //</span><br></pre></td></tr></table></figure><h4 id="XSS攻击的解决措施"><a href="#XSS攻击的解决措施" class="headerlink" title="XSS攻击的解决措施"></a>XSS攻击的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>输出转义：对用户输入的内容进行转义，确保用户输入的内容不会被当做HTML代码执行。</li><li>HTTP头部设置：设置HTTP头部的Content-Security-Policy字段，限制页面加载的资源。</li><li>Cookie设置：设置Cookie的HttpOnly属性，防止JavaScript读取Cookie。</li></ul><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF（Cross Site Request Forgery）跨站请求伪造，是一种利用用户已登录的身份，以用户不知情的情况下，完成非法操作的攻击方式。</p><ul><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问断线都具备一定的有效期，比如1天过期，或者几个小时过气，再次期间权限信息会保留在用户浏览器的cookie中，这本例子中假设用户C刚刚登录了网站A，全新还没有过期。</li><li>攻击者利用正常网站A的CSFR漏洞，构造页面一个恶意网页B，在页面中包含对发往正常网站A的请求，在用户C加载页面B（或者点击某些元素时触发）时，会触发攻击请求，完成攻击。</li><li>由于加载恶意页面B和触发攻击请求都是在用户浏览器端完成的，因为之前用户登录过正常网站，发往正常网站的请求会带有用户授权信息（在cookie中），在授权信息没有过期的情况达到攻击目的。</li></ul><h4 id="CSRF攻击的解决措施"><a href="#CSRF攻击的解决措施" class="headerlink" title="CSRF攻击的解决措施"></a>CSRF攻击的解决措施</h4><ul><li>验证来源站点：在服务器端验证请求的来源站点，只允许来自合法站点的请求。</li><li>验证请求内容：在请求中添加验证信息，确保请求是用户自己发起的。</li><li>防止重复提交：使用Token验证，确保请求只能被执行一次。</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是一种利用Web应用程序中的漏洞，通过在用户提交的数据中插入恶意的SQL语句，从而实现非法操作的攻击方式。</p><p>例如：登陆查询的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果用户输入的<code>$username</code>和<code>$password</code>没有经过过滤，那么用户可以输入一段恶意的SQL语句，比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;archer2017&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样就会返回所有用户的信息，因为<code>OR 1=1</code>永远为真。</p><h4 id="SQL注入的解决措施"><a href="#SQL注入的解决措施" class="headerlink" title="SQL注入的解决措施"></a>SQL注入的解决措施</h4><ul><li>输入验证和过滤：对用户输入的内容进行验证和过滤，确保用户输入的内容符合预期。</li><li>如果不可避免地使用SQL语句进行拼装，可以对用户输入数据进行转义，确保用户输入的内容不会被当做SQL语句执行。</li></ul><h3 id="上传文件漏洞"><a href="#上传文件漏洞" class="headerlink" title="上传文件漏洞"></a>上传文件漏洞</h3><p>上传文件漏洞也是一种常见的web漏洞，攻击者可以用利用服务器端的上传文件漏洞绕过安全验证将代码提交到服务器端，并想办法让代码文件被执行。一单可执行的代码上传成功，会造成比较严重的安全问题，比如获取服务器权限，为攻击者开后门，或者让服务器超载，破快服务器的可用性，甚至是上传病毒，木马。</p><h4 id="上传文件漏洞的解决措施"><a href="#上传文件漏洞的解决措施" class="headerlink" title="上传文件漏洞的解决措施"></a>上传文件漏洞的解决措施</h4><ul><li>限制上传文件类型：限制上传文件的类型，确保只能上传安全的文件。</li><li>将上传文件和应用程序分开存储</li><li>对上传的图片进行重绘</li><li>对上传文件重命名，最好具有一定的随机性，提高攻击成本</li></ul><h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>DDOS（Distributed Denial of Service）分布式拒绝服务攻击，是一种通过大量合法请求，占用服务器资源，导致服务器无法正常提供服务的攻击方式。</p><p>在了解 DDoS 之前，我们需要先知道什么是 DoS。最基本的 DoS 就是利用合理的客户端请求里占用过多的服务器资源，从而使合法用户无法得到服务器的响应。DDoS 攻击便是在传统的 DoS 攻击的基础上产生的一类攻击方式。传统的 DoS攻击一般是一对一的方式，当攻击目标的CPU速度、内存或者网络带宽等各项性能指标不高的情况下，它的效果是明显的，但随着计算机与网络技术的发展，计算机的处理能力显著增加，内存不断增大，这便使得 DoS 攻击逐渐失去了效果。</p><h4 id="DDOS分类"><a href="#DDOS分类" class="headerlink" title="DDOS分类"></a>DDOS分类</h4><p><strong>SYN Flood</strong></p><p>SYN Flood就是利用了 TCP 协议三次握手的过程来达到攻击的目的。攻击者伪造大量的 IP 地址给服务器发送 SYN 报文，因为伪造的 IP 地址不可能存在，也就不可能从客户端得到任何响应，就会一直卡在第三步，服务端就得维护一个非常大的半连接等待列表，并且不断对这个列表中的 IP 地址进行遍历重试，占用了大量的系统资源。而由于服务器资源有限，恶意的连接占满了服务器的等待队列，导致服务器不再接收新的 SYN 请求，使正常的用户无法完成通信。</p><p><strong>DNS Query Flood</strong></p><p>DNS Query Flood 攻击采用的方法是向被攻击的服务器发送海量的域名解析请求。而这部分请求解析的域名一般都是随机生成的，大部分不存在，并且通过伪造端口和客户端IP，防止查询请求被 ACL（访问控制列表）过滤。被攻击的 DNS服务器 在收到域名解析的请求后，首先会在自己的服务器上查找是否该域名的 IP，因为域名的不存在，在自身自然是找不到的，因此DNS 服务器便会向上层的 DNS服务器递归查询域名，直到全球互联网的 13台 根DNS服务器。大量不存在的域名解析请求给服务器带来了很大的负载，当解析请求超过一定量级的时候，就会造成 DNS服务器 解析域名超时，使正常的域名都查询不到对应的 IP，达到了攻击的效果。</p><p><strong>HTTP&#x2F;CC Flood</strong></p><p>CC攻击的原理是通过控制大量的 “肉鸡” 或者利用从互联网上搜寻的大量匿名的 HTTP 代理，模拟正常用户给网站发起请求直到该网站拒绝服务为止。大部分网站会通过 CDN 以及分布式缓存来加快服务端的响应，提高网站的吞吐量。而这些恶意的 HTTP 请求会有意的避开这些缓存，需要进行多次 DB 查询操作或者一次请求会返回大量的数据，加速系统资源的消耗，从而拖垮后端的业务处理系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习网站：&lt;a href=&quot;https://xss-game.appspot.com/level1&quot;&gt;https://xss-game.appspot.com/level1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Network Security" scheme="https://kelinkong.github.io/categories/Network-Security/"/>
    
    
  </entry>
  
</feed>
