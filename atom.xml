<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2025-04-29T02:12:10.757Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字人-基础扫盲</title>
    <link href="https://kelinkong.github.io/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/"/>
    <id>https://kelinkong.github.io/2025/04/25/%E6%95%B0%E5%AD%97%E4%BA%BA-%E5%9F%BA%E7%A1%80%E6%89%AB%E7%9B%B2/</id>
    <published>2025-04-25T01:00:57.000Z</published>
    <updated>2025-04-29T02:12:10.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数字人模型"><a href="#数字人模型" class="headerlink" title="数字人模型"></a>数字人模型</h2><h3 id="什么是数字人模型？"><a href="#什么是数字人模型？" class="headerlink" title="什么是数字人模型？"></a>什么是数字人模型？</h3><p>“虚拟数字人模型”是近年来非常热门的一个概念，它结合了人工智能、计算机图形学、语音合成、自然语言处理等技术，用来创建和驱动一个在视觉、语音和行为上都像真人一样的“数字人”。</p><h4 id="核心构成模块"><a href="#核心构成模块" class="headerlink" title="核心构成模块"></a>核心构成模块</h4><ol><li><p><strong>视觉模型（Avatar生成）</strong></p><ul><li>用来生成虚拟人的三维形象（2D 或 3D）</li><li>可以使用：Unity、Unreal Engine、MetaHuman、Blender 等工具</li><li>技术支持：计算机图形学、人脸建模、动作捕捉</li></ul></li><li><p><strong>语音模型（TTS &amp; ASR）</strong></p><ul><li>TTS：文字转语音（Text to Speech）</li><li>ASR：语音识别（Automatic Speech Recognition）</li></ul></li><li><p><strong>语言理解与生成模型（NLP）</strong></p><ul><li>负责理解用户说的话，生成合适的回应</li><li>如：GPT、ChatGLM、BERT 等大语言模型</li><li>也包含意图识别、情感识别、对话管理等</li></ul></li><li><p><strong>行为驱动模型（动画与情绪联动）</strong></p><ul><li>根据语音和文本生成对应的面部表情和动作</li><li>技术：表情驱动（facial animation）、骨骼动画、AI驱动的姿态识别</li></ul></li><li><p><strong>知识图谱 &#x2F; 记忆系统（可选）</strong></p><ul><li>帮助数字人拥有长期记忆、个性化推荐能力</li></ul></li></ol><h4 id="常见技术栈"><a href="#常见技术栈" class="headerlink" title="常见技术栈"></a>常见技术栈</h4><ul><li><strong>语言处理</strong>：OpenAI GPT、ChatGLM、BERT、Rasa</li><li><strong>语音合成&#x2F;识别</strong>：科大讯飞、腾讯云、百度语音、微软 Azure</li><li><strong>3D建模</strong>：MetaHuman、Unreal Engine、Unity</li><li><strong>驱动引擎</strong>：Unity、UE + Python&#x2F;JS 脚本控制</li><li><strong>集成平台</strong>：D-ID、Synthesia、Alibaba数字人平台等</li></ul><h3 id="常用的数字人模型有哪些？"><a href="#常用的数字人模型有哪些？" class="headerlink" title="常用的数字人模型有哪些？"></a>常用的数字人模型有哪些？</h3><table><thead><tr><th>模型类别</th><th>代表模型</th><th>用途说明</th></tr></thead><tbody><tr><td>🌐 语言模型（NLP）</td><td>ChatGPT &#x2F; GPT-4 &#x2F; ChatGLM &#x2F; Mistral &#x2F; LLaMA</td><td>处理自然语言对话，生成内容</td></tr><tr><td>🔊 语音合成模型（TTS）</td><td>FastSpeech、VITS、Edge TTS、科大讯飞语音</td><td>将文本转成语音，表达情绪语调</td></tr><tr><td>🎙️ 语音识别模型（ASR）</td><td>Whisper、腾讯云语音识别、百度ASR</td><td>将用户语音转成文字，供语言模型处理</td></tr><tr><td>😃 表情&#x2F;驱动模型</td><td>Audio2Face、DeepMotion、Faceware</td><td>根据语音驱动面部表情、动作</td></tr><tr><td>🧠 多模态模型</td><td>GPT-4V、CLIP、Flamingo</td><td>让数字人具备图文混合理解与生成能力</td></tr></tbody></table><h2 id="LiveTalking学习"><a href="#LiveTalking学习" class="headerlink" title="LiveTalking学习"></a>LiveTalking学习</h2><p>仓库地址：<a href="https://github.com/lipku/LiveTalking">LiveTalking</a></p><p>LiveTalking是一个基于数字人技术开发的实时语音交互平台，它允许用户与数字人进行实时语音交互，并实时展示数字人的表情和动作。</p><h3 id="项目运行的流程"><a href="#项目运行的流程" class="headerlink" title="项目运行的流程"></a>项目运行的流程</h3><p>在<code>app.py</code></p><p>在if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:块中，首先通过argparse.ArgumentParser()解析命令行参数。这些参数控制模型类型、传输协议（如WebRTC、RTMP等）、音频处理选项、TTS服务器地址等。</p><p>加载模型和头像 根据选择的模型类型（opt.model），从不同的模块（如ernerf、musetalk、wav2lip）加载相应的模型和头像。</p><table><thead><tr><th>模型</th><th>一句话功能定位</th></tr></thead><tbody><tr><td><strong>ER-NeRF</strong></td><td>高保真的<strong>3D人脸建模和渲染</strong></td></tr><tr><td><strong>MUSE-Talk</strong></td><td>基于音频的<strong>语音驱动唇形动画生成</strong>（多情绪）</td></tr><tr><td><strong>Wav2Lip</strong></td><td>基于音频的<strong>视频嘴型对齐模型</strong></td></tr><tr><td><strong>Ultralight Digital Human</strong></td><td>全流程数字人系统：<strong>轻量建模 + 驱动合成</strong></td></tr></tbody></table><h4 id="📊-功能与特性对比表"><a href="#📊-功能与特性对比表" class="headerlink" title="📊 功能与特性对比表"></a>📊 功能与特性对比表</h4><table><thead><tr><th>项目</th><th><strong>ER-NeRF</strong></th><th><strong>MUSE-Talk</strong></th><th><strong>Wav2Lip</strong></th><th><strong>Ultralight-Digital-Human</strong></th></tr></thead><tbody><tr><td>类型</td><td>NeRF建模</td><td>动画生成（头部）</td><td>嘴型对齐（视频增强）</td><td>全栈式数字人引擎</td></tr><tr><td>输入</td><td>多视角照片 + 音频</td><td>音频（可选图像）</td><td>视频 + 音频</td><td>语音&#x2F;文本 + 图像</td></tr><tr><td>输出</td><td>高精度3D人脸</td><td>带嘴型动画的头像视频</td><td>嘴型对齐修正后视频</td><td>数字人口播视频</td></tr><tr><td>是否3D</td><td>✅（NeRF）</td><td>❌（伪3D&#x2F;2D）</td><td>❌</td><td>可2D或伪3D</td></tr><tr><td>表情&#x2F;情绪控制</td><td>✅</td><td>✅（multi-style）</td><td>❌</td><td>支持一定表情合成</td></tr><tr><td>实时性</td><td>❌（较慢）</td><td>❌（需预处理）</td><td>✅（较快）</td><td>✅（轻量）</td></tr><tr><td>模型体积</td><td>大</td><td>中等</td><td>小</td><td>小（可部署）</td></tr><tr><td>是否可商用</td><td>❌ 研究为主</td><td>❌ 研究为主</td><td>✅（MIT开源）</td><td>✅（商用可谈）</td></tr><tr><td>适用方向</td><td>数字人建模&#x2F;高保真渲染</td><td>虚拟主播嘴型动画</td><td>提升对口型视频真实感</td><td>快速构建轻量数字人客服等</td></tr></tbody></table><p><strong>“口型驱动模型”只是构建数字人的一小部分，而 LiveTalking 是把语音输入 → 模型推理 → 视频输出 → 播放&#x2F;控制 这整条流程封装起来的完整运行框架。</strong></p><h2 id="LatentSync学习"><a href="#LatentSync学习" class="headerlink" title="LatentSync学习"></a>LatentSync学习</h2><p>仓库地址：<a href="https://github.com/bytedance/LatentSync">LatentSync</a></p><p><code>scripts/inference.py</code>代码的核心解析，这是LatentSync项目的<strong>模型推理核心实现</strong>，实现了音视频同步生成的完整处理流程：</p><hr><h3 id="一、代码核心架构"><a href="#一、代码核心架构" class="headerlink" title="一、代码核心架构"></a>一、代码核心架构</h3><table><thead><tr><th>模块</th><th>功能说明</th><th>关键技术</th></tr></thead><tbody><tr><td><strong>音频编码器</strong></td><td>通过Whisper模型提取音频特征</td><td><code>Audio2Feature</code>类实现</td></tr><tr><td><strong>VAE</strong></td><td>视频潜在空间编码&#x2F;解码</td><td>StabilityAI的<code>sd-vae-ft-mse</code></td></tr><tr><td><strong>UNet3D</strong></td><td>时空特征融合与去噪</td><td>3D条件扩散模型</td></tr><tr><td><strong>推理管线</strong></td><td>协调各模块完成生成流程</td><td><code>LipsyncPipeline</code>类</td></tr></tbody></table><h3 id="二、关键代码流程"><a href="#二、关键代码流程" class="headerlink" title="二、关键代码流程"></a>二、关键代码流程</h3><h4 id="1-初始化阶段"><a href="#1-初始化阶段" class="headerlink" title="1. 初始化阶段"></a>1. 初始化阶段</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择计算精度（根据GPU能力自动切换FP16/FP32）</span></span><br><span class="line">is_fp16_supported = torch.cuda.get_device_capability()[<span class="number">0</span>] &gt; <span class="number">7</span></span><br><span class="line">dtype = torch.float16 <span class="keyword">if</span> is_fp16_supported <span class="keyword">else</span> torch.float32</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载扩散模型调度器</span></span><br><span class="line">scheduler = DDIMScheduler.from_pretrained(<span class="string">&quot;configs&quot;</span>)  <span class="comment"># 使用DDIM加速采样</span></span><br></pre></td></tr></table></figure><h4 id="2-模型加载"><a href="#2-模型加载" class="headerlink" title="2. 模型加载"></a>2. 模型加载</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 音频特征提取器（根据cross_attention_dim选择模型规模）</span></span><br><span class="line">audio_encoder = Audio2Feature(</span><br><span class="line">    model_path=<span class="string">&quot;checkpoints/whisper/tiny.pt&quot;</span>,  <span class="comment"># 384维特征</span></span><br><span class="line">    num_frames=config.data.num_frames,         <span class="comment"># 视频帧数（如16帧）</span></span><br><span class="line">    audio_feat_length=config.data.audio_feat_length  <span class="comment"># 音频特征长度</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图像潜在空间编解码器</span></span><br><span class="line">vae = AutoencoderKL.from_pretrained(<span class="string">&quot;stabilityai/sd-vae-ft-mse&quot;</span>)</span><br><span class="line">vae.config.scaling_factor = <span class="number">0.18215</span>  <span class="comment"># 潜在空间缩放系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D UNet去噪模型</span></span><br><span class="line">denoising_unet = UNet3DConditionModel.from_pretrained(</span><br><span class="line">    config=OmegaConf.to_container(config.model),  <span class="comment"># 模型结构配置</span></span><br><span class="line">    ckpt_path=args.inference_ckpt_path            <span class="comment"># 预训练权重</span></span><br><span class="line">).to(dtype=dtype)</span><br></pre></td></tr></table></figure><h4 id="3-推理管线构建"><a href="#3-推理管线构建" class="headerlink" title="3. 推理管线构建"></a>3. 推理管线构建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pipeline = LipsyncPipeline(</span><br><span class="line">    vae=vae,                   <span class="comment"># 潜在空间编解码</span></span><br><span class="line">    audio_encoder=audio_encoder,  <span class="comment"># 音频特征提取</span></span><br><span class="line">    denoising_unet=denoising_unet,  <span class="comment"># 时空去噪</span></span><br><span class="line">    scheduler=scheduler         <span class="comment"># 扩散调度策略</span></span><br><span class="line">).to(<span class="string">&quot;cuda&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="4-生成执行"><a href="#4-生成执行" class="headerlink" title="4. 生成执行"></a>4. 生成执行</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pipeline(</span><br><span class="line">    video_path=args.video_path,  <span class="comment"># 输入视频（驱动姿态）</span></span><br><span class="line">    audio_path=args.audio_path,  <span class="comment"># 输入音频（驱动唇形）</span></span><br><span class="line">    video_out_path=args.video_out_path,  <span class="comment"># 输出视频路径</span></span><br><span class="line">    num_inference_steps=args.inference_steps,  <span class="comment"># 去噪步数（默认20）</span></span><br><span class="line">    guidance_scale=args.guidance_scale,  <span class="comment"># 分类器自由引导强度（默认1.0）</span></span><br><span class="line">    width=config.data.resolution,  <span class="comment"># 输出分辨率（如512）</span></span><br><span class="line">    mask_image_path=config.data.mask_image_path  <span class="comment"># 面部区域掩码</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h3 id="三、关键参数说明"><a href="#三、关键参数说明" class="headerlink" title="三、关键参数说明"></a>三、关键参数说明</h3><table><thead><tr><th>参数</th><th>作用</th><th>典型值</th></tr></thead><tbody><tr><td><code>num_inference_steps</code></td><td>控制生成质量与速度的平衡</td><td>20-50步</td></tr><tr><td><code>guidance_scale</code></td><td>调节音频条件对生成的引导强度</td><td>1.0-3.0</td></tr><tr><td><code>num_frames</code></td><td>同时处理的视频帧数</td><td>16帧</td></tr><tr><td><code>resolution</code></td><td>输出视频分辨率</td><td>512x512</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数字人模型&quot;&gt;&lt;a href=&quot;#数字人模型&quot; class=&quot;headerlink&quot; title=&quot;数字人模型&quot;&gt;&lt;/a&gt;数字人模型&lt;/h2&gt;&lt;h3 id=&quot;什么是数字人模型？&quot;&gt;&lt;a href=&quot;#什么是数字人模型？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Digital Human" scheme="https://kelinkong.github.io/categories/Digital-Human/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-基础学习</title>
    <link href="https://kelinkong.github.io/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2025/04/18/Java-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-04-18T02:03:00.000Z</published>
    <updated>2025-05-12T01:28:51.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>:基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li><li><strong>比较方式</strong>：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li></ul><h2 id="Java的垃圾回收（GC算法）、内存模型（堆-栈）、类加载机制和C-的区别"><a href="#Java的垃圾回收（GC算法）、内存模型（堆-栈）、类加载机制和C-的区别" class="headerlink" title="Java的垃圾回收（GC算法）、内存模型（堆&#x2F;栈）、类加载机制和C++的区别"></a>Java的垃圾回收（GC算法）、内存模型（堆&#x2F;栈）、类加载机制和C++的区别</h2><p>Java和C++在内存管理、内存模型和类加载机制上有显著区别，主要源于Java的自动内存管理（GC）和运行时环境（JVM）的设计。以下是详细对比：</p><h3 id="1-垃圾回收（GC）-vs-手动内存管理"><a href="#1-垃圾回收（GC）-vs-手动内存管理" class="headerlink" title="1. 垃圾回收（GC） vs. 手动内存管理"></a>1. 垃圾回收（GC） vs. 手动内存管理</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>内存管理方式</td><td>自动垃圾回收（GC）</td><td>手动管理（<code>new</code>&#x2F;<code>delete</code>或智能指针）</td></tr><tr><td>内存泄漏风险</td><td>较低（GC自动回收不可达对象）</td><td>较高（需手动释放，易遗漏或重复删除）</td></tr><tr><td>回收算法</td><td>分代收集（Young&#x2F;Old区）、标记-清除、G1等</td><td>无内置GC，需手动实现或依赖第三方库（如Boehm GC）</td></tr><tr><td>性能影响</td><td>GC可能导致STW（Stop-The-World）暂停</td><td>无GC开销，但手动管理可能引入性能问题</td></tr><tr><td>典型工具</td><td>JVM参数调优（<code>-Xms</code>, <code>-Xmx</code>）、VisualVM</td><td>Valgrind（检测内存泄漏）、智能指针（<code>shared_ptr</code>）</td></tr></tbody></table><p>关键区别：<br>• Java的GC自动处理对象生命周期，而C++依赖程序员手动控制（或通过RAII模式）。  </p><p>• Java的GC算法针对不同对象生命周期优化（如分代假设），C++无此机制。</p><h3 id="2-内存模型（堆-栈）"><a href="#2-内存模型（堆-栈）" class="headerlink" title="2. 内存模型（堆&#x2F;栈）"></a>2. 内存模型（堆&#x2F;栈）</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>对象存储位置</td><td>所有对象在堆上（栈仅存基本类型和引用）</td><td>对象可分配在堆（<code>new</code>）或栈（局部变量）</td></tr><tr><td>栈分配效率</td><td>栈仅存基本类型（如<code>int</code>）和对象引用</td><td>栈可存完整对象，访问更快（无堆分配开销）</td></tr><tr><td>堆内存释放</td><td>由GC自动回收</td><td>需手动<code>delete</code>或依赖作用域结束（栈对象）</td></tr><tr><td>内存碎片问题</td><td>GC会整理内存（如CMS的压缩阶段）</td><td>需手动处理（如自定义内存池）</td></tr></tbody></table><p>示例代码对比：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java：对象只能在堆上</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// obj是引用，存储在栈；Object实例在堆</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++：对象可在栈或堆上</span></span><br><span class="line">Object obj_stack;          <span class="comment">// 对象在栈上（自动析构）</span></span><br><span class="line">Object* obj_heap = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 对象在堆上（需手动delete）</span></span><br></pre></td></tr></table></figure><p>关键区别：<br>• Java强制对象分配在堆上（栈仅存引用），C++允许灵活选择。  </p><p>• C++栈对象生命周期与作用域绑定，Java需依赖GC。</p><h3 id="3-类加载机制-vs-编译链接"><a href="#3-类加载机制-vs-编译链接" class="headerlink" title="3. 类加载机制 vs. 编译链接"></a>3. 类加载机制 vs. 编译链接</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>代码加载时机</td><td>运行时动态加载（按需由ClassLoader加载）</td><td>编译时静态链接（所有符号在编译期解析）</td></tr><tr><td>动态性</td><td>支持运行时反射、动态代理等</td><td>无原生反射，需额外库（如RTTI）</td></tr><tr><td>类初始化顺序</td><td>严格规范（静态块、父类优先）</td><td>依赖编译顺序，无明确规范</td></tr><tr><td>依赖管理</td><td>通过ClassPath&#x2F;Jar包隔离</td><td>通过头文件（<code>.h</code>）和库文件（<code>.so</code>&#x2F;<code>.dll</code>）</td></tr></tbody></table><p>Java类加载流程：  </p><ol><li>加载：查找字节码（<code>.class</code>文件）→ 生成<code>Class</code>对象。  </li><li>验证：检查字节码安全性。  </li><li>准备：分配静态变量内存（默认值）。  </li><li>解析：将符号引用转为直接引用。  </li><li>初始化：执行静态代码块和赋值。</li></ol><p>C++编译流程：  </p><ol><li>预处理 → 编译 → 汇编 → 链接（静态&#x2F;动态）。</li></ol><p>关键区别：<br>• Java的类加载是运行时行为，支持动态特性（如热部署）；C++在编译时完成链接，更静态。  </p><p>• Java通过ClassLoader实现隔离（如Tomcat的多Web应用），C++需手动管理符号冲突。</p><h3 id="4-其他重要区别"><a href="#4-其他重要区别" class="headerlink" title="4. 其他重要区别"></a>4. 其他重要区别</h3><table><thead><tr><th>特性</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>指针与引用</td><td>无显式指针，只有引用（安全）</td><td>支持指针和引用（灵活但危险）</td></tr><tr><td>多继承</td><td>不支持（通过接口<code>interface</code>模拟）</td><td>支持多继承（菱形继承问题需虚继承解决）</td></tr><tr><td>运行时类型</td><td>反射API完整（<code>Class</code>对象、方法调用等）</td><td>有限RTTI（<code>typeid</code>、<code>dynamic_cast</code>）</td></tr></tbody></table><h2 id="Java反射的原理"><a href="#Java反射的原理" class="headerlink" title="Java反射的原理"></a>Java反射的原理</h2><p>Java的反射（Reflection）和C++的类似功能实现有本质区别，主要源于两者在运行时类型信息（RTTI）和语言设计哲学上的差异。以下是详细对比和原理分析：</p><hr><p><strong>一、Java反射的原理</strong><br><strong>1. 核心机制</strong><br>• Class对象：每个加载的类在JVM中都有一个唯一的<code>Class</code>对象，存储类的元数据（字段、方法、构造器等）。</p><p>• 动态访问：通过<code>Class</code>对象，可以在运行时获取并操作类的成员，无需在编译时知道具体类结构。</p><p>• 关键类库：</p><p>  • <code>Class&lt;T&gt;</code>：表示类的元数据。</p><p>  • <code>Field</code>：类的字段（包括私有字段）。</p><p>  • <code>Method</code>：类的方法。</p><p>  • <code>Constructor</code>：类的构造器。</p><p><strong>2. 实现原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：通过反射调用String的substring方法</span></span><br><span class="line">Class&lt;?&gt; clazz = String.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(<span class="string">&quot;Hello World&quot;</span>, <span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><p>• 步骤解析：</p><ol><li>类加载：JVM的类加载子系统加载目标类（如<code>String</code>），生成<code>Class</code>对象。 <strong>因为Java的每一个类的类名都是唯一的，所以可以通过类名来获取Class对象。</strong></li><li>元数据提取：通过<code>Class</code>对象的方法（如<code>getMethod()</code>）从方法区中查找元数据。</li><li>动态调用：<code>Method.invoke()</code>通过JNI（Java Native Interface）或JVM内部方法触发实际调用。</li></ol><p><strong>3. 底层支持</strong><br>• 方法区：存储类的元数据（JVM规范中的“类数据”部分）。</p><p>• JVM指令：</p><p>  • <code>invokevirtual</code>：普通方法调用。</p><p>  • <code>invokespecial</code>：构造器&#x2F;私有方法调用。</p><p>  • <code>invokeinterface</code>：接口方法调用。</p><p>  • <code>invokedynamic</code>：动态语言支持（如Lambda表达式）。</p><p><strong>4. 性能开销</strong><br>• 原因：</p><p>  • 运行时解析方法&#x2F;字段（跳过编译期优化）。</p><p>  • 安全检查（如私有方法访问权限）。</p><p>• 优化手段：</p><p>  • 缓存<code>Class</code>&#x2F;<code>Method</code>对象。</p><p>  • 使用<code>MethodHandle</code>（JSR 292，类似C++的函数指针）。</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>这里通过一个必须使用反射的典型场景——动态加载并调用未知类的私有方法，结合代码示例详细说明：</p><hr><p><strong>场景描述</strong><br>假设你正在开发一个插件系统，需要加载第三方开发的插件类（编译时无法获知具体实现），并调用其私有初始化方法 <code>init()</code>。<br>由于以下限制，必须使用反射：  </p><ol><li>插件类名和方法名仅在运行时通过配置文件获取（编译时无法确定）。  </li><li>目标方法是<code>private</code>的，常规调用无法访问。</li></ol><hr><p><strong>示例代码</strong><br><strong>1. 插件类（第三方提供，编译时未知）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三方插件（实际开发中可能是动态加载的jar包中的类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecretPlugin</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123; <span class="comment">// 私有方法，常规方式无法调用</span></span><br><span class="line">        <span class="built_in">this</span>.status = <span class="string">&quot;ACTIVE&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;插件已秘密初始化，状态：&quot;</span> + status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 主程序（通过反射强制调用私有方法）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 动态获取插件类名（例如从配置文件中读取）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pluginClassName</span> <span class="operator">=</span> <span class="string">&quot;SecretPlugin&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 反射加载类（编译时无法知道SecretPlugin的存在）</span></span><br><span class="line">        Class&lt;?&gt; pluginClass = Class.forName(pluginClassName);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">pluginInstance</span> <span class="operator">=</span> pluginClass.getDeclaredConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 反射获取私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">initMethod</span> <span class="operator">=</span> pluginClass.getDeclaredMethod(<span class="string">&quot;init&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 突破私有限制！</span></span><br><span class="line">        initMethod.setAccessible(<span class="literal">true</span>); <span class="comment">// 关键操作：关闭访问检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 调用私有方法</span></span><br><span class="line">        initMethod.invoke(pluginInstance); <span class="comment">// 输出：插件已秘密初始化，状态：ACTIVE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>为什么必须用反射？</strong></p><table><thead><tr><th>限制条件</th><th>常规Java代码</th><th>反射的解决方案</th></tr></thead><tbody><tr><td>类名在编译时未知</td><td>无法直接<code>new SecretPlugin()</code></td><td><code>Class.forName()</code>动态加载</td></tr><tr><td>方法是<code>private</code>的</td><td>无法通过对象调用<code>plugin.init()</code></td><td><code>getDeclaredMethod()</code> + <code>setAccessible(true)</code></td></tr><tr><td>方法签名可能变化</td><td>硬编码调用会导致编译错误</td><td>通过字符串名称获取方法，灵活适应变化</td></tr></tbody></table><hr><p><strong>关键反射API解析</strong></p><ol><li><p><code>Class.forName(String)</code><br>• 动态加载类，完全通过字符串类名操作。  </p><p>• <em>类似场景</em>：JDBC驱动加载（如<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>）。</p></li><li><p><code>getDeclaredMethod(String)</code><br>• 获取类声明的任意方法（包括私有方法），而<code>getMethod()</code>只能获取公共方法。</p></li><li><p><code>setAccessible(true)</code><br>• 关闭Java的访问控制检查，突破<code>private</code>&#x2F;<code>protected</code>限制。  </p><p>• <em>警告</em>：滥用会破坏封装性，应谨慎使用！</p></li><li><p><code>Method.invoke(Object)</code><br>• 动态调用方法，第一个参数是方法所属对象实例。</p></li></ol><hr><p><strong>实际应用场景</strong></p><ol><li><p>框架开发<br>• Spring：通过反射注入<code>@Autowired</code>依赖，调用<code>@PostConstruct</code>方法。  </p><p>• JUnit：发现并运行测试方法（标记<code>@Test</code>的方法名在编译时未知）。</p><p><img src="/../imgs/image-91.png"></p></li><li><p>动态代理<br>• <code>InvocationHandler</code>内部用反射调用目标方法。</p></li><li><p>序列化&#x2F;反序列化<br>• Jackson&#x2F;GSON通过反射访问私有字段将JSON转为对象。</p></li></ol><h2 id="使用-Autowired注解和手动创建的区别"><a href="#使用-Autowired注解和手动创建的区别" class="headerlink" title="使用@Autowired注解和手动创建的区别"></a>使用@Autowired注解和手动创建的区别</h2><p>在Spring框架中，使用<code>@Autowired</code>自动注入依赖和手动创建（如<code>new</code>关键字）有显著区别，主要体现在对象生命周期管理、代码耦合度和扩展性等方面。以下是详细对比：</p><hr><p><strong>1. 核心区别对比</strong></p><table><thead><tr><th>维度</th><th>使用<code>@Autowired</code></th><th>手动创建（<code>new</code>）</th></tr></thead><tbody><tr><td>控制权</td><td>Spring容器管理对象的创建、依赖注入和生命周期</td><td>开发者手动控制</td></tr><tr><td>耦合度</td><td>低（依赖接口而非具体实现）</td><td>高（直接依赖具体类）</td></tr><tr><td>单例管理</td><td>默认单例（共享实例）</td><td>每次<code>new</code>生成独立实例</td></tr><tr><td>依赖注入</td><td>自动解析并注入嵌套依赖（如A依赖B，B依赖C）</td><td>需手动逐层创建依赖链</td></tr><tr><td>扩展性</td><td>轻松替换实现（如通过<code>@Primary</code>或<code>@Qualifier</code>）</td><td>需修改代码重新编译</td></tr><tr><td>测试友好性</td><td>方便Mock依赖（如<code>@MockBean</code>）</td><td>需手动构造测试环境</td></tr><tr><td>AOP支持</td><td>自动代理（事务、日志等切面生效）</td><td>手动创建的对象无法被Spring AOP增强</td></tr></tbody></table><hr><p><strong>2. 代码示例对比</strong><br><strong>场景</strong>：订单服务（<code>OrderService</code>）依赖支付服务（<code>PaymentService</code>）</p><p><strong>方案1：使用<code>@Autowired</code>（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 由Spring注入</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案2：手动创建（不推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 手动创建依赖（高耦合）</span></span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        paymentService.charge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;扣款成功&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>3. 关键差异解析</strong><br><strong>(1) 对象生命周期管理</strong><br>• <code>@Autowired</code>：  </p><p>  • Spring容器统一管理Bean，默认单例模式（整个应用共享一个<code>PaymentService</code>实例）。  </p><p>  • 可通过<code>@Scope(&quot;prototype&quot;)</code>改为多例。  </p><p>• 手动创建：  </p><p>  • 每次<code>new</code>都会生成新实例，生命周期由开发者控制，容易导致内存泄漏或资源浪费。</p><p><strong>(2) 依赖解耦</strong><br>• <code>@Autowired</code>：  </p><p>  • <code>OrderService</code>仅依赖<code>PaymentService</code>的接口（如果提取了接口），后续替换实现（如<code>AlipayService</code>替换<code>PaymentService</code>）无需修改<code>OrderService</code>代码。  </p><p>• 手动创建：  </p><p>  • <code>OrderService</code>直接绑定<code>PaymentService</code>的具体实现，变更实现需修改源代码并重新编译。</p><p><strong>(3) 复杂依赖链处理</strong><br>假设依赖链：<code>OrderService → PaymentService → FraudDetectionService</code><br>• <code>@Autowired</code>：  </p><p>  Spring自动完成整个依赖链的注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FraudDetectionService fraudDetectionService;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 手动创建：  </p><p>  需手动逐层构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = <span class="keyword">new</span> <span class="title class_">PaymentService</span>(<span class="keyword">new</span> <span class="title class_">FraudDetectionService</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(4) AOP与代理支持</strong><br>• <code>@Autowired</code>：  </p><p>  • 若<code>PaymentService</code>有<code>@Transactional</code>注解，Spring会自动生成代理对象实现事务管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charge</span><span class="params">()</span> &#123; <span class="comment">/* 事务生效 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 手动创建：  </p><p>  • <code>new PaymentService()</code>的对象不会被代理，事务、日志等AOP功能全部失效。</p><hr><p><strong>4. 何时选择手动创建？</strong><br>尽管<code>@Autowired</code>是推荐做法，但在以下场景可能需要手动创建：  </p><ol><li>不可控的第三方类：某些库需要手动实例化（如<code>new Gson()</code>）。  </li><li>性能敏感代码：避免Spring代理开销（但99%的场景无需考虑）。  </li><li>单元测试：测试中可能需要手动构造对象（但Spring也提供<code>@TestConfiguration</code>）。</li></ol><hr><p><strong>5. 常见误区</strong><br><strong>误区1：<code>@Autowired</code>等于<code>new</code>？</strong><br>• 错误认知：认为<code>@Autowired</code>只是“自动帮你写<code>new</code>”。  </p><p>• 真相：<code>@Autowired</code>是依赖注入（DI），强调控制反转（IoC），容器负责管理对象及其依赖关系。</p><p><strong>误区2：手动创建更简单？</strong><br>• 短期看：手动创建似乎更直接。  </p><p>• 长期看：随着项目复杂化，手动管理依赖会变成灾难（如修改依赖需全局搜索<code>new</code>语句）。</p><hr><p><strong>6. 最佳实践</strong></p><ol><li>始终优先使用<code>@Autowired</code>：<br>让Spring管理依赖，享受单例、AOP、易于测试等优势。  </li><li>面向接口编程：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentGateway paymentGateway; <span class="comment">// 依赖接口而非具体类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>必要时配合<code>@Bean</code>：<br>在配置类中手动定义Bean（仍由Spring管理）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaymentService <span class="title function_">paymentService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaymentService</span>(customConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用-Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新"><a href="#使用-Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新" class="headerlink" title="使用@Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新"></a>使用@Autowired注解，默认为单例模式，修改可变字段导致所有Bean实例的更新</h3><p>是的，如果Bean是单例（默认）且状态可变，修改其字段会影响所有依赖该Bean的地方。这是Spring单例模式的核心特性，需要根据业务场景谨慎设计。以下是详细分析和解决方案：</p><hr><p><strong>1. 问题复现：单例Bean的字段共享</strong><br><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 默认单例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 可变字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入单例Human</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceB</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Human human; <span class="comment">// 注入同一个单例Human</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作后的影响</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">personServiceA.getHuman().setAge(<span class="number">30</span>); </span><br><span class="line">System.out.println(personServiceB.getHuman().getAge()); <span class="comment">// 输出30！所有注入的地方同步修改</span></span><br></pre></td></tr></table></figure><hr><p><strong>2. 解决方案（根据场景选择）</strong></p><p><strong>方案1：改用原型（Prototype）作用域</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 每次注入新实例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>效果：  </p><p>  • 每次<code>@Autowired</code>或<code>getBean()</code>时生成新实例，修改字段互不影响。  </p><p>缺点：  </p><p>  • 内存开销增大（适合轻量级对象）。  </p><p>  • 需确保无循环依赖（原型Bean注入单例Bean需额外配置）。</p><p><strong>方案2：使用线程局部变量（ThreadLocal）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; age = ThreadLocal.withInitial(() -&gt; <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age.set(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 效果：  </p><p>  • 每个线程独立修改<code>age</code>字段（适合Web应用的请求级隔离）。  </p><p>• 注意：  </p><p>  • 需在请求结束时调用<code>age.remove()</code>防止内存泄漏（可通过拦截器实现）。</p><p><strong>方案3：无状态设计（最佳实践）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="comment">// 不存储可变状态，仅提供方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateRetirementAge</span><span class="params">(<span class="type">int</span> currentAge)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentAge + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：  </p><p>  • 所有方法参数由调用方传入，Bean本身无字段。  </p><p>  • 彻底避免线程安全问题，适合工具类。</p><p><strong>方案4：动态获取Bean（手动控制生命周期）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context; <span class="comment">// 注入Spring上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Human</span> <span class="variable">human</span> <span class="operator">=</span> context.getBean(Human.class); <span class="comment">// 每次获取新实例（需配合@Scope(&quot;prototype&quot;)）</span></span><br><span class="line">        human.setAge(<span class="number">30</span>); <span class="comment">// 不影响其他Bean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适用场景：  </p><p>  • 需要精细控制Bean生命周期的特殊逻辑。</p><p><strong>3. 不同场景的推荐策略</strong></p><table><thead><tr><th>场景</th><th>推荐方案</th><th>原因</th></tr></thead><tbody><tr><td>配置类（如数据库连接参数）</td><td>单例 + 不可变字段</td><td>配置通常全局一致，启动后不应修改</td></tr><tr><td>用户会话信息（如购物车）</td><td>原型作用域或Request作用域</td><td>每个用户需要独立实例</td></tr><tr><td>工具类（如日期计算）</td><td>单例 + 无状态</td><td>无需存储状态，线程安全</td></tr><tr><td>缓存管理</td><td>单例 + ConcurrentHashMap</td><td>共享缓存数据，但需线程安全容器</td></tr></tbody></table><hr><p><strong>4. 关键注意事项</strong></p><ol><li><p>不要滥用单例：<br>• 单例Bean应尽量设计为无状态或只读状态（如<code>@Service</code>、<code>@Repository</code>）。  </p><p>• 可变状态单例Bean是线程安全的大敌（除非用同步锁或并发容器）。</p></li><li><p>慎用<code>@Scope(&quot;prototype&quot;)</code>：<br>• 原型Bean注入单例Bean时，需配合<code>@Lookup</code>或<code>ObjectProvider</code>：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonBean</span> &#123;</span><br><span class="line">    <span class="meta">@Lookup</span> <span class="comment">// Spring会动态生成子类覆盖此方法</span></span><br><span class="line">    <span class="keyword">public</span> PrototypeBean <span class="title function_">getPrototypeBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 实际由Spring实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Web应用的作用域：<br>• 使用<code>@RequestScope</code>或<code>@SessionScope</code>替代手动线程隔离：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequestScope</span> <span class="comment">// 每个HTTP请求独立实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProfile</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="autowired注解和-RequiredArgConstructor的区别"><a href="#autowired注解和-RequiredArgConstructor的区别" class="headerlink" title="@autowired注解和@RequiredArgConstructor的区别"></a>@autowired注解和@RequiredArgConstructor的区别</h2><p><code>@Autowired</code> 和 <code>@RequiredArgsConstructor</code> 都是用于依赖注入的注解，但它们的实现方式、使用场景和底层机制有显著区别。以下是详细对比：</p><hr><p><strong>1. 核心区别总结</strong></p><table><thead><tr><th>维度</th><th><code>@Autowired</code> (Spring原生)</th><th><code>@RequiredArgsConstructor</code> (Lombok)</th></tr></thead><tbody><tr><td>所属框架</td><td>Spring 原生注解</td><td>Lombok 生成的代码（编译时生效）</td></tr><tr><td>注入方式</td><td>反射（运行时通过字段或构造器注入）</td><td>编译时生成全参构造器（基于final或<code>@NonNull</code>字段）</td></tr><tr><td>代码可见性</td><td>显式出现在代码中</td><td>编译后生成实际代码（开发时不可见）</td></tr><tr><td>灵活性</td><td>支持字段、构造器、Setter注入</td><td>仅支持构造器注入</td></tr><tr><td>依赖范围</td><td>必须引入Spring</td><td>需引入Lombok（不依赖Spring）</td></tr><tr><td>适用场景</td><td>需要动态代理或复杂注入逻辑时</td><td>追求代码简洁、减少样板代码</td></tr></tbody></table><hr><p><strong>2. 使用示例对比</strong><br><strong>场景</strong>：一个服务类依赖两个组件</p><p><strong>方案1：<code>@Autowired</code>（字段注入）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 字段注入（反射直接赋值）</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：  </p><p>  • 代码简洁，但违反了”不可变对象”原则（字段可被反射修改）。  </p><p>  • 依赖Spring容器运行时通过反射注入。</p><p><strong>方案2：<code>@Autowired</code>（构造器注入）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 构造器注入（Spring推荐方式）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">        <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：  </p><p>  • 明确依赖关系，支持不可变对象（final字段）。  </p><p>  • Spring 4.3+ 可省略<code>@Autowired</code>（单一构造器时自动注入）。</p><p><strong>方案3：<code>@RequiredArgsConstructor</code>（Lombok）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  <span class="comment">// 自动生成final字段的构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InventoryService inventoryService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编译后等效于方案2的构造器注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 特点：  </p><p>  • 代码最简洁，Lombok在编译时生成完整构造器。  </p><p>  • 需要字段标记为<code>final</code>或添加<code>@NonNull</code>注解。  </p><p>  • 不依赖Spring（也可用于非Spring项目）。</p><hr><p><strong>3. 关键差异解析</strong><br><strong>(1) 实现原理</strong><br>• <code>@Autowired</code>：  </p><p>  • 运行时通过反射或代理注入依赖，Spring容器负责查找并赋值。  </p><p>  • 支持三种注入方式：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 字段注入（不推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Setter注入</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(A a)</span> &#123; <span class="built_in">this</span>.a = a; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构造器注入（推荐）</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(A a)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>• <code>@RequiredArgsConstructor</code>：  </p><p>  • 编译时由Lombok生成包含所有<code>final</code>&#x2F;<code>@NonNull</code>字段的构造器。  </p><p>  • 生成的代码示例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译后实际代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, InventoryService is)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.paymentService = ps;</span><br><span class="line">    <span class="built_in">this</span>.inventoryService = is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(2) 依赖验证</strong><br>• <code>@Autowired</code>：  </p><p>  • 默认要求依赖必须存在（可通过<code>@Autowired(required=false)</code>设为可选）。  </p><p>  • 启动时如果依赖缺失，抛出<code>BeanCreationException</code>。</p><p>• <code>@RequiredArgsConstructor</code>：  </p><p>  • 依赖的校验基于<code>final</code>或<code>@NonNull</code>：  </p><pre><code>◦ 如果字段有`@NonNull`且依赖为null，抛出`NullPointerException`。  ◦ 非final字段不包含在生成构造器中。</code></pre><p><strong>(3) 与Spring的整合</strong></p><table><thead><tr><th>行为</th><th><code>@Autowired</code></th><th><code>@RequiredArgsConstructor</code></th></tr></thead><tbody><tr><td>AOP代理</td><td>支持（如<code>@Transactional</code>生效）</td><td>支持（生成的构造器能被Spring处理）</td></tr><tr><td>循环依赖</td><td>支持（通过三级缓存）</td><td>支持（同构造器注入）</td></tr><tr><td>Qualifier选择</td><td>支持（<code>@Qualifier</code>指定Bean）</td><td>需手动在字段添加<code>@Qualifier</code></td></tr></tbody></table><hr><p><strong>4. 如何选择？</strong><br><strong>优先使用 <code>@RequiredArgsConstructor</code> 当：</strong><br>• 项目已引入Lombok。  </p><p>• 追求代码简洁性，减少样板代码。  </p><p>• 需要不可变对象（final字段）。  </p><p><strong>优先使用 <code>@Autowired</code> 当：</strong><br>• 需要非final字段注入。  </p><p>• 需要Setter注入或字段注入（尽管不推荐）。  </p><p>• 需要动态条件注入（如<code>@Autowired(required=false)</code>）。  </p><p><strong>最佳实践组合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;  <span class="comment">// 必须的依赖</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired(required = false)</span>  <span class="comment">// 可选的依赖</span></span><br><span class="line">    <span class="keyword">private</span> DiscountService discountService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>5. 常见问题</strong><br><strong>Q1: 两者能混用吗？</strong><br>• 可以，但通常没必要。例如：  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 额外注入非final依赖</span></span><br><span class="line">    <span class="keyword">private</span> InventoryService inventoryService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Q2: Lombok和Spring谁先执行？</strong><br>• Lombok在编译时生成代码，Spring在运行时处理注解。顺序：  </p><p>  Lombok生成代码 → 编译 → Spring扫描注解。</p><p><strong>Q3: 为什么IDEA提示<code>@Autowired</code>警告？</strong><br>• 现代IDE推荐构造器注入（明确依赖+不可变），而<code>@Autowired</code>字段注入隐藏了依赖关系。使用<code>@RequiredArgsConstructor</code>可避免此警告。</p><hr><p><strong>总结</strong><br>• <code>@Autowired</code>：Spring原生的灵活注入方式，适合复杂场景。  </p><p>• <code>@RequiredArgsConstructor</code>：Lombok的简洁方案，适合追求代码整洁和不可变性。  </p><p>• 推荐：在新项目中优先使用<code>@RequiredArgsConstructor</code>，保持代码简洁且线程安全。</p><h2 id="Java中的构造器注入和C-中的组合有什么区别？"><a href="#Java中的构造器注入和C-中的组合有什么区别？" class="headerlink" title="Java中的构造器注入和C++中的组合有什么区别？"></a>Java中的构造器注入和C++中的组合有什么区别？</h2><p>你提到了一个非常关键的问题！其实在 现代Spring（尤其是Spring 4.3+版本）中，构造器注入的<code>@Autowired</code>注解是可以省略的，这正是为了减少代码的冗余，让它更接近“纯Java”的风格（类似C++的组合）。下面分几个层面解释：</p><hr><p><strong>1. 为什么早期需要<code>@Autowired</code>？</strong><br>在Spring 4.3之前，如果类有多个构造器，Spring不知道应该用哪个构造器来注入依赖，必须用<code>@Autowired</code>明确标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 告诉Spring用这个构造器注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">()</span> &#123; <span class="comment">/* Spring不会用这个无参构造器 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>2. 现代Spring的改进（省略<code>@Autowired</code>）</strong><br>从 Spring 4.3 开始，如果类只有一个构造器，Spring会自动选择它进行依赖注入，无需<code>@Autowired</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 4.3+ 可以省略@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动被Spring用于依赖注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，代码看起来和C++的组合（Composition）几乎一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++的依赖注入（手动组合）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService paymentService) </span><br><span class="line">        : <span class="built_in">paymentService</span>(paymentService) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>3. 和C++组合的核心区别</strong><br>虽然语法相似，但Spring的构造器注入和C++手动组合有本质区别：</p><table><thead><tr><th>维度</th><th>Spring构造器注入</th><th>C++手动组合</th></tr></thead><tbody><tr><td>对象创建权</td><td>Spring容器负责实例化并注入依赖</td><td>开发者手动<code>new</code>依赖对象</td></tr><tr><td>依赖解析</td><td>Spring自动查找匹配的Bean（按类型&#x2F;名称）</td><td>需手动构造依赖链（如<code>new PaymentService()</code>）</td></tr><tr><td>单例管理</td><td>默认单例（共享实例）</td><td>每次<code>new</code>生成独立实例</td></tr><tr><td>动态代理</td><td>支持AOP（如<code>@Transactional</code>生效）</td><td>无原生支持</td></tr><tr><td>测试友好性</td><td>可轻松替换为Mock（Spring测试支持）</td><td>需手动替换依赖</td></tr></tbody></table><hr><p><strong>4. 为什么Spring仍然比C++组合强大？</strong></p><p><strong>(1) 自动依赖解析</strong><br>• Spring：  </p><p>  若<code>PaymentService</code>本身依赖其他Bean（如<code>@Repository</code>），Spring会自动递归解决整个依赖树。<br>• C++：  </p><p>  需手动构造所有嵌套依赖：<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动管理依赖链</span></span><br><span class="line">Database db = <span class="keyword">new</span> <span class="built_in">Database</span>();</span><br><span class="line">Logger logger = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">PaymentService ps = <span class="keyword">new</span> <span class="built_in">PaymentService</span>(db, logger);</span><br><span class="line">OrderService os = <span class="keyword">new</span> <span class="built_in">OrderService</span>(ps);</span><br></pre></td></tr></table></figure></p><p><strong>(2) 动态扩展能力</strong><br>• Spring：  </p><p>  通过<code>@Profile</code>、<code>@Conditional</code>等动态选择实现类，无需修改代码：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span> <span class="comment">// 仅在开发环境生效</span></span><br><span class="line"><span class="keyword">public</span> PaymentService <span class="title function_">mockPaymentService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockPaymentService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• C++：  </p><p>  需通过预编译宏或工厂模式硬编码：<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV</span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">MockPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  PaymentService ps = <span class="keyword">new</span> <span class="built_in">RealPaymentService</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><strong>(3) 解耦与测试</strong><br>Spring：  </p><p>  单元测试时可直接注入Mock对象：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PaymentService</span> <span class="variable">mockPs</span> <span class="operator">=</span> Mockito.mock(PaymentService.class);</span><br><span class="line">    <span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderService</span>(mockPs); <span class="comment">// 不依赖Spring容器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>C++：  </p><p>  需依赖虚接口或模板技巧实现类似效果。</p><hr><p><strong>5. 什么情况下该用<code>@Autowired</code>？</strong><br>虽然构造器注入可以省略<code>@Autowired</code>，但在以下场景仍需显式标注：</p><ol><li>多个构造器时：指定哪个构造器用于注入。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  <span class="comment">// 明确告诉Spring用这个构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(paymentService, <span class="keyword">new</span> <span class="title class_">DefaultLogger</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService, Logger logger)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">        <span class="built_in">this</span>.logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可选依赖：结合<code>@Autowired(required=false)</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span>  <span class="comment">// discountService可选</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService ps, DiscountService ds)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>6. 终极对比：Spring vs C++</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring构造器注入（现代写法）</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderService</span><span class="params">(PaymentService paymentService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.paymentService = paymentService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++手动组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PaymentService* paymentService;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrderService</span>(PaymentService* ps) : <span class="built_in">paymentService</span>(ps) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">OrderService</span>() &#123; <span class="keyword">delete</span> paymentService; &#125; <span class="comment">// 需手动管理内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相同点：表面语法相似，都通过构造器传入依赖。  </p><p>不同点：  </p><p>  • Spring的依赖是容器管理的Bean，C++是原始对象指针。  </p><p>  • Spring自动处理依赖链、代理、作用域，C++需手动实现。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本类型和包装类型的区别？&quot;&gt;&lt;a href=&quot;#基本类型和包装类型的区别？&quot; class=&quot;headerlink&quot; title=&quot;基本类型和包装类型的区别？&quot;&gt;&lt;/a&gt;基本类型和包装类型的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>deepseek-v3技术报告学习</title>
    <link href="https://kelinkong.github.io/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2025/02/13/deepseek-v3%E6%8A%80%E6%9C%AF%E6%8A%A5%E5%91%8A%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-02-13T10:20:17.000Z</published>
    <updated>2025-02-14T02:03:35.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型架构层"><a href="#模型架构层" class="headerlink" title="模型架构层"></a>模型架构层</h2><p><img src="/../imgs/image-86.png" alt="模型结构图"></p><p>DeepSeekMoE架构相对于传统的Transformer架构，做了以下几项主要改进：</p><p>**Mixture of Experts (MoE)**：</p><ul><li>DeepSeekMoE引入了路由专家（routed experts）和共享专家（shared experts）。与传统的Transformer不同，DeepSeekMoE可以根据输入动态选择不同的专家，从而使得模型能够根据任务需求利用不同的专门知识，而不是对所有输入使用相同的参数。</li><li>路由机制和Top-K路由机制确保每层只使用部分专家进行计算，从而提高了计算效率，避免了传统Transformer中对所有专家都进行计算的冗余。</li></ul><p><strong>多头潜在注意力（MLA）：</strong></p><ul><li>DeepSeekMoE的注意力机制进行了增强，使用了潜在Q和潜在K表示，区别于传统的查询（Q）、键（K）和值（V）表示。这样可以在注意力机制中提供更丰富的表示，从而改进了模型捕捉序列中依赖关系的能力。</li><li>通过RoPE（旋转位置编码）进一步增强了位置编码，帮助模型捕捉序列中的复杂模式。</li><li>引入了推理过程中的缓存机制，部分计算可以在推理时预计算或缓存，从而加速推理过程。</li></ul><p><strong>共享专家层：</strong></p><ul><li>DeepSeekMoE使用共享专家层，这意味着多个输入可以共享同一层的计算资源，而不是每个输入都使用完全独立的层。这样可以减少冗余计算，提升计算效率。</li></ul><p><strong>前馈网络和注意力机制的改进：</strong></p><ul><li>DeepSeekMoE采用了RMSNorm归一化机制，它是对层归一化（LayerNorm）的一种变体，能够在不依赖大批量训练的情况下稳定训练过程。</li><li>尽管保留了传统Transformer的前馈网络和多头注意力层，但通过MoE和潜在注意力的增强，使得模型能够处理更复杂的数据表示和更高效的计算。</li></ul><h3 id="MLA"><a href="#MLA" class="headerlink" title="MLA"></a>MLA</h3><p>当我们谈到DeepSeekMoE在注意力机制和其他方面的改进时，实际上这些改进是为了提升模型的表达能力、捕捉更复杂的依赖关系并加速推理过程。以下是对每个改进的更具体的解释：</p><h4 id="潜在Q和潜在K表示-Latent-Q-Latent-K"><a href="#潜在Q和潜在K表示-Latent-Q-Latent-K" class="headerlink" title="潜在Q和潜在K表示 (Latent Q &amp; Latent K)"></a><strong>潜在Q和潜在K表示 (Latent Q &amp; Latent K)</strong></h4><ul><li><strong>传统注意力机制：</strong> 在标准的Transformer架构中，查询（Q）、键（K）和值（V）是直接从输入中计算出来的。这些向量通过标准的点积操作来计算注意力权重，最终决定了每个输入对其他输入的影响。</li><li><strong>潜在Q和潜在K表示：</strong> 在DeepSeekMoE中，注意力机制引入了<strong>潜在Q</strong>（latent query）和<strong>潜在K</strong>（latent key）表示。与传统方法不同，这些潜在表示并不是直接从输入数据中提取的，而是通过学习到的潜在空间生成的。这允许模型捕捉更复杂的关系和特征。<ul><li><strong>潜在Q</strong>和<strong>潜在K</strong>通过生成更丰富的表示，使得模型能够处理更高阶的依赖关系，不仅限于传统的直接输入映射。</li><li>这种方法能够提升模型的表达能力，尤其是在需要捕捉长期依赖或者更复杂的输入特征时，潜在表示比传统的直接映射方式更加灵活和高效。</li></ul></li></ul><h4 id="RoPE（旋转位置编码）"><a href="#RoPE（旋转位置编码）" class="headerlink" title="RoPE（旋转位置编码）"></a><strong>RoPE（旋转位置编码）</strong></h4><ul><li><strong>传统位置编码：</strong> 在经典的Transformer模型中，位置编码（通常是正弦和余弦函数的组合）被加入到输入的词向量中，以便模型能够理解单词在序列中的相对位置。这些位置编码是固定的，对不同的输入序列进行相同的编码。</li><li><strong>RoPE（旋转位置编码）：</strong> DeepSeekMoE采用了<strong>RoPE</strong>，即旋转位置编码，这是一种改进的相对位置编码方法。RoPE通过对位置编码进行旋转，能够使得位置编码不仅与输入的绝对位置相关，还与输入之间的相对位置（距离）相关。<ul><li>这使得模型能够更好地处理长序列，并且更加灵活地理解序列中不同位置之间的相对关系。</li><li>RoPE编码的旋转性质使得模型能够在处理长距离依赖时表现得更好，尤其是在处理具有复杂结构的序列时。</li></ul></li></ul><h4 id="推理过程中的缓存机制"><a href="#推理过程中的缓存机制" class="headerlink" title="推理过程中的缓存机制"></a><strong>推理过程中的缓存机制</strong></h4><ul><li><strong>传统推理过程：</strong> 在传统的Transformer模型中，每次推理都会从头开始计算所有的输入，无论这些输入是否已经在之前的推理过程中计算过。这个过程可能会导致较慢的推理速度，特别是在处理长序列时。</li><li><strong>缓存机制：</strong> 在DeepSeekMoE中，推理过程引入了缓存机制。通过缓存中间计算结果，模型可以避免重复计算，特别是当处理重复或相似的输入时，缓存机制可以显著加速推理过程。<ul><li>在推理时，部分计算（例如中间的表示）可以提前计算并缓存起来，这样在处理后续输入时，模型可以直接使用缓存的结果，而无需重新计算。</li><li>这种机制提高了推理效率，尤其在推理时需要多次处理相似输入的情况下，可以大大减少计算的开销。</li></ul></li></ul><p>这些改进使得DeepSeekMoE不仅能够处理更加复杂的输入，还能够提高推理效率：</p><ul><li><strong>潜在Q和潜在K</strong>的引入使得模型能够捕捉更高阶的依赖关系，提升了注意力机制的表现。</li><li><strong>RoPE</strong>提供了一种更加灵活的相对位置编码方式，帮助模型更好地理解序列中的相对位置，尤其是在长序列中表现更优。</li><li><strong>缓存机制</strong>则通过减少重复计算加速了推理过程，提高了效率，特别是在处理大量或相似的输入时。</li></ul><h3 id="MOE"><a href="#MOE" class="headerlink" title="MOE"></a>MOE</h3><p>在DeepSeekMoE架构中，<strong>专家</strong>（Experts）是指一组参数化的子模型，它们可以针对特定的任务或输入做出不同的响应。这些专家是网络中的子模型或计算单元，每个专家通常具备独特的知识或处理能力，因此它们能够在不同的任务或输入下展现出不同的特性。</p><h4 id="什么是专家？"><a href="#什么是专家？" class="headerlink" title="什么是专家？"></a>什么是专家？</h4><p>专家可以理解为一类具有特定参数的子模型或计算单元，每个专家在模型中负责处理输入的某些特定部分或任务。这些专家可以是类似于普通神经网络层的结构，或者更复杂的模块，它们在训练过程中会学习到针对某些类型输入的特殊模式。</p><h4 id="如何使用专家？"><a href="#如何使用专家？" class="headerlink" title="如何使用专家？"></a>如何使用专家？</h4><p>DeepSeekMoE中的专家使用方式依赖于<strong>路由机制</strong>。在每次前向传播过程中，输入数据首先会通过一个<strong>路由器</strong>（Router）来选择哪些专家将被激活进行计算。路由器根据输入的特征决定哪些专家最适合处理当前输入。专家选择的过程通常有以下几个关键步骤：</p><ol><li><p><strong>输入数据进入路由器：</strong> 输入首先通过路由器，它根据输入的特征计算出每个专家的权重或得分。</p></li><li><p><strong>Top-K路由：</strong> 路由器根据计算结果选择得分最高的前K个专家进行处理（例如Top-K），这意味着并不是所有专家都会被激活，只有最相关的专家才会被使用。</p></li><li><p><strong>专家的激活：</strong> 被选中的专家进行计算并生成相应的输出。每个专家的计算结果可能会不同，因为它们专注于不同的特征或任务。</p></li><li><p><strong>输出合成：</strong> 激活的专家的输出将被合成并传递给后续的网络层。通常，会对多个专家的输出进行加权合成，以得到最终的输出。</p></li><li><p><strong>共享专家：</strong> 在一些情况下，也可以有<strong>共享专家</strong>，即多个输入共享相同的专家进行计算，这样可以进一步节省计算资源。</p></li></ol><h4 id="如何判断选择哪些专家？"><a href="#如何判断选择哪些专家？" class="headerlink" title="如何判断选择哪些专家？"></a>如何判断选择哪些专家？</h4><p>在DeepSeekMoE架构中，激活哪些专家是通过<strong>路由机制</strong>来判断的。具体来说，路由机制根据输入的特征来动态选择需要激活的专家。这一过程包含了Share专家和Router专家的激活策略，具体如下：</p><p><strong>Share 专家</strong></p><ul><li><strong>一直激活：</strong> Share专家是始终参与计算的，它们不依赖于输入的特征，而是对所有的输入都会进行计算。换句话说，Share专家不经过路由选择，而是直接计算每个输入的输出。</li></ul><p><strong>Router 专家</strong></p><ul><li><p><strong>计算亲和度：</strong> Router专家的激活过程通过计算输入与各个专家之间的亲和度（相似性）来选择合适的专家。具体来说，这个过程通过以下步骤进行：</p><ul><li>首先，输入经过一个线性变换（通常是一个线性层），得到一个新的表示（亲和度评分），这个表示可以用来衡量输入与每个专家之间的相关性。</li><li>接着，这些评分会被用来选择Top-K个专家，即选择与输入亲和度最高的专家进行计算。</li></ul></li><li><p><strong>分组选择与Top-K策略：</strong></p><ul><li>在实际实现中，Router专家的选择会更加复杂。首先，会将所有的专家分成若干个组（n_groups）。每个组内包含多个专家。</li><li>然后，对于每个组，选择<strong>Top-2</strong>个专家，通过加总每组内Top-2专家的亲和度评分来确定哪个组的亲和度最高。</li><li>最后，在亲和度最高的这些组中，选择<strong>Top-K</strong>个专家，这样就可以确定最终需要激活的K个专家。</li></ul></li></ul><p><strong>加权输出：</strong></p><ul><li>最终，Router专家和Share专家的输出会通过亲和度加权融合在一起。具体来说，对于每个输入，Router专家和Share专家都会计算其输出，之后根据计算出的亲和度（即输入与每个专家之间的相关性），将这两个部分的输出进行加权求和，得到MoE层的最终输出。</li></ul><h2 id="训练方法创新"><a href="#训练方法创新" class="headerlink" title="训练方法创新"></a>训练方法创新</h2><h3 id="FP8高低混合精度训练"><a href="#FP8高低混合精度训练" class="headerlink" title="FP8高低混合精度训练"></a>FP8高低混合精度训练</h3><p><img src="/../imgs/image-87.png"></p><p>首先，为提高模型训练速度，大部分核心计算操作（尤其是 GEMM 运算），均采用 FP8 精度实现。这些 GEMM 运算接收 FP8 格式的张量输入，输出 BF16 或 FP32 格式的结果。如图6所示，线性运算相关的三个 GEMM 操作，包括 Fprop（前向传播）、Dgrad（激活值反向传播）和 Wgrad（权重反向传播），均采用 FP8 执行。这种设计策略理论上将计算速度提升至原有 BF16 方法的两倍。同时，FP8 格式的 Wgrad GEMM 使得激活值能够以 FP8 格式存储用于反向传播，显著降低了内存使用量。</p><p>虽然 FP8 格式在效率方面具有优势，但某些运算由于对计算精度较为敏感，仍需要更高精度的支持。另外，部分计算开销较小的运算可以采用更高精度而不会显著影响整体训练效率。</p><p>因此，经过详细评估，系统对以下模块保持原有精度（BF16 或 FP32）：向量层、输出层、MoE 门控模块、标准化运算和注意力运算模块。这种针对性的高精度保留策略确保了 DeepSeek-V3 训练过程的动态稳定性。为进一步保障数值计算的稳定性，主要权重参数、权重梯度和优化器状态均采用更高精度存储。虽然这些高精度组件会带来一定的内存开销，但通过在分布式训练系统中跨多个 DP 层级进行高效数据分割，这些额外开销得到了有效控制。</p><p><strong>激活值反向传播（Dgrad）：</strong> 当神经网络进行前向传播时，每一层会计算其激活值（通常是通过激活函数的输出）。反向传播过程中，我们会通过计算每个层的误差，并通过梯度来更新网络的参数。激活值反向传播的核心目的是计算损失函数相对于每一层的输入（即激活值）的梯度。</p><p><strong>权重反向传播（Wgrad）</strong>： 在神经网络中，权重是模型的可学习参数。每次计算梯度时，目标是计算损失函数相对于权重的梯度，即计算权重在模型输出错误中的贡献。通过这些梯度信息，网络的权重会被调整，从而使得网络能够更好地拟合训练数据。</p><ul><li>激活值反向传播：计算的是每个层的激活值相对于损失函数的梯度，作用是提供层与层之间的误差传递，帮助调整每一层的输入（激活值）。</li><li>权重反向传播：则是计算每一层的权重相对于损失函数的梯度。它的目的是通过更新每一层的权重来降低模型的误差，最终优化网络性能。</li></ul><p><img src="/../imgs/image-88.png"></p><p>BF16、FP32 向 FP8 转换采用分组量化。</p><h3 id="DualPipe-框架"><a href="#DualPipe-框架" class="headerlink" title="DualPipe 框架"></a>DualPipe 框架</h3><p>分布式训练的目的其实就一个：节省更多的资源，资源包括计算时间、显存、机器数量。总的来说应该是节省总的GPUhours。</p><p><img src="/../imgs/image-89.png"><br>模型训练中主要计算量来源于ATTENTION-O(L2)，MLP-O(H2)。<br>由于分布式训练，导致前向后向计算均需要通信，通信包括dispatch（将输入分到各个weight、expert）、combine（将各个weight、expert的输出结果聚合）两部分。</p><p>由于在同一个batch中，通信和计算是交替进行的，这将导致效率低下。为此deepseek v3 提出双管路的方法，使得通信与计算能够并行。</p><p><img src="/../imgs/image-90.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模型架构层&quot;&gt;&lt;a href=&quot;#模型架构层&quot; class=&quot;headerlink&quot; title=&quot;模型架构层&quot;&gt;&lt;/a&gt;模型架构层&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/../imgs/image-86.png&quot; alt=&quot;模型结构图&quot;&gt;&lt;/p&gt;
&lt;p&gt;DeepS</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>DB-图数据库Neo4j</title>
    <link href="https://kelinkong.github.io/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/"/>
    <id>https://kelinkong.github.io/2025/01/10/DB-%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93Neo4j/</id>
    <published>2025-01-10T02:12:24.000Z</published>
    <updated>2025-01-10T02:17:00.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neo4j-图数据库简介"><a href="#Neo4j-图数据库简介" class="headerlink" title="Neo4j 图数据库简介"></a>Neo4j 图数据库简介</h2><p><strong>Neo4j</strong> 是一种基于 <strong>图模型</strong> 的开源图数据库，专为存储和查询高度连接的数据而设计。与传统关系型数据库不同，Neo4j 的底层原理专注于实体（节点）和它们之间的关系（边）的直接存储和管理，具有高效处理复杂连接查询的能力。</p><p>以下是 Neo4j 的简介和底层原理：</p><h3 id="一、Neo4j-简介"><a href="#一、Neo4j-简介" class="headerlink" title="一、Neo4j 简介"></a>一、Neo4j 简介</h3><h4 id="1-主要特点"><a href="#1-主要特点" class="headerlink" title="1. 主要特点"></a>1. <strong>主要特点</strong></h4><ul><li><p><strong>图模型</strong>：</p><ul><li>数据存储为节点（Nodes）、关系（Relationships）和属性（Properties）。</li><li>节点表示实体，关系表示实体之间的连接，属性用来描述节点和关系的详细信息。</li></ul></li><li><p><strong>查询语言：Cypher</strong>：</p><ul><li>专为图数据设计的一种声明性查询语言，类似 SQL，但更直观，适合复杂的图查询。</li></ul></li><li><p><strong>高效的图遍历</strong>：</p><ul><li>直接存储关系，使得在大量数据中查询连接关系（如路径、网络）非常高效。</li></ul></li><li><p><strong>弹性和可扩展性</strong>：</p><ul><li>支持单机和分布式部署，适合从小型应用到企业级应用的需求。</li></ul></li></ul><h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. <strong>应用场景</strong></h4><ul><li><strong>推荐系统</strong>：基于社交关系或行为数据推荐内容。</li><li><strong>社交网络分析</strong>：分析用户间的交互和关系。</li><li><strong>知识图谱</strong>：存储和查询结构化知识。</li><li><strong>欺诈检测</strong>：通过关系模式检测可疑行为。</li><li><strong>供应链管理</strong>：优化复杂的物流和供应网络。</li></ul><h3 id="二、底层原理"><a href="#二、底层原理" class="headerlink" title="二、底层原理"></a>二、底层原理</h3><h4 id="1-存储模型"><a href="#1-存储模型" class="headerlink" title="1. 存储模型"></a>1. <strong>存储模型</strong></h4><p>Neo4j 使用 <strong>原生图存储模型</strong>，直接存储节点和关系，避免了传统数据库中通过表关联的开销。</p><ul><li><p><strong>节点（Nodes）</strong>：</p><ul><li>存储实体数据，每个节点有唯一的 ID 和属性（键值对）。</li><li>例如：<code>User: &#123;name: &#39;Alice&#39;, age: 25&#125;</code>。</li></ul></li><li><p><strong>关系（Relationships）</strong>：</p><ul><li>直接存储连接节点的关系，包括关系类型和属性。</li><li>例如：<code>(Alice)-[:FRIENDS]-&gt;(Bob)</code> 表示 Alice 和 Bob 是朋友。</li></ul></li><li><p><strong>属性（Properties）</strong>：</p><ul><li>节点和关系可以包含多个属性，用于描述实体或连接的详细信息。</li></ul></li></ul><h4 id="2-索引与查找"><a href="#2-索引与查找" class="headerlink" title="2. 索引与查找"></a>2. <strong>索引与查找</strong></h4><ul><li><p><strong>索引</strong>：</p><ul><li>Neo4j 支持基于节点或关系属性的索引，用于快速定位图中的某些节点或关系。</li><li>索引底层通常采用 B+ 树或类似数据结构。</li></ul></li><li><p><strong>图遍历</strong>：</p><ul><li>Neo4j 的核心是基于深度优先（DFS）或广度优先（BFS）的图遍历算法。</li><li>与传统数据库的表扫描不同，Neo4j 通过直接访问存储的关系指针来实现高效遍历。</li></ul></li></ul><h4 id="3-事务与一致性"><a href="#3-事务与一致性" class="headerlink" title="3. 事务与一致性"></a>3. <strong>事务与一致性</strong></h4><ul><li><p><strong>ACID 事务</strong>：</p><ul><li>Neo4j 支持事务处理，确保数据的一致性。</li><li>每次操作（如添加节点或关系）都被记录在事务日志中，可支持回滚。</li></ul></li><li><p><strong>锁管理</strong>：</p><ul><li>使用细粒度的锁（如节点锁和关系锁），提高并发性能。</li></ul></li></ul><h4 id="4-查询与优化"><a href="#4-查询与优化" class="headerlink" title="4. 查询与优化"></a>4. <strong>查询与优化</strong></h4><ul><li><p><strong>Cypher 查询语言</strong>：</p><ul><li>Cypher 提供了简洁的语法，支持复杂的模式匹配和路径查询。</li><li>例如：查询所有好友的好友：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (user:Person)-[:FRIENDS]-&gt;(:Person)-[:FRIENDS]-&gt;(friend_of_friend)</span><br><span class="line">WHERE user.name = &#x27;Alice&#x27;</span><br><span class="line">RETURN friend_of_friend</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查询优化器</strong>：</p><ul><li>Cypher 查询在执行前会由优化器解析和优化，生成高效的执行计划。</li><li>例如，使用索引优先查找节点，再进行图遍历。</li></ul></li></ul><h4 id="5-存储与磁盘布局"><a href="#5-存储与磁盘布局" class="headerlink" title="5. 存储与磁盘布局"></a>5. <strong>存储与磁盘布局</strong></h4><ul><li><p><strong>存储文件</strong>：</p><ul><li>节点和关系被存储为分离的文件：<ul><li>节点存储文件：包含节点 ID 和属性。</li><li>关系存储文件：包含关系 ID、起点和终点节点的 ID 以及属性。</li></ul></li><li>通过这种分离，Neo4j 能快速定位和加载节点及其相关关系。</li></ul></li><li><p><strong>内存映射</strong>：</p><ul><li>使用内存映射文件（Memory-Mapped Files）技术将磁盘数据加载到内存，提高查询性能。</li></ul></li></ul><h4 id="6-分布式与扩展"><a href="#6-分布式与扩展" class="headerlink" title="6. 分布式与扩展"></a>6. <strong>分布式与扩展</strong></h4><ul><li><strong>分片（Sharding）</strong>：<ul><li>将图数据分片存储在不同的节点中，支持大规模图的存储。</li></ul></li><li><strong>复制（Replication）</strong>：<ul><li>支持主从复制，确保高可用性。</li></ul></li><li><strong>Raft 协议</strong>：<ul><li>Neo4j 4.x 及以上版本中，使用 Raft 协议管理分布式事务和数据一致性。</li></ul></li></ul><h3 id="三、Neo4j-的优势"><a href="#三、Neo4j-的优势" class="headerlink" title="三、Neo4j 的优势"></a>三、Neo4j 的优势</h3><ol><li><p><strong>关系查询效率高</strong>：</p><ul><li>图存储和遍历使得关系密集型查询（如路径分析、模式匹配）效率远超关系型数据库。</li></ul></li><li><p><strong>直观的查询语言</strong>：</p><ul><li>Cypher 简洁易用，适合复杂的图模式匹配。</li></ul></li><li><p><strong>灵活的模式</strong>：</p><ul><li>图数据库无需固定模式（Schema-Free），支持动态更新。</li></ul></li><li><p><strong>可扩展性</strong>：</p><ul><li>适合从单机到分布式的各种部署需求。</li></ul></li></ol><h3 id="四、与传统关系型数据库的对比"><a href="#四、与传统关系型数据库的对比" class="headerlink" title="四、与传统关系型数据库的对比"></a>四、与传统关系型数据库的对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>Neo4j（图数据库）</strong></th><th><strong>关系型数据库</strong></th></tr></thead><tbody><tr><td><strong>数据结构</strong></td><td>节点、关系、属性</td><td>表、行、列</td></tr><tr><td><strong>查询语言</strong></td><td>Cypher</td><td>SQL</td></tr><tr><td><strong>关系存储</strong></td><td>直接存储节点和关系</td><td>通过外键间接存储</td></tr><tr><td><strong>关系查询效率</strong></td><td>高效（基于指针）</td><td>相对较低（基于表连接）</td></tr><tr><td><strong>扩展性</strong></td><td>优秀，支持分布式图存储</td><td>通常需要复杂的分布式架构支持</td></tr><tr><td><strong>适用场景</strong></td><td>复杂连接查询（如社交网络分析）</td><td>面向事务处理的结构化数据管理</td></tr></tbody></table><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>Neo4j 是一种高效的图数据库，专注于存储和查询复杂连接数据，其底层基于原生图存储和高效的图遍历算法。无论是社交网络、推荐系统，还是知识图谱，Neo4j 都能提供直观的建模方法和高性能的查询能力，非常适合处理关系密集型数据。</p><h2 id="与GraphRAG结合"><a href="#与GraphRAG结合" class="headerlink" title="与GraphRAG结合"></a>与GraphRAG结合</h2><p><strong>Neo4j</strong> 和 <strong>微软的 Graph RAG</strong>（Retrieval-Augmented Generation with Graphs）结合在一起，主要是通过将 Neo4j 提供的知识图谱功能与 RAG 的检索与生成流程集成，利用图数据库的高效关系查询能力增强 RAG 的性能。以下是它们结合的核心原理和流程：</p><h3 id="1-结合的动机"><a href="#1-结合的动机" class="headerlink" title="1. 结合的动机"></a>1. <strong>结合的动机</strong></h3><p>微软的 <strong>Graph RAG</strong> 是一种结合知识图谱的 RAG 方法，旨在通过知识图谱优化检索和生成的质量。Neo4j 提供了强大的图存储和查询能力，是 Graph RAG 的理想后端数据库。</p><p>结合的优势包括：</p><ul><li><strong>增强检索性能</strong>：Neo4j 能高效存储和查询复杂关系，支持从知识图谱中快速检索相关信息。</li><li><strong>支持复杂推理</strong>：通过知识图谱进行推理（如多跳推理），提升生成结果的准确性。</li><li><strong>实时更新和动态扩展</strong>：Neo4j 支持动态更新知识图谱，确保生成模型使用的是最新数据。</li></ul><h3 id="2-结合的工作流程"><a href="#2-结合的工作流程" class="headerlink" title="2. 结合的工作流程"></a>2. <strong>结合的工作流程</strong></h3><p>Neo4j 和 Graph RAG 的集成主要包括以下步骤：</p><h4 id="1-构建知识图谱"><a href="#1-构建知识图谱" class="headerlink" title="(1) 构建知识图谱"></a><strong>(1) 构建知识图谱</strong></h4><ul><li><p><strong>知识图谱的来源</strong>：</p><ul><li>通过数据预处理（如实体和关系抽取），从原始数据（如文档或数据库）中生成知识图谱。</li><li>这些知识被存储在 Neo4j 中，节点代表实体，边代表关系，属性包含附加信息。</li></ul></li><li><p><strong>存储到 Neo4j</strong>：</p><ul><li>使用 Cypher 查询语言或 Neo4j 提供的 API 将节点和关系存储到数据库中。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (a:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(b:Person &#123;name: &#x27;Bob&#x27;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-图谱增强的检索"><a href="#2-图谱增强的检索" class="headerlink" title="(2) 图谱增强的检索"></a><strong>(2) 图谱增强的检索</strong></h4><ul><li>在 Graph RAG 中，检索步骤会调用 Neo4j 来从知识图谱中查找相关信息。</li><li><strong>查询类型</strong>：<ul><li><strong>简单检索</strong>：基于实体或关系的直接匹配。例如，查找与特定实体相关的所有关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[r]-&gt;(other)</span><br><span class="line">RETURN r, other</span><br></pre></td></tr></table></figure></li><li><strong>多跳推理</strong>：查找多步关系链。例如，获取 Alice 的朋友的朋友：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS*2]-&gt;(friend_of_friend)</span><br><span class="line">RETURN friend_of_friend</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-生成阶段"><a href="#3-生成阶段" class="headerlink" title="(3) 生成阶段"></a><strong>(3) 生成阶段</strong></h4><ul><li>检索结果被格式化后传递给语言模型（LLM），作为生成上下文的一部分。</li><li>在生成阶段，Neo4j 的结构化信息可以作为事实验证的依据，增强生成的可靠性和相关性。</li></ul><h4 id="4-实时更新"><a href="#4-实时更新" class="headerlink" title="(4) 实时更新"></a><strong>(4) 实时更新</strong></h4><ul><li>Graph RAG 可以通过 Neo4j 动态更新知识图谱。例如，在新的数据被引入时，可以通过批量或实时更新将新知识存储到图谱中。</li></ul><h3 id="3-技术集成方式"><a href="#3-技术集成方式" class="headerlink" title="3. 技术集成方式"></a>3. <strong>技术集成方式</strong></h3><p>Neo4j 和 Graph RAG 的结合通过 API 或 SDK 实现，以下是常见的集成方法：</p><h4 id="1-Neo4j-驱动"><a href="#1-Neo4j-驱动" class="headerlink" title="(1) Neo4j 驱动"></a><strong>(1) Neo4j 驱动</strong></h4><ul><li>使用 Neo4j 官方驱动（Python、Java、Node.js 等）与 Graph RAG 的后端交互。</li><li><strong>Python 示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> neo4j <span class="keyword">import</span> GraphDatabase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到 Neo4j 数据库</span></span><br><span class="line">driver = GraphDatabase.driver(<span class="string">&quot;bolt://localhost:7687&quot;</span>, auth=(<span class="string">&quot;neo4j&quot;</span>, <span class="string">&quot;password&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_related_entities</span>(<span class="params">tx, entity_name</span>):</span><br><span class="line">    query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    MATCH (e:Entity &#123;name: $name&#125;)-[:RELATED_TO]-&gt;(related)</span></span><br><span class="line"><span class="string">    RETURN related</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = tx.run(query, name=entity_name)</span><br><span class="line">    <span class="keyword">return</span> [record[<span class="string">&quot;related&quot;</span>] <span class="keyword">for</span> record <span class="keyword">in</span> result]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> driver.session() <span class="keyword">as</span> session:</span><br><span class="line">    related_entities = session.read_transaction(fetch_related_entities, <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(related_entities)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-REST-API"><a href="#2-REST-API" class="headerlink" title="(2) REST API"></a><strong>(2) REST API</strong></h4><ul><li>如果 Neo4j 部署为服务，可以通过其 REST API 从 Graph RAG 后端发起 HTTP 请求获取数据。</li><li>示例请求：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:7474/db/data/transaction/commit \</span><br><span class="line">     -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">     -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">       &quot;statements&quot;: [</span></span><br><span class="line"><span class="string">         &#123;</span></span><br><span class="line"><span class="string">           &quot;statement&quot;: &quot;MATCH (n:Person &#123;name: &#x27;</span>Alice<span class="string">&#x27;&#125;) RETURN n&quot;</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">       ]</span></span><br><span class="line"><span class="string">     &#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Neo4j-LangChain"><a href="#3-Neo4j-LangChain" class="headerlink" title="(3) Neo4j + LangChain"></a><strong>(3) Neo4j + LangChain</strong></h4><ul><li>LangChain 提供了与 Neo4j 集成的模块，允许直接在生成模型的工作流中调用 Neo4j 的图查询能力。</li><li>示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.graphs <span class="keyword">import</span> Neo4jGraph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到 Neo4j</span></span><br><span class="line">graph = Neo4jGraph(url=<span class="string">&quot;bolt://localhost:7687&quot;</span>, username=<span class="string">&quot;neo4j&quot;</span>, password=<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询图数据库</span></span><br><span class="line">query = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">MATCH (a:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(b)</span></span><br><span class="line"><span class="string">RETURN b.name</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">result = graph.query(query)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-结合的优势"><a href="#4-结合的优势" class="headerlink" title="4. 结合的优势"></a>4. <strong>结合的优势</strong></h3><ol><li><strong>图结构优化检索</strong>：<ul><li>Neo4j 提供高效的图遍历算法，显著提高 RAG 系统的检索效率。</li></ul></li><li><strong>支持多跳推理</strong>：<ul><li>Graph RAG 可以通过 Neo4j 实现复杂的关系推理，例如多跳关系或路径查询。</li></ul></li><li><strong>增强生成质量</strong>：<ul><li>图数据库的结构化数据能够为 LLM 提供精准的上下文，减少生成内容中的幻觉现象。</li></ul></li><li><strong>动态知识更新</strong>：<ul><li>Neo4j 支持实时或批量更新图数据，确保 RAG 系统使用最新知识。</li></ul></li></ol><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. <strong>应用场景</strong></h3><ul><li><strong>知识图谱问答（Knowledge Graph QA）</strong>：基于图谱的精确问答。</li><li><strong>推荐系统</strong>：结合用户兴趣图谱推荐内容。</li><li><strong>事实验证（Fact Verification）</strong>：验证生成内容是否符合知识图谱的事实。</li><li><strong>多跳问答（Multi-Hop QA）</strong>：通过图谱实现复杂推理任务。</li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><p>Neo4j 和微软的 Graph RAG 结合，通过 Neo4j 提供的高效图存储与查询能力，以及 Graph RAG 的检索增强生成架构，能够大幅提升生成质量和检索效率。这种结合适用于知识密集型任务，如知识图谱问答、复杂推理和实时数据更新场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Neo4j-图数据库简介&quot;&gt;&lt;a href=&quot;#Neo4j-图数据库简介&quot; class=&quot;headerlink&quot; title=&quot;Neo4j 图数据库简介&quot;&gt;&lt;/a&gt;Neo4j 图数据库简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Neo4j&lt;/strong&gt; 是一种基于 &lt;</summary>
      
    
    
    
    <category term="DataBase" scheme="https://kelinkong.github.io/categories/DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-编译相关</title>
    <link href="https://kelinkong.github.io/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    <id>https://kelinkong.github.io/2025/01/09/Java-%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/</id>
    <published>2025-01-09T03:36:18.000Z</published>
    <updated>2025-01-09T03:44:03.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的即时编译器"><a href="#Java的即时编译器" class="headerlink" title="Java的即时编译器"></a>Java的即时编译器</h2><p>Java 的即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中的重要组成部分，它在程序运行时将 Java 字节码 (Bytecode) 转换为本地机器代码，从而提高程序运行效率。以下是关于 JIT 的详细科普：</p><h3 id="1-JIT-编译器的作用"><a href="#1-JIT-编译器的作用" class="headerlink" title="1. JIT 编译器的作用"></a>1. <strong>JIT 编译器的作用</strong></h3><ul><li>Java 程序先被编译为字节码，这是一种中间代码，独立于底层硬件和操作系统。</li><li>JVM 通过<strong>解释器 (Interpreter)</strong> 将字节码逐行解释为机器代码执行，但逐行解释速度较慢。</li><li>为了优化性能，JVM 使用 JIT 将热代码段（执行频率高的代码）直接编译成机器码并缓存起来。之后再运行这些代码时，无需解释，直接执行机器码，极大提高了性能。</li></ul><h3 id="2-JIT-的工作原理"><a href="#2-JIT-的工作原理" class="headerlink" title="2. JIT 的工作原理"></a>2. <strong>JIT 的工作原理</strong></h3><ol><li><strong>字节码加载</strong>：<ul><li>JVM 通过类加载器加载字节码到内存。</li></ul></li><li><strong>初始执行</strong>：<ul><li>字节码开始由解释器逐行解释执行。</li></ul></li><li><strong>热点代码检测</strong>：<ul><li>JIT 使用<strong>热点探测技术</strong>（如计数器）来识别频繁执行的代码（如循环体）。</li></ul></li><li><strong>即时编译</strong>：<ul><li>识别到热点代码后，JIT 将其编译为本地机器代码并优化执行。</li></ul></li><li><strong>缓存与复用</strong>：<ul><li>已编译的机器代码被缓存起来供后续直接使用。</li></ul></li></ol><h3 id="3-JIT-编译的优化技术"><a href="#3-JIT-编译的优化技术" class="headerlink" title="3. JIT 编译的优化技术"></a>3. <strong>JIT 编译的优化技术</strong></h3><p>JIT 编译器除了简单地将字节码翻译为机器码，还会进行多种优化，如：</p><ul><li><strong>方法内联</strong>：将小方法的代码直接嵌入调用处，减少方法调用的开销。</li><li><strong>常量折叠</strong>：在编译时计算出常量表达式的结果。</li><li><strong>循环展开</strong>：减少循环中的控制逻辑，增加运行效率。</li><li><strong>消除冗余代码</strong>：去掉多余的、不必要的代码执行。</li><li><strong>逃逸分析</strong>：检测对象是否会逃出方法作用域，从而优化内存分配。</li></ul><h3 id="4-JIT-的类型"><a href="#4-JIT-的类型" class="headerlink" title="4. JIT 的类型"></a>4. <strong>JIT 的类型</strong></h3><p>JVM 中的 JIT 编译器主要分为以下几种：</p><ol><li><strong>C1（Client Compiler）</strong>：<ul><li>针对客户端应用优化，启动速度快。</li><li>适用于需要快速响应的程序。</li></ul></li><li><strong>C2（Server Compiler）</strong>：<ul><li>针对服务器端应用优化，执行速度更快。</li><li>适用于长时间运行、对性能要求高的程序。</li></ul></li><li><strong>Graal JIT</strong>：<ul><li>新一代 JIT 编译器，基于 Java 实现，优化更为激进。</li><li>提供更好的性能和可扩展性。</li></ul></li></ol><h3 id="5-JIT-的优缺点"><a href="#5-JIT-的优缺点" class="headerlink" title="5. JIT 的优缺点"></a>5. <strong>JIT 的优缺点</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>高性能</strong>：将热点代码编译为本地机器码，大幅提升执行效率。</li><li><strong>动态优化</strong>：根据运行时的实际情况进行优化（如分支预测、内存管理）。</li><li><strong>跨平台性</strong>：结合字节码和本地机器码，既实现跨平台，又提升性能。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>启动延迟</strong>：JIT 编译需要时间，可能导致程序启动较慢。</li><li><strong>内存占用</strong>：缓存的机器码会占用额外的内存。</li></ul><h3 id="6-JIT-和-AOT（Ahead-Of-Time）-编译的对比"><a href="#6-JIT-和-AOT（Ahead-Of-Time）-编译的对比" class="headerlink" title="6. JIT 和 AOT（Ahead-Of-Time） 编译的对比"></a>6. <strong>JIT 和 AOT（Ahead-Of-Time） 编译的对比</strong></h3><table><thead><tr><th>特性</th><th>JIT 编译</th><th>AOT 编译</th></tr></thead><tbody><tr><td>编译时间</td><td>运行时动态编译</td><td>编译前静态完成</td></tr><tr><td>性能优化</td><td>基于运行时动态信息进行优化</td><td>基于编译时静态信息优化</td></tr><tr><td>启动速度</td><td>启动较慢，需等待编译完成</td><td>启动较快</td></tr><tr><td>可移植性</td><td>字节码跨平台，动态编译本地代码</td><td>编译后的本地代码与平台绑定</td></tr></tbody></table><h3 id="7-如何调整-JIT-设置"><a href="#7-如何调整-JIT-设置" class="headerlink" title="7. 如何调整 JIT 设置"></a>7. <strong>如何调整 JIT 设置</strong></h3><p>JVM 提供了一些参数用于调整 JIT 的行为：</p><ul><li><code>-Xint</code>：强制 JVM 只使用解释模式，禁用 JIT（通常用于调试）。</li><li><code>-Xcomp</code>：强制 JVM 编译所有代码（可能导致启动变慢）。</li><li><code>-Xmixed</code>：默认模式，解释与编译结合使用。</li></ul><h3 id="8-常见问题"><a href="#8-常见问题" class="headerlink" title="8. 常见问题"></a>8. <strong>常见问题</strong></h3><ul><li><strong>为什么程序启动时较慢？</strong><ul><li>因为 JIT 需要对热点代码进行编译，初期可能依赖解释器运行。</li></ul></li><li><strong>JIT 编译会带来性能下降吗？</strong><ul><li>在某些情况下（如频繁的代码编译或不适当的优化策略），可能会出现<strong>编译抖动</strong>（过多的编译开销）。</li></ul></li></ul><h2 id="AOT-编译"><a href="#AOT-编译" class="headerlink" title="AOT 编译"></a>AOT 编译</h2><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation) 。和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。</p><h3 id="1-AOT-编译的基本概念"><a href="#1-AOT-编译的基本概念" class="headerlink" title="1. AOT 编译的基本概念"></a>1. <strong>AOT 编译的基本概念</strong></h3><p>AOT 编译将源代码或中间代码（如 Java 字节码）编译为目标平台的机器代码，生成一个独立的、可以直接运行的本地二进制文件。编译后的程序无需依赖运行时解释器，直接运行在目标硬件上。</p><h3 id="2-AOT-编译的工作流程"><a href="#2-AOT-编译的工作流程" class="headerlink" title="2. AOT 编译的工作流程"></a>2. <strong>AOT 编译的工作流程</strong></h3><ol><li><strong>源代码编写</strong>：<ul><li>开发者使用高级编程语言（如 Java、C#）。</li></ul></li><li><strong>编译为中间代码</strong>：<ul><li>像 Java 这样的语言通常会先编译为字节码（例如 <code>.class</code> 文件）。</li></ul></li><li><strong>AOT 编译</strong>：<ul><li>AOT 编译器（如 GraalVM 的 AOT 工具）将字节码转换为本地机器代码。</li></ul></li><li><strong>生成可执行文件</strong>：<ul><li>输出结果是一个可以直接运行的二进制文件，无需额外的运行时编译步骤。</li></ul></li></ol><h3 id="3-AOT-编译的优点"><a href="#3-AOT-编译的优点" class="headerlink" title="3. AOT 编译的优点"></a>3. <strong>AOT 编译的优点</strong></h3><h4 id="1-启动速度快"><a href="#1-启动速度快" class="headerlink" title="(1) 启动速度快"></a>(1) <strong>启动速度快</strong></h4><ul><li>编译在运行前完成，程序启动时不需要动态解释或即时编译，因此启动速度显著提高。</li></ul><h4 id="2-优化性能"><a href="#2-优化性能" class="headerlink" title="(2) 优化性能"></a>(2) <strong>优化性能</strong></h4><ul><li>AOT 编译可以提前执行许多优化步骤，比如方法内联、循环优化和消除冗余代码。</li><li>特别适合对启动时间敏感的应用程序，比如微服务或 CLI 工具。</li></ul><h4 id="3-内存占用低"><a href="#3-内存占用低" class="headerlink" title="(3) 内存占用低"></a>(3) <strong>内存占用低</strong></h4><ul><li>不需要运行时 JIT 编译缓存，因此内存占用更低。</li><li>适合内存受限的环境，如嵌入式设备和移动应用。</li></ul><h4 id="4-跨语言整合"><a href="#4-跨语言整合" class="headerlink" title="(4) 跨语言整合"></a>(4) <strong>跨语言整合</strong></h4><ul><li>AOT 编译可以方便地将不同语言编写的模块编译成统一的本地代码，便于跨语言调用。</li></ul><h4 id="5-更容易分发"><a href="#5-更容易分发" class="headerlink" title="(5) 更容易分发"></a>(5) <strong>更容易分发</strong></h4><ul><li>生成的可执行文件独立于编译器或运行时环境，可以轻松分发和部署。</li></ul><h3 id="4-AOT-编译的缺点"><a href="#4-AOT-编译的缺点" class="headerlink" title="4. AOT 编译的缺点"></a>4. <strong>AOT 编译的缺点</strong></h3><h4 id="1-灵活性不足"><a href="#1-灵活性不足" class="headerlink" title="(1) 灵活性不足"></a>(1) <strong>灵活性不足</strong></h4><ul><li>AOT 编译缺乏运行时动态优化的能力，无法基于实际运行情况调整性能。</li><li>某些优化（如分支预测、逃逸分析）需要运行时信息，AOT 无法完成。</li></ul><h4 id="2-编译时间长"><a href="#2-编译时间长" class="headerlink" title="(2) 编译时间长"></a>(2) <strong>编译时间长</strong></h4><ul><li>编译过程通常比 JIT 更复杂，生成本地代码需要更多时间和资源。</li></ul><h4 id="3-平台绑定"><a href="#3-平台绑定" class="headerlink" title="(3) 平台绑定"></a>(3) <strong>平台绑定</strong></h4><ul><li>AOT 编译生成的可执行文件与目标平台紧密绑定，跨平台能力不如字节码+JVM 的方案。</li></ul><h4 id="4-文件体积大"><a href="#4-文件体积大" class="headerlink" title="(4) 文件体积大"></a>(4) <strong>文件体积大</strong></h4><ul><li>AOT 编译后的可执行文件可能包含额外的运行时支持代码，文件体积较大。</li></ul><h3 id="5-AOT-编译的应用场景"><a href="#5-AOT-编译的应用场景" class="headerlink" title="5. AOT 编译的应用场景"></a>5. <strong>AOT 编译的应用场景</strong></h3><p>AOT 编译在以下场景中特别有用：</p><ol><li><strong>启动速度敏感的应用</strong>：<ul><li>微服务、命令行工具、图形用户界面（GUI）程序等需要快速启动的应用。</li></ul></li><li><strong>资源受限设备</strong>：<ul><li>嵌入式系统、物联网设备和移动设备等内存有限的平台。</li></ul></li><li><strong>无运行时环境的环境</strong>：<ul><li>部署时无法安装完整的虚拟机或运行时（如 JVM）的场景。</li></ul></li><li><strong>安全性要求高的应用</strong>：<ul><li>直接编译为本地代码可以减少对运行时的依赖，降低潜在的安全风险。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java的即时编译器&quot;&gt;&lt;a href=&quot;#Java的即时编译器&quot; class=&quot;headerlink&quot; title=&quot;Java的即时编译器&quot;&gt;&lt;/a&gt;Java的即时编译器&lt;/h2&gt;&lt;p&gt;Java 的即时编译器 (JIT) 是 Java 虚拟机 (JVM) 中的重</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-动手学深度学习-笔记</title>
    <link href="https://kelinkong.github.io/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2024/12/27/AI-%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%AC%94%E8%AE%B0/</id>
    <published>2024-12-27T01:37:50.000Z</published>
    <updated>2024-12-31T02:23:47.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>当张量的形状为 <code>(3, 4, 4)</code> 时，可以将其理解为一个 <strong>包含多个层的神经网络模型</strong>。让我们用 <strong>特征和权重</strong> 来比喻：</p><h3 id="比喻解释"><a href="#比喻解释" class="headerlink" title="比喻解释"></a>比喻解释</h3><p>假设你有一个神经网络模型，输入层有 4 个特征（即 4 个特征值），并且你有 4 个权重值用于每个特征的计算。</p><ul><li><strong>3</strong>：表示神经网络中有 <strong>3 个不同的层</strong>（例如 3 个不同的神经网络中的权重矩阵）。</li><li><strong>4</strong>：每个层的 <strong>输入特征有 4 个</strong>（例如每一层有 4 个特征或神经元）。</li><li><strong>4</strong>：每个层的 <strong>每个特征有 4 个权重值</strong>（即每个特征都被 4 个不同的权重处理，或者每个神经元的连接数是 4）。</li></ul><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设你有一个多层感知机（MLP）神经网络模型，其中每一层的输入和输出都是 4 维的向量，而每一层的每个神经元的权重是一个 4 维的向量。张量的形状 <code>(3, 4, 4)</code> 就可以表示：</p><ul><li>第一维 <code>3</code> 代表神经网络中有 3 层（或 3 个不同的权重矩阵）。</li><li>第二维和第三维 <code>4</code> 代表每个矩阵（层）的大小是 4x4，这意味着每一层有 4 个输入特征，并且每个特征有 4 个对应的权重。</li></ul><h3 id="具体举例"><a href="#具体举例" class="headerlink" title="具体举例"></a>具体举例</h3><p>假设你有以下模型：</p><ol><li><strong>层 1</strong>：输入是 4 个特征，输出是 4 个神经元。每个神经元有 4 个权重，意味着每个神经元的计算有 4 个权重与输入特征进行相乘。</li><li><strong>层 2</strong>：同样，输入是 4 个特征，输出也是 4 个神经元，每个神经元有 4 个权重。</li><li><strong>层 3</strong>：依然是 4 个输入特征，4 个神经元和 4 个权重。</li></ol><p>这样，总共有 3 个层，每层都有一个 4x4 的权重矩阵，表示每个特征在该层中如何与其他特征结合形成输出。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设这是一个 3 层的神经网络，每层有 4 个输入特征，4 个权重</span></span><br><span class="line">weights = torch.tensor([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>], [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>]],</span><br><span class="line">                       [[<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>], [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>], [<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>], [<span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>]],</span><br><span class="line">                       [[<span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">36</span>], [<span class="number">37</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">40</span>], [<span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>], [<span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(weights.shape)  <span class="comment"># 输出: torch.Size([3, 4, 4])</span></span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>第一维 <code>3</code> 表示你有 <strong>3 个层</strong>，每层有一个 4x4 的权重矩阵。</li><li>第二维和第三维的 <code>4</code> 表示每个层的每个神经元的计算中使用了 4 个权重，每个权重都与输入特征相乘。</li></ul><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>正则化（Regularization）是机器学习中用来<strong>防止模型过拟合</strong>的一种技术。过拟合是指模型在训练数据上表现很好，但在新数据（测试数据）上表现差，通常是因为模型太复杂，学习到了数据中的噪音或不重要的细节。</p><h3 id="1-过拟合的原因"><a href="#1-过拟合的原因" class="headerlink" title="1. 过拟合的原因"></a>1. <strong>过拟合的原因</strong></h3><ul><li>模型在训练时过于“记住”了训练数据中的细节，而不是学到泛化规律（即如何处理新数据）。</li><li>复杂的模型（比如有很多参数）更容易过拟合。</li></ul><h3 id="2-正则化的目的"><a href="#2-正则化的目的" class="headerlink" title="2. 正则化的目的"></a>2. <strong>正则化的目的</strong></h3><p>正则化的目标是通过限制模型的复杂度，避免模型对训练数据的过度拟合。它通过给模型加上一些额外的约束，使得模型在学习时不能“随意”地调整参数，而是保持适度的简单性。</p><h3 id="3-如何实现正则化？"><a href="#3-如何实现正则化？" class="headerlink" title="3. 如何实现正则化？"></a>3. <strong>如何实现正则化？</strong></h3><p>正则化通常通过在损失函数中加入一个额外的项来实现，这个项通常与模型的<strong>权重</strong>（参数）大小有关。常见的正则化方法有两种：</p><h4 id="1-L1-正则化（Lasso）"><a href="#1-L1-正则化（Lasso）" class="headerlink" title="(1) L1 正则化（Lasso）"></a>(1) <strong>L1 正则化（Lasso）</strong></h4><ul><li>L1 正则化在损失函数中加入一个与<strong>权重的绝对值之和</strong>成比例的项。</li><li>它的作用是“惩罚”大权重，迫使模型学习到的特征更加简洁。</li><li><strong>L1 正则化的效果</strong>：它可以将某些权重变为零，相当于<strong>自动选择特征</strong>。</li></ul><p>公式：<br>$$<br>\text{L1 正则化} &#x3D; \lambda \sum_{i&#x3D;1}^{n} |w_i|<br>$$</p><ul><li>其中，$w_i$ 是模型的权重，$\lambda$ 是正则化的强度（越大，惩罚越强）。</li></ul><h4 id="2-L2-正则化（Ridge）"><a href="#2-L2-正则化（Ridge）" class="headerlink" title="(2) L2 正则化（Ridge）"></a>(2) <strong>L2 正则化（Ridge）</strong></h4><ul><li>L2 正则化在损失函数中加入一个与<strong>权重的平方和</strong>成比例的项。</li><li>它的作用是<strong>惩罚大权重</strong>，但不像 L1 那样将权重变为零，而是让权重变得更小，防止某些特征对模型的影响过大。</li><li><strong>L2 正则化的效果</strong>：它可以平滑模型，使模型更加稳健。</li></ul><p>公式：<br>$$<br>\text{L2 正则化} &#x3D; \lambda \sum_{i&#x3D;1}^{n} w_i^2<br>$$</p><h3 id="4-如何理解正则化？"><a href="#4-如何理解正则化？" class="headerlink" title="4. 如何理解正则化？"></a>4. <strong>如何理解正则化？</strong></h3><p><strong>举个简单的例子</strong>：<br>假设你在做一个学生的成绩预测模型，输入特征有 <strong>学习时间、上课出勤率、平时作业分数</strong> 等。如果模型过于复杂，可能会学习到一些不重要的特征，比如学生每天吃的零食种类。这样，模型会在训练集上表现很好，但在实际使用时可能表现差，因为这些不重要的特征对新数据没有帮助。</p><p>通过正则化，你给模型添加了一些<strong>惩罚</strong>，强迫它只关注重要的特征，并避免关注那些噪音和不重要的细节。这样，模型会学到更有用的规律，泛化能力更强。</p><h3 id="5-正则化的效果"><a href="#5-正则化的效果" class="headerlink" title="5. 正则化的效果"></a>5. <strong>正则化的效果</strong></h3><ul><li><strong>减少过拟合</strong>：通过限制模型复杂度，使得模型不仅能在训练数据上表现好，也能在新数据上表现好。</li><li><strong>提升模型的泛化能力</strong>：正则化可以帮助模型学到更为通用的规律，而不是记住训练数据中的细节。</li></ul><h2 id="如何理解L1-L2正则化？"><a href="#如何理解L1-L2正则化？" class="headerlink" title="如何理解L1&#x2F;L2正则化？"></a>如何理解L1&#x2F;L2正则化？</h2><p>好的，我们再深入一点，详细计算一下 L1 正则化是如何惩罚权重的，以及它如何引导模型减少不重要特征的影响。</p><h3 id="假设情境"><a href="#假设情境" class="headerlink" title="假设情境"></a>假设情境</h3><p>我们使用一个非常简单的线性回归模型，有 <strong>2 个特征</strong>$x_1$ 和$x_2$，目标是预测 <strong>y</strong>。模型的公式为：<br>$$<br>y &#x3D; w_1 x_1 + w_2 x_2 + b<br>$$<br>其中：</p><ul><li>$w_1$ 和 $w_2$ 是特征 $x_1$ 和 $x_2$ 的权重。</li><li>$b$ 是偏置项（在这里我们忽略不讨论）。</li></ul><p>我们要最小化的是<strong>总损失</strong>，即：<br>$$<br>\text{总损失} &#x3D; \text{MSE（均方误差）} + \text{L1 正则化损失}<br>$$<br>均方误差（MSE）用来衡量模型预测值与实际值之间的误差，而 L1 正则化损失用来惩罚权重，使它们尽可能小。</p><h3 id="1-没有正则化的情况"><a href="#1-没有正则化的情况" class="headerlink" title="1. 没有正则化的情况"></a>1. <strong>没有正则化的情况</strong></h3><p>假设我们没有正则化，只有 MSE 损失。对于一个简单的回归模型，损失函数可以表示为：<br>$$<br>\text{MSE} &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N} (y_{\text{预测}, i} - y_{\text{实际}, i})^2<br>$$<br>其中，$y_{\text{预测}, i} &#x3D; w_1 x_{1,i} + w_2 x_{2,i} + b$，是模型的预测值。</p><p>在没有正则化的情况下，模型的目标是尽量减小 MSE，但它不考虑特征权重的大小，可能会导致模型过度依赖某些特征。</p><h3 id="2-加入-L1-正则化"><a href="#2-加入-L1-正则化" class="headerlink" title="2. 加入 L1 正则化"></a>2. <strong>加入 L1 正则化</strong></h3><p>L1 正则化在损失函数中加入了对权重的惩罚项。对于每个权重，惩罚项是它的绝对值。损失函数现在变成了：<br>$$<br>\text{总损失} &#x3D; \text{MSE} + \lambda \left( |w_1| + |w_2| \right)<br>$$<br>其中，$\lambda$ 是正则化系数，控制惩罚项的强度。如果 $\lambda$ 很大，惩罚就会更强，权重会被压缩得更小。</p><h3 id="3-例子：权重调整过程"><a href="#3-例子：权重调整过程" class="headerlink" title="3. 例子：权重调整过程"></a>3. <strong>例子：权重调整过程</strong></h3><p>假设我们训练了模型，得到了初始的权重：</p><ul><li>$w_1 &#x3D; 5$</li><li>$w_2 &#x3D; 0.1$</li><li>正则化系数 $\lambda &#x3D; 0.1$</li></ul><p>我们还假设 MSE 损失部分的计算结果为 50（为了简化计算，不考虑具体的样本数据）。</p><h4 id="步骤-1：计算正则化损失"><a href="#步骤-1：计算正则化损失" class="headerlink" title="步骤 1：计算正则化损失"></a>步骤 1：计算正则化损失</h4><p>L1 正则化损失是：<br>$$<br>\text{L1 正则化损失} &#x3D; \lambda \left( |w_1| + |w_2| \right)<br>$$<br>代入权重值：<br>$$<br>\text{L1 正则化损失} &#x3D; 0.1 \times (|5| + |0.1|) &#x3D; 0.1 \times (5 + 0.1) &#x3D; 0.1 \times 5.1 &#x3D; 0.51<br>$$</p><h4 id="步骤-2：总损失"><a href="#步骤-2：总损失" class="headerlink" title="步骤 2：总损失"></a>步骤 2：总损失</h4><p>现在，模型的总损失是：<br>$$<br>\text{总损失} &#x3D; \text{MSE} + \text{L1 正则化损失}<br>$$<br>$$<br>\text{总损失} &#x3D; 50 + 0.51 &#x3D; 50.51<br>$$<br>所以，在这种情况下，L1 正则化的惩罚项增加了总损失。</p><h4 id="步骤-3：权重更新（梯度下降）"><a href="#步骤-3：权重更新（梯度下降）" class="headerlink" title="步骤 3：权重更新（梯度下降）"></a>步骤 3：权重更新（梯度下降）</h4><p>模型通过梯度下降来最小化总损失。在梯度下降过程中，L1 正则化的惩罚项会影响梯度的计算，使得权重的更新不仅考虑误差，还考虑惩罚项。</p><p>在每次更新过程中，L1 正则化对每个权重的影响如下：</p><ul><li>对于 $w_1$，L1 正则化会迫使它变小。因为 $|w_1| &#x3D; 5$，所以它的梯度下降会考虑惩罚项。</li><li>对于 $w_2$，L1 正则化会更加显著地影响它。由于 $|w_2| &#x3D; 0.1$，惩罚项在 $w_2$ 上的效果更明显，权重会逐步变小。</li></ul><p><strong>因为较大的权重已经对模型的预测结果产生较大的影响，L1 正则化的惩罚项只是对这个权重施加一个适度的惩罚，导致它会被逐渐减小，但不至于过多压缩。较小的权重这是因为它本身的绝对值较小，正则化的惩罚就会占据更大的比重，迫使它迅速变小甚至归零。</strong>（模型总是在选择使得损失函数变小的参数）</p><h4 id="步骤-4：逐步更新"><a href="#步骤-4：逐步更新" class="headerlink" title="步骤 4：逐步更新"></a>步骤 4：逐步更新</h4><p>假设我们计算出了梯度，并在一次更新后得到以下新的权重（梯度下降步长为 0.1）：</p><ul><li>$ w_1 &#x3D; 4.8$</li><li>$w_2 &#x3D; 0.05$</li></ul><p>这个更新过程说明了，<strong>L1 正则化会推动较小的权重变得更小</strong>，并让它们趋向于零。</p><h3 id="4-最终权重的变化"><a href="#4-最终权重的变化" class="headerlink" title="4. 最终权重的变化"></a>4. <strong>最终权重的变化</strong></h3><p>继续进行多次更新，L1 正则化会导致 $w_2$（那个较小的权重）逐渐减少，甚至变为零。假设经过足够多的训练步骤，最后我们得到：</p><ul><li>$w_1  &#x3D; 4.5$</li><li>$w_2 &#x3D; 0$</li></ul><p>此时，<strong>L1 正则化已经将不重要的特征（即 $w_2$）的权重压缩为零</strong>，表明模型已经“去除了”不重要的特征。</p><h2 id="自注意力机制"><a href="#自注意力机制" class="headerlink" title="自注意力机制"></a>自注意力机制</h2><h3 id="自注意力机制-Self-Attention-Mechanism"><a href="#自注意力机制-Self-Attention-Mechanism" class="headerlink" title="自注意力机制 (Self-Attention Mechanism)"></a>自注意力机制 (Self-Attention Mechanism)</h3><p>自注意力机制是 Transformer 模型的核心，它帮助模型捕捉输入序列中不同位置之间的依赖关系。它的目的是使每个输入元素（例如一个词）能够与其他输入元素进行交互，从而更好地理解上下文信息。自注意力机制比传统的循环神经网络（RNN）和卷积神经网络（CNN）更强大，因为它能够同时考虑整个序列的信息，而不需要按顺序逐一处理。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li><p><strong>输入表示</strong>：自注意力机制首先接收一个输入序列。对于文本输入，通常每个词被嵌入成一个向量，形成一个矩阵。</p></li><li><p><strong>查询（Query）、键（Key）和值（Value）</strong>：</p><ul><li><strong>查询（Q）</strong>：每个输入词（或词向量）都会映射为一个查询向量，用来与其他词进行“匹配”。</li><li><strong>键（K）</strong>：每个输入词也会映射为一个键向量，查询会与这些键进行匹配，以确定其相关性。</li><li><strong>值（V）</strong>：每个输入词也会有一个值向量，最终输出是基于查询和键的匹配得分加权得到的值向量的加权和。</li></ul></li><li><p><strong>计算注意力得分</strong>：<br>自注意力机制通过计算每个查询向量与所有键向量之间的相似度（通常使用点积）。相似度得分越高，表示查询和键之间的关联越强。通常，通过Softmax对得分进行归一化，得到注意力权重。</p><p>$$<br>\text{Attention Score} &#x3D; Q \cdot K^T<br>$$<br>然后，使用 Softmax 函数将这些得分转化为概率，确保权重总和为1：</p><p>$$<br>\text{Attention Weight} &#x3D; \text{Softmax}(Q \cdot K^T)<br>$$</p></li><li><p><strong>加权求和值</strong>：<br>通过对每个值（V）向量加权求和，生成最终的输出。具体来说，注意力权重会决定各个值向量在最终输出中的贡献。</p><p>$$<br>\text{Output} &#x3D; \sum (\text{Attention Weight}_i \cdot V_i)<br>$$</p></li><li><p><strong>多头注意力</strong>：<br>Transformer 使用多头注意力机制，意味着查询、键和值向量会被拆分成多个子空间，分别计算注意力。这允许模型在不同的子空间中关注输入的不同方面。</p><p>最后，多个头的结果会被拼接起来，并通过一个线性层进行变换。</p></li></ol><h4 id="自注意力机制的作用"><a href="#自注意力机制的作用" class="headerlink" title="自注意力机制的作用"></a>自注意力机制的作用</h4><ul><li><strong>捕获长距离依赖</strong>：传统的 RNN 和 CNN 主要通过局部邻域来获取信息，而自注意力机制可以通过计算所有词的相关性，捕获长距离依赖。</li><li><strong>并行处理</strong>：由于不依赖于序列的顺序，自注意力机制允许模型对输入进行并行处理，效率更高。</li><li><strong>灵活性</strong>：每个位置根据上下文信息调整其关注的焦点。</li></ul><h3 id="Transformer-中的自注意力层"><a href="#Transformer-中的自注意力层" class="headerlink" title="Transformer 中的自注意力层"></a>Transformer 中的自注意力层</h3><p>Transformer 模型完全基于自注意力机制，它使用了多个自注意力层来处理序列数据。Transformer 模型中最重要的组件是 <strong>自注意力层</strong>（Self-Attention Layer）和 <strong>前馈神经网络</strong>（Feed-Forward Neural Networks）。我们来深入探讨自注意力层的工作原理。</p><h4 id="Transformer-模型架构"><a href="#Transformer-模型架构" class="headerlink" title="Transformer 模型架构"></a>Transformer 模型架构</h4><p>Transformer 模型由多个堆叠的编码器（Encoder）和解码器（Decoder）组成。在每个编码器和解码器中，自注意力层都起着关键作用。</p><ol><li><p><strong>编码器（Encoder）</strong>：<br>每个编码器层有两个主要部分：</p><ul><li><strong>自注意力机制</strong>：编码器的每一层都包括一个自注意力层，它允许输入序列中的每个位置根据全局上下文来调整其表示。</li><li><strong>前馈神经网络</strong>：每个编码器还包含一个小型的前馈神经网络（Feed-Forward Neural Network），它通过线性变换和激活函数进一步处理输入。</li></ul></li><li><p><strong>解码器（Decoder）</strong>：<br>解码器的结构与编码器相似，但它在自注意力机制中加入了“遮蔽”（Masked）机制，以确保解码时每个位置仅能看到当前位置及之前的输入。此外，解码器中的每个自注意力层还会与编码器的输出交互，获取全局信息。</p></li></ol><h4 id="自注意力层的具体实现"><a href="#自注意力层的具体实现" class="headerlink" title="自注意力层的具体实现"></a>自注意力层的具体实现</h4><p>自注意力层包括以下几个步骤：</p><ol><li><p><strong>输入嵌入和位置编码</strong>：<br>输入的每个词首先通过嵌入（embedding）层转换为向量，并加上位置编码，以捕捉序列的顺序信息。</p></li><li><p><strong>查询、键和值</strong>：<br>将输入的嵌入向量通过线性变换生成查询（Q）、键（K）和值（V）向量。</p></li><li><p><strong>计算注意力</strong>：<br>计算每个查询和所有键的点积，得到注意力分数，并通过 Softmax 得到归一化的权重。</p></li><li><p><strong>加权求和</strong>：<br>使用这些权重对值（V）向量加权求和，得到每个位置的加权表示。</p></li><li><p><strong>输出</strong>：<br>最后的输出通过多头注意力机制合并多个头的结果，然后通过一个线性层进行变换。</p></li></ol><h4 id="自注意力层的公式"><a href="#自注意力层的公式" class="headerlink" title="自注意力层的公式"></a>自注意力层的公式</h4><p>假设我们有一个输入序列 $X &#x3D; [x_1, x_2, \dots, x_n]$，每个 $x_i$ 是一个词的嵌入向量。通过训练，我们学习到查询（Q）、键（K）和值（V）矩阵，分别将输入映射为 $Q &#x3D; XW_Q$、$K &#x3D; XW_K$、$V &#x3D; XW_V$。</p><ol><li><strong>计算注意力得分</strong>：</li></ol><p>$$<br>\text{Attention Score}(Q, K) &#x3D; \frac{QK^T}{\sqrt{d_k}}<br>$$</p><ol start="2"><li><strong>归一化注意力得分</strong>：</li></ol><p>$$<br>\text{Attention Weight} &#x3D; \text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)<br>$$</p><ol start="3"><li><strong>加权求和</strong>：</li></ol><p>$$<br>\text{Output} &#x3D; \text{Attention Weight} \cdot V<br>$$</p><h2 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h2><p>在 Transformer 中的 <strong>多头注意力</strong>（Multi-Head Attention）机制中，”拼接”（concatenation）指的是将多个注意力头的输出连接起来，以便能够捕获输入序列的更多信息。接下来，拼接后的结果会经过一个线性变换来得到最终的输出。</p><h3 id="多头注意力机制的步骤"><a href="#多头注意力机制的步骤" class="headerlink" title="多头注意力机制的步骤"></a>多头注意力机制的步骤</h3><ol><li><p><strong>计算多个注意力头</strong>：<br>在多头注意力中，首先将输入的查询（Query）、键（Key）和值（Value）通过不同的线性变换分别映射到多个子空间，形成多个不同的查询、键和值的集合。每个头（head）对应于不同的查询、键、值子空间。</p><p>假设总的嵌入维度是 $C$，而有 $h$ 个注意力头。那么，每个注意力头的维度为 $A &#x3D; \frac{C}{h}$，即每个头的维度是总维度 $C$ 除以头的数量 $h$。</p></li><li><p><strong>每个注意力头的计算</strong>：<br>对于每个注意力头，都会计算一个独立的自注意力输出。具体的计算过程如下：</p><ul><li>对每个头，使用自己的查询、键和值计算注意力得分并进行加权求和，得到该头的输出。</li></ul></li><li><p><strong>拼接所有头的输出</strong>：<br>每个头的输出维度是 $A$，所以如果有 $h$ 个头，那么拼接后的输出将是一个维度为 $h \times A &#x3D; C$ 的向量。也就是说，拼接后的结果恢复了原始的输入维度 $C$。</p><p>这个拼接的过程非常简单，就是将每个头的输出按顺序连接在一起，得到一个大向量。</p></li><li><p><strong>线性变换</strong>：<br>将拼接后的多头注意力输出通过一个线性层（即一个权重矩阵）进行变换，得到最终的输出。</p></li></ol><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><p>假设输入的维度为 $C &#x3D; 8$，有 $h &#x3D; 2$ 个注意力头（即每个头的维度 $A &#x3D; 4$）。我们来看看这个过程如何进行：</p><ol><li><p><strong>输入和映射</strong>：<br>输入是一个长度为 8 的向量，经过线性变换后，我们会得到两个查询（Query）、键（Key）和值（Value）的子空间，每个子空间的维度是 4。</p></li><li><p><strong>计算每个头的输出</strong>：<br>对于每个头（总共有 2 个头），计算它们的注意力输出（每个头的输出维度为 4）。</p><ul><li>头 1 的输出是一个 4 维向量。</li><li>头 2 的输出是另一个 4 维向量。</li></ul></li><li><p><strong>拼接</strong>：<br>将这两个头的输出拼接起来，得到一个 8 维的向量：</p><p>$$<br>\text{Concatenated Output} &#x3D; [\text{Head 1 Output}, \text{Head 2 Output}]<br>$$</p><p>这就是拼接的过程。最终拼接结果的维度是 $C &#x3D; 8$。</p></li><li><p><strong>线性变换</strong>：<br>将拼接后的输出通过一个线性变换，得到最终的多头注意力层输出。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>多头注意力的拼接步骤其实是将每个注意力头计算出的输出向量沿着维度方向拼接起来，得到一个较大的向量。</li><li>这种拼接允许模型在不同的子空间中“并行”地学习不同类型的特征，而不是仅仅依赖于一个单一的注意力头。</li><li>最后，通过线性变换将拼接后的输出映射回原始维度 $C$，为后续的网络层提供输入。</li></ul><p>这个过程使得 Transformer 模型能够从多个角度和不同的子空间捕获序列中的信息，从而提高模型的表达能力。</p><h2 id="传统神经网络的输入和transform中的输入"><a href="#传统神经网络的输入和transform中的输入" class="headerlink" title="传统神经网络的输入和transform中的输入"></a>传统神经网络的输入和transform中的输入</h2><h3 id="1-传统神经网络中的输入"><a href="#1-传统神经网络中的输入" class="headerlink" title="1. 传统神经网络中的输入"></a>1. <strong>传统神经网络中的输入</strong></h3><p>在传统的神经网络（如前馈神经网络）中，输入通常是一个固定维度的向量或矩阵，具体内容取决于任务类型：</p><ul><li><p><strong>结构化数据</strong>：<br>输入是一个包含多种特征的向量。例如，在房价预测中，输入可能是房屋面积、房间数量等数值型特征。</p></li><li><p><strong>图像数据</strong>：<br>输入是二维或三维矩阵。例如，在图像分类任务中，输入是像素值组成的矩阵，可能还有 RGB 通道。</p></li><li><p><strong>文本数据</strong>：<br>输入通常是经过嵌入的向量，例如词嵌入（word embedding）或句子嵌入。</p></li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>输入是独立的，每个样本的输入没有显式的上下文关联。</li><li>输入的维度固定。</li><li>输入数据需要提前提取和处理为数值形式。</li></ul><hr><h3 id="2-Transformer-编码器中的前馈神经网络输入"><a href="#2-Transformer-编码器中的前馈神经网络输入" class="headerlink" title="2. Transformer 编码器中的前馈神经网络输入"></a>2. <strong>Transformer 编码器中的前馈神经网络输入</strong></h3><p>在 Transformer 的编码器中，前馈神经网络（Feed-Forward Neural Network, FFN）的输入是 <strong>注意力层的输出</strong>，它是上下文相关的特征表示。以下是输入的主要特点：</p><ul><li><p><strong>来源</strong>：<br>输入是经过自注意力层处理后的输出，每个词（或序列位置）的表示已经包含了与其他词的上下文依赖关系。</p></li><li><p><strong>形状</strong>：<br>输入是一个三维张量，形状为 $[batch_size, sequence_length, embedding_dim]$。</p><ul><li><code>batch_size</code>：批量大小。</li><li><code>sequence_length</code>：序列的长度（例如一个句子中的词数）。</li><li><code>embedding_dim</code>：每个词的嵌入向量的维度。</li></ul></li><li><p><strong>内容</strong>：<br>每个位置的表示已经结合了该位置与其他位置之间的注意力权重（即上下文信息），所以它是 <strong>上下文相关的表示</strong>。</p></li></ul><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li>输入包含上下文依赖信息。</li><li>输入维度与嵌入维度一致，但输入每个位置的值已经经过注意力机制的加权。</li><li>输入可以表示整个序列的信息，而不是单个独立样本。</li></ul><hr><h3 id="3-传统神经网络输入与-Transformer-编码器中-FFN-输入的区别"><a href="#3-传统神经网络输入与-Transformer-编码器中-FFN-输入的区别" class="headerlink" title="3. 传统神经网络输入与 Transformer 编码器中 FFN 输入的区别"></a>3. <strong>传统神经网络输入与 Transformer 编码器中 FFN 输入的区别</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>传统神经网络的输入</strong></th><th><strong>Transformer 编码器中的 FFN 输入</strong></th></tr></thead><tbody><tr><td><strong>上下文依赖</strong></td><td>输入数据通常是独立的，每个样本相互无关。</td><td>输入每个位置的表示包含上下文相关信息。</td></tr><tr><td><strong>输入形状</strong></td><td>向量或矩阵，具体形状依赖任务。</td><td>三维张量，形状为 ([batch_size, sequence_length, embedding_dim])。</td></tr><tr><td><strong>维度</strong></td><td>固定的输入特征维度。</td><td>嵌入维度通常与序列的长度和批量大小相关联。</td></tr><tr><td><strong>表示方式</strong></td><td>特征通常是直接提取的原始数据特征。</td><td>输入是经过嵌入层和自注意力层处理的特征表示。</td></tr><tr><td><strong>上下文信息</strong></td><td>特征是独立的，不包含其他样本的信息。</td><td>特征表示已经包含序列中其他位置的相关性。</td></tr></tbody></table><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. <strong>总结</strong></h3><ul><li><strong>传统神经网络</strong>：输入是独立的特征向量，通常没有上下文信息。网络依赖于层间权重来建模数据之间的关系。</li><li><strong>Transformer 编码器中的前馈神经网络</strong>：输入是注意力层输出的上下文相关表示，已经包含序列中各位置之间的依赖关系。FFN 的作用是在每个位置上进一步非线性地变换这些上下文相关的特征。</li></ul><p>这种区别使得 Transformer 特别适合处理序列数据，例如自然语言处理和时间序列建模，因为其输入已经通过自注意力层捕获了序列的全局信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;张量&quot;&gt;&lt;a href=&quot;#张量&quot; class=&quot;headerlink&quot; title=&quot;张量&quot;&gt;&lt;/a&gt;张量&lt;/h2&gt;&lt;p&gt;当张量的形状为 &lt;code&gt;(3, 4, 4)&lt;/code&gt; 时，可以将其理解为一个 &lt;strong&gt;包含多个层的神经网络模型&lt;/stron</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-基于transformers的自然语言处理(NLP)入门</title>
    <link href="https://kelinkong.github.io/2024/12/24/AI-%E5%9F%BA%E4%BA%8Etransformers%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP-%E5%85%A5%E9%97%A8/"/>
    <id>https://kelinkong.github.io/2024/12/24/AI-%E5%9F%BA%E4%BA%8Etransformers%E7%9A%84%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86-NLP-%E5%85%A5%E9%97%A8/</id>
    <published>2024-12-24T00:55:44.000Z</published>
    <updated>2024-12-26T08:20:27.703Z</updated>
    
    <content type="html"><![CDATA[<p>教程地址：<a href="https://github.com/datawhalechina/learn-nlp-with-transformers">基于transformers的自然语言处理(NLP)入门</a></p><h2 id="常见的NLP任务"><a href="#常见的NLP任务" class="headerlink" title="常见的NLP任务"></a>常见的NLP任务</h2><ul><li>文本分类：对单个、两个或者多段文本进行分类。举例：“这个教程真棒！”这段文本的情感倾向是正向的，“我在学习transformer”和“如何学习transformer”这两段文本是相似的。</li><li>序列标注：对文本序列中的token、字或者词进行分类。举例：“我在国家图书馆学transformer。”这段文本中的国家图书馆是一个地点，可以被标注出来方便机器对文本的理解。</li><li>问答任务——抽取式问答和多选问答：1、抽取式问答根据问题从一段给定的文本中找到答案，答案必须是给定文本的一小段文字。举例：问题“小学要读多久?”和一段文本“小学教育一般是六年制。”，则答案是“六年”。2、多选式问答，从多个选项中选出一个正确答案。举例：“以下哪个模型结构在问答中效果最好？“和4个选项”A、MLP，B、cnn，C、lstm，D、transformer“，则答案选项是D。</li><li>生成任务——语言模型、机器翻译和摘要生成：根据已有的一段文字生成（generate）一个字通常叫做语言模型，根据一大段文字生成一小段总结性文字通常叫做摘要生成，将源语言比如中文句子翻译成目标语言比如英语通常叫做机器翻译。</li></ul><h2 id="seq2seq框架"><a href="#seq2seq框架" class="headerlink" title="seq2seq框架"></a>seq2seq框架</h2><p>seq2seq是一种常见的NLP模型结构，全称是：sequence to sequence，翻译为“序列到序列”。顾名思义：从一个文本序列得到一个新的文本序列。典型的任务有：机器翻译任务，文本摘要任务。</p><p>seq2seq模型由编码器（Encoder）和解码器（Decoder）组成。绿色的编码器会处理输入序列中的每个元素并获得输入信息，这些信息会被转换成为一个黄色的向量（称为context向量）。当我们处理完整个输入序列后，编码器把 context向量 发送给紫色的解码器，解码器通过context向量中的信息，逐个元素输出新的序列。</p><p>我们来看一下黄色的context向量是什么？本质上是一组浮点数。而这个context的数组长度是基于编码器RNN的隐藏层神经元数量的。上图展示了长度为4的context向量，但在实际应用中，context向量的长度是自定义的，比如可能是256，512或者1024。</p><p>那么RNN是如何具体地处理输入序列的呢？</p><ol><li><p>假设序列输入是一个句子，这个句子可以由$n$个词表示：$sentence &#x3D; {w_1, w_2,…,w_n}$。</p></li><li><p>RNN首先将句子中的每一个词映射成为一个向量得到一个向量序列：$X &#x3D; {x_1, x_2,…,x_n}$，每个单词映射得到的向量通常又叫做：word embedding。</p></li><li><p>然后在处理第$t \in [1,n]$个时间步的序列输入$x_t$时，RNN网络的输入和输出可以表示为：$h_{t} &#x3D; RNN(x_t, h_{t-1})$</p></li></ol><ul><li>输入：RNN在时间步$t$的输入之一为单词$w_t$经过映射得到的向量$x_t$。</li><li>输入：RNN另一个输入为上一个时间步$t-1$得到的hidden state向量$h_{t-1}$，同样是一个向量。</li><li>输出：RNN在时间步$t$的输出为$h_t$ hidden state向量。</li></ul><h2 id="神经网络矩阵乘法"><a href="#神经网络矩阵乘法" class="headerlink" title="神经网络矩阵乘法"></a>神经网络矩阵乘法</h2><p>参考视频：<a href="https://www.youtube.com/watch?v=UNmqTiOnRfg">A friendly introduction to Recurrent Neural Networks</a></p><p><img src="/../imgs/image-84.png"></p><p>通过矩阵，将一个输入序列映射到输出序列。</p><p><img src="/../imgs/image-85.png"></p><p>假设可以写为：<br>$$<br>A*a&#x3D;b<br>$$<br>那么如何得到矩阵A呢？</p><p>当已知向量 $\mathbf{b}$ 和向量 $\mathbf{c}$，并且它们满足线性方程 $A\mathbf{b} &#x3D; \mathbf{c}$ 时，求解矩阵 $A$ 的问题本质上是一个欠定问题（如果 $\mathbf{b}$ 不是零向量）。这是因为对于给定的 $\mathbf{b}$ 和 $\mathbf{c}$，通常存在无数个不同的矩阵 $A$ 可以使等式成立。为了获得一个唯一的解，我们需要额外的信息或约束条件。</p><h3 id="使用最小二乘法"><a href="#使用最小二乘法" class="headerlink" title="使用最小二乘法"></a>使用最小二乘法</h3><p>如果我们有多个样本对 $(\mathbf{b}_i, \mathbf{c}_i)$，其中 $i &#x3D; 1, 2, …, k$，那么可以通过最小化误差平方和来估计 $A$：</p><p>$$<br>\min_{A} \sum_{i&#x3D;1}^{k} | A\mathbf{b}_i - \mathbf{c}_i |^2<br>$$</p><p>这可以通过构建一个更大的系统并求解正规方程来实现。例如，如果我们有 $k$ 对 $(\mathbf{b}_i, \mathbf{c}_i)$，则可以形成如下矩阵方程：</p><p>$$<br>B^T B A &#x3D; B^T C<br>$$</p><p>这里 $B$ 是由所有 $\mathbf{b}_i$ 组成的大矩阵，每一列对应一个 $\mathbf{b}_i$，而 $C$ 同样是由所有 $\mathbf{c}_i$ 组成的大矩阵。通过解这个方程可以得到一个最佳拟合的 $A$。</p><p><strong>这里的矩阵$A$其实就是我们想要得到的权重矩阵。而$\mathbf{b}$就是输出向量。</strong></p><p>那么问题就转换为如何去求解权重矩阵。参考：<a href="https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/">AI-神经网络中的三个基本概念：梯度下降、反向传播、损失函数</a></p><p>考虑一个简单的全连接层（fully connected layer），它接收来自前一层的输出作为输入，并将其传递给下一层。假设前一层有<br>$n$个神经元，当前层有<br>$m$个神经元，那么每个输入特征都会对所有输出神经元产生影响。因此，我们需要定义一组参数来描述这种关系——这就是权重矩阵的作用所在。</p><p>所以说来说去，其实是一个东西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;教程地址：&lt;a href=&quot;https://github.com/datawhalechina/learn-nlp-with-transformers&quot;&gt;基于transformers的自然语言处理(NLP)入门&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见的NLP任务&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-GraphRAG</title>
    <link href="https://kelinkong.github.io/2024/12/20/AI-GraphRAG/"/>
    <id>https://kelinkong.github.io/2024/12/20/AI-GraphRAG/</id>
    <published>2024-12-20T02:38:54.000Z</published>
    <updated>2025-01-10T02:19:05.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GraphRAG"><a href="#GraphRAG" class="headerlink" title="GraphRAG"></a>GraphRAG</h2><p>仓库地址：<a href="https://github.com/microsoft/graphrag">GraphRAG</a></p><p>GraphRAG（Graph-based Retrieval Augmented Generation，基于图的检索增强生成）是一种利用图结构来增强大型语言模型（LLM）检索能力的先进方法。它旨在解决传统 RAG 方法在处理复杂关系、全局性问题和多跳推理方面的局限性。以下是 GraphRAG 的一些实现原理和技术要点：</p><p><strong>核心思想：</strong></p><p>GraphRAG 的核心是将文本数据转化为知识图谱，利用图的结构化信息来指导检索过程，从而更有效地为 LLM 提供上下文信息。与传统的基于向量相似度的检索方法不同，GraphRAG 侧重于实体之间的关系和整个数据集的结构，这使得它能够回答需要综合理解和推理的问题。</p><p><strong>实现原理：</strong></p><ol><li><p><strong>文本分块与信息抽取：</strong> 首先将原始文本分割成较小的块（chunk），然后从每个文本块中提取实体、关系和属性等信息。这通常使用命名实体识别（NER）、关系抽取等 NLP 技术。</p></li><li><p><strong>构建知识图谱：</strong> 将提取出的实体作为图的节点，实体之间的关系作为图的边，构建知识图谱。这个图谱可以包含多种类型的关系，例如“属于”、“位于”、“是…的作者”等等。</p></li><li><p><strong>图社区检测：</strong> 使用图算法（例如 Louvain 算法、PageRank 算法）检测图中的社区或子图。这些社区通常代表了文本中相关的概念或主题。</p></li><li><p><strong>社区摘要：</strong> 为每个检测到的社区生成摘要，概述该社区的主要内容和关键信息。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询时，GraphRAG 首先将查询转化为图查询，例如查找与某个实体相关的其他实体或关系。然后，在知识图谱上执行图查询，检索相关的社区或子图。</p></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的社区摘要或子图信息作为上下文提供给 LLM，让 LLM 基于这些上下文生成最终的回答。</p></li></ol><p><strong>技术要点：</strong></p><ul><li><p><strong>知识图谱构建：</strong></p><ul><li><strong>信息抽取质量：</strong> 实体和关系的准确提取至关重要，直接影响图谱的质量和检索效果。</li><li><strong>图谱规模和稀疏性：</strong> 如何有效地处理大规模图谱和图谱中的稀疏性是一个挑战。</li><li><strong>图谱的动态更新：</strong> 如何随着新数据的加入动态更新图谱，保持其时效性。</li></ul></li><li><p><strong>图算法选择：</strong></p><ul><li><strong>社区检测算法：</strong> 选择合适的社区检测算法，以有效地发现图谱中的相关主题。</li><li><strong>图查询算法：</strong> 如何高效地在图谱上执行查询，检索相关信息。</li></ul></li><li><p><strong>上下文选择和融合：</strong></p><ul><li><strong>上下文的相关性：</strong> 如何选择与查询最相关的上下文信息。</li><li><strong>上下文的长度和格式：</strong> 如何将图结构的信息有效地融入到 LLM 的输入中。</li></ul></li><li><p><strong>与传统 RAG 的结合：</strong></p><ul><li><strong>混合检索策略：</strong> 将图检索和向量检索结合起来，充分利用两者的优势。</li><li><strong>多阶段检索：</strong> 先使用图检索缩小检索范围，再使用向量检索进行精细化检索。</li></ul></li></ul><p><strong>GraphRAG 的优势：</strong></p><ul><li><strong>处理复杂关系：</strong> 能够更好地理解和处理实体之间的复杂关系，例如多跳关系。</li><li><strong>回答全局性问题：</strong> 能够基于整个数据集的结构进行推理和总结，回答需要全局视野的问题。</li><li><strong>提高检索效率：</strong> 通过图结构的引导，可以更有效地检索相关信息，减少不必要的计算。</li></ul><p><strong>GraphRAG 的挑战：</strong></p><ul><li><strong>知识图谱构建的复杂性：</strong> 构建高质量的知识图谱需要大量的工程和技术投入。</li><li><strong>图算法的选择和优化：</strong> 选择合适的图算法并进行优化需要一定的专业知识。</li><li><strong>与 LLM 的有效集成：</strong> 如何将图结构的信息有效地传递给 LLM，并让 LLM 充分利用这些信息。</li></ul><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>为了帮助你更好地理解 GraphRAG，我将举一个具体的例子，并结合实际应用场景进行说明。</p><p><strong>场景：</strong> 假设我们有一个关于电影的数据库，其中包含电影的各种信息，例如电影名称、导演、演员、类型、上映日期、剧情简介等。我们希望构建一个问答系统，用户可以提出关于电影的各种问题，例如“克里斯托弗·诺兰导演的科幻电影有哪些？”或者“《盗梦空间》的主演是谁？”。</p><p><strong>传统 RAG 方法的局限性：</strong> 如果使用传统的 RAG 方法，我们可能会将电影信息分割成文本块，并使用向量相似度来检索与用户查询相关的文本块。这种方法在回答简单的问题时可能有效，但在回答需要多跳推理或全局信息的问题时就显得力不从心。例如，如果用户问“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”，传统 RAG 方法可能难以有效地回答，因为它需要检索多个电影的信息，并进行关联和统计。</p><p><strong>使用 GraphRAG 的解决方案：</strong></p><ol><li><p><strong>构建知识图谱：</strong></p><ul><li><strong>实体：</strong> 电影名称、导演、演员、类型等。</li><li><strong>关系：</strong> “导演”、“主演”、“属于类型”、“上映于”等。</li></ul><p>例如，《盗梦空间》可以表示为一个节点，“克里斯托弗·诺兰”和“莱昂纳多·迪卡普里奥”也分别表示为节点。“克里斯托弗·诺兰”和《盗梦空间》之间存在“导演”关系，《莱昂纳多·迪卡普里奥》和《盗梦空间》之间存在“主演”关系。</p></li><li><p><strong>图社区检测（可选）：</strong> 可以使用社区检测算法将相关的电影、导演和演员聚类成不同的社区。例如，可以将克里斯托弗·诺兰导演的电影聚类成一个社区，将某个类型的电影聚类成另一个社区。</p></li><li><p><strong>查询处理与图检索：</strong> 当用户提出查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 的处理步骤如下：</p><ul><li>将查询转化为图查询：查找与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计每个“导演”节点与“莱昂纳多·迪卡普里奥”节点之间边的数量（即合作次数）。</li><li>在知识图谱上执行图查询：遍历图谱，找到所有与“莱昂纳多·迪卡普里奥”节点相连的“导演”节点，并统计它们之间的连接次数。</li><li>返回结果：返回合作次数超过两次的导演列表，例如“马丁·斯科塞斯”。</li></ul></li><li><p><strong>上下文生成与 LLM 集成：</strong> 将检索到的导演列表以及相关的电影信息（例如电影名称、上映日期等）作为上下文提供给 LLM。LLM 基于这些上下文生成最终的回答，例如“莱昂纳多·迪卡普里奥与马丁·斯科塞斯合作过多次，包括《华尔街之狼》、《禁闭岛》等电影。”。</p></li></ol><p><strong>具体例子图示：</strong></p><p>假设我们的知识图谱包含以下信息：</p><ul><li>《盗梦空间》- 导演：克里斯托弗·诺兰</li><li>《盗梦空间》- 主演：莱昂纳多·迪卡普里奥</li><li>《禁闭岛》- 导演：马丁·斯科塞斯</li><li>《禁闭岛》- 主演：莱昂纳多·迪卡普里奥</li><li>《华尔街之狼》- 导演：马丁·斯科塞斯</li><li>《华尔街之狼》- 主演：莱昂纳多·迪卡普里奥</li></ul><p>当用户查询“与莱昂纳多·迪卡普里奥合作过两次以上的导演有哪些？”时，GraphRAG 会在图谱上找到以下路径：</p><ul><li>莱昂纳多·迪卡普里奥 -&gt; 《盗梦空间》-&gt; 克里斯托弗·诺兰</li><li>莱昂纳多·迪卡普里奥 -&gt; 《禁闭岛》-&gt; 马丁·斯科塞斯</li><li>莱昂纳多·迪卡普里奥 -&gt; 《华尔街之狼》-&gt; 马丁·斯科塞斯</li></ul><p>通过统计，发现马丁·斯科塞斯与莱昂纳多·迪卡普里奥合作了两次以上，因此将其返回。</p><p><strong>总结：</strong></p><p>通过这个例子可以看出，GraphRAG 利用知识图谱的结构化信息，能够有效地处理需要多跳推理和全局信息的问题，相比传统的 RAG 方法具有明显的优势。它将文本信息转化为图结构，使得 LLM 能够更好地理解和利用这些信息，从而生成更准确、更全面的回答。</p><p>希望这个例子能够帮助你更好地理解 GraphRAG 的实施原理和优势。如果你还有其他问题，欢迎继续提问。</p><h2 id="什么样的场景适合构建知识图谱？"><a href="#什么样的场景适合构建知识图谱？" class="headerlink" title="什么样的场景适合构建知识图谱？"></a>什么样的场景适合构建知识图谱？</h2><p>构建知识图谱并非适用于所有场景。它是一种强大的工具，但也有其特定的适用范围。以下是一些适合构建知识图谱的场景，以及一些不适合的场景：</p><p><strong>适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据之间存在复杂关联：</strong> 如果数据之间存在大量的关系和连接，并且这些关系对于理解数据至关重要，那么知识图谱就非常适用。例如：</p><ul><li><strong>社交网络：</strong> 人与人之间的朋友关系、关注关系、共同参与的活动等。</li><li><strong>生物医药：</strong> 基因、蛋白质、疾病、药物之间的相互作用和关联。</li><li><strong>金融领域：</strong> 公司、股东、投资、交易等之间的关系。</li></ul></li><li><p><strong>需要进行推理和分析：</strong> 如果需要基于数据进行推理、分析和预测，知识图谱可以提供强大的支持。例如：</p><ul><li><strong>智能问答系统：</strong> 回答需要多步推理的问题，例如“与某人合作过两次以上的导演有哪些？”。</li><li><strong>风险评估：</strong> 分析金融交易中的潜在风险，例如欺诈检测。</li><li><strong>推荐系统：</strong> 基于用户的历史行为和兴趣，推荐相关的产品或服务。</li></ul></li><li><p><strong>数据来源多样且异构：</strong> 如果数据来自不同的来源，并且格式各异，知识图谱可以提供一种统一的表示方式，方便数据的整合和利用。例如：</p><ul><li><strong>企业级数据整合：</strong> 将来自不同部门、不同系统的数据整合到一个统一的知识图谱中。</li><li><strong>跨领域数据融合：</strong> 将来自不同领域的数据融合到一起，例如将医疗数据和社交数据结合起来进行健康管理。</li></ul></li><li><p><strong>需要可视化和探索：</strong> 知识图谱以图形化的方式呈现数据，方便用户进行可视化和探索，发现数据中隐藏的模式和规律。例如：</p><ul><li><strong>情报分析：</strong> 分析犯罪网络、恐怖组织等。</li><li><strong>科研探索：</strong> 探索科学研究中的新发现和新联系。</li></ul></li><li><p><strong>需要支持语义搜索：</strong> 传统的关键词搜索只能找到包含关键词的文档，而知识图谱可以支持基于语义的搜索，找到与用户查询相关的概念和实体。例如：</p><ul><li><strong>电商搜索：</strong> 用户搜索“适合跑步的鞋子”，可以返回各种类型的跑鞋，而不仅仅是包含“跑步”和“鞋子”这两个词的商品。</li></ul></li></ol><p><strong>不适合构建知识图谱的场景：</strong></p><ol><li><p><strong>数据结构简单且关系单一：</strong> 如果数据结构非常简单，并且数据之间只有简单的线性关系，那么使用传统的数据库或表格就足够了，不需要构建知识图谱。</p></li><li><p><strong>数据量小且变化频繁：</strong> 如果数据量非常小，并且变化非常频繁，那么维护知识图谱的成本可能会高于其带来的收益。</p></li><li><p><strong>对推理和分析的需求不高：</strong> 如果应用场景主要关注数据的存储和检索，而不需要进行复杂的推理和分析，那么使用传统的数据库就足够了。</p></li></ol><p><strong>总结：</strong></p><p>以下是一些判断是否适合构建知识图谱的关键因素：</p><ul><li><strong>数据之间的关联程度：</strong> 关联越复杂，越适合使用知识图谱。</li><li><strong>对推理和分析的需求：</strong> 需求越高，越适合使用知识图谱。</li><li><strong>数据来源的多样性和异构性：</strong> 来源越多，越适合使用知识图谱进行整合。</li><li><strong>对可视化和探索的需求：</strong> 需求越高，越适合使用知识图谱。</li></ul><h2 id="GraphRAG是如何构建知识图谱的？"><a href="#GraphRAG是如何构建知识图谱的？" class="headerlink" title="GraphRAG是如何构建知识图谱的？"></a>GraphRAG是如何构建知识图谱的？</h2><p>微软的 <strong>GraphRAG</strong> 在构建知识图谱时，采用了一套结合自然语言处理（NLP）、图数据库（如 Neo4j）、以及大语言模型（LLMs）的系统化方法。这种方法的核心目标是将非结构化数据（如文档、文本）转换为结构化的图谱表示，并通过知识图谱增强检索与生成任务。</p><p>以下是 <strong>GraphRAG</strong> 构建知识图谱的核心步骤和技术实现：</p><h3 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1. 整体流程"></a>1. <strong>整体流程</strong></h3><p><strong>GraphRAG</strong> 的知识图谱构建流程主要分为以下步骤：</p><ol><li><strong>数据预处理</strong>：从非结构化数据中抽取知识。</li><li><strong>实体和关系抽取</strong>：识别图谱的节点（实体）和边（关系）。</li><li><strong>图谱生成</strong>：将抽取的实体和关系组织为图结构，并存储到图数据库中。</li><li><strong>图谱优化与增强</strong>：通过推理、去噪和融合提高图谱质量。</li><li><strong>实时更新</strong>：动态将新知识添加到图谱中。</li></ol><h3 id="2-核心步骤"><a href="#2-核心步骤" class="headerlink" title="2. 核心步骤"></a>2. <strong>核心步骤</strong></h3><h4 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="(1) 数据预处理"></a><strong>(1) 数据预处理</strong></h4><ul><li><strong>目标</strong>：将原始数据（如文本、网页、文档）转换为可处理的格式。</li><li><strong>方法</strong>：<ul><li>文本分块：将长文档切分为逻辑段落或句子。</li><li>清理无关内容：去除非信息性内容（如广告、格式符号）。</li><li>NLP 预处理：对文本进行分词、词性标注和依存分析。</li></ul></li></ul><h4 id="2-实体和关系抽取"><a href="#2-实体和关系抽取" class="headerlink" title="(2) 实体和关系抽取"></a><strong>(2) 实体和关系抽取</strong></h4><ul><li><strong>目标</strong>：从文本中提取实体和实体间的语义关系。</li><li><strong>技术</strong>：<ol><li><strong>实体抽取（NER, Named Entity Recognition）</strong>：<ul><li>识别出文本中的实体（如人名、地点、组织、事件等）。</li><li>示例：<ul><li>输入：<code>Microsoft 在 2023 年发布了新产品。</code></li><li>输出：<code>实体：&#123;Microsoft, 2023&#125;</code></li></ul></li></ul></li><li><strong>关系抽取</strong>：<ul><li>识别实体间的语义关系。</li><li>示例：<ul><li>输入：<code>Microsoft 在 2023 年发布了新产品。</code></li><li>输出：<code>关系：&#123;Microsoft -&gt; 发布 -&gt; 新产品&#125;</code>。</li></ul></li></ul></li><li><strong>工具</strong>：<ul><li>基于规则：依赖语法分析器或知识库规则。</li><li>基于模型：使用预训练模型（如 BERT、T5）微调的关系抽取模型。</li></ul></li></ol></li></ul><h4 id="3-图谱生成"><a href="#3-图谱生成" class="headerlink" title="(3) 图谱生成"></a><strong>(3) 图谱生成</strong></h4><ul><li><strong>目标</strong>：将实体和关系组织为图结构。</li><li><strong>方法</strong>：<ul><li>图结构定义：<ul><li><strong>节点（Nodes）</strong>：实体（如“Microsoft”）。</li><li><strong>边（Edges）</strong>：关系（如“发布”）。</li><li><strong>属性（Properties）</strong>：附加信息（如时间戳、来源）。</li></ul></li><li>图存储：<ul><li>使用图数据库（如 Neo4j）存储生成的知识图谱。</li></ul></li><li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE (a:Organization &#123;name: &#x27;Microsoft&#x27;&#125;)-[:RELEASED]-&gt;(b:Product &#123;name: &#x27;New Product&#x27;, year: 2023&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="4-图谱优化与增强"><a href="#4-图谱优化与增强" class="headerlink" title="(4) 图谱优化与增强"></a><strong>(4) 图谱优化与增强</strong></h4><ul><li><strong>目标</strong>：提升图谱的质量和推理能力。</li><li><strong>方法</strong>：<ol><li><strong>知识融合</strong>：<ul><li>合并重复实体，标准化数据表示。</li><li>示例：将 <code>MSFT</code> 和 <code>Microsoft</code> 统一为同一节点。</li></ul></li><li><strong>关系推理</strong>：<ul><li>使用规则或模型推断隐含关系。</li><li>示例：若 <code>A 是 B 的父亲</code> 且 <code>B 是 C 的父亲</code>，则推断 <code>A 是 C 的祖父</code>。</li></ul></li><li><strong>去噪</strong>：<ul><li>过滤低置信度的实体和关系。</li><li>基于置信分数或人工审核移除冗余或错误信息。</li></ul></li></ol></li></ul><h4 id="5-实时更新"><a href="#5-实时更新" class="headerlink" title="(5) 实时更新"></a><strong>(5) 实时更新</strong></h4><ul><li><strong>目标</strong>：使图谱始终包含最新知识。</li><li><strong>方法</strong>：<ul><li>增量更新：将新增数据中的实体和关系提取后动态添加到图谱中。</li><li>数据校验：对新增知识进行验证，避免图谱污染。</li></ul></li></ul><h3 id="3-技术与工具"><a href="#3-技术与工具" class="headerlink" title="3. 技术与工具"></a>3. <strong>技术与工具</strong></h3><h4 id="1-NLP-模型"><a href="#1-NLP-模型" class="headerlink" title="(1) NLP 模型"></a><strong>(1) NLP 模型</strong></h4><ul><li><strong>预训练模型</strong>：如 BERT、GPT-4、T5，用于实体和关系抽取。</li><li><strong>微调模型</strong>：在特定领域数据上微调的模型提高精度。</li></ul><h4 id="2-图数据库"><a href="#2-图数据库" class="headerlink" title="(2) 图数据库"></a><strong>(2) 图数据库</strong></h4><ul><li><strong>Neo4j</strong>：作为存储和查询的后端，支持高效的图遍历和查询。</li><li><strong>图查询语言</strong>：使用 Cypher 查询语言实现图谱管理。</li></ul><h4 id="3-集成语言模型（LLMs）"><a href="#3-集成语言模型（LLMs）" class="headerlink" title="(3) 集成语言模型（LLMs）"></a><strong>(3) 集成语言模型（LLMs）</strong></h4><ul><li>通过 LLMs 提供上下文增强，确保在生成过程中充分利用图谱信息。</li><li>示例：<ul><li>生成模型会根据用户查询，结合知识图谱的结果生成回答。</li></ul></li></ul><h3 id="4-结合生成任务的工作流程"><a href="#4-结合生成任务的工作流程" class="headerlink" title="4. 结合生成任务的工作流程"></a>4. <strong>结合生成任务的工作流程</strong></h3><p>知识图谱不仅被用作静态存储，还用于 Graph RAG 的检索和生成流程：</p><ol><li><strong>查询图谱</strong>：<ul><li>用户问题触发对图谱的查询，通过图遍历找到相关实体和关系。</li><li>示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Alice&#x27;&#125;)-[:KNOWS]-&gt;(friends)</span><br><span class="line">RETURN friends</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>检索结果传递给 LLM</strong>：<ul><li>将图谱的检索结果转化为语言模型的输入，作为上下文。</li></ul></li><li><strong>生成答案</strong>：<ul><li>使用 LLM 基于上下文生成最终答案，避免生成幻觉。</li></ul></li></ol><h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a>5. <strong>应用场景</strong></h3><ul><li><strong>开放域问答</strong>：<ul><li>用户问题通过知识图谱检索相关背景信息，提供准确回答。</li></ul></li><li><strong>知识图谱增强生成</strong>：<ul><li>用知识图谱的结构化数据补充生成内容。</li></ul></li><li><strong>多跳推理</strong>：<ul><li>基于图谱实现复杂的关系推理。</li></ul></li></ul><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. <strong>总结</strong></h3><p>微软的 <strong>Graph RAG</strong> 通过从非结构化数据中构建知识图谱，将知识存储为结构化的图数据，增强了检索和生成过程的效率与准确性。结合 Neo4j 等图数据库，Graph RAG 实现了高效的知识管理和利用，尤其适合知识密集型任务，如开放问答和多跳推理场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GraphRAG&quot;&gt;&lt;a href=&quot;#GraphRAG&quot; class=&quot;headerlink&quot; title=&quot;GraphRAG&quot;&gt;&lt;/a&gt;GraphRAG&lt;/h2&gt;&lt;p&gt;仓库地址：&lt;a href=&quot;https://github.com/microsoft/gra</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-神经网络中的三个基本概念：梯度下降、反向传播、损失函数</title>
    <link href="https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
    <id>https://kelinkong.github.io/2024/12/19/AI-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E3%80%81%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E3%80%81%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</id>
    <published>2024-12-19T02:05:45.000Z</published>
    <updated>2024-12-20T08:18:52.148Z</updated>
    
    <content type="html"><![CDATA[<!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><p>文章参考：<a href="https://github.com/microsoft/ai-edu/blob/master/%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/A2-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/%E7%AC%AC1%E6%AD%A5%20-%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/02.0-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D.md">神经网络中的三个基本概念</a></p><h2 id="2-0-通俗地理解三大概念"><a href="#2-0-通俗地理解三大概念" class="headerlink" title="2.0 通俗地理解三大概念"></a>2.0 通俗地理解三大概念</h2><p>这三大概念是：反向传播，梯度下降，损失函数。</p><p>神经网络训练的最基本的思想就是：先“猜”一个结果，称为预测结果 $a$，看看这个预测结果和事先标记好的训练集中的真实结果 $y$ 之间的差距，然后调整策略，再试一次，这一次就不是“猜”了，而是有依据地向正确的方向靠近。如此反复多次，一直到预测结果和真实结果之间相差无几，亦即 $|a-y|\rightarrow 0$，就结束训练。</p><p>在神经网络训练中，我们把“猜”叫做初始化，可以随机，也可以根据以前的经验给定初始值。即使是“猜”，也是有技术含量的。</p><p>下面我们举几个例子来直观的说明下这三个概念。</p><h3 id="2-0-1-例一：猜数"><a href="#2-0-1-例一：猜数" class="headerlink" title="2.0.1 例一：猜数"></a>2.0.1 例一：猜数</h3><p>甲乙两个人玩儿猜数的游戏，数字的范围是 $[1,50]$：</p><p>甲：我猜5</p><p>乙：太小了</p><p>甲：50</p><p>乙：有点儿大</p><p>甲：30</p><p>乙：小了</p><p>……</p><p>在这个游戏里：</p><ul><li>目的：猜到乙心中的数字；</li><li>初始化：甲猜5；</li><li>前向计算：甲每次猜的新数字；</li><li>损失函数：乙在根据甲猜的数来和自己心中想的数做比较，得出“大了”或“小了”的结论；</li><li>反向传播：乙告诉甲“小了”、“大了”；</li><li>梯度下降：甲根据乙的反馈中的含义自行调整下一轮的猜测值。</li></ul><p>这里的损失函数是什么呢？就是“太小了”，“有点儿大”，很不精确！这个“所谓的”损失函数给出了两个信息：</p><ol><li>方向：大了或小了</li><li>程度：“太”，“有点儿”，但是很模糊</li></ol><h3 id="2-0-2-例二：黑盒子"><a href="#2-0-2-例二：黑盒子" class="headerlink" title="2.0.2 例二：黑盒子"></a>2.0.2 例二：黑盒子</h3><p>假设有一个黑盒子：</p><p>我们只能看到输入和输出的数值，看不到里面的样子，当输入1时，输出2.334，然后黑盒子有个信息显示：我需要输出值是4。然后我们试了试输入2，结果输出5.332，一下子比4大了很多。那么我们第一次的损失值是 $2.334-4&#x3D;-1.666$，而二次的损失值是 $5.332-4&#x3D;1.332$。</p><p>这里，我们的损失函数就是一个简单的减法，用实际值减去目标值，但是它可以告诉你两个信息：1）方向，是大了还是小了；2）差值，是0.1还是1.1。这样就给了我们下一次猜的依据。</p><ul><li>目的：猜到一个输入值，使得黑盒子的输出是4；</li><li>初始化：输入1；</li><li>前向计算：黑盒子内部的数学逻辑；</li><li>损失函数：在输出端，用输出值减4；</li><li>反向传播：告诉猜数的人差值，包括正负号和值；</li><li>梯度下降：在输入端，根据正负号和值，确定下一次的猜测值。</li></ul><h3 id="2-0-3-例三：打靶"><a href="#2-0-3-例三：打靶" class="headerlink" title="2.0.3 例三：打靶"></a>2.0.3 例三：打靶</h3><p>小明拿了一支步枪，射击100米外的靶子。这支步枪没有准星，或者是准星有问题，或者是小明眼神儿不好看不清靶子，或者是雾很大，或者风很大，或者由于木星的影响而侧向引力场异常……反正就是遇到各种干扰因素。</p><p>第一次试枪后，拉回靶子一看，弹着点偏左了，于是在第二次试枪时，小明就会有意识地向右侧偏几毫米，再看靶子上的弹着点，如此反复几次，小明就会掌握这支步枪的脾气了。图2-2显示了小明的5次试枪过程。</p><p><img src="/../imgs/image-72.png" alt="图2-2 打靶的弹着点记录"></p><p>在有监督的学习中，需要衡量神经网络输出和所预期的输出之间的差异大小。这种误差函数需要能够反映出当前网络输出和实际结果之间一种量化之后的不一致程度，也就是说函数值越大，反映出模型预测的结果越不准确。</p><p>这个例子中，小明预期的目标是全部命中靶子的中心，最外圈是1分，之后越向靶子中心分数是2，3，4分，正中靶心可以得10分。</p><ul><li>每次试枪弹着点和靶心之间的差距就叫做误差，可以用一个误差函数来表示，比如差距的绝对值，如图中的红色线。</li><li>一共试枪5次，就是迭代&#x2F;训练了5次的过程 。</li><li>每次试枪后，把靶子拉回来看弹着点，然后调整下一次的射击角度的过程，叫做反向传播。注意，把靶子拉回来看和跑到靶子前面去看有本质的区别，后者容易有生命危险，因为还有别的射击者。一个不恰当的比喻是，在数学概念中，人跑到靶子前面去看，叫做正向微分；把靶子拉回来看，叫做反向微分。</li><li>每次调整角度的数值和方向，叫做梯度。比如向右侧调整1毫米，或者向左下方调整2毫米。如图中的绿色矢量线。</li></ul><p>上图是每次单发点射，所以每次训练样本的个数是1。在实际的神经网络训练中，通常需要多个样本，做批量训练，以避免单个样本本身采样时带来的误差。在本例中，多个样本可以描述为连发射击，假设一次可以连打3发子弹，每次的离散程度都类似，如图2-3所示。<br><img src="/../imgs/image-73.png" alt="图2-3 连发弹着点记录"></p><ul><li>如果每次3发子弹连发，这3发子弹的弹着点和靶心之间的差距之和再除以3，叫做损失，可以用损失函数来表示。</li></ul><p>那小明每次射击结果和目标之间的差距是多少呢？在这个例子里面，用得分来衡量的话，就是说小明得到的反馈结果从差9分，到差8分，到差2分，到差1分，到差0分，这就是用一种量化的结果来表示小明的射击结果和目标之间差距的方式。也就是误差函数的作用。因为是一次只有一个样本，所以这里采用的是误差函数的称呼。如果一次有多个样本，就要叫做损失函数了。</p><p>其实射击还不这么简单，如果是远距离狙击，还要考虑空气阻力和风速，在神经网络里，空气阻力和风速可以对应到隐藏层的概念上。</p><p>在这个例子中：</p><ul><li>目的：打中靶心；</li><li>初始化：随便打一枪，能上靶就行，但是要记住当时的步枪的姿态；</li><li>前向计算：让子弹飞一会儿，击中靶子；</li><li>损失函数：环数，偏离角度；</li><li>反向传播：把靶子拉回来看；</li><li>梯度下降：根据本次的偏差，调整步枪的射击角度。</li></ul><p>损失函数的描述是这样的：</p><ol><li>1环，偏左上45度；</li><li>6环，偏左上15度；</li><li>7环，偏左；</li><li>8环，偏左下15度；</li><li>10环。</li></ol><p>这里的损失函数也有两个信息：</p><ol><li>距离；</li><li>方向。</li></ol><p><strong>所以，梯度，是个矢量！</strong> 它应该即告诉我们方向，又告诉我们数值。</p><h3 id="2-0-4-黑盒子的真正玩法"><a href="#2-0-4-黑盒子的真正玩法" class="headerlink" title="2.0.4 黑盒子的真正玩法"></a>2.0.4 黑盒子的真正玩法</h3><p>以上三个例子比较简单，容易理解，我们把黑盒子再请出来：黑盒子这件事真正的意义并不是猜测当输入是多少时输出会是4。它的实际意义是：我们要破解这个黑盒子！于是，我们会有如下破解流程：</p><ol><li>记录下所有输入值和输出值，如表2-1。</li></ol><p>表2-1 样本数据表</p><table><thead><tr><th align="center">样本ID</th><th>输入(特征值)</th><th>输出(标签)</th></tr></thead><tbody><tr><td align="center">1</td><td>1</td><td>2.21</td></tr><tr><td align="center">2</td><td>1.1</td><td>2.431</td></tr><tr><td align="center">3</td><td>1.2</td><td>2.652</td></tr><tr><td align="center">4</td><td>2</td><td>4.42</td></tr></tbody></table><ol start="2"><li>搭建一个神经网络，给出初始权重值，我们先假设这个黑盒子的逻辑是：$z&#x3D;x + x^2$；</li><li>输入1，根据 $z&#x3D;x + x^2$ 得到输出为2，而实际的输出值是2.21，则误差值为 $2-2.21&#x3D;-0.21$，小了；</li><li>调整权重值，比如 $z&#x3D;1.5x+x^2$，再输入1.1，得到的输出为2.86，实际输出为2.431，则误差值为 $2.86-2.431&#x3D;0.429$，大了；</li><li>调整权重值，比如 $z&#x3D;1.2x+x^2$，再输入1.2……</li><li>调整权重值，再输入2……</li><li>所有样本遍历一遍，计算平均的损失函数值；</li><li>依此类推，重复3，4，5，6过程，直到损失函数值小于一个指标，比如 $0.001$，我们就可以认为网络训练完毕，黑盒子“破解”了，实际是被复制了，因为神经网络并不能得到黑盒子里的真实函数体，而只是近似模拟。</li></ol><p>从上面的过程可以看出，如果误差值是正数，我们就把权重降低一些；如果误差值为负数，则升高权重。</p><h3 id="2-0-5-总结"><a href="#2-0-5-总结" class="headerlink" title="2.0.5 总结"></a>2.0.5 总结</h3><p>简单总结一下反向传播与梯度下降的基本工作原理：</p><ol><li>初始化；</li><li>正向计算；</li><li>损失函数为我们提供了计算损失的方法；</li><li>梯度下降是在损失函数基础上向着损失最小的点靠近而指引了网络权重调整的方向；</li><li>反向传播把损失值反向传给神经网络的每一层，让每一层都根据损失值反向调整权重；</li><li>Go to 2，直到精度足够好（比如损失函数值小于 $0.001$）。</li></ol><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-1-线性反向传播"><a href="#2-1-线性反向传播" class="headerlink" title="2.1 线性反向传播"></a>2.1 线性反向传播</h2><h3 id="2-1-1-正向计算的实例"><a href="#2-1-1-正向计算的实例" class="headerlink" title="2.1.1 正向计算的实例"></a>2.1.1 正向计算的实例</h3><p>假设有一个函数：</p><p>$$z &#x3D; x \cdot y \tag{1}$$</p><p>其中:</p><p>$$x &#x3D; 2w + 3b \tag{2}$$</p><p>$$y &#x3D; 2b + 1 \tag{3}$$</p><p>计算图如图2-4。</p><p><img src="/../imgs/image-74.png" alt="图2-4 简单线性计算的计算图"></p><p>注意这里 $x,y,z$ 不是变量，只是中间计算结果；$w,b$ 才是变量。因为在后面要学习的神经网络中，要最终求解的目标是 $w$ 和 $b$ 的值，所以在这里先预热一下。</p><p>当 $w &#x3D; 3, b &#x3D; 4$ 时，会得到图2-5的结果。</p><p><img src="/../imgs/image-75.png" alt="图2-5 计算结果"></p><p>最终的 $z$ 值，受到了前面很多因素的影响：变量 $w$，变量 $b$，计算式 $x$，计算式 $y$。</p><h3 id="2-1-2-反向传播求解-w"><a href="#2-1-2-反向传播求解-w" class="headerlink" title="2.1.2 反向传播求解 $w$"></a>2.1.2 反向传播求解 $w$</h3><h4 id="求-w-的偏导"><a href="#求-w-的偏导" class="headerlink" title="求 $w$ 的偏导"></a>求 $w$ 的偏导</h4><p>目前 $z&#x3D;162$，如果想让 $z$ 变小一些，比如目标是 $z&#x3D;150$，$w$ 应该如何变化呢？为了简化问题，先只考虑改变 $w$ 的值，而令 $b$ 值固定为 $4$。</p><p>如果想解决这个问题，最笨的办法是可以在输入端一点一点的试，把 $w$ 变成 $3.5$ 试试，再变成 $3$ 试试……直到满意为止。现在我们将要学习一个更好的解决办法：反向传播。</p><p>从 $z$ 开始一层一层向回看，图中各节点关于变量 $w$ 的偏导计算结果如下：</p><p>因为 $z &#x3D; x \cdot y$，其中 $x &#x3D; 2w + 3b, y &#x3D; 2b + 1$</p><p>所以：</p><p>$$<br>\frac{\partial{z}}{\partial{w}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}&#x3D;y \cdot 2&#x3D;18 \tag{4}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}&#x3D;\frac{\partial{}}{\partial{x}}(x \cdot y)&#x3D;y&#x3D;9<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{w}}&#x3D;\frac{\partial{}}{\partial{w}}(2w+3b)&#x3D;2<br>$$</p><p><img src="/../imgs/image-76.png" alt="图2-6 对 $w$ 的偏导求解过程"></p><p>图2-6其实就是链式法则的具体表现，$z$ 的误差通过中间的 $x$ 传递到 $w$。如果不是用链式法则，而是直接用 $z$ 的表达式计算对 $w$ 的偏导数，会怎么样呢？我们来试验一下。</p><p>根据公式1、2、3，我们有：</p><p>$$<br>z&#x3D;x \cdot y&#x3D;(2w+3b)(2b+1)&#x3D;4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求 $w$ 的偏导：</p><p>$$<br>\frac{\partial z}{\partial w}&#x3D;4b+2&#x3D;4 \cdot 4 + 2&#x3D;18 \tag{6}<br>$$</p><p>公式4和公式6的结果完全一致！所以，请大家相信链式法则的科学性。</p><h4 id="求-w-的具体变化值"><a href="#求-w-的具体变化值" class="headerlink" title="求 $w$ 的具体变化值"></a>求 $w$ 的具体变化值</h4><p><strong>公式4和公式6的含义是：当 $w$ 变化一点点时，$z$ 会产生 $w$ 的变化值18倍的变化</strong>。记住我们的目标是让 $z&#x3D;150$，目前在初始状态时是 $z&#x3D;162$，所以，问题转化为：当需要 $z$ 从 $162$ 变到 $150$ 时，$w$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z &#x3D; 18 \cdot \Delta w<br>$$</p><p>则：</p><p>$$<br>\Delta w &#x3D; {\Delta z \over 18}&#x3D;\frac{162-150}{18}&#x3D; 0.6667<br>$$</p><p>所以：</p><p>$$<br>w &#x3D; w - 0.6667&#x3D;2.3333<br>$$</p><p>$$<br>x&#x3D;2w+3b&#x3D;16.6667<br>$$</p><p>$$<br>z&#x3D;x \cdot y&#x3D;16.6667 \times 9&#x3D;150.0003<br>$$</p><p>我们一下子就成功地让 $z$ 值变成了 $150.0003$，与 $150$ 的目标非常地接近，这就是偏导数的威力所在。</p><h4 id="【课堂练习】推导-z-对-b-的偏导数，结果在下一小节中使用"><a href="#【课堂练习】推导-z-对-b-的偏导数，结果在下一小节中使用" class="headerlink" title="【课堂练习】推导 $z$ 对 $b$ 的偏导数，结果在下一小节中使用"></a>【课堂练习】推导 $z$ 对 $b$ 的偏导数，结果在下一小节中使用</h4><h3 id="2-1-3-反向传播求解-b"><a href="#2-1-3-反向传播求解-b" class="headerlink" title="2.1.3 反向传播求解 $b$"></a>2.1.3 反向传播求解 $b$</h3><h4 id="求-b-的偏导"><a href="#求-b-的偏导" class="headerlink" title="求 $b$ 的偏导"></a>求 $b$ 的偏导</h4><p>这次我们令 $w$ 的值固定为 $3$，变化 $b$ 的值，目标还是让 $z&#x3D;150$。同上一小节一样，先求 $b$ 的偏导数。</p><p>注意，在上一小节中，求 $w$ 的导数只经过了一条路：从 $z$ 到 $x$ 到 $w$。但是求 $b$ 的导数时要经过两条路，如图2-7所示：</p><ol><li>从 $z$ 到 $x$ 到 $b$；</li><li>从 $z$ 到 $y$ 到 $b$。</li></ol><p><img src="/../imgs/image-77.png" alt="图2-7 对b的偏导求解过程"></p><p>从复合导数公式来看，这两者应该是相加的关系，所以有：</p><p>$$<br>\frac{\partial{z}}{\partial{b}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}&#x3D;y \cdot 3+x \cdot 2&#x3D;63 \tag{7}<br>$$</p><p>其中：</p><p>$$<br>\frac{\partial{z}}{\partial{x}}&#x3D;\frac{\partial{}}{\partial{x}}(x \cdot y)&#x3D;y&#x3D;9<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{y}}&#x3D;\frac{\partial{}}{\partial{y}}(x \cdot y)&#x3D;x&#x3D;18<br>$$</p><p>$$<br>\frac{\partial{x}}{\partial{b}}&#x3D;\frac{\partial{}}{\partial{b}}(2w+3b)&#x3D;3<br>$$</p><p>$$<br>\frac{\partial{y}}{\partial{b}}&#x3D;\frac{\partial{}}{\partial{b}}(2b+1)&#x3D;2<br>$$</p><p>我们不妨再验证一下链式求导的正确性。把公式5再拿过来：</p><p>$$<br>z&#x3D;x \cdot y&#x3D;(2w+3b)(2b+1)&#x3D;4wb+2w+6b^2+3b \tag{5}<br>$$</p><p>对上式求b的偏导：</p><p>$$<br>\frac{\partial z}{\partial b}&#x3D;4w+12b+3&#x3D;12+48+3&#x3D;63 \tag{8}<br>$$</p><p>结果和公式7的链式法则一样。</p><h4 id="求-b-的具体变化值"><a href="#求-b-的具体变化值" class="headerlink" title="求 $b$ 的具体变化值"></a>求 $b$ 的具体变化值</h4><p>公式7和公式8的含义是：当 $b$ 变化一点点时，$z$ 会发生 $b$ 的变化值 $63$ 倍的变化。记住我们的目标是让 $z&#x3D;150$，目前在初始状态时是 $162$，所以，问题转化为：当我们需要 $z$ 从 $162$ 变到 $150$ 时，$b$ 需要变化多少？</p><p>既然：</p><p>$$<br>\Delta z &#x3D; 63 \cdot \Delta b<br>$$</p><p>则：</p><p>$$<br>\Delta b &#x3D; \frac{\Delta z}{63}&#x3D;\frac{162-150}{63}&#x3D;0.1905<br>$$</p><p>所以：<br>$$<br>b&#x3D;b-0.1905&#x3D;3.8095<br>$$</p><p>$$<br>x&#x3D;2w+3b&#x3D;17.4285<br>$$</p><p>$$<br>y&#x3D;2b+1&#x3D;8.619<br>$$</p><p>$$<br>z&#x3D;x \cdot y&#x3D;17.4285 \times 8.619&#x3D;150.2162<br>$$</p><p>这个结果也是与 $150$ 很接近了，但是精度还不够。再迭代几次，直到误差不大于 <code>1e-4</code> 时，我们就可以结束迭代了，对于计算机来说，这些运算的执行速度很快。</p><h4 id="【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？"><a href="#【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？" class="headerlink" title="【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？"></a>【课题练习】请自己尝试手动继续迭代两次，看看误差的精度可以达到多少？</h4><p>这个问题用数学公式倒推求解一个二次方程，就能直接得到准确的b值吗？是的！但是我们是要说明机器学习的方法，机器并不会解二次方程，而且很多时候不是用二次方程就能解决实际问题的。而上例所示，是用机器所擅长的迭代计算的方法来不断逼近真实解，这就是机器学习的真谛！而且这种方法是普遍适用的。</p><h3 id="2-1-4-同时求解-w-和-b-的变化值"><a href="#2-1-4-同时求解-w-和-b-的变化值" class="headerlink" title="2.1.4 同时求解 $w$ 和 $b$ 的变化值"></a>2.1.4 同时求解 $w$ 和 $b$ 的变化值</h3><p>这次我们要同时改变 $w$ 和 $b$，到达最终结果为 $z&#x3D;150$ 的目的。</p><p>已知 $\Delta z&#x3D;12$，我们不妨把这个误差的一半算在 $w$ 的账上，另外一半算在 $b$ 的账上：</p><p>$$<br>\Delta b&#x3D;\frac{\Delta z &#x2F; 2}{63} &#x3D; \frac{12&#x2F;2}{63}&#x3D;0.095<br>$$</p><p>$$<br>\Delta w&#x3D;\frac{\Delta z &#x2F; 2}{18} &#x3D; \frac{12&#x2F;2}{18}&#x3D;0.333<br>$$</p><ul><li>$w &#x3D; w-\Delta w&#x3D;3-0.333&#x3D;2.667$</li><li>$b &#x3D; b - \Delta b&#x3D;4-0.095&#x3D;3.905$</li><li>$x&#x3D;2w+3b&#x3D;2 \times 2.667+3 \times 3.905&#x3D;17.049$</li><li>$y&#x3D;2b+1&#x3D;2 \times 3.905+1&#x3D;8.81$</li><li>$z&#x3D;x \times y&#x3D;17.049 \times 8.81&#x3D;150.2$</li></ul><h4 id="【课堂练习】用Python代码实现以上双变量的反向传播计算过程"><a href="#【课堂练习】用Python代码实现以上双变量的反向传播计算过程" class="headerlink" title="【课堂练习】用Python代码实现以上双变量的反向传播计算过程"></a>【课堂练习】用Python代码实现以上双变量的反向传播计算过程</h4><p>容易出现的问题：</p><ol><li>在检查 $\Delta z$ 时的值时，注意要用绝对值，因为有可能是个负数</li><li>在计算 $\Delta b$ 和 $\Delta w$ 时，第一次时，它们对 $z$ 的贡献值分别是 $1&#x2F;63$ 和 $1&#x2F;18$，但是第二次时，由于 $b,w$ 值的变化，对 $z$ 的贡献值也会有微小变化，所以要重新计算。具体解释如下：</li></ol><p>$$<br>\frac{\partial{z}}{\partial{b}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{b}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{b}}&#x3D;y \cdot 3+x \cdot 2&#x3D;3y+2x<br>$$</p><p>$$<br>\frac{\partial{z}}{\partial{w}}&#x3D;\frac{\partial{z}}{\partial{x}} \cdot \frac{\partial{x}}{\partial{w}}+\frac{\partial{z}}{\partial{y}}\cdot\frac{\partial{y}}{\partial{w}}&#x3D;y \cdot 2+x \cdot 0 &#x3D; 2y<br>$$<br>所以，在每次迭代中，要重新计算下面两个值：<br>$$<br>\Delta b&#x3D;\frac{\Delta z}{3y+2x}<br>$$</p><p>$$<br>\Delta w&#x3D;\frac{\Delta z}{2y}<br>$$</p><p>以下是程序的运行结果。</p><p>没有在迭代中重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">003455</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">806068</span>,z=<span class="number">150</span>.<span class="number">007970</span>,delta_z=<span class="number">0</span>.<span class="number">007970</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000127</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805942</span>,z=<span class="number">150</span>.<span class="number">000294</span>,delta_z=<span class="number">0</span>.<span class="number">000294</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000011</span>,delta_z=<span class="number">0</span>.<span class="number">000011</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b$ 的贡献值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">single</span> variable new: b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">190476</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">809524</span>,z=<span class="number">150</span>.<span class="number">217687</span>,delta_z=<span class="number">0</span>.<span class="number">217687</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">714286</span>, delta_b=<span class="number">0</span>.<span class="number">003585</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805938</span>,z=<span class="number">150</span>.<span class="number">000077</span>,delta_z=<span class="number">0</span>.<span class="number">000077</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">671261</span>, delta_b=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">3</span>.<span class="number">805937</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">805937</span></span><br></pre></td></tr></table></figure><p>从以上两个结果对比中，可以看到三点：</p><ol><li><code>factor_b</code>第一次是<code>63</code>，以后每次都会略微降低一些</li><li>第二个函数迭代了3次就结束了，而第一个函数迭代了5次，效率不一样</li><li>最后得到的结果是一样的，因为这个问题只有一个解</li></ol><p>对于双变量的迭代，有同样的问题：</p><p>没有在迭代中重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都保持<code>63</code>和<code>18</code>)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">001440</span>, delta_w=<span class="number">0</span>.<span class="number">005039</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661628</span>,b=<span class="number">3</span>.<span class="number">903322</span>,z=<span class="number">150</span>.<span class="number">005526</span>,delta_z=<span class="number">0</span>.<span class="number">005526</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000044</span>, delta_w=<span class="number">0</span>.<span class="number">000154</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661474</span>,b=<span class="number">3</span>.<span class="number">903278</span>,z=<span class="number">150</span>.<span class="number">000170</span>,delta_z=<span class="number">0</span>.<span class="number">000170</span></span><br><span class="line"><span class="attribute">delta_b</span>=<span class="number">0</span>.<span class="number">000001</span>, delta_w=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661469</span>,b=<span class="number">3</span>.<span class="number">903277</span>,z=<span class="number">150</span>.<span class="number">000005</span>,delta_z=<span class="number">0</span>.<span class="number">000005</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903277</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661469</span></span><br></pre></td></tr></table></figure><p>在每次迭代中都重新计算 $\Delta b,\Delta w$ 的贡献值(<code>factor_b</code>和<code>factor_w</code>每次都变化)：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">double</span> variable new: w, b -----</span><br><span class="line"><span class="attribute">w</span>=<span class="number">3</span>.<span class="number">000000</span>,b=<span class="number">4</span>.<span class="number">000000</span>,z=<span class="number">162</span>.<span class="number">000000</span>,delta_z=<span class="number">12</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">63</span>.<span class="number">000000</span>, factor_w=<span class="number">18</span>.<span class="number">000000</span>, delta_b=<span class="number">0</span>.<span class="number">095238</span>, delta_w=<span class="number">0</span>.<span class="number">333333</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">666667</span>,b=<span class="number">3</span>.<span class="number">904762</span>,z=<span class="number">150</span>.<span class="number">181406</span>,delta_z=<span class="number">0</span>.<span class="number">181406</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">523810</span>, factor_w=<span class="number">17</span>.<span class="number">619048</span>, delta_b=<span class="number">0</span>.<span class="number">001499</span>, delta_w=<span class="number">0</span>.<span class="number">005148</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661519</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000044</span>,delta_z=<span class="number">0</span>.<span class="number">000044</span></span><br><span class="line"><span class="attribute">factor_b</span>=<span class="number">60</span>.<span class="number">485234</span>, factor_w=<span class="number">17</span>.<span class="number">613053</span>, delta_b=<span class="number">0</span>.<span class="number">000000</span>, delta_w=<span class="number">0</span>.<span class="number">000001</span></span><br><span class="line"><span class="attribute">w</span>=<span class="number">2</span>.<span class="number">661517</span>,b=<span class="number">3</span>.<span class="number">903263</span>,z=<span class="number">150</span>.<span class="number">000000</span>,delta_z=<span class="number">0</span>.<span class="number">000000</span></span><br><span class="line"><span class="attribute">done</span>!</span><br><span class="line"><span class="attribute">final</span> b=<span class="number">3</span>.<span class="number">903263</span></span><br><span class="line"><span class="attribute">final</span> w=<span class="number">2</span>.<span class="number">661517</span></span><br></pre></td></tr></table></figure><p>这个与第一个单变量迭代不同的地方是：这个问题可以有多个解，所以两种方式都可以得到各自的正确解，但是第二种方式效率高，而且满足梯度下降的概念。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://colah.github.io/posts/2015-08-Backprop/">http://colah.github.io/posts/2015-08-Backprop/</a></p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-2-非线性反向传播"><a href="#2-2-非线性反向传播" class="headerlink" title="2.2 非线性反向传播"></a>2.2 非线性反向传播</h2><h3 id="2-2-1-提出问题"><a href="#2-2-1-提出问题" class="headerlink" title="2.2.1 提出问题"></a>2.2.1 提出问题</h3><p>在上面的线性例子中，我们可以发现，误差一次性地传递给了初始值 $w$ 和 $b$，即，只经过一步，直接修改 $w$ 和 $b$ 的值，就能做到误差校正。因为从它的计算图看，无论中间计算过程有多么复杂，它都是线性的，所以可以一次传到底。缺点是这种线性的组合最多只能解决线性问题，不能解决更复杂的问题。这个我们在神经网络基本原理中已经阐述过了，需要有激活函数连接两个线性单元。</p><p>下面我们看一个非线性的例子，如图2-8所示。</p><p><img src="/../imgs/image-78.png" alt="图2-8 非线性的反向传播"></p><p>其中$1&lt;x&lt;&#x3D;10,0&lt;y&lt;2.15$。假设有5个人分别代表 $x,a,b,c,y$：</p><h4 id="正向过程"><a href="#正向过程" class="headerlink" title="正向过程"></a>正向过程</h4><ol><li>第1个人，输入层，随机输入第一个 $x$ 值，$x$ 的取值范围 $(1,10]$，假设第一个数是 $2$；</li><li>第2个人，第一层网络计算，接收第1个人传入 $x$ 的值，计算：$a&#x3D;x^2$；</li><li>第3个人，第二层网络计算，接收第2个人传入 $a$ 的值，计算：$b&#x3D;\ln (a)$；</li><li>第4个人，第三层网络计算，接收第3个人传入 $b$ 的值，计算：$c&#x3D;\sqrt{b}$；</li><li>第5个人，输出层，接收第4个人传入 $c$ 的值</li></ol><h4 id="反向过程"><a href="#反向过程" class="headerlink" title="反向过程"></a>反向过程</h4><ol start="6"><li>第5个人，计算 $y$ 与 $c$ 的差值：$\Delta c &#x3D; c - y$，传回给第4个人</li><li>第4个人，接收第5个人传回$\Delta c$，计算 $\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}$</li><li>第3个人，接收第4个人传回$\Delta b$，计算 $\Delta a &#x3D; \Delta b \cdot a$</li><li>第2个人，接收第3个人传回$\Delta a$，计算 $\Delta x &#x3D; \frac{\Delta}{2x}$</li><li>第1个人，接收第2个人传回$\Delta x$，更新 $x \leftarrow x - \Delta x$，回到第1步</li></ol><p>提出问题：假设我们想最后得到 $c&#x3D;2.13$ 的值，$x$ 应该是多少？（误差小于 $0.001$ 即可）</p><h3 id="2-2-2-数学解析解"><a href="#2-2-2-数学解析解" class="headerlink" title="2.2.2 数学解析解"></a>2.2.2 数学解析解</h3><p>$$<br>c&#x3D;\sqrt{b}&#x3D;\sqrt{\ln(a)}&#x3D;\sqrt{\ln(x^2)}&#x3D;2.13<br>$$</p><p>$$<br>x &#x3D; 9.6653<br>$$</p><h3 id="2-2-3-梯度迭代解"><a href="#2-2-3-梯度迭代解" class="headerlink" title="2.2.3 梯度迭代解"></a>2.2.3 梯度迭代解</h3><p>$$<br>\frac{da}{dx}&#x3D;\frac{d(x^2)}{dx}&#x3D;2x&#x3D;\frac{\Delta a}{\Delta x} \tag{1}<br>$$</p><p>$$<br>\frac{db}{da} &#x3D;\frac{d(\ln{a})}{da} &#x3D;\frac{1}{a} &#x3D; \frac{\Delta b}{\Delta a} \tag{2}<br>$$</p><p>$$<br>\frac{dc}{db}&#x3D;\frac{d(\sqrt{b})}{db}&#x3D;\frac{1}{2\sqrt{b}}&#x3D;\frac{\Delta c}{\Delta b} \tag{3}<br>$$</p><p>因此得到如下一组公式，可以把最后一层 $\Delta c$ 的误差一直反向传播给最前面的 $\Delta x$，从而更新 $x$ 值：</p><p>$$<br>\Delta c &#x3D; c - y \tag{4}<br>$$</p><p>根据式3</p><p>$$<br>\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}<br>$$</p><p>根据式2</p><p>$$<br>\Delta a &#x3D; \Delta b \cdot a<br>$$</p><p>根据式1</p><p>$$<br>\Delta x &#x3D; \Delta a &#x2F; 2x<br>$$</p><p>我们给定初始值 $x&#x3D;2$，$\Delta x&#x3D;0$，依次计算结果如表2-2。</p><p>表2-2 正向与反向的迭代计算</p><table><thead><tr><th>方向</th><th>公式</th><th>迭代1</th><th>迭代2</th><th>迭代3</th><th>迭代4</th><th>迭代5</th></tr></thead><tbody><tr><td>正向</td><td>$x&#x3D;x-\Delta x$</td><td>2</td><td>4.243</td><td>7.344</td><td>9.295</td><td>9.665</td></tr><tr><td>正向</td><td>$a&#x3D;x^2$</td><td>4</td><td>18.005</td><td>53.934</td><td>86.404</td><td>93.233</td></tr><tr><td>正向</td><td>$b&#x3D;\ln(a)$</td><td>1.386</td><td>2.891</td><td>3.988</td><td>4.459</td><td>4.535</td></tr><tr><td>正向</td><td>$c&#x3D;\sqrt{b}$</td><td>1.177</td><td>1.700</td><td>1.997</td><td>2.112</td><td>2.129</td></tr><tr><td></td><td>标签值y</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td><td>2.13</td></tr><tr><td>反向</td><td>$\Delta c &#x3D; c - y$</td><td>-0.953</td><td>-0.430</td><td>-0.133</td><td>-0.018</td><td></td></tr><tr><td>反向</td><td>$\Delta b &#x3D; \Delta c \cdot 2\sqrt{b}$</td><td>-2.243</td><td>-1.462</td><td>-0.531</td><td>-0.078</td><td></td></tr><tr><td>反向</td><td>$\Delta a &#x3D; \Delta b \cdot a$</td><td>-8.973</td><td>-26.317</td><td>-28.662</td><td>-6.698</td><td></td></tr><tr><td>反向</td><td>$\Delta x &#x3D; \Delta a &#x2F; 2x$</td><td>-2.243</td><td>-3.101</td><td>-1.951</td><td>-0.360</td><td></td></tr></tbody></table><p>表2-2，先看“迭代-1”列，从上到下是一个完整的正向+反向的过程，最后一行是 $-2.243$，回到“迭代-2”列的第一行，$2-(-2.243)&#x3D;4.243$，然后继续向下。到第5轮时，正向计算得到的 $c&#x3D;2.129$，非常接近 $2.13$ 了，迭代结束。</p><p>运行示例代码可以得到如下结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">how <span class="keyword">to</span> play: 1) input x, 2) calculate c, 3) input target number but <span class="keyword">not</span> faraway <span class="keyword">from</span> c</span><br><span class="line">input x as initial number(1.2,10), you can try 1.3:</span><br><span class="line">2</span><br><span class="line"><span class="attribute">c</span>=1.177410</span><br><span class="line">input y as target number(0.5,2), you can try 1.8:</span><br><span class="line">2.13</span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=2.000000,a=4.000000,b=1.386294,c=1.177410</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">delta_c</span>=-0.952590, <span class="attribute">delta_b</span>=-2.243178, <span class="attribute">delta_a</span>=-8.972712, <span class="attribute">delta_x</span>=-2.243178</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">forward<span class="built_in">..</span>.</span><br><span class="line"><span class="attribute">x</span>=9.655706,a=93.232666,b=4.535098,c=2.129577</span><br><span class="line">backward<span class="built_in">..</span>.</span><br><span class="line">done!</span><br></pre></td></tr></table></figure><p>为节省篇幅只列出了第一步和最后一步（第5步）的结果，第一步时<code>c=1.177410</code>，最后一步时<code>c=2.129577</code>，停止迭代。</p><!--Copyright © Microsoft Corporation. All rights reserved.  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--><h2 id="2-3-梯度下降"><a href="#2-3-梯度下降" class="headerlink" title="2.3 梯度下降"></a>2.3 梯度下降</h2><h3 id="2-3-1-从自然现象中理解梯度下降"><a href="#2-3-1-从自然现象中理解梯度下降" class="headerlink" title="2.3.1 从自然现象中理解梯度下降"></a>2.3.1 从自然现象中理解梯度下降</h3><p>在大多数文章中，都以“一个人被困在山上，需要迅速下到谷底”来举例，这个人会“寻找当前所处位置最陡峭的地方向下走”。这个例子中忽略了安全因素，这个人不可能沿着最陡峭的方向走，要考虑坡度。</p><p>在自然界中，梯度下降的最好例子，就是泉水下山的过程：</p><ol><li>水受重力影响，会在当前位置，沿着最陡峭的方向流动，有时会形成瀑布（梯度下降）；</li><li>水流下山的路径不是唯一的，在同一个地点，有可能有多个位置具有同样的陡峭程度，而造成了分流（可以得到多个解）；</li><li>遇到坑洼地区，有可能形成湖泊，而终止下山过程（不能得到全局最优解，而是局部最优解）。</li></ol><h3 id="2-3-2-梯度下降的数学理解"><a href="#2-3-2-梯度下降的数学理解" class="headerlink" title="2.3.2 梯度下降的数学理解"></a>2.3.2 梯度下降的数学理解</h3><p>梯度下降的数学公式：</p><p>$$\theta_{n+1} &#x3D; \theta_{n} - \eta \cdot \nabla J(\theta) \tag{1}$$</p><p>其中：</p><ul><li>$\theta_{n+1}$：下一个值；</li><li>$\theta_n$：当前值；</li><li>$-$：减号，梯度的反向；</li><li>$\eta$：学习率或步长，控制每一步走的距离，不要太快以免错过了最佳景点，不要太慢以免时间太长；</li><li>$\nabla$：梯度，函数当前位置的最快上升点；</li><li>$J(\theta)$：函数。</li></ul><h4 id="梯度下降的三要素"><a href="#梯度下降的三要素" class="headerlink" title="梯度下降的三要素"></a>梯度下降的三要素</h4><ol><li>当前点；</li><li>方向；</li><li>步长。</li></ol><h4 id="为什么说是“梯度下降”？"><a href="#为什么说是“梯度下降”？" class="headerlink" title="为什么说是“梯度下降”？"></a>为什么说是“梯度下降”？</h4><p>“梯度下降”包含了两层含义：</p><ol><li>梯度：函数当前位置的最快上升点；</li><li>下降：与导数相反的方向，用数学语言描述就是那个减号。</li></ol><p>亦即与上升相反的方向运动，就是下降。</p><p><img src="/../imgs/image-79.png" alt="图2-9 梯度下降的步骤"></p><p>图2-9解释了在函数极值点的两侧做梯度下降的计算过程，梯度下降的目的就是使得x值向极值点逼近。</p><h3 id="2-3-3-单变量函数的梯度下降"><a href="#2-3-3-单变量函数的梯度下降" class="headerlink" title="2.3.3 单变量函数的梯度下降"></a>2.3.3 单变量函数的梯度下降</h3><p>假设一个单变量函数：</p><p>$$J(x) &#x3D; x ^2$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$$J’(x) &#x3D; 2x$$</p><p>假设初始位置为：</p><p>$$x_0&#x3D;1.2$$</p><p>假设学习率：</p><p>$$\eta &#x3D; 0.3$$</p><p>根据公式(1)，迭代公式：</p><p>$$x_{n+1} &#x3D; x_{n} - \eta \cdot \nabla J(x)&#x3D; x_{n} - \eta \cdot 2x$$</p><p>假设终止条件为 $J(x)&lt;0.01$，迭代过程是：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">480000</span>, y=<span class="number">0</span>.<span class="number">230400</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">192000</span>, y=<span class="number">0</span>.<span class="number">036864</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">076800</span>, y=<span class="number">0</span>.<span class="number">005898</span></span><br><span class="line"><span class="attribute">x</span>=<span class="number">0</span>.<span class="number">030720</span>, y=<span class="number">0</span>.<span class="number">000944</span></span><br></pre></td></tr></table></figure><p>上面的过程如图2-10所示。</p><p><img src="/../imgs/image-80.png" alt="图2-10 使用梯度下降法迭代的过程"></p><h3 id="2-3-4-双变量的梯度下降"><a href="#2-3-4-双变量的梯度下降" class="headerlink" title="2.3.4 双变量的梯度下降"></a>2.3.4 双变量的梯度下降</h3><p>假设一个双变量函数：</p><p>$$J(x,y) &#x3D; x^2 + \sin^2(y)$$</p><p>我们的目的是找到该函数的最小值，于是计算其微分：</p><p>$${\partial{J(x,y)} \over \partial{x}} &#x3D; 2x$$<br>$${\partial{J(x,y)} \over \partial{y}} &#x3D; 2 \sin y \cos y$$</p><p>假设初始位置为：</p><p>$$(x_0,y_0)&#x3D;(3,1)$$</p><p>假设学习率：</p><p>$$\eta &#x3D; 0.1$$</p><p>根据公式(1)，迭代过程是的计算公式：</p><p>$$<br>(x_{n+1},y_{n+1}) &#x3D; (x_n,y_n) - \eta \cdot \nabla J(x,y)<br>$$</p><p>$$<br> &#x3D; (x_n,y_n) - \eta \cdot (2x,2 \cdot \sin y \cdot \cos y) \tag{1}<br>$$</p><p>根据公式(1)，假设终止条件为 $J(x,y)&lt;0.01$，迭代过程如表2-3所示。</p><p>表2-3 双变量梯度下降的迭代过程</p><table><thead><tr><th>迭代次数</th><th>x</th><th>y</th><th>J(x,y)</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>1</td><td>9.708073</td></tr><tr><td>2</td><td>2.4</td><td>0.909070</td><td>6.382415</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>15</td><td>0.105553</td><td>0.063481</td><td>0.015166</td></tr><tr><td>16</td><td>0.084442</td><td>0.050819</td><td>0.009711</td></tr></tbody></table><p>迭代16次后，$J(x,y)$ 的值为 $0.009711$，满足小于 $0.01$ 的条件，停止迭代。</p><p>上面的过程如表2-4所示，由于是双变量，所以需要用三维图来解释。请注意看两张图中间那条隐隐的黑色线，表示梯度下降的过程，从红色的高地一直沿着坡度向下走，直到蓝色的洼地。</p><p>表2-4 在三维空间内的梯度下降过程</p><p><img src="/../imgs/image-81.png"></p><h3 id="2-3-5-学习率η的选择"><a href="#2-3-5-学习率η的选择" class="headerlink" title="2.3.5 学习率η的选择"></a>2.3.5 学习率η的选择</h3><p>在公式表达时，学习率被表示为$\eta$。在代码里，我们把学习率定义为<code>learning_rate</code>，或者<code>eta</code>。针对上面的例子，试验不同的学习率对迭代情况的影响，如表2-5所示。</p><p>表2-5 不同学习率对迭代情况的影响</p><p><img src="/../imgs/image-83.png"></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNet</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Neural Network class</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, eta</span>):</span><br><span class="line">        self.eta = eta</span><br><span class="line">        self.w = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向计算</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        z = self.w * x + self.b</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__backward</span>(<span class="params">self, x, y, z</span>):</span><br><span class="line">        dz = z - y  <span class="comment"># dz 表示预测值 z 和真实值 y 之间的误差</span></span><br><span class="line">        db = dz <span class="comment"># 因为偏置项 b 对于每个输入样本 x 都是相同的，所以误差 dz 直接反映了偏置项 b 的更新量。因此，db = dz 表示偏置项 b 的梯度（即偏导数）等于误差 dz。</span></span><br><span class="line">        dw = x * dz <span class="comment"># 损失函数对w求梯度（偏导数），损失函数为均方误差，所以损失函数对w求导，即dw = x * dz</span></span><br><span class="line">        <span class="keyword">return</span> dw, db</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 梯度更新</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__update</span>(<span class="params">self, dw, db</span>):</span><br><span class="line">        self.w = self.w - self.eta * dw</span><br><span class="line">        self.b = self.b - self.eta * db</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, dataReader</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(dataReader.num_train_data):</span><br><span class="line">            x, y = dataReader.get_train_data(i)  <span class="comment"># 获取第i个训练样本</span></span><br><span class="line">            z = self.__forward(x)  <span class="comment"># 前向计算得到z</span></span><br><span class="line">            dw, db = self.__backward(x, y, z) <span class="comment"># 反向传播得到dw和db</span></span><br><span class="line">            self.__update(dw, db) <span class="comment"># 更新参数w和b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inference</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__forward(x)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!--Copyright © Microsoft Corporation. All rights reserved.
  适用于[License](https://github.com/Microsoft/ai-edu/blob/master/LICENSE.md)版权许可--</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-异步接口调用</title>
    <link href="https://kelinkong.github.io/2024/12/17/Java-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/12/17/Java-%E5%BC%82%E6%AD%A5%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</id>
    <published>2024-12-17T11:16:30.000Z</published>
    <updated>2024-12-24T03:02:38.305Z</updated>
    
    <content type="html"><![CDATA[<p>当<strong>异步方法</strong>提供服务时，调用方通常需要一种机制来<strong>知道异步方法什么时候返回结果</strong>以及<strong>是否执行成功</strong>。在 <strong>Spring Boot</strong> 中，这可以通过返回 <code>Future</code>、<code>CompletableFuture</code> 或使用回调机制来实现。</p><h2 id="1-使用-Future-接口"><a href="#1-使用-Future-接口" class="headerlink" title="1. 使用 Future 接口"></a><strong>1. 使用 <code>Future</code> 接口</strong></h2><p><code>@Async</code> 方法可以返回一个 <code>Future</code> 对象，调用方可以通过 <code>Future</code> 的方法查询执行状态和结果。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;String&gt; <span class="title function_">asyncMethodWithFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.failedFuture(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例"><a href="#调用方示例" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testAsync&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testAsync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Future&lt;String&gt; result = myService.asyncMethodWithFuture();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!result.isDone()) &#123; <span class="comment">// 轮询检查是否完成</span></span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;异步方法未完成...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result.get(); <span class="comment">// 获取结果，阻塞直到异步任务完成</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;异步调用失败：&quot;</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ol><li><code>Future</code> 提供方法如：<ul><li><code>isDone()</code>：检查任务是否完成。</li><li><code>get()</code>：获取结果（会阻塞当前线程，直到任务完成）。</li></ul></li><li>调用方可以轮询 <code>isDone()</code> 判断异步方法的状态。</li></ol><p><strong>缺点</strong>：轮询消耗资源，且 <code>get()</code> 方法是<strong>阻塞</strong>的，不够高效。</p><hr><h2 id="2-使用-CompletableFuture"><a href="#2-使用-CompletableFuture" class="headerlink" title="2. 使用 CompletableFuture"></a><strong>2. 使用 <code>CompletableFuture</code></strong></h2><p><code>CompletableFuture</code> 提供更灵活的非阻塞异步处理，支持链式操作和回调。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">asyncMethodWithCompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.failedFuture(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例-1"><a href="#调用方示例-1" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testCompletableFuture&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">testCompletableFuture</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> myService.asyncMethodWithCompletableFuture()</span><br><span class="line">                .thenApply(result -&gt; <span class="string">&quot;异步任务返回结果：&quot;</span> + result)</span><br><span class="line">                .exceptionally(ex -&gt; <span class="string">&quot;异步任务失败：&quot;</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ol><li><strong>非阻塞</strong>：调用方无需等待，可以直接返回 <code>CompletableFuture</code> 供调用方使用。</li><li><code>thenApply</code>：任务成功时执行的回调操作。</li><li><code>exceptionally</code>：任务失败时的回调处理。</li></ol><p><strong>优点</strong>：</p><ul><li>支持链式调用，代码清晰。</li><li>无需主动轮询，任务完成时自动触发回调。</li></ul><hr><h2 id="3-使用回调机制"><a href="#3-使用回调机制" class="headerlink" title="3. 使用回调机制"></a><strong>3. 使用回调机制</strong></h2><p>如果你不想依赖 <code>Future</code> 或 <code>CompletableFuture</code>，可以手动实现回调逻辑，通过 <strong>自定义回调接口</strong> 来通知调用方。</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethodWithCallback</span><span class="params">(Callback callback)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>); <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            callback.onSuccess(<span class="string">&quot;异步方法执行成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            callback.onFailure(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用方示例-2"><a href="#调用方示例-2" class="headerlink" title="调用方示例"></a><strong>调用方示例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testCallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testCallback</span><span class="params">()</span> &#123;</span><br><span class="line">        myService.asyncMethodWithCallback(<span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String result)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;回调成功：&quot;</span> + result);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;回调失败：&quot;</span> + t.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;异步方法已触发，等待回调结果...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a><strong>结果分析</strong></h3><ul><li><code>Callback</code> 接口定义了成功和失败时的回调方法。</li><li>异步任务执行后，通过回调接口通知调用方结果。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>方法</th><th>特点</th><th>是否阻塞</th><th>适用场景</th></tr></thead><tbody><tr><td><code>Future</code></td><td>简单轮询和阻塞获取结果</td><td>阻塞</td><td>小型任务，简单异步</td></tr><tr><td><code>CompletableFuture</code></td><td>支持链式调用、非阻塞和回调</td><td>非阻塞</td><td>高性能异步处理</td></tr><tr><td>自定义回调接口</td><td>完全自定义回调逻辑</td><td>非阻塞</td><td>灵活控制回调和通知</td></tr></tbody></table><p><strong>推荐</strong>：使用 <code>CompletableFuture</code>，它功能强大、非阻塞，并且易于维护和扩展。</p><h2 id="异步编程-多并发示例"><a href="#异步编程-多并发示例" class="headerlink" title="异步编程+多并发示例"></a>异步编程+多并发示例</h2><p>为了确保外系统调用接口 A 时不会因接口 B 的处理耗时而超时，可以设计接口 A 为 <strong>异步返回机制</strong>，即外系统调用接口 A 时，接口 A 立即返回一个请求 ID，随后在后台完成调用接口 B 的多次处理任务，外系统可以通过请求 ID 查询最终结果。</p><p>假设我现在有一个接口A，调用了接口B，但是接口B每次需要耗时20s左右才能处理完成，且我需要多次调用接口B，但是我又不能大规模并发的调用接口B（有并发数限制），我的接口A和B都是一个微应用接口，现在我需要把微应用接口A暴露给外系统调用，我要如何高效实现？</p><p>以下是基于已有线程池的实现方案：</p><hr><h3 id="解决方案：立即响应，异步处理"><a href="#解决方案：立即响应，异步处理" class="headerlink" title="解决方案：立即响应，异步处理"></a><strong>解决方案：立即响应，异步处理</strong></h3><ol><li><p><strong>外部接口 A 的处理逻辑：</strong></p><ul><li>接收外部请求。</li><li>立即生成一个唯一请求 ID，并存储初始状态。</li><li>使用线程池异步处理任务。</li><li>立即返回请求 ID。</li></ul></li><li><p><strong>后台任务逻辑：</strong></p><ul><li>在线程池中分解任务。</li><li>按并发限制逐个调用接口 B。</li><li>将结果存储到缓存或数据库中。</li></ul></li><li><p><strong>结果查询接口：</strong></p><ul><li>外系统通过查询接口，使用请求 ID 检索处理结果。</li></ul></li></ol><hr><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a><strong>实现步骤</strong></h3><h4 id="1-定义接口-A"><a href="#1-定义接口-A" class="headerlink" title="1. 定义接口 A"></a><strong>1. 定义接口 A</strong></h4><p>通过线程池异步处理任务，立即返回请求 ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceAController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService; <span class="comment">// 现有线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>); <span class="comment">// 并发限制</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; results = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(); <span class="comment">// 模拟存储结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数注入线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InterfaceAController</span><span class="params">(ExecutorService executorService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">processRequest</span><span class="params">(<span class="meta">@RequestBody</span> RequestData requestData)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString(); <span class="comment">// 生成唯一请求 ID</span></span><br><span class="line">        results.put(requestId, <span class="string">&quot;Processing&quot;</span>); <span class="comment">// 初始化状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步处理任务</span></span><br><span class="line">        executorService.submit(() -&gt; handleRequest(requestId, requestData));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 立即返回请求 ID</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(requestId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(String requestId, RequestData requestData)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; tasks = requestData.getSubTasks(); <span class="comment">// 分解请求</span></span><br><span class="line">            List&lt;String&gt; taskResults = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (String task : tasks) &#123;</span><br><span class="line">                semaphore.acquire(); <span class="comment">// 控制并发数</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> callInterfaceB(task); <span class="comment">// 调用接口 B</span></span><br><span class="line">                    taskResults.add(result);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release(); <span class="comment">// 释放许可</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 合并结果并存储</span></span><br><span class="line">            results.put(requestId, String.join(<span class="string">&quot;, &quot;</span>, taskResults));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            results.put(requestId, <span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">callInterfaceB</span><span class="params">(String task)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 模拟接口 B 的调用</span></span><br><span class="line">        Thread.sleep(<span class="number">20000</span>); <span class="comment">// 假设接口 B 耗时 20 秒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Processed &quot;</span> + task;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/result/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">getResult</span><span class="params">(<span class="meta">@PathVariable</span> String id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> results.get(id);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.NOT_FOUND).body(<span class="string">&quot;Result not found&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;Processing&quot;</span>.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseEntity.status(HttpStatus.PROCESSING).body(<span class="string">&quot;Still processing&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-外系统调用流程"><a href="#2-外系统调用流程" class="headerlink" title="2. 外系统调用流程"></a><strong>2. 外系统调用流程</strong></h3><ol><li><p>调用 <code>/api/process</code>：</p><ul><li><strong>请求：</strong>发送业务数据。</li><li><strong>响应：</strong>立即返回一个唯一的请求 ID。</li></ul></li><li><p>调用 <code>/api/result/&#123;id&#125;</code>：</p><ul><li><strong>请求：</strong>查询对应请求 ID 的处理结果。</li><li><strong>响应：</strong><ul><li>如果结果尚未处理完成，返回状态码 <code>HTTP 102 Processing</code>。</li><li>如果处理完成，返回最终结果。</li></ul></li></ul></li></ol><hr><h3 id="3-优化与增强"><a href="#3-优化与增强" class="headerlink" title="3. 优化与增强"></a><strong>3. 优化与增强</strong></h3><h4 id="结果存储"><a href="#结果存储" class="headerlink" title="结果存储"></a><strong>结果存储</strong></h4><ul><li>如果任务结果较大，建议存储到 Redis 或数据库中，以减少内存压力。</li></ul><h4 id="结果通知"><a href="#结果通知" class="headerlink" title="结果通知"></a><strong>结果通知</strong></h4><ul><li>除轮询机制外，可以提供<strong>回调机制</strong>，通知外系统任务完成。</li><li>例如，外系统调用接口 A 时提供回调 URL，任务完成后主动通知：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyExternalSystem</span><span class="params">(String callbackUrl, String result)</span> &#123;</span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    restTemplate.postForEntity(callbackUrl, result, String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="超时监控"><a href="#超时监控" class="headerlink" title="超时监控"></a><strong>超时监控</strong></h4><ul><li>为每个任务设置超时时间，确保长时间未完成的任务能正确标记为失败。</li></ul><h4 id="负载调控"><a href="#负载调控" class="headerlink" title="负载调控"></a><strong>负载调控</strong></h4><ul><li>如果任务量较大，可结合消息队列（如 Kafka）进一步解耦任务提交和处理。</li></ul><hr><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h3><ol><li><strong>外系统不超时：</strong>接口 A 立即响应，外系统只需查询结果或接收回调。</li><li><strong>高效调用接口 B：</strong>通过线程池和信号量控制并发，避免超出接口 B 的限制。</li><li><strong>扩展性好：</strong>可通过增加线程池大小或优化队列管理提升性能。</li></ol><hr><h3 id="完整调用示例"><a href="#完整调用示例" class="headerlink" title="完整调用示例"></a><strong>完整调用示例</strong></h3><ol><li><p>外系统调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d <span class="string">&#x27;&#123;&quot;subTasks&quot;: [&quot;task1&quot;, &quot;task2&quot;]&#125;&#x27;</span> http://localhost:8080/api/process</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;requestId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abcd1234&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>查询结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:8080/api/result/abcd1234</span><br></pre></td></tr></table></figure><ul><li>如果正在处理中：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Processing&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li>如果处理完成：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Completed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Processed task1, Processed task2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>Java并发编程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YourService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建固定大小为 5 的线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">YourService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executorService = Executors.newFixedThreadPool(<span class="number">5</span>);  <span class="comment">// 设置最大并发数为 5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processConcurrently</span><span class="params">(List&lt;String&gt; prompts, User user, List&lt;QuestionGenerationContext&gt; questionsContext, Vo vo)</span> &#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;Void&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prompts.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 使用 CompletableFuture 结合线程池来并发执行任务</span></span><br><span class="line">            CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 调用 send 方法</span></span><br><span class="line">                LinkedHashMap&lt;String, String&gt; response = send(prompts.get(index), user);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 格式化结果</span></span><br><span class="line">                List&lt;QuestionGeneration&gt; questions = QuestionGenerationUtil.formartText(response, questionsContext.get(index));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程安全地加入 vo</span></span><br><span class="line">                <span class="keyword">synchronized</span> (vo) &#123;</span><br><span class="line">                    vo.addQuestions(questions);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, executorService);</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有任务完成</span></span><br><span class="line">        CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).join();</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LinkedHashMap&lt;String, String&gt; <span class="title function_">send</span><span class="params">(String prompt, User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟 send 请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个长期运行的接口，如果调用关闭线程池，那么接下来就会拒绝服务。解决方法：</p><ol><li>全局线程池，避免每一个接口都创建一个线程池。</li><li>在接口调用时去创建一个线程池，然后调用完接口后关闭（不推荐）。</li></ol><h2 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">executor.setCorePoolSize(<span class="number">5</span>);  <span class="comment">// 设置核心线程池大小</span></span><br><span class="line">executor.setMaxPoolSize(<span class="number">10</span>);  <span class="comment">// 设置最大线程池大小</span></span><br><span class="line">executor.setQueueCapacity(<span class="number">25</span>);  <span class="comment">// 设置任务队列的容量</span></span><br><span class="line">executor.setThreadNamePrefix(<span class="string">&quot;custom-thread-&quot;</span>);  <span class="comment">// 设置线程名前缀</span></span><br><span class="line">executor.initialize();  <span class="comment">// 初始化线程池</span></span><br></pre></td></tr></table></figure><p><code>ThreadPoolTaskExecutor</code>（以及其他线程池实现，如 <code>ThreadPoolExecutor</code>）提供了以下三项核心配置：<strong>核心线程池大小（core pool size）</strong>、<strong>最大线程池大小（maximum pool size）</strong> 和 <strong>任务队列容量（queue capacity）</strong>。这三者共同决定了线程池的行为、任务的调度方式以及线程池的资源使用情况。</p><p>让我们逐一解释它们的作用：</p><h3 id="1-核心线程池大小（Core-Pool-Size）："><a href="#1-核心线程池大小（Core-Pool-Size）：" class="headerlink" title="1. 核心线程池大小（Core Pool Size）："></a>1. <strong>核心线程池大小（Core Pool Size）</strong>：</h3><ul><li><strong>作用</strong>：核心线程池大小指定了线程池中始终保持的最小线程数。这些核心线程会在没有任务可执行时持续存活，直到线程池被关闭。即使线程池中的线程没有正在执行的任务，它们也不会被销毁，直到线程池关闭或线程池中的任务完全完成。</li><li><strong>默认行为</strong>：线程池会尽可能维持这些核心线程，不会因为任务队列为空而减少到小于 <code>corePoolSize</code> 的数量。</li><li><strong>影响</strong>：如果你的应用有一定的并发需求并且需要快速响应任务，可以增加核心线程池的大小。否则，默认的大小可能已经足够。</li></ul>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.setCorePoolSize(<span class="number">5</span>);  <span class="comment">// 核心线程数为5</span></span><br></pre></td></tr></table></figure><h3 id="2-最大线程池大小（Maximum-Pool-Size）："><a href="#2-最大线程池大小（Maximum-Pool-Size）：" class="headerlink" title="2. 最大线程池大小（Maximum Pool Size）："></a>2. <strong>最大线程池大小（Maximum Pool Size）</strong>：</h3><ul><li><strong>作用</strong>：最大线程池大小指定了线程池中最多可以同时容纳多少线程。当任务数超过核心线程池大小，并且队列已满时，线程池会创建更多的线程来处理任务，但总线程数不会超过 <code>maximumPoolSize</code>。</li><li><strong>默认行为</strong>：如果没有设置最大线程池大小，线程池的最大线程数默认为 <code>Integer.MAX_VALUE</code>，这意味着它可以根据系统资源随时增加线程数，直到达到系统限制。</li><li><strong>影响</strong>：通过设置 <code>maximumPoolSize</code>，你可以控制线程池的最大并发数，避免线程池消耗过多系统资源。</li></ul>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.setMaxPoolSize(<span class="number">10</span>);  <span class="comment">// 最大线程数为10</span></span><br></pre></td></tr></table></figure><h3 id="3-任务队列容量（Queue-Capacity）："><a href="#3-任务队列容量（Queue-Capacity）：" class="headerlink" title="3. 任务队列容量（Queue Capacity）："></a>3. <strong>任务队列容量（Queue Capacity）</strong>：</h3><ul><li><strong>作用</strong>：任务队列用于存储等待执行的任务。当线程池的核心线程池处于满负荷状态时，新的任务会被放入队列中等待执行。队列的容量决定了能存储多少个等待任务。</li><li><strong>默认行为</strong>：如果没有设置队列容量，通常线程池使用的是一个 <strong>无界队列</strong>（<code>LinkedBlockingQueue</code>），这意味着队列容量几乎是无限的，所有等待的任务会被排入队列直到有线程空闲。如果队列有界（有限容量），则会导致任务被拒绝执行（例如，抛出 <code>RejectedExecutionException</code>）。</li><li><strong>影响</strong>：通过设置 <code>queueCapacity</code>，你可以控制任务队列的大小。当队列满了且没有空闲线程时，新的任务会被拒绝，或者在有界队列时，会创建新线程直到达到 <code>maximumPoolSize</code>。</li></ul>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.setQueueCapacity(<span class="number">25</span>);  <span class="comment">// 任务队列容量为25</span></span><br></pre></td></tr></table></figure><h3 id="线程池行为总结："><a href="#线程池行为总结：" class="headerlink" title="线程池行为总结："></a>线程池行为总结：</h3><ul><li><strong>当有任务到达时</strong>，线程池首先会尝试使用核心线程池中的线程来处理任务。如果核心线程池中的线程都在忙，且队列未满，那么任务会被放入队列等待执行。</li><li><strong>当队列已满</strong>，如果线程池的线程数还没有达到最大线程数，线程池会创建新的线程来处理任务。此时，线程池的线程数会增大，但不会超过 <code>maximumPoolSize</code>。</li><li><strong>当线程池达到最大线程数且队列已满时</strong>，新的任务会被拒绝执行，除非你配置了拒绝策略来处理这些任务（如 <code>AbortPolicy</code>, <code>CallerRunsPolicy</code> 等）。</li></ul><h3 id="典型的线程池配置："><a href="#典型的线程池配置：" class="headerlink" title="典型的线程池配置："></a>典型的线程池配置：</h3><ul><li><strong>核心线程池大小</strong>：适合处理常规并发任务的最小线程数。</li><li><strong>最大线程池大小</strong>：适合应对任务爆发期或高并发的最大线程数。</li><li><strong>任务队列容量</strong>：决定了线程池如何排队等待任务执行。根据应用的需求，队列可以选择有界或无界，具体取决于任务的性质。</li></ul><h3 id="示例配置的具体作用："><a href="#示例配置的具体作用：" class="headerlink" title="示例配置的具体作用："></a>示例配置的具体作用：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">executor.setCorePoolSize(<span class="number">5</span>);  <span class="comment">// 最小线程数为 5</span></span><br><span class="line">executor.setMaxPoolSize(<span class="number">10</span>);  <span class="comment">// 最大线程数为 10</span></span><br><span class="line">executor.setQueueCapacity(<span class="number">25</span>);  <span class="comment">// 队列容量为 25</span></span><br></pre></td></tr></table></figure><ul><li>线程池最开始会有 5 个线程（核心线程数）。如果有更多的任务到达，而没有线程可用，它会将任务放入队列中等待执行。</li><li>当队列中的任务满了（队列最大容量为 25），线程池会新增线程来处理任务，但线程池的最大线程数不能超过 10。</li><li>如果任务数超过了最大线程数，且队列也已满，新的任务将会被拒绝（除非你配置了拒绝策略）。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>核心线程池大小</strong>：控制最小线程数，任务会先被这些线程处理。</li><li><strong>最大线程池大小</strong>：控制最大线程数，超出这个数量的任务会等待或被拒绝。</li><li><strong>任务队列容量</strong>：决定任务等待队列的大小，当线程池的核心线程都在工作且队列满时，线程池才会创建新线程。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当&lt;strong&gt;异步方法&lt;/strong&gt;提供服务时，调用方通常需要一种机制来&lt;strong&gt;知道异步方法什么时候返回结果&lt;/strong&gt;以及&lt;strong&gt;是否执行成功&lt;/strong&gt;。在 &lt;strong&gt;Spring Boot&lt;/strong&gt; 中，这可以通过返回</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>前端-expo</title>
    <link href="https://kelinkong.github.io/2024/11/22/%E5%89%8D%E7%AB%AF-expo/"/>
    <id>https://kelinkong.github.io/2024/11/22/%E5%89%8D%E7%AB%AF-expo/</id>
    <published>2024-11-22T03:38:47.000Z</published>
    <updated>2025-04-29T02:12:52.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="expo是什么？"><a href="#expo是什么？" class="headerlink" title="expo是什么？"></a>expo是什么？</h2><p>Expo 是一个用于构建原生应用的工具集合，它提供了一组工具和框架，用于开发跨平台应用。Expo 提供了简化原生应用的开发过程的工具，如自动构建和发布，以及集成各种第三方库。</p><h3 id="Expo-的介绍"><a href="#Expo-的介绍" class="headerlink" title="Expo 的介绍"></a><strong>Expo 的介绍</strong></h3><p>Expo 是一个用于构建 React Native 应用的工具链，提供了一种快速搭建、开发、测试和发布移动应用的方法。它简化了 React Native 开发流程，使开发者可以更专注于业务逻辑，而无需担心底层的原生配置。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><strong>易用性</strong>：快速启动，无需配置复杂的环境。</li><li><strong>跨平台支持</strong>：一次开发，适配 iOS 和 Android。</li><li><strong>丰富的 API</strong>：内置支持摄像头、位置、通知等原生功能。</li><li><strong>强大的工具链</strong>：<ul><li><strong>Expo Go</strong>：一个移动应用，用于实时查看开发中的项目。</li><li><strong>Expo CLI</strong>：命令行工具，管理项目的开发、打包和部署。</li></ul></li><li><strong>托管服务</strong>：提供打包、发布和更新服务。</li></ol><hr><h3 id="Expo-的安装"><a href="#Expo-的安装" class="headerlink" title="Expo 的安装"></a><strong>Expo 的安装</strong></h3><p>Expo 的安装分为工具安装和项目初始化。</p><h4 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a><strong>前置要求</strong></h4><ol><li><strong>Node.js</strong>：安装最新的 LTS 版本（推荐使用 <a href="https://github.com/nvm-sh/nvm">nvm</a> 管理 Node.js）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v    <span class="comment"># 检查 Node.js 版本</span></span><br></pre></td></tr></table></figure></li><li><strong>npm 或 yarn</strong>：Node.js 安装后会自带 <code>npm</code>，也可以选择安装 <code>yarn</code>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm -v     <span class="comment"># 检查 npm 版本</span></span><br><span class="line">yarn -v    <span class="comment"># 如果使用 yarn，检查其版本</span></span><br></pre></td></tr></table></figure></li></ol><p>现在推荐通过 <code>npx expo</code> 直接执行命令，而不是全局安装 <code>expo-cli</code>。这是为了减少全局依赖，确保使用的是最新版本的 Expo 命令行工具。</p><hr><h3 id="使用-npx-expo-的流程"><a href="#使用-npx-expo-的流程" class="headerlink" title="使用 npx expo 的流程"></a><strong>使用 npx expo 的流程</strong></h3><h4 id="1-初始化项目"><a href="#1-初始化项目" class="headerlink" title="1. 初始化项目"></a><strong>1. 初始化项目</strong></h4><p>你可以直接通过 <code>npx expo</code> 命令初始化一个新的 Expo 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx expo init my-new-project</span><br></pre></td></tr></table></figure><ul><li><p><strong>选择模板</strong>：执行命令后，你可以选择以下模板之一：</p><ul><li><strong>blank</strong>：空白项目。</li><li>**blank (TypeScript)**：支持 TypeScript 的空白项目。</li><li>**tabs (TypeScript)**：带底部导航栏的 TypeScript 项目。</li></ul></li><li><p><strong>进入项目目录</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-new-project</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-启动开发服务器"><a href="#2-启动开发服务器" class="headerlink" title="2. 启动开发服务器"></a><strong>2. 启动开发服务器</strong></h4><p>在项目目录中运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx expo start</span><br></pre></td></tr></table></figure><ul><li>打开浏览器后，你会看到一个开发面板：<ul><li><strong>二维码</strong>：可以用手机上的 <strong>Expo Go</strong> 应用扫描来查看项目。</li><li><strong>选择平台</strong>：可以选择在 iOS 模拟器、Android 模拟器或 Web 浏览器中运行。</li></ul></li></ul><hr><h4 id="3-安装依赖"><a href="#3-安装依赖" class="headerlink" title="3. 安装依赖"></a><strong>3. 安装依赖</strong></h4><p>Expo 提供了一个专用的 <code>expo install</code> 命令，用来安装与当前 Expo SDK 版本兼容的依赖。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx expo install expo-camera expo-location</span><br></pre></td></tr></table></figure><hr><h4 id="4-构建和发布应用"><a href="#4-构建和发布应用" class="headerlink" title="4. 构建和发布应用"></a><strong>4. 构建和发布应用</strong></h4><ul><li><p><strong>构建应用</strong>：</p><ul><li>使用 <code>EAS Build</code>（推荐）来构建应用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx expo install eas-cli</span><br><span class="line">npx eas build</span><br></pre></td></tr></table></figure></li><li>Expo 已不再推荐直接使用 <code>expo build</code>，因为 EAS 提供了更现代的构建方式，支持自定义原生代码。</li></ul></li><li><p><strong>发布应用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx expo publish</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="为什么推荐-npx？"><a href="#为什么推荐-npx？" class="headerlink" title="为什么推荐 npx？"></a><strong>为什么推荐 npx？</strong></h3><ol><li><strong>确保使用最新版本</strong>：通过 <code>npx expo</code>，每次执行时都会自动下载最新的命令行工具。</li><li><strong>减少全局安装依赖</strong>：无需全局安装 <code>expo-cli</code>，避免版本冲突。</li><li><strong>简单易用</strong>：直接通过项目本地的工具执行命令，无需额外配置。</li></ol><hr><h3 id="常用-npx-expo-命令"><a href="#常用-npx-expo-命令" class="headerlink" title="常用 npx expo 命令"></a><strong>常用 npx expo 命令</strong></h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>npx expo init</code></td><td>初始化一个新的 Expo 项目</td></tr><tr><td><code>npx expo start</code></td><td>启动开发服务器，支持 Web 和移动设备测试</td></tr><tr><td><code>npx expo install</code></td><td>安装兼容 Expo 的依赖包</td></tr><tr><td><code>npx expo upgrade</code></td><td>升级 Expo 项目到最新版本</td></tr><tr><td><code>npx eas build</code></td><td>构建 iOS 和 Android 的生产版本</td></tr><tr><td><code>npx expo export:web</code></td><td>导出为静态 Web 应用</td></tr></tbody></table><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li>使用 <code>npx expo</code> 是当前最推荐的方式。</li><li>无需全局安装 <code>expo-cli</code>，保持工具链轻量化。</li><li>支持快速开发、调试和构建跨平台应用。</li></ul><p>如果需要详细指导，比如环境配置或特定功能开发，可以继续告诉我！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;expo是什么？&quot;&gt;&lt;a href=&quot;#expo是什么？&quot; class=&quot;headerlink&quot; title=&quot;expo是什么？&quot;&gt;&lt;/a&gt;expo是什么？&lt;/h2&gt;&lt;p&gt;Expo 是一个用于构建原生应用的工具集合，它提供了一组工具和框架，用于开发跨平台应用。Ex</summary>
      
    
    
    
    <category term="frontend" scheme="https://kelinkong.github.io/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud: 断路器</title>
    <link href="https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    <id>https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/</id>
    <published>2024-11-19T01:07:12.000Z</published>
    <updated>2024-11-19T02:15:39.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="断路器（Circuit-Breaker）简介"><a href="#断路器（Circuit-Breaker）简介" class="headerlink" title="断路器（Circuit Breaker）简介"></a>断路器（Circuit Breaker）简介</h3><p><strong>断路器</strong>是一种用于防止分布式系统中的故障扩散的机制。它借鉴了电路中的断路器原理，当某个服务出现故障或响应异常时，断路器会主动中断请求链路，避免故障传播到整个系统，保护系统的可用性和稳定性。</p><p>断路器通常在微服务架构中使用，结合服务治理框架（如 Spring Cloud Hystrix、Resilience4j 等）实现。</p><hr><h3 id="断路器的核心概念"><a href="#断路器的核心概念" class="headerlink" title="断路器的核心概念"></a>断路器的核心概念</h3><p>断路器有三种状态：<strong>关闭（Closed）</strong>、<strong>打开（Open）</strong> 和 <strong>半开（Half-Open）</strong>。</p><ol><li><p><strong>关闭状态（Closed）</strong>：</p><ul><li>默认状态，服务正常时断路器处于关闭状态。</li><li>请求直接转发到目标服务。</li><li>如果在一定时间内连续发生错误（如超时、异常等）超过预设阈值，断路器会进入<strong>打开状态</strong>。</li></ul></li><li><p><strong>打开状态（Open）</strong>：</p><ul><li>当断路器打开时，请求不再转发到目标服务，而是直接失败或返回预设的降级结果。</li><li>断路器会在打开状态维持一段时间（冷却时间），然后进入<strong>半开状态</strong>。</li></ul></li><li><p><strong>半开状态（Half-Open）</strong>：</p><ul><li>冷却时间结束后，断路器会允许少量请求通过，测试目标服务是否恢复。</li><li>如果测试请求成功率达到预期，断路器会切换回关闭状态。</li><li>如果测试请求仍然失败，则断路器重新进入打开状态。</li></ul></li></ol><hr><h3 id="断路器的作用"><a href="#断路器的作用" class="headerlink" title="断路器的作用"></a>断路器的作用</h3><ol><li><p><strong>避免级联故障</strong>：<br>当某个服务发生故障时，断路器能够切断请求，防止故障扩散到其他服务，保护系统的整体稳定性。</p></li><li><p><strong>快速失败</strong>：<br>在目标服务不可用时，断路器立即返回失败结果或降级响应，避免用户长时间等待，提高用户体验。</p></li><li><p><strong>系统保护</strong>：<br>减少对故障服务的访问压力，避免因请求积压导致服务雪崩。</p></li></ol><hr><h3 id="断路器的关键指标"><a href="#断路器的关键指标" class="headerlink" title="断路器的关键指标"></a>断路器的关键指标</h3><ol><li><p><strong>失败率</strong>：<br>一段时间内的失败请求占比。如果失败率超过阈值，断路器进入打开状态。</p></li><li><p><strong>请求数量</strong>：<br>设置触发断路器的最小请求数，确保断路器在足够的请求量下判断服务是否故障。</p></li><li><p><strong>熔断时间（冷却时间）</strong>：<br>指断路器打开后保持不再发送请求的时间，熔断时间过后进入半开状态。</p></li><li><p><strong>恢复检测</strong>：<br>在半开状态下，通过少量请求测试服务是否恢复，避免因误判直接恢复全部流量。</p></li></ol><hr><h3 id="常见断路器框架"><a href="#常见断路器框架" class="headerlink" title="常见断路器框架"></a>常见断路器框架</h3><ol><li><p><strong>Hystrix（已停止维护）</strong>：</p><ul><li>Netflix 开发，支持熔断器、线程隔离、请求缓存、请求合并等功能。</li><li>使用广泛，但因功能复杂导致性能损耗高，现已被 Resilience4j 替代。</li></ul></li><li><p><strong>Resilience4j</strong>：</p><ul><li>轻量级 Java 熔断器库，支持断路器、限流、重试、超时等功能。</li><li>性能优于 Hystrix，更适合现代微服务架构。</li></ul></li><li><p><strong>Spring Cloud Circuit Breaker</strong>：</p><ul><li>Spring 官方的断路器抽象层，支持多种断路器实现，如 Resilience4j 和 Sentinel。</li></ul></li></ol><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>微服务调用失败</strong>：<br>处理服务超时、响应错误等异常情况，防止用户请求被无限制地转发到失败服务。</p></li><li><p><strong>高并发场景</strong>：<br>在流量激增时对服务降级，保护系统核心功能。</p></li><li><p><strong>依赖外部资源</strong>：<br>调用第三方接口或外部服务时，避免对其过度依赖导致自身系统故障。</p></li></ol><hr><h3 id="断路器的优缺点"><a href="#断路器的优缺点" class="headerlink" title="断路器的优缺点"></a>断路器的优缺点</h3><p><strong>优点</strong>：</p><ul><li>防止服务雪崩。</li><li>提升系统稳定性。</li><li>提高用户体验，避免长时间等待。</li></ul><p><strong>缺点</strong>：</p><ul><li>增加系统复杂度。</li><li>需要合理设置阈值，否则可能引发误判。</li><li>引入额外的延迟（如熔断检测）。</li></ul><hr><h3 id="实现示例（使用-Resilience4j）"><a href="#实现示例（使用-Resilience4j）" class="headerlink" title="实现示例（使用 Resilience4j）"></a>实现示例（使用 Resilience4j）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;paymentFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用目标服务</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://payment-service/pay&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFallback</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Payment service is currently unavailable. Please try again later.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @CircuitBreaker 注解指定断路器名称和降级方法，当目标服务出现异常时返回降级响应。</p><hr><p>通过断路器，分布式系统可以更好地处理服务故障和性能问题，确保高可用性和用户体验。</p><p>参考文档：<a href="https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/index.md">Resilience4j</a></p><h2 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h2><p><img src="/../imgs/image-68.png"></p><p>配置断路器</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">circuitbreaker:</span> <span class="comment"># 降级熔断</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">50</span> <span class="comment"># 调用失败达到50%后打开断路器</span></span><br><span class="line">        <span class="attr">sliding-window-type:</span> <span class="string">count_based</span> <span class="comment"># 滑动窗口类型</span></span><br><span class="line">        <span class="attr">sliding-window-size:</span> <span class="number">6</span> <span class="comment"># 滑动窗口大小 count_based6个请求 time_base6秒</span></span><br><span class="line">        <span class="attr">minimum-number-of-calls:</span> <span class="number">6</span> <span class="comment"># 每个滑动窗口的周期</span></span><br><span class="line">        <span class="attr">automatic-transition-from-open-to-half-open-enabled:</span> <span class="literal">true</span> <span class="comment"># 开始过度到半开状态</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="string">5s</span> <span class="comment"># 从开启到半开启需要5s</span></span><br><span class="line">        <span class="attr">permitted-number-of-calls-in-half-open-state:</span> <span class="number">2</span> <span class="comment">#半开状态允许通过的最大请求数</span></span><br><span class="line">        <span class="attr">record-exceptions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">java.lang.Exception</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">base-config:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;断路器（Circuit-Breaker）简介&quot;&gt;&lt;a href=&quot;#断路器（Circuit-Breaker）简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud: OpenFeign</title>
    <link href="https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/"/>
    <id>https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/</id>
    <published>2024-11-14T10:18:20.000Z</published>
    <updated>2024-11-19T01:00:01.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenFeign介绍"><a href="#OpenFeign介绍" class="headerlink" title="OpenFeign介绍"></a>OpenFeign介绍</h2><p>OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 Netflix Feign，支持与 Spring Cloud 一起使用。它简化了 HTTP 服务调用的过程，可以通过定义接口来调用远程服务，而不需要手写复杂的 HTTP 请求代码。开发者只需定义接口并使用注解来配置 HTTP 请求的细节。</p><p>在 Spring Cloud 中，OpenFeign 作为微服务间通信的一个常用工具，尤其适合构建基于 REST 的微服务应用。</p><h3 id="OpenFeign-相对-RestTemplate-LoadBalanced-的优势"><a href="#OpenFeign-相对-RestTemplate-LoadBalanced-的优势" class="headerlink" title="OpenFeign 相对 RestTemplate + @LoadBalanced 的优势"></a>OpenFeign 相对 RestTemplate + @LoadBalanced 的优势</h3><p>即便 <code>RestTemplate</code> 可以通过 <code>@LoadBalanced</code> 实现负载均衡，OpenFeign 仍然在以下方面具备优势：</p><ol><li><p><strong>声明式语法简洁性</strong>：OpenFeign 使用接口和注解定义请求，可以省去大量手动编写 URL 和方法的代码，特别是在大型项目中，显著减少重复代码。</p></li><li><p><strong>熔断与容错支持</strong>：OpenFeign 默认集成了 Hystrix 等容错机制，可以在微服务调用中轻松实现熔断功能。而在 <code>RestTemplate</code> 中实现熔断需要手动配置，例如结合 <code>CircuitBreaker</code> 进行实现，稍显繁琐。</p></li><li><p><strong>可扩展性</strong>：OpenFeign 提供了更强的扩展支持，如全局请求拦截器（<code>RequestInterceptor</code>）、超时设置等，可通过注解或配置文件集中管理。而 <code>RestTemplate</code> 则需要通过 <code>ClientHttpRequestInterceptor</code> 来手动添加拦截器，配置相对复杂。</p></li><li><p><strong>可维护性和测试性</strong>：OpenFeign 将远程服务抽象为接口，使得服务之间的依赖关系更清晰，测试时可以轻松进行 Mock，不需要关心实现细节。而在 <code>RestTemplate</code> 中进行类似的 Mock 测试时，需要为每个请求配置更多细节。</p></li></ol><h2 id="使用-OpenFeign"><a href="#使用-OpenFeign" class="headerlink" title="使用 OpenFeign"></a>使用 OpenFeign</h2><p>首先，我们需要在 pom.xml 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们可以在 Spring Boot 项目中定义一个接口，该接口将定义远程服务的 API。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;cloud-provider-payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/pay/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 <code>@FeignClient</code> 注解定义了一个 Feign 客户端，<code>name</code> 属性指定了服务提供者的服务名，<code>@GetMapping</code> 注解定义了一个 GET 请求，<code>@PathVariable</code> 注解用于获取请求参数。</p><p>最后，我们可以在 Controller 中注入该接口，并调用远程服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们注入了 <code>PaymentFeignService</code> 接口，并调用了 <code>getPaymentById</code> 方法，实现了远程服务的调用。</p><p><strong>OpenFeign天然支持负载均衡</strong>，只需要在配置文件中配置服务提供者的服务名即可，无需关心具体的 IP 和端口。</p><h2 id="配置超时时间"><a href="#配置超时时间" class="headerlink" title="配置超时时间"></a>配置超时时间</h2><p>调用服务的超时时间是一个重要的配置，可以避免因为网络延迟导致的性能问题。</p><p>在 OpenFeign 中，我们可以通过配置文件来设置超时时间，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">        <span class="attr">client:</span></span><br><span class="line">            <span class="attr">config:</span></span><br><span class="line">            <span class="attr">default:</span> <span class="comment"># 全局配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">            <span class="attr">my-service:</span> <span class="comment"># 指定服务配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们设置了默认的超时时间为 5 秒。</p><p>openFeign的默认超时时间是60s。</p><h2 id="配置重试机制"><a href="#配置重试机制" class="headerlink" title="配置重试机制"></a>配置重试机制</h2><p>在 OpenFeign 中，可以设置重试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenFeignConfig.java</span></span><br><span class="line"><span class="keyword">public</span> OpenFeignConfig&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重试机制</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Retryer <span class="title function_">myRetryer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retryer</span>.Default(<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志记录级别</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 更换默认的client</span><br><span class="line">在 OpenFeign 中，我们可以通过配置文件来更换默认的 client，例如：</span><br><span class="line">```yaml</span><br><span class="line">cloud:</span><br><span class="line">    openfeign:</span><br><span class="line">        httpclient:</span><br><span class="line">            hc5:</span><br><span class="line">                enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们通过 <code>cloud.openfeign.httpclient.hc5.enabled</code> 属性来启用 HttpClient 5.x 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenFeign介绍&quot;&gt;&lt;a href=&quot;#OpenFeign介绍&quot; class=&quot;headerlink&quot; title=&quot;OpenFeign介绍&quot;&gt;&lt;/a&gt;OpenFeign介绍&lt;/h2&gt;&lt;p&gt;OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 N</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud:服务注册与发现</title>
    <link href="https://kelinkong.github.io/2024/11/14/Spring-Cloud-%E6%96%B0%E5%A2%9E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/"/>
    <id>https://kelinkong.github.io/2024/11/14/Spring-Cloud-%E6%96%B0%E5%A2%9E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/</id>
    <published>2024-11-14T02:51:57.000Z</published>
    <updated>2025-04-29T02:15:34.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务之间的通信"><a href="#微服务之间的通信" class="headerlink" title="微服务之间的通信"></a>微服务之间的通信</h2><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate是Spring提供的用于访问Rest服务的客户端模板工具集。</p><p>添加配置类<code>RestTemplateConfig</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用配置类？而不是每次使用<code>RestTemplate</code>时都创建一个新的实例？</p><blockquote><p>因为<code>RestTemplate</code>的实例化是一个比较耗时的操作，如果每次使用都创建一个新的实例，会影响性能。</p><p>RestTemplate 是设计为线程安全的，能够在多个线程之间共享。通过定义一个单例的 RestTemplate，可以确保多个线程安全地访问同一个实例，而不需要担心并发问题。</p><p>使用配置类可以集中管理 RestTemplate 的配置，比如超时设置、拦截器、消息转换器等。这使得应用程序的配置更加一致和易于维护。</p></blockquote><ol><li>创建一个<code>RestTemplate</code>实例，并注入到Spring容器中。</li><li>使用<code>RestTemplate</code>发送HTTP请求，并接收响应。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateClient</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/user/name&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RestTemplate</code> 是 Spring 框架中的一个类，用于在客户端上发送 HTTP 请求并处理响应。它支持多种 HTTP 请求方法，主要包括以下几种：</p><h4 id="1-GET-请求"><a href="#1-GET-请求" class="headerlink" title="1. GET 请求"></a>1. <code>GET</code> 请求</h4><p>用于从服务器获取资源。<code>RestTemplate</code> 提供了 <code>getForObject</code> 和 <code>getForEntity</code> 方法：</p><ul><li><p>**<code>getForObject</code>**：返回指定类型的对象（自动转换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://example.com/resource&quot;</span>, String.class);</span><br></pre></td></tr></table></figure></li><li><p>**<code>getForEntity</code>**：返回 <code>ResponseEntity</code> 对象，其中包含 HTTP 状态码、头部信息和实体内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(<span class="string">&quot;http://example.com/resource&quot;</span>, String.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-POST-请求"><a href="#2-POST-请求" class="headerlink" title="2. POST 请求"></a>2. <code>POST</code> 请求</h4><p>用于向服务器提交数据，<code>RestTemplate</code> 提供了 <code>postForObject</code> 和 <code>postForEntity</code> 方法：</p><ul><li><p>**<code>postForObject</code>**：提交数据后返回响应的实体内容（转换为指定类型）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.postForObject(<span class="string">&quot;http://example.com/resource&quot;</span>, requestBody, String.class);</span><br></pre></td></tr></table></figure></li><li><p>**<code>postForEntity</code>**：提交数据后返回 <code>ResponseEntity</code>，包含状态码、头部信息和实体内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(<span class="string">&quot;http://example.com/resource&quot;</span>, requestBody, String.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-PUT-请求"><a href="#3-PUT-请求" class="headerlink" title="3. PUT 请求"></a>3. <code>PUT</code> 请求</h4><p>用于更新服务器上的资源，<code>RestTemplate</code> 提供了 <code>put</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.put(<span class="string">&quot;http://example.com/resource/&#123;id&#125;&quot;</span>, updatedResource, id);</span><br></pre></td></tr></table></figure><p><code>PUT</code> 请求通常不返回响应内容，因此 <code>put</code> 方法的返回类型为 <code>void</code>。</p><h4 id="4-DELETE-请求"><a href="#4-DELETE-请求" class="headerlink" title="4. DELETE 请求"></a>4. <code>DELETE</code> 请求</h4><p>用于删除服务器上的资源，<code>RestTemplate</code> 提供了 <code>delete</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.delete(<span class="string">&quot;http://example.com/resource/&#123;id&#125;&quot;</span>, id);</span><br></pre></td></tr></table></figure><p>同样，<code>DELETE</code> 请求通常不返回响应内容，因此 <code>delete</code> 方法的返回类型为 <code>void</code>。</p><h2 id="提取通用模块"><a href="#提取通用模块" class="headerlink" title="提取通用模块"></a>提取通用模块</h2><p>将所有使用的通用模块提取到一个单独的模块中，方便其他模块引用。</p><ol><li>创建一个新的模块，命名为<code>common</code>。</li><li>将通用模块的代码复制到<code>common</code>模块中。</li><li>在其他模块中添加<code>common</code>模块的依赖。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="consul介绍"><a href="#consul介绍" class="headerlink" title="consul介绍"></a>consul介绍</h2><p>Consul 是 HashiCorp 公司提供的一款开源的服务发现和配置管理工具。它提供了一种简单的方式来注册和发现服务，并提供了服务健康检查功能。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://developer.hashicorp.com/consul/install?product_intent=consul">consul下载链接</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/consul</span><br></pre></td></tr></table></figure><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>启动consul：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>访问：<br><a href="http://localhost:8500/">http://localhost:8500</a></p><p>配置文件地址：<a href="https://cloud.spring.io/spring-cloud-consul/reference/html/">Spring- cloud-consul</a></p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ol><li>添加依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置文件<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span>         <span class="comment"># Consul 的地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span>              <span class="comment"># Consul 的端口号</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">my-service</span>   <span class="comment"># 服务名，可随项目需求更改</span></span><br><span class="line">        <span class="attr">health-check-interval:</span> <span class="string">10s</span> <span class="comment"># 健康检查时间间隔</span></span><br></pre></td></tr></table></figure></li><li>在主启动类上添加 @EnableDiscoveryClient 注解，Spring Boot 应用启动时会自动将服务注册到 Consul。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过 @LoadBalanced 注解和 RestTemplate 或 Feign 客户端来进行服务调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>服务消费者需要依赖服务提供者的服务名，而不是具体的IP和端口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">// 注入RestTemplate</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData <span class="title function_">addOrder</span><span class="params">(PayDTO payDTO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/pay/add&quot;</span>, payDTO, ResultData.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="consul-配置"><a href="#consul-配置" class="headerlink" title="consul 配置"></a>consul 配置</h2><p>使用 Consul 作为配置管理工具，可以将应用的配置信息集中存储在 Consul 中，应用从 Consul 读取配置，而不是依赖本地文件。Spring Cloud 提供了 <code>spring-cloud-starter-consul-config</code> 模块，方便与 Consul 集成，以下是如何配置和使用 Consul 来进行配置管理的步骤：</p><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><p>在 <code>pom.xml</code> 中添加 Consul 配置依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置-Consul-连接"><a href="#2-配置-Consul-连接" class="headerlink" title="2. 配置 Consul 连接"></a>2. 配置 Consul 连接</h3><p>在 <code>application.yml</code> 或 <code>application.properties</code> 中配置 Consul 的连接地址和一些关键设置：</p><p>这里也可以在<code>bootstrap.yml</code>中配置：<code>bootstrap.yaml</code>的优先级高于<code>application.yaml</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span>         <span class="comment"># Consul 的主机地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span>              <span class="comment"># Consul 的端口</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>         <span class="comment"># 启用 Consul 配置管理</span></span><br><span class="line">        <span class="attr">default-context:</span> <span class="string">application</span>  <span class="comment"># 默认上下文（通用配置）</span></span><br><span class="line">        <span class="attr">profile-separator:</span> <span class="string">&#x27;-&#x27;</span>        <span class="comment"># 配置文件和环境的分隔符</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">yaml</span>                  <span class="comment"># 配置格式 (yaml 或 properties)</span></span><br><span class="line">        <span class="attr">fail-fast:</span> <span class="literal">true</span>               <span class="comment"># 启动时加载配置失败是否立即失败</span></span><br></pre></td></tr></table></figure><h3 id="3-在-Consul-中存储配置"><a href="#3-在-Consul-中存储配置" class="headerlink" title="3. 在 Consul 中存储配置"></a>3. 在 Consul 中存储配置</h3><p>Consul 的配置管理使用 Key-Value 存储系统。将配置文件内容以键值对形式存储在 Consul 中，格式如下：</p><h4 id="Key-结构"><a href="#Key-结构" class="headerlink" title="Key 结构"></a>Key 结构</h4><p>Consul 中的键通常按以下路径结构组织：</p><ul><li><code>config/&#123;application-name&#125;/&#123;profile&#125;/data</code></li></ul><p>例如，应用名为 <code>my-app</code>，环境为 <code>dev</code> 的配置路径为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config<span class="regexp">/my-app/</span>dev/data</span><br></pre></td></tr></table></figure><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p>可以通过 Consul 的 Web UI 或命令行将配置写入 Consul。在 Web UI 中可以添加键值对，也可以使用 <code>curl</code> 命令来添加配置。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT --data-binary @application.yml http://localhost:8500/v1/kv/config/my-app/data</span><br></pre></td></tr></table></figure><p>将配置数据 <code>application.yml</code> 上传到 Consul 的 <code>config/my-app/data</code> 路径。</p><h3 id="4-Consul-配置的层次结构"><a href="#4-Consul-配置的层次结构" class="headerlink" title="4. Consul 配置的层次结构"></a>4. Consul 配置的层次结构</h3><p>Consul 的配置会覆盖，层次结构为：</p><ul><li><code>config/application/</code>：通用配置（所有应用和环境共享）。</li><li><code>config/&#123;application-name&#125;/</code>：特定应用的配置。</li><li><code>config/&#123;application-name&#125;/&#123;profile&#125;/</code>：特定应用的特定环境配置（如 <code>dev</code>、<code>prod</code>）。</li></ul><h3 id="5-读取配置"><a href="#5-读取配置" class="headerlink" title="5. 读取配置"></a>5. 读取配置</h3><p>在 Spring Boot 应用中，不需要额外的代码来读取 Consul 配置。Spring Cloud Consul Config 会自动将 Consul 中的配置加载到 Spring 的 <code>Environment</code> 中，和 <code>application.yml</code> 或 <code>application.properties</code> 中的配置一样使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 Consul 加载的配置会自动生效</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;Hello from Consul&quot;</span></span><br></pre></td></tr></table></figure><p>在应用中，可以像平常一样使用 <code>@Value</code> 注解或 <code>@ConfigurationProperties</code> 注解获取配置值：在data中写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">atguigu:</span></span><br><span class="line">    <span class="attr">info:</span> <span class="string">&quot;Hello from Consul&quot;</span></span><br></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;atguigu.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-配置动态刷新"><a href="#6-配置动态刷新" class="headerlink" title="6. 配置动态刷新"></a>6. 配置动态刷新</h3><p>Spring Cloud Consul 支持配置的动态刷新。如果 Consul 中的配置发生变化，可以自动更新应用中的配置值。启用动态刷新需要在 <code>@RefreshScope</code> 注解的支持下：</p><ol><li>在需要动态刷新的 Bean 类上添加 <code>@RefreshScope</code> 注解。</li><li>默认配置会每 60 秒刷新一次，可以在 <code>application.yml</code> 中通过 <code>spring.cloud.consul.config.watch-delay</code> 配置刷新频率（单位为毫秒）。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">watch-delay:</span> <span class="number">1000</span>    <span class="comment"># 每秒检查一次配置更新</span></span><br></pre></td></tr></table></figure><p>在需要动态刷新的配置类上使用 <code>@RefreshScope</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.config.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个配置不是持久化的，当服务重启后，配置不会保留。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务之间的通信&quot;&gt;&lt;a href=&quot;#微服务之间的通信&quot; class=&quot;headerlink&quot; title=&quot;微服务之间的通信&quot;&gt;&lt;/a&gt;微服务之间的通信&lt;/h2&gt;&lt;h3 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; cla</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud：base工程</title>
    <link href="https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/"/>
    <id>https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-11-13T07:31:35.000Z</published>
    <updated>2024-11-14T02:34:21.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h2><p>使用Idea做为编译器，创建一个新的Spring Cloud项目。</p><p>版本选择：</p><p><img src="/../imgs/image-67.png"></p><h3 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start mysql</span><br></pre></td></tr></table></figure><p><strong>查看mysql版本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select VERSION();</span><br><span class="line">+-----------+</span><br><span class="line">| VERSION() |</span><br><span class="line">+-----------+</span><br><span class="line">| 9.0.1     |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database db2024;</span><br></pre></td></tr></table></figure><p><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_pay</span><br><span class="line">(</span><br><span class="line">    id          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    pay_no      VARCHAR(50) NOT NULL COMMENT &#x27;支付流水号&#x27;,</span><br><span class="line">    order_no    VARCHAR(50) NOT NULL COMMENT &#x27;订单流水号&#x27;,</span><br><span class="line">    user_id     INT DEFAULT 1 NULL COMMENT &#x27;用户账号ID&#x27;,</span><br><span class="line">    amount      DECIMAL(8, 2) DEFAULT 9.90 NOT NULL COMMENT &#x27;交易金额&#x27;,</span><br><span class="line">    deleted     TINYINT UNSIGNED DEFAULT &#x27;0&#x27; NOT NULL COMMENT &#x27;删除标志, 默认0不删除,1删除&#x27;,</span><br><span class="line">    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;</span><br><span class="line">)</span><br><span class="line">COMMENT &#x27;支付交易表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自动生成mapper和实体类"><a href="#自动生成mapper和实体类" class="headerlink" title="自动生成mapper和实体类"></a>自动生成mapper和实体类</h2><p>创建一个mybatis-generator模块，自动生成mapper和实体类。</p><p>使用<code>mybatis-generator-maven-plugin</code>插件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在maven中，双击<code>mybatis-generator:generate</code>即可生成。</p><p>配置文件在<code>src/main/resources/generator/generatorConfig.xml</code>。</p><h2 id="新建一个微服务流程"><a href="#新建一个微服务流程" class="headerlink" title="新建一个微服务流程"></a>新建一个微服务流程</h2><ol><li>新建一个模块，例如：pay-service。</li><li>更改pom.xml文件，添加依赖。</li><li>写yml配置文件。</li><li>编写启动类。</li><li>编写业务代码。</li></ol><h2 id="Swager3"><a href="#Swager3" class="headerlink" title="Swager3"></a>Swager3</h2><p>Swager是一个API文档生成工具，可以通过注解生成API文档。</p><p>常用注解：</p><ul><li><code>@Tag</code>：用在类上，说明该类的作用。</li><li><code>@Operation</code>：用在方法上，说明方法的作用。</li><li><code>@Parameter</code>：用在方法参数上，说明参数的作用。</li><li><code>Schema</code>：用在实体类上，说明实体类的作用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController()</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pay&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;支付微服务模块&quot;, description = &quot;支付crud操作&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PayService payService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增&quot;, description = &quot;新增支付流水, 参数是JSON字符串&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> PayDTO payDTO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payService.add(payDTO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写配置类，配置Swagger3。</p><p>进入地址：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p><p>在网页上可以看到生成的API文档。点击try it out可以测试接口。</p><h2 id="时间格式问题"><a href="#时间格式问题" class="headerlink" title="时间格式问题"></a>时间格式问题</h2><h3 id="使用-JsonFormat注解"><a href="#使用-JsonFormat注解" class="headerlink" title="使用@JsonFormat注解"></a>使用<code>@JsonFormat</code>注解</h3><p>在实体类中添加注解，指定时间格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure><h3 id="在application-yml中配置"><a href="#在application-yml中配置" class="headerlink" title="在application.yml中配置"></a>在application.yml中配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">        <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">        <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure><h2 id="统一返回值"><a href="#统一返回值" class="headerlink" title="统一返回值"></a>统一返回值</h2><p>现在主流的返回值需要包括：</p><ul><li>code：状态码</li><li>data：数据</li><li>message：消息</li><li>timestamp：时间戳（调用接口的时间）</li></ul><p>状态码一般是枚举类型。</p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>编写枚举类的技巧：举值-构造-遍历。</p><h2 id="全局异常处理和返回"><a href="#全局异常处理和返回" class="headerlink" title="全局异常处理和返回"></a>全局异常处理和返回</h2><p>定义一个全局异常处理类，继承<code>ResponseEntityExceptionHandler</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> <span class="keyword">extends</span> <span class="title class_">ResponseEntityExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;全局异常处理：&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生异常时，会调用<code>handleException</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开发前准备&quot;&gt;&lt;a href=&quot;#开发前准备&quot; class=&quot;headerlink&quot; title=&quot;开发前准备&quot;&gt;&lt;/a&gt;开发前准备&lt;/h2&gt;&lt;p&gt;使用Idea做为编译器，创建一个新的Spring Cloud项目。&lt;/p&gt;
&lt;p&gt;版本选择：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-配置文件</title>
    <link href="https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-13T01:50:41.000Z</published>
    <updated>2024-11-13T02:14:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>基于SpringBoot的Java学习笔记-配置文件</p><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-1-config.html">配置文件</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot的默认配置文件在：<code>src/main/resources/application.properties</code></p><p>关于Spring Boot应用的配置内容都可以集中在该文件中了，根据我们引入的不同Starter模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。比如，我们需要自定义web模块的服务端口号，可以在<code>application.properties</code>中添加<code>server.port=8888</code>来指定服务端口为8888，也可以通过<code>spring.application.name=hello</code>来指定应用名（该名字在Spring Cloud应用中会被注册为服务名）。</p><p>也可以使用yaml文件来配置。</p><p>如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">  <span class="attr">context-path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">shutdown:</span></span><br><span class="line">    <span class="attr">graceful:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8889</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><p>对应的application.properties文件：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="attr">server.context-path</span>=<span class="string">/hello</span></span><br><span class="line"><span class="attr">server.shutdown.graceful</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.port</span>=<span class="string">8889</span></span><br><span class="line"><span class="attr">server.shutdown.timeout</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">server.shutdown.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.path</span>=<span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>在配置文件中可以定义一些自定义参数，如</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">book.name</span>=<span class="string">Spring Boot 2.x</span></span><br></pre></td></tr></table></figure><p>在Java代码中可以通过<code>@Value</code>注解来获取配置文件中的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bookName;</span><br></pre></td></tr></table></figure><p>还可以使用随机数</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在启动应用时，可以通过命令行参数来覆盖配置文件中的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar myapp.jar --server.port=8888</span><br></pre></td></tr></table></figure><p><code>--</code>后面的参数会覆盖配置文件中的参数。</p><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>在Spring Boot中多环境配置文件名需要满足<code>application-&#123;profile&#125;.properties</code>的格式，其中<code>&#123;profile&#125;</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li><li><code>application.properties</code>：默认环境</li></ul><p>在<code>application.properties</code>中通过<code>spring.profiles.active</code>来指定当前环境，如：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h3><p>Spring Boot会按照如下顺序加载配置文件：</p><ul><li>命令行中传入的参数。</li><li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容。</li><li>java:comp&#x2F;env中的JNDI属性。</li><li>Java的系统属性，可以通过System.getProperties()获得的内容。</li><li>操作系统的环境变量</li><li>通过random.*配置的随机属性</li><li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之外的application.properties和YAML配置内容</li><li>位于当前应用jar包之内的application.properties和YAML配置内容</li><li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li></ul><h2 id="加密敏感信息"><a href="#加密敏感信息" class="headerlink" title="加密敏感信息"></a>加密敏感信息</h2><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-5-jasypt.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E5%AF%86">Spring Boot 2.x敏感信息加密</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于SpringBoot的Java学习笔记-配置文件&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.didispace.com/spring-boot-2/2-1-config.html&quot;&gt;配置文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-使用langchain-chatchat和ollama构建大模型</title>
    <link href="https://kelinkong.github.io/2024/11/07/AI-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/07/AI-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-07T11:14:13.000Z</published>
    <updated>2024-12-20T07:25:48.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>github地址：</strong></p><p>langchina-chatchat地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></p><p>ollama地址：<a href="https://github.com/ollama/ollama">ollama</a></p><h2 id="使用langchain-chatchat和ollama构建大模型"><a href="#使用langchain-chatchat和ollama构建大模型" class="headerlink" title="使用langchain-chatchat和ollama构建大模型"></a>使用langchain-chatchat和ollama构建大模型</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>langchain-chatchat</strong></p><p>langchain-chatchat在0.3版本之后支持使用pip安装，这里推荐创建一个新的虚拟环境来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create -n langchain python=3.10</span><br><span class="line">conda activate langchain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install langchain-chatchat -U</span><br></pre></td></tr></table></figure><p><strong>ollama</strong></p><p>ollama的安装比较简单，只需要使用pip安装即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ollama</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>langchain-chatchat</strong></p><p><strong>初始化</strong>，建议创建一个空的文件夹来进行初始化。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat init</span><br></pre></td></tr></table></figure><p>该命令会执行以下操作：</p><ul><li>创建所有需要的数据目录</li><li>复制 samples 知识库内容</li><li>生成默认 yaml 配置文件</li></ul><p><strong>修改配置文件</strong></p><p>具体每个配置文件的作用可以到github仓库查看，这里只列出需要修改的配置文件。</p><p>在文件<code>model_settings.yaml</code>中，修改:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">platform_name:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">platform_type:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">api_base_url:</span> <span class="string">http://127.0.0.1:11434/v1</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">EMPTY</span></span><br><span class="line">  <span class="attr">api_proxy:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">api_concurrencies:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">auto_detect_model:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">llm_models:</span> <span class="comment"># 本地部署的模型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwen2</span></span><br><span class="line">  <span class="attr">embed_models:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">quentinz/bge-large-zh-v1.5</span> <span class="comment"># 嵌入模型</span></span><br><span class="line">  <span class="attr">text2image_models:</span> []</span><br><span class="line">  <span class="attr">image2text_models:</span> []</span><br><span class="line">  <span class="attr">rerank_models:</span> []</span><br><span class="line">  <span class="attr">speech2text_models:</span> []</span><br><span class="line">  <span class="attr">text2speech_models:</span> []</span><br></pre></td></tr></table></figure><p>前面的默认模型可以不修改，开启自动检测后，会自动检测ollama中的模型。</p><p><strong>ollama</strong></p><p>加载大语言模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run qwen2</span><br></pre></td></tr></table></figure><p>如果本地没有部署，会自动下载模型。打开浏览器查看是否正确启动：<a href="http://localhost:11434/">http://localhost:11434</a></p><p>加载嵌入模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama pull quentinz/bge-large-zh-v1.5:latest</span><br></pre></td></tr></table></figure><p>嵌入模型不需要运行，只需要下载即可。</p><blockquote><p>嵌入模型（例如 quentinz&#x2F;bge-large-zh-v1.5）的主要作用是将文本转换成向量表示，这种向量表示也叫做“嵌入” (embedding)。这些嵌入可以捕捉到文本的语义信息，以便在不同的 NLP 任务中进行高效的相似度计算和语义搜索。</p><p>quentinz&#x2F;bge-large-zh-v1.5 可以用于生成中文文本的嵌入。例如，当输入一句中文文本时，该模型会输出一个向量（embedding），我们可以利用这个向量来完成以下操作</p></blockquote><h3 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h3><p>在生成知识库之前，要先确保ollama已经正确启动，使用默认的向量数据库，需要下载驱动，在pycharm中点击info.db，根据提示下载驱动即可。</p><p>使用<code>chatchat</code>命令生成知识库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat kb -r</span><br></pre></td></tr></table></figure><p>这里可能会遇到各种bug，自行到社区issue中查找解决方案。如果没有解决方案，可以给社区提issue。</p><p>出现以下提示表示生成成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">知识库名称      ：samples</span><br><span class="line">知识库类型      ：faiss</span><br><span class="line">向量模型：      ：bge-large-zh-v1.5</span><br><span class="line">知识库路径      ：/root/anaconda3/envs/chatchat/lib/python3.11/site-packages/chatchat/data/knowledge_base/samples</span><br><span class="line">文件总数量      ：47</span><br><span class="line">入库文件数      ：42</span><br><span class="line">知识条目数      ：740</span><br><span class="line">用时            ：0:02:29.701002</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">总计用时        ：0:02:33.414425</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat start -a</span><br></pre></td></tr></table></figure><p>运行成功之后，可以在网页上进行知识库配置、对话等。</p><p>其余功能有待摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;langchina-chatchat地址：&lt;a href=&quot;https:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AI-大模型有关的一些工具链</title>
    <link href="https://kelinkong.github.io/2024/11/07/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>https://kelinkong.github.io/2024/11/07/AI-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-11-07T02:36:51.000Z</published>
    <updated>2024-12-20T07:30:12.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大模型的汇总仓库"><a href="#大模型的汇总仓库" class="headerlink" title="大模型的汇总仓库"></a>大模型的汇总仓库</h2><p><a href="https://github.com/ikaijua/Awesome-AITools/blob/main/README-CN.md">awesome AI</a></p><h2 id="使用大模型做具体场景助手"><a href="#使用大模型做具体场景助手" class="headerlink" title="使用大模型做具体场景助手"></a>使用大模型做具体场景助手</h2><p>使用开源工具来实现具体场景下的 AI 助手，流程可以简化如下：</p><ol><li><p>Prompt 工程</p><ul><li>流程：设计并优化 prompt，让大模型生成符合需求的答案，进行 prompt 测试和调整。</li><li>工具：可以使用 OpenAI API（如 GPT-3 开源替代品）结合 LangChain 或 LlamaIndex（前称 GPT Index）来管理和优化 prompt。</li></ul></li><li><p>构建知识库</p><ul><li>流程：收集和清洗数据，将信息分块后存入知识库，并生成索引以便高效检索。</li><li>工具：<ul><li>Elasticsearch 或 FAISS：用于分块后的数据存储和快速检索。</li><li>Haystack 或 LlamaIndex：可用于索引管理，便于与生成模型集成。</li></ul></li></ul></li><li><p>检索增强生成（RAG）</p><ul><li>流程：通过检索模块先找到相关信息片段，再输入生成模型生成回答，增强内容准确性。</li><li>工具：Haystack 或 LangChain，集成检索与生成，提供基于上下文的回答。</li></ul></li><li><p>大模型微调</p><ul><li>流程：将场景相关数据准备好后对大模型进行微调，使其适应具体领域或场景。</li><li>工具：<ul><li>Hugging Face Transformers：用于加载和微调模型。</li><li>Hugging Face Datasets：用于管理和预处理训练数据。</li></ul></li></ul></li><li><p>模型量化</p><ul><li>流程：在部署前对模型进行量化，以减小模型体积并加快推理速度。</li><li>工具：BitsAndBytes（4&#x2F;8 位量化）、ONNX Runtime（支持量化优化）。</li></ul></li><li><p>部署</p><ul><li>流程：将微调和量化后的模型部署在服务器或云端。</li><li>工具：<ul><li>FastAPI 或 Flask：用于搭建 API 服务。</li><li>Docker：用于容器化部署，保证环境一致性。</li><li>Hugging Face Inference（如使用推理服务器）或 ONNX Runtime（加速推理）。</li></ul></li></ul></li></ol><p>简化流程示例</p><p>设计 prompt → 构建知识库 → RAG 检索 → 大模型微调 → 模型量化 → 部署</p><p>这些步骤结合开源工具能够实现高效的 AI 助手。</p><h2 id="ollama"><a href="#ollama" class="headerlink" title="ollama"></a>ollama</h2><h3 id="ollama简介"><a href="#ollama简介" class="headerlink" title="ollama简介"></a>ollama简介</h3><p>ollama用来部署和运行大型语言模型，它提供了一个简单的命令行工具，可以用来运行模型、查看模型列表、下载模型等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计 prompt → 构建知识库 → RAG 检索 → Ollama 微调 → Ollama 量化 → Ollama 部署</span><br></pre></td></tr></table></figure><p>官网地址：<a href="https://ollama.com/">ollama</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行一个模型，如果本地不存在该模型，会自动到仓库下载，仓库地址：<br><a href="https://ollama.com/library">ollama模型仓库</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run llama3-8b-8192</span><br></pre></td></tr></table></figure><p>一些指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看模型列表</span></span><br><span class="line">ollama list</span><br><span class="line"><span class="comment"># 查看当前运行的模型</span></span><br><span class="line">ollama ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># -h 查看帮助</span></span><br><span class="line">serve       Start ollama</span><br><span class="line">create      Create a model from a Modelfile</span><br><span class="line">show        Show information <span class="keyword">for</span> a model</span><br><span class="line">run         Run a model</span><br><span class="line">stop        Stop a running model</span><br><span class="line">pull        Pull a model from a registry</span><br><span class="line">push        Push a model to a registry</span><br><span class="line">list        List models</span><br><span class="line">ps          List running models</span><br><span class="line"><span class="built_in">cp</span>          Copy a model</span><br><span class="line"><span class="built_in">rm</span>          Remove a model</span><br><span class="line"><span class="built_in">help</span>        Help about any <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>查看ollama是否正确启动：<a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a></p><h2 id="open-webui"><a href="#open-webui" class="headerlink" title="open-webui"></a>open-webui</h2><p>open-webui提供了一个简单的web界面，可以用来查看模型列表、运行模型等。</p><p>仓库地址：<a href="https://github.com/open-webui/open-webui">open-webui</a></p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install open-webui</span><br><span class="line">open-webui serve</span><br></pre></td></tr></table></figure><h2 id="modelscope"><a href="#modelscope" class="headerlink" title="modelscope"></a>modelscope</h2><p>官网地址：<a href="https://modelscope.ai/">modelscope</a></p><p>github地址：<a href="https://github.com/modelscope/modelscope/tree/master">modelscope</a></p><h3 id="modelscope简介"><a href="#modelscope简介" class="headerlink" title="modelscope简介"></a>modelscope简介</h3><p>modelscope是一个 “模型即服务”(MaaS) 平台，旨在汇集来自 AI 社区的最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。ModelScope 库使开发人员能够通过丰富的 API 设计执行推理、训练和评估，从而促进跨不同 AI 领域的最先进模型的统一体验。</p><p>ModelScope Library 为模型贡献者提供了必要的分层 API，以便将来自 CV、NLP、语音、多模态以及科学计算的模型集成到 ModelScope 生态系统中。所有这些不同模型的实现都以一种简单统一访问的方式进行封装，用户只需几行代码即可完成模型推理、微调和评估。同时，灵活的模块化设计使得在必要时也可以自定义模型训练推理过程中的不同组件。</p><h3 id="安装和使用-1"><a href="#安装和使用-1" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>在ModelScope Hub 中有很多可以训练的模型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n modelscope python=3.10</span><br><span class="line">conda activate modelscope</span><br></pre></td></tr></table></figure><p>模型下载需要先配置好Git LFS。</p><blockquote><p>git lfs 是一个 Git 的扩展，它用来存储大文件。它的设计目标是让 Git 能够更好地管理大文件，而不是让 Git 成为一个文件存储系统。Git LFS 通过将大文件存储在远程服务器上，而不是存储在 Git 仓库中，来解决 Git 仓库过大的问题。</p></blockquote><p>之后就可以下载用来训练的模型，和github上的代码一样，可以直接使用git clone。</p><p>训练好的模型（微调）在部署时，通常还需要量化，这样才能在较小的设备上运行。</p><h2 id="langchain和langchain-chatchat"><a href="#langchain和langchain-chatchat" class="headerlink" title="langchain和langchain-chatchat"></a>langchain和langchain-chatchat</h2><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>这里有一个简单的教程:<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">langchain</a>，可以用来构建一个简单的LLM（Large Language Model）应用。</p><p>核心就是构建链，链可以包含各种处理步骤，例如模型、解析器和提示。</p><h3 id="langchain-chatchat"><a href="#langchain-chatchat" class="headerlink" title="langchain-chatchat"></a>langchain-chatchat</h3><p>仓库地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-files">langchain-chatchat</a></p><p>一种利用 langchain 思想实现的基于本地知识库的问答应用，目标期望建立一套对中文场景与开源模型支持友好、可离线运行的知识库问答解决方案。</p><p><strong>原理：</strong><br><img src="/../imgs/image-65.png"><br><img src="/../imgs/image-66.png"></p><p>在这个项目中，并不涉及模型的微调。模型微调参考：<a href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/">llvm-微调大模型</a></p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>官网地址：<a href="https://www.dify.ai/">Dify</a></p><p>github地址：<a href="https://github.com/langgenius/dify">Dify</a></p><p>官方文档：<a href="https://docs.dify.ai/">Dify文档</a></p><p>Dify 是一款开源的大语言模型(LLM) 应用开发平台。它融合了后端即服务（Backend as Service）和 LLMOps 的理念，使开发者可以快速搭建生产级的生成式 AI 应用。即使你是非技术人员，也能参与到 AI 应用的定义和数据运营过程中。</p><p>由于 Dify 内置了构建 LLM 应用所需的关键技术栈，包括对数百个模型的支持、直观的 Prompt 编排界面、高质量的 RAG 引擎、稳健的 Agent 框架、灵活的流程编排，并同时提供了一套易用的界面和 API。这为开发者节省了许多重复造轮子的时间，使其可以专注在创新和业务需求上。</p><p>dify支持ollama，可以直接使用本地部署的模型。</p><h2 id="Groqcloud"><a href="#Groqcloud" class="headerlink" title="Groqcloud"></a>Groqcloud</h2><p>官网地址：<a href="https://console.groq.com/playground">Groqcloud</a></p><p>GroqCloud 是由 Groq 公司提供的云服务，专注于快速 AI 推理。它利用 Groq 的语言处理单元（LPU）硬件和相关软件，推理速度很快，而且API便宜。</p><h2 id="向量知识库"><a href="#向量知识库" class="headerlink" title="向量知识库"></a>向量知识库</h2><ul><li>第一类是开源的专用向量数据库，如 Chroma、Vespa、LanceDB、Marqo、Qdrant 和 Milvus，这些数据库专门设计用于处理向量数据。</li><li>第二类是支持向量搜索的开源数据库，如 OpenSearch、PostgreSQL、ClickHouse 和 Cassandra，它们是常规数据库，但支持向量搜索功能。</li><li>第三类是商用的专用向量数据库，如 Weaviate 和 Pinecone，它们专门用于处理向量数据，但属于商业产品或通过商业许可获得源码。</li><li>第四类是支持向量搜索的商用数据库，如 Elasticsearch、Redis、Rockset 和 SingleStore，这些常规数据库支持向量搜索功能，同时属于商业产品或可通过商业许可获得源码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大模型的汇总仓库&quot;&gt;&lt;a href=&quot;#大模型的汇总仓库&quot; class=&quot;headerlink&quot; title=&quot;大模型的汇总仓库&quot;&gt;&lt;/a&gt;大模型的汇总仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ikaijua/Awesome-AI</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-使用 LCEL 构建一个简单的 LLM 应用</title>
    <link href="https://kelinkong.github.io/2024/11/06/AI-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/11/06/AI-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/</id>
    <published>2024-11-06T01:43:04.000Z</published>
    <updated>2024-12-20T07:28:17.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h2><p>教程来源于：<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">LangChain</a></p><h2 id="使用-LCEL-构建一个简单的-LLM-应用"><a href="#使用-LCEL-构建一个简单的-LLM-应用" class="headerlink" title="使用 LCEL 构建一个简单的 LLM 应用"></a>使用 LCEL 构建一个简单的 LLM 应用</h2><p>langchain的简单使用。</p><h3 id="什么是LangChain？"><a href="#什么是LangChain？" class="headerlink" title="什么是LangChain？"></a>什么是LangChain？</h3><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>在本教程中，会创建一个简单的LLM（Large Language Model）应用。</p><p>主要分为：prompt、model、parser</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langserve <span class="keyword">import</span> add_routes</span><br><span class="line"><span class="keyword">from</span> langchain_groq <span class="keyword">import</span> ChatGroq</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_TRACING_V2&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line">os.environ[<span class="string">&quot;GROQ_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create prompt template</span></span><br><span class="line">system_template = <span class="string">&quot;Translate the following into &#123;language&#125;:&quot;</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    <span class="string">&quot;system&quot;</span>, system_template,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create model</span></span><br><span class="line">model = ChatGroq(model=<span class="string">&quot;llama3-8b-8192&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create output parser</span></span><br><span class="line">parser = StrOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create chain</span></span><br><span class="line">chain = prompt_template | model | parser</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create FastAPI app</span></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&quot;LangChain OpenAI API&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A FastAPI app that uses LangChain and OpenAI to translate text.&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add routes</span></span><br><span class="line">add_routes(</span><br><span class="line">    app,</span><br><span class="line">    chain,</span><br><span class="line">    path=<span class="string">&quot;/chain&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the LangChain OpenAI API&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run FastAPI app</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单教程&quot;&gt;&lt;a href=&quot;#简单教程&quot; class=&quot;headerlink&quot; title=&quot;简单教程&quot;&gt;&lt;/a&gt;简单教程&lt;/h2&gt;&lt;p&gt;教程来源于：&lt;a href=&quot;https://www.langchain.com.cn/docs/tutorials/llm</summary>
      
    
    
    
    <category term="AI" scheme="https://kelinkong.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>AI-微调大模型</title>
    <link href="https://kelinkong.github.io/2024/11/01/AI-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/01/AI-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-01T06:35:34.000Z</published>
    <updated>2024-12-20T07:27:44.029Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h2><p>源代码来自:<a href="https://www.cnblogs.com/obullxl/p/18312594/NTopic2024071801">老牛同学</a></p><p>使用开源大模型 Qwen2-0.5B 的示例，实现了一个基于微调和 RAG（Retrieval-Augmented Generation）的文本分类助手。以下是各部分的详细解释：</p><h3 id="1-引入必要库"><a href="#1-引入必要库" class="headerlink" title="1. 引入必要库"></a>1. 引入必要库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> swanlab.integration.huggingface <span class="keyword">import</span> SwanLabCallback</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, TaskType, get_peft_model</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, TrainingArguments, Trainer, DataCollatorForSeq2Seq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> swanlab</span><br></pre></td></tr></table></figure><p>这部分代码引入了主要用于微调、训练和生成文本的库，包括 <code>transformers</code>、<code>peft</code>（主要用于 LoRA 微调）、<code>datasets</code>（用于处理数据集），以及 <code>swanlab</code> 用于回调和日志记录。</p><h3 id="2-设置路径和设备"><a href="#2-设置路径和设备" class="headerlink" title="2. 设置路径和设备"></a>2. 设置路径和设备</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_DIR = <span class="string">&#x27;D:\\ModelSpace\\Qwen2&#x27;</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><p>设置模型的根目录和设备名称。设备名称判断系统是否支持 CUDA（GPU 加速），如果不支持则使用 CPU。</p><p>在mac中使用mps加速</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-数据集格式转换函数"><a href="#3-数据集格式转换函数" class="headerlink" title="3. 数据集格式转换函数"></a>3. 数据集格式转换函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dataset_jsonl_transfer</span>(<span class="params">origin_path, new_path</span>):</span><br><span class="line">    messages = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            data = json.loads(line)</span><br><span class="line">            text = data[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">            catagory = data[<span class="string">&quot;category&quot;</span>]</span><br><span class="line">            output = data[<span class="string">&quot;output&quot;</span>]</span><br><span class="line">            message = &#123;</span><br><span class="line">                <span class="string">&quot;input&quot;</span>: <span class="string">f&quot;文本:<span class="subst">&#123;text&#125;</span>,分类选项列表:<span class="subst">&#123;catagory&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="string">&quot;output&quot;</span>: output,</span><br><span class="line">            &#125;</span><br><span class="line">            messages.append(message)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(new_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> messages:</span><br><span class="line">            file.write(json.dumps(message, ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>dataset_jsonl_transfer</code> 函数用于将原始 JSON 数据转换成微调所需的数据格式。原始文件的每行包含一个 JSON 对象，函数将其读取、重构并保存成新的 JSONL 格式文件，每行包含一个示例数据。</p><h3 id="4-数据预处理函数"><a href="#4-数据预处理函数" class="headerlink" title="4. 数据预处理函数"></a>4. 数据预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_func</span>(<span class="params">example</span>):</span><br><span class="line">    MAX_LENGTH = <span class="number">384</span></span><br><span class="line">    instruction = tokenizer(<span class="string">f&quot;&lt;|im_start|&gt;system\n你是一个文本分类领域的专家...<span class="subst">&#123;example[<span class="string">&#x27;input&#x27;</span>]&#125;</span>&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    response = tokenizer(<span class="string">f&quot;<span class="subst">&#123;example[<span class="string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    input_ids = instruction[<span class="string">&quot;input_ids&quot;</span>] + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    attention_mask = instruction[<span class="string">&quot;attention_mask&quot;</span>] + response[<span class="string">&quot;attention_mask&quot;</span>] + [<span class="number">1</span>]</span><br><span class="line">    labels = [-<span class="number">100</span>] * <span class="built_in">len</span>(instruction[<span class="string">&quot;input_ids&quot;</span>]) + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_ids) &gt; MAX_LENGTH:</span><br><span class="line">        input_ids, attention_mask, labels = input_ids[:MAX_LENGTH], attention_mask[:MAX_LENGTH], labels[:MAX_LENGTH]</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;input_ids&quot;</span>: input_ids, <span class="string">&quot;attention_mask&quot;</span>: attention_mask, <span class="string">&quot;labels&quot;</span>: labels&#125;</span><br></pre></td></tr></table></figure><p><code>process_func</code> 函数将数据处理成大模型可以接受的格式，包含 <code>input_ids</code>、<code>attention_mask</code> 和 <code>labels</code>。这里模拟了一个对话输入，用户提问，助手返回分类输出。如果序列长度超出最大限制 <code>MAX_LENGTH</code>，进行截断。</p><h3 id="5-加载模型和分词器"><a href="#5-加载模型和分词器" class="headerlink" title="5. 加载模型和分词器"></a>5. 加载模型和分词器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_dir = os.path.join(BASE_DIR, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_dir, use_fast=<span class="literal">False</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_dir, device_map=device, torch_dtype=torch.bfloat16)</span><br><span class="line">model.enable_input_require_grads()</span><br></pre></td></tr></table></figure><p>加载模型和分词器，将 <code>bfloat16</code> 用于精度，以减少 GPU 占用量。<code>model.enable_input_require_grads()</code> 开启梯度检查点支持，以节省内存。</p><h3 id="6-加载和处理数据集"><a href="#6-加载和处理数据集" class="headerlink" title="6. 加载和处理数据集"></a>6. 加载和处理数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;train.jsonl&#x27;</span>)</span><br><span class="line">test_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;test.jsonl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(train_dataset_path, train_jsonl_new_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(test_dataset_path, test_jsonl_new_path)</span><br><span class="line"></span><br><span class="line">train_df = pd.read_json(train_jsonl_new_path, lines=<span class="literal">True</span>)</span><br><span class="line">train_ds = Dataset.from_pandas(train_df)</span><br><span class="line">train_dataset = train_ds.<span class="built_in">map</span>(process_func, remove_columns=train_ds.column_names)</span><br></pre></td></tr></table></figure><p>检查并转换数据集，将其加载为 <code>Dataset</code> 格式，并通过 <code>process_func</code> 处理成可用于训练的数据格式。</p><h3 id="7-LoRA-配置与应用"><a href="#7-LoRA-配置与应用" class="headerlink" title="7. LoRA 配置与应用"></a>7. LoRA 配置与应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = LoraConfig(</span><br><span class="line">    task_type=TaskType.CAUSAL_LM,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, ...],</span><br><span class="line">    inference_mode=<span class="literal">False</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    lora_alpha=<span class="number">32</span>,</span><br><span class="line">    lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = get_peft_model(model, config)</span><br></pre></td></tr></table></figure><p>设置并应用 LoRA（Low-Rank Adaptation）配置，用于高效微调。<code>LoRA</code> 能通过添加低秩矩阵在不改变原模型参数的情况下更新模型，适合大模型的微调。</p><h3 id="8-训练参数与-Trainer-初始化"><a href="#8-训练参数与-Trainer-初始化" class="headerlink" title="8. 训练参数与 Trainer 初始化"></a>8. 训练参数与 Trainer 初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = TrainingArguments(</span><br><span class="line">    output_dir=os.path.join(BASE_DIR, <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>),</span><br><span class="line">    per_device_train_batch_size=<span class="number">4</span>,</span><br><span class="line">    gradient_accumulation_steps=<span class="number">4</span>,</span><br><span class="line">    logging_steps=<span class="number">10</span>,</span><br><span class="line">    num_train_epochs=<span class="number">2</span>,</span><br><span class="line">    save_steps=<span class="number">100</span>,</span><br><span class="line">    learning_rate=<span class="number">1e-4</span>,</span><br><span class="line">    save_on_each_node=<span class="literal">True</span>,</span><br><span class="line">    gradient_checkpointing=<span class="literal">True</span>,</span><br><span class="line">    report_to=<span class="string">&quot;none&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">swanlab_callback = SwanLabCallback(project=<span class="string">&quot;Qwen2-FineTuning&quot;</span>, experiment_name=<span class="string">&quot;Qwen2-0.5B&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainer = Trainer(</span><br><span class="line">    model=model,</span><br><span class="line">    args=args,</span><br><span class="line">    train_dataset=train_dataset,</span><br><span class="line">    data_collator=DataCollatorForSeq2Seq(tokenizer=tokenizer, padding=<span class="literal">True</span>),</span><br><span class="line">    callbacks=[swanlab_callback],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置训练参数并创建 <code>Trainer</code> 实例，指定保存路径、batch 大小、梯度累积步数、日志记录频率、学习率等。<code>SwanLabCallback</code> 用于将训练过程发送至 <code>SwanLab</code> 进行实时监控。</p><h3 id="9-训练模型"><a href="#9-训练模型" class="headerlink" title="9. 训练模型"></a>9. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainer.train()</span><br></pre></td></tr></table></figure><p>调用 <code>.train()</code> 开始训练。</p><h3 id="10-模型推理与评估"><a href="#10-模型推理与评估" class="headerlink" title="10. 模型推理与评估"></a>10. 模型推理与评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">messages, model, tokenizer</span>):</span><br><span class="line">    text = tokenizer.apply_chat_template(messages, tokenize=<span class="literal">False</span>, add_generation_prompt=<span class="literal">True</span>)</span><br><span class="line">    model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(device)</span><br><span class="line">    generated_ids = model.generate(model_inputs.input_ids, max_new_tokens=<span class="number">512</span>)</span><br><span class="line">    generated_ids = [output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)]</span><br><span class="line">    <span class="keyword">return</span> tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>predict</code> 函数实现了模型推理功能，将输入转成模型格式后生成输出文本。</p><h3 id="11-测试集上的推理"><a href="#11-测试集上的推理" class="headerlink" title="11. 测试集上的推理"></a>11. 测试集上的推理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_json(test_jsonl_new_path, lines=<span class="literal">True</span>)[:<span class="number">10</span>]</span><br><span class="line">test_text_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> test_df.iterrows():</span><br><span class="line">    instruction = row[<span class="string">&#x27;你是一个文本分类领域的专家，你会接收到一段文本和几个潜在的分类选项列表，请输出文本内容的正确分类&#x27;</span>]</span><br><span class="line">    input_value = row[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;instruction&#125;</span>&quot;</span>&#125;, &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;input_value&#125;</span>&quot;</span>&#125;]</span><br><span class="line">    response = predict(messages, model, tokenizer)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;response&#125;</span>&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    result_text = <span class="string">f&quot;<span class="subst">&#123;messages[<span class="number">0</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">1</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">    test_text_list.append(swanlab.Text(result_text, caption=response))</span><br><span class="line"></span><br><span class="line">swanlab.log(&#123;<span class="string">&quot;Prediction&quot;</span>: test_text_list&#125;)</span><br><span class="line">swanlab.finish()</span><br></pre></td></tr></table></figure><p>在测试集上对模型进行评估，将预测结果和输入对比，并将输出文本记录到 <code>SwanLab</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微调大模型&quot;&gt;&lt;a href=&quot;#微调大模型&quot; class=&quot;headerlink&quot; title=&quot;微调大模型&quot;&gt;&lt;/a&gt;微调大模型&lt;/h2&gt;&lt;p&gt;源代码来自:&lt;a href=&quot;https://www.cnblogs.com/obullxl/p/18312594/</summary>
      
    
    
    
    
  </entry>
  
</feed>
