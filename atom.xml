<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-17T07:50:33.596Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Query_Execution</title>
    <link href="http://example.com/2023/08/17/Query-Execution/"/>
    <id>http://example.com/2023/08/17/Query-Execution/</id>
    <published>2023-08-17T07:50:33.000Z</published>
    <updated>2023-08-17T07:50:33.596Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CMU15-445 B+tree</title>
    <link href="http://example.com/2023/08/17/B-tree/"/>
    <id>http://example.com/2023/08/17/B-tree/</id>
    <published>2023-08-17T07:07:54.000Z</published>
    <updated>2023-08-17T07:48:51.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-树的介绍（以InnoDB为例）"><a href="#B-树的介绍（以InnoDB为例）" class="headerlink" title="B+树的介绍（以InnoDB为例）"></a>B+树的介绍（以InnoDB为例）</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>B+树只有叶子结点存储数据，内部节点和根结点只存储索引。</p><p>另外，索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：</p><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><h2 id="bustub"><a href="#bustub" class="headerlink" title="bustub"></a>bustub</h2><p>在这这个实验中只需要实现三个接口：查询、插入和删除。</p><p>需要使用我们在 Project 1 中实现的 buffer pool manager 来获取 page。</p><p>internal page 中，KV 对的 K 是能够比较大小的索引，V 是 page id，用来指向下一层的节点。</p><p>leaf page 和 internal page 的内存布局基本一样，只是 leaf page 多了一个成员变量 <code>next_page_id</code>，指向下一个 leaf page（用于 range scan）</p><p>internal page 中储存 key 和 child page id，那么在拿到 page id 后如何获得对应的 page 指针？用 Project 1 中实现的 buffer pool。</p><p><code>Page *page = buffer_pool_manager_-&gt;FetchPage(page_id);</code></p><p>新建一个结点&#x2F;Page, 示例为新建root</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">page_id_t</span> page_id;</span><br><span class="line">Page *page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;page_id);</span><br><span class="line"><span class="keyword">auto</span> leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">leaf_node-&gt;<span class="built_in">Init</span>(page_id, INVALID_PAGE_ID, leaf_max_size_);</span><br><span class="line">root_page_id_ = page_id;</span><br><span class="line">buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page_id, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>找到leaf page，然后二分法找到key，就能够找到对应的record id。</p><p>唯一要注意的问题就是我们在拿到 page id 后，调用 buffer pool 的 FetchPage() 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，无法从 disk 读取其他的 page。比较合适的做法是，在本次操作中，找出 page 最后一次被使用的地方，并在最后一次使用后 unpin。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>假设叶子结点插入值之后满了，要考虑break的问题，要向父节点中插入break之后新的索引，假设父节点也满了，也要break（这是一个递归的过程），注意这里内部节点的第一个位置只存放value，而不存放key</p><p><img src="/../imgs/B+insert.png"></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>delete的时候，如果当前节点小于最小size（Max size&#x2F;2），首先考虑从兄弟结点偷一个过来，如果兄弟结点投不了，就考虑merge。因为是一个向上递归删除的过程，所以merge的时候要区分是叶节点还是内部节点。</p><p>这里注意是先删除再做merge或者偷一个key</p><p><img src="/../imgs/b+delete.png"></p><h3 id="锁的问题："><a href="#锁的问题：" class="headerlink" title="锁的问题："></a>锁的问题：</h3><p>螃蟹式加锁（区分读锁和写锁）</p><p>参考课件:<a href="https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf">https://15445.courses.cs.cmu.edu/fall2022/slides/09-indexconcurrency.pdf</a></p><p>先给父节点加锁，然后给子节点加锁，如果确认子节点安全（不会发生merge或者break），此时解锁父节点</p><p><img src="/../imgs/image-22.png" alt="Alt text"></p><p>当寻找兄弟结点时，一个指针往前走，假设另一个进程在往后寻找兄弟结点，此时会不会发生死锁？</p><p>不会，因为当子节点需要寻找兄弟节点时，说明此时该节点不安全，所以父节点的锁不会释放，也就意味着另一个子进程拿不到父节点的锁，只会等待。</p><p>如何确定该page有没有被锁住？使用事务管理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;B-树的介绍（以InnoDB为例）&quot;&gt;&lt;a href=&quot;#B-树的介绍（以InnoDB为例）&quot; class=&quot;headerlink&quot; title=&quot;B+树的介绍（以InnoDB为例）&quot;&gt;&lt;/a&gt;B+树的介绍（以InnoDB为例）&lt;/h2&gt;&lt;p&gt;InnoDB 的数据</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU15-445 buffer pool manager</title>
    <link href="http://example.com/2023/08/17/bufferpool/"/>
    <id>http://example.com/2023/08/17/bufferpool/</id>
    <published>2023-08-17T06:29:40.000Z</published>
    <updated>2023-08-17T07:07:06.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库中为什么需要buffer-pool？"><a href="#数据库中为什么需要buffer-pool？" class="headerlink" title="数据库中为什么需要buffer pool？"></a>数据库中为什么需要buffer pool？</h3><p>数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。</p><p>要想提升查询性能，添加缓存。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>通常存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在MySQL中，InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的16KB的大小划分出一个个的页(<code>frame</code>)， Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲(<code>free list</code>)的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><h3 id="Buffer-Pool-Manager-需要实现的功能："><a href="#Buffer-Pool-Manager-需要实现的功能：" class="headerlink" title="Buffer Pool Manager 需要实现的功能："></a>Buffer Pool Manager 需要实现的功能：</h3><p><code>auto NewPgImp(page_id_t *page_id) -&gt; Page * override</code><br>返回一个<code>Page</code>（首先检查free list中有没有空闲的Page，如果有从free list返回，如果没有使用LRU_K算法replace一个页面之后返回, 注意这里的<code>page_id</code>是一个传入参数）</p><p><code>auto FetchPgImp(page_id_t page_id) -&gt; Page * override;</code><br>在buffer pool中可能存在这个page_id, 标记为visit之后返回，不存在就和创建新的Page一样操作</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> <span class="keyword">override</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a>Extendible Hash Table</h3><h4 id="为什么这里需要一个hash表？"><a href="#为什么这里需要一个hash表？" class="headerlink" title="为什么这里需要一个hash表？"></a>为什么这里需要一个hash表？</h4><p>外部使用的参数为<code>page_id</code> , 内部转换为<code>frame_id</code>, 每一个frame对应着一个page。从<code>page_id</code>转换为<code>frame_id</code>通过hash表实现。</p><p><strong>重点在于如何去管理桶，当桶满了再插入时应该如何操作。</strong></p><p>每个桶（bucket）都有一个本地深度（local depth）和一个全局深度（global depth）</p><p>本地深度是指每个桶中存储的键值对的哈希值的前缀长度。例如，如果本地深度为2，则桶中存储的键值对的哈希值的前两位必须相同。</p><p>全局深度是指哈希表中所有桶的本地深度的最大值。它表示哈希表的索引空间的大小。</p><p>如果插入时全局深度等于本地深度，哈希目录扩展为两倍（左移一位）<br>此时针对桶的处理最简单的办法是也新建一倍的桶，每一个桶对应着每个索引，但是这样很浪费空间，当有数据插入的时候再考虑新建桶。<br>扩展目录为double，更新index，将桶中的数据重新插入到新的桶中。</p><p><img src="/../imgs/image-21.png" alt="Alt text"></p><h3 id="LRU-K算法"><a href="#LRU-K算法" class="headerlink" title="LRU_K算法"></a>LRU_K算法</h3><p>和传统的LRU不一样的地方在于，传统的LRU是淘汰最近未使用的，而LRU_K多维护了一个record链表，用于记录访问次数大于等于K的Page，当淘汰时优先淘汰访问次数小于K次的，若所有的Page访问次数都大于K次才从record链表中去淘汰。</p><p><img src="/../imgs/image-20.png" alt="Alt text"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/../imgs/bufferpool.png"></p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li><p>是否是dirty，是在Page内部用变量标识的，在buffer pool中没有使用额外的list管理脏页。</p></li><li><p>在buffer pool中的Page array的作用：<code>pages_</code>用来管理已经在bufferp pool中的Page</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page_table_-&gt;<span class="built_in">Find</span>(page_id, frame_id)) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">    pages_[frame_id].pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> &amp;pages_[frame_id];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库中为什么需要buffer-pool？&quot;&gt;&lt;a href=&quot;#数据库中为什么需要buffer-pool？&quot; class=&quot;headerlink&quot; title=&quot;数据库中为什么需要buffer pool？&quot;&gt;&lt;/a&gt;数据库中为什么需要buffer pool？&lt;/</summary>
      
    
    
    
    <category term="database" scheme="http://example.com/categories/database/"/>
    
    
  </entry>
  
  <entry>
    <title>malloc是如何和物理地址关联上的？</title>
    <link href="http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/"/>
    <id>http://example.com/2023/08/16/malloc%E6%98%AF%E5%A6%82%E4%BD%95%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%85%B3%E8%81%94%E4%B8%8A%E7%9A%84/</id>
    <published>2023-08-16T17:38:52.000Z</published>
    <updated>2023-08-16T09:49:33.551Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-19.png"></p><ol><li><p>malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。</p></li><li><p>操作系统维护着可用物理内存的信息,知道哪些内存地址 当前未被使用。当收到malloc的请求时,它会从可用物理内存中选择一块未使用的内存,将其标记为已分配,并返回给应用程序。</p></li><li><p>在32位系统中,malloc返回的地址是虚拟地址,需要经过MMU地址转换找到对应的物理地址。64位系统中,malloc的地址空间通常就直接对应物理地址空间。</p><p> a. 在32位系统中,CPU可以寻址的虚拟地址空间比较小,一般为4GB左右。而物理内存可能会超过4GB。为了让进程可以访问超过4GB的物理内存,操作系统会使用虚拟内存技术,将虚拟地址映射到物理地址上。malloc返回的虚拟地址需要通过MMU(内存管理单元)翻译成物理地址,才能真正访问到内存。</p><p> b. 而在64位系统中,虚拟地址空间巨大(16EB),远远大于当前的物理内存大小。所以操作系统可以选择把虚拟地址直接映射到物理地址上,这种称为平坦内存模型。在这种情况下,malloc返回的地址就是物理地址,不需要再做地址转换。应用程序把malloc返回的地址直接作为物理地址使用即可。</p></li></ol><h3 id="平坦内存模型-Flat-Memory-Model"><a href="#平坦内存模型-Flat-Memory-Model" class="headerlink" title="平坦内存模型(Flat Memory Model)"></a>平坦内存模型(Flat Memory Model)</h3><ol><li>在平坦内存模型下,进程的虚拟地址与物理地址是一一对应的。操作系统不会进行地址转换,进程使用的虚拟地址就是对应物理内存的物理地址。</li><li>由于虚拟地址直接对应物理地址,不需要进行地址转换,所以省去了地址转换所带来的性能开销。</li><li>程序直接使用虚拟地址访问物理内存,不需要区分逻辑地址和物理地址,编程模型简单。</li><li>64位系统拥有极其大的虚拟地址空间(16EB),使得直接映射成为可能。虚拟地址空间大于目前的物理内存容量。</li><li>由于省去了内存虚拟化,无法实现弹性调配物理页框,可能会出现较严重的内存碎片。</li><li>很多64位系统不会选择完全平坦的模型,而是在一定范围内做映射,同时配合页表实现虚拟内存。综合利用了平坦模型与传统虚拟内存的优点。</li></ol><h3 id="MMU-Memory-Management-Unit"><a href="#MMU-Memory-Management-Unit" class="headerlink" title="MMU(Memory Management Unit)"></a>MMU(Memory Management Unit)</h3><p>有些系统MMU集成在CPU中，有些系统是单独芯片实现，通过地址总线和CPU连接。（地址总线、数据总线、控制总线–&gt;传递信号）</p><ol><li>地址转换 MMU负责将CPU产生的虚拟地址转换成物理地址。转换过程需要参考TLB,根据虚拟地址的高位找到对应的页表项,翻译出物理页号,与虚拟地址的低位组合成物理地址。</li><li>页面置换 当访问的页面不在物理内存时,MMU会触发页面置换（<em>页面置换算法通常不是由MMU(内存管理单元)直接实现的,而是由操作系统内核的虚拟内存管理子系统来实现。页表和地址转换是由MMU硬件来完成,但确定哪些页面需要换出、加载,以及页面替换策略则由操作系统内核的虚拟内存管理机制决定。</em>）,将内存中的某一页换出,将需要访问的页换入物理内存。</li><li>存取权限检查 MMU会检查每次地址转换后的物理内存访问权限,例如是否可读、可写、可执行,避免非法访问。</li><li>缓存一致性 MMU会与CPU缓存协同工作,实现缓存一致性,保证内存访问正确。</li><li>地址空间隔离 MMU为每个进程维护一个独立的地址空间,实现进程间的内存隔离。</li><li>中断与异常 若地址非法或者缺页等异常,MMU会触发中断信号,通知CPU进行异常处理。</li><li>硬件缓存 部分MMU集成了TLB等缓存结构,加速地址转换的速度。</li></ol><h3 id="为什么MMU可以解决内存碎片的问题？"><a href="#为什么MMU可以解决内存碎片的问题？" class="headerlink" title="为什么MMU可以解决内存碎片的问题？"></a>为什么MMU可以解决内存碎片的问题？</h3><ol><li>MMU实现了虚拟地址到物理地址的映射,程序只需要一个连续的虚拟地址空间。操作系统可以将不连续的物理内存片段映射到该连续虚拟地址空间上。通过这种映射,即使物理内存分布不连续,程序视图也是一个连续空间,可以任意使用而不会出现碎片。操作系统会负责这些不连续物理页的映射和调度,对上层应用透明。</li><li>当物理内存使用产生外部碎片时,虚拟存储技术可以进行碎片回收,将闲置的小块内存映射给其他程序使用。</li><li>同时,虚拟内存可以将暂时不用的内存页换出到磁盘,腾出物理内存空间供其他程序使用,减少内存碎片。</li><li>进而避免了严重的外部碎片,提高了物理内存的利用效率。</li></ol><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>一个计算系统通常包含多级缓存,任何两个存储层次之间都可能存在数据一致性的问题。</p><ol><li><p>CPU缓存与硬盘缓存</p></li><li><p>多核CPU之间</p></li><li><p>各级系统缓存之间</p><p> MMU与CPU缓存的一致性是通过以下几种方式实现的:<br> a. 缓存一致性协议 CPU和MMU之间通过一定的硬件协议(如Intel的MESI协议)来维持缓存和主存的数据一致性。当缓存数据被修改时,会根据协议规则通知MMU将主存更新。</p><p> b. 缓存锁定 针对一些关键数据,CPU缓存会被锁定,每次访问必须从MMU加载,而不是缓存中的拷贝。保证了这部分数据的一致性。</p><p> c. 地址翻译表同步 地址翻译表如TLB也存放在CPU高速缓存中,MMU会同步更新CPU中的翻译表缓存,保证访问获取的是最新翻译关系。</p><p> d. 缓存行注释 MMU可以向缓存中的缓存行添加标记信息,如是否可缓存、是否已修改等,方便缓存控制。</p></li><li><p>分布式缓存系统</p></li><li><p>存储设备之间</p></li><li><p>客户端缓存</p></li></ol><h3 id="malloc调用时什么时候用sys-mmap-什么时候用brk？"><a href="#malloc调用时什么时候用sys-mmap-什么时候用brk？" class="headerlink" title="malloc调用时什么时候用sys_mmap, 什么时候用brk？"></a>malloc调用时什么时候用sys_mmap, 什么时候用brk？</h3><p>在调用malloc时会产生系统调用，切换到内核态，然后执行系统调用<br>在malloc调用时,是否使用sys_mmap或brk分配内存,主要取决于请求的内存大小:</p><ol><li>对于较小的内存请求,malloc通常会使用brk系统调用去扩展程序的堆区。</li><li>当请求较大内存页(一般超过128KB)时,malloc会使用mmap系统调用去映射匿名内存页。</li></ol><p>mmap相比brk的优势在于:</p><ul><li>可以指定地址对齐,提高效率</li><li>可以随时释放不连续的大内存块</li><li>避免堆区碎片</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-19.png&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;malloc函数用于在堆上动态分配内存,它会向操作系统请求一块未使用的内存,然后返回这块内存的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作系统维护着可用物理内存的信息,知道</summary>
      
    
    
    
    <category term="os" scheme="http://example.com/categories/os/"/>
    
    
  </entry>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-08-16T01:54:10.363Z</published>
    <updated>2023-08-16T08:49:05.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/../imgs/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed --save</code></p><h3 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h3><p>在vscode中预览是有图片的，生成和发布之后无法显示图片。<br><img src="/../imgs/image-4.png"></p><p>因为在源文件的 post 目录下新建了 img 子目录,然后在 markdown 中使用相对路径引用图片。</p><p>这在本地预览时可以正常显示,但是部署后会出错。</p><p>因为 Hexo 在生成时,会将 post 中的 markdown 和资源文件一起复制到 public 目录,相对位置不变。</p><p>但是 img 子目录不会自动复制过去。所以 public 中找不到 img 中的图片,导致无法显示。</p><p><strong>解决方法：</strong> 将img重命名为imgs(因为会和主题的img文件夹命名冲突)，然后将文件夹移动到<code>source</code>目录下，而不是放在<code>_posts</code>目录下，注意粘贴的设置也需要修改为imgs。</p><p><img src="/../imgs/image-6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo Cannot GET/</title>
    <link href="http://example.com/2023/08/15/hexo_Cannot_GET/"/>
    <id>http://example.com/2023/08/15/hexo_Cannot_GET/</id>
    <published>2023-08-15T07:33:02.000Z</published>
    <updated>2023-08-16T03:32:00.098Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>在hexo搭建博客的过程中，出现Cannot GET&#x2F;xxx的错误。</p><h3 id="查看是否缺少组件"><a href="#查看是否缺少组件" class="headerlink" title="查看是否缺少组件"></a>查看是否缺少组件</h3><ol><li><p>到public目录下找到xxx文件是否存在，我的错误是<code>Cannot GET/</code>，所以去找<code>index.html</code>是否存在。</p></li><li><p>不存在，执行<code>hexo clean &amp;&amp; hexo g</code>重新生成</p></li><li><p>还是不存在，执行<code>npm audit fix</code>或者是<code>npm ls --depth 0</code>，查看是否缺少组件。通过<code>npm install hexo-xxx-xxx</code>安装</p></li><li><p>执行完毕后发现我并不缺少组件。尝试其他解决办法。</p></li></ol><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p><code>config–&gt;index.js</code>中的 <code>assetsPublicPath: &#39;/&#39;</code>改成<code>assetsPublicPath: ‘./’</code></p><h3 id="没有文件"><a href="#没有文件" class="headerlink" title="没有文件"></a>没有文件</h3><p>在路径<code>\source\_posts\</code>中至少需要存放一篇文档，否则会出现<code>Cannot GET/</code>错误。</p><h3 id="nodejs等级太高"><a href="#nodejs等级太高" class="headerlink" title="nodejs等级太高"></a>nodejs等级太高</h3><p>官方文档参考链接：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><p><img src="/../imgs/image-1.png"></p><h3 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h3><p>将所有markdown文件的名称替换为英文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hexo搭建博客的过程中，出现Cannot GET&amp;#x2F;xxx的错误。&lt;/p&gt;
&lt;h3 id=&quot;查看是否缺少组件&quot;&gt;&lt;a href=&quot;#查看是否缺少组件&quot; class=&quot;headerlink&quot; title=&quot;查</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解合集</title>
    <link href="http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/"/>
    <id>http://example.com/2022/10/15/leetoce%E9%A2%98%E8%A7%A3%E5%90%88%E9%9B%86/</id>
    <published>2022-10-15T07:33:02.000Z</published>
    <updated>2023-08-16T09:06:32.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DFS-回溯"><a href="#DFS-回溯" class="headerlink" title="DFS&#x2F;回溯"></a>DFS&#x2F;回溯</h3><p><strong>以整数拆分为例：</strong><br><img src="/../imgs/image-5.png"></p><p><strong>剪枝条件</strong></p><ul><li>当和为n时，保存结果</li><li>当和大于n时，进行剪枝</li></ul><p>在DFS中，同一排的结点是在同一个函数调用中进行处理，如上图中的第一排，1、2、3、4、这4个结点是在第一次函数调用中进行处理。</p><p><strong>因此使用一个for循环来处理同一排的结点。</strong><br>因为元素可以重复取用，本来for循环的起始位置应该都为1，但是为了避免重复，我们可以假设for循环的起始位置为其父节点的值，这里用变量<code>index</code>表示</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="comment">//n表示要拆分的数 index表示当前函数从哪个数开始拆 sum表示当前的和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == n) &#123;<span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">myPrint</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; n) <span class="keyword">return</span>;<span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; n; ++i) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//元素可以重复使用，下一次还是从i开始拆分，拆到n为止</span></span><br><span class="line">        <span class="built_in">split</span>(n, i, sum + i);</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/combinations/">77 组合</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">216. 组合总和 III</a><br><a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-sdy-r-mava/">39. 组合总和</a><br><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/c-hui-su-suan-fa-by-sdy-r-6soj/">17. 电话号码的字母组合</a><br><a href="https://leetcode.cn/problems/combination-sum-ii/solution/by-sdy-r-vecj/">40. 组合总和 II</a><br><a href="https://leetcode.cn/problems/subsets-ii/solution/by-sdy-r-nehc/">90. 子集 II</a><br><a href="https://leetcode.cn/problems/permutations-ii/solution/by-sdy-r-fiul/">47. 全排列 II</a><br><a href="https://blog.csdn.net/wenningker/article/details/124399435?spm=1001.2014.3001.5502">679. 24点游戏</a><br><a href="https://leetcode.cn/problems/longest-univalue-path/solution/by-sdy-r-0cz4/">687. 最长同值路径</a></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><a href="https://www.bilibili.com/video/BV1X741127ZM/?spm_id_from=333.337.search-card.all.click&vd_source=59139a795dc5f3ee3da07683650b7b16">一个超级实用的视频</a><br><strong>状态表示：</strong><br>f 函数代表什么状态？<br>写出状态表示之后我们会有一个f函数的集合，代表递推到f(i)时，有多少种可能的状态。</p><p><strong>动态转移方程</strong><br>把集合中的每一种可能表示出来，对应要求的结果（求最大、最小、求和等）写出动态转移方程。</p><ul><li>状态表示</li><li>状态集，从状态集求出当前状态</li></ul><p><strong>思考当前状态对比前一个状态会有什么变化：</strong></p><ul><li>从前一步加1？</li><li>等于前一步？</li></ul><p><strong>如下图所示</strong><br><img src="/../imgs/image-7.png"></p><p><a href="https://blog.csdn.net/wenningker/article/details/124410311?spm=1001.2014.3001.5502">路径和有关的题目</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solution/by-sdy-r-6p9s/">714. 买卖股票的最佳时机含手续费</a></p><p><a href="https://leetcode.cn/problems/word-break/solution/by-sdy-r-cj3h/">139. 单词拆分</a></p><p><a href="https://leetcode.cn/problems/integer-break/solution/by-sdy-r-q33e/">343. 整数拆分</a></p><p><a href="https://leetcode.cn/problems/house-robber-iii/solution/by-sdy-r-9rnk/">337. 打家劫舍 III</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/by-sdy-r-hrxf/">300. 最长递增子序列</a></p><p><a href="https://leetcode.cn/problems/distinct-subsequences-ii/solution/by-sdy-r-atvj/">940. 不同的子序列 II</a></p><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain/solution/by-sdy-r-g02s/">646. 最长数对链</a></p><p><a href="https://leetcode.cn/problems/triangle/solution/by-sdy-r-fuap/">120. 三角形最小路径和</a></p><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a></p><p><a href="https://leetcode.cn/problems/wildcard-matching/solution/by-sdy-r-pm4u/">44. 通配符匹配</a></p><p><a href="https://leetcode.cn/problems/edit-distance/solution/by-sdy-r-boss/">72. 编辑距离</a></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p><strong>每次选取局部最优解，得到最终的最优解。</strong><br><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a><br><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/solution/by-sdy-r-3ec9/">406. 根据身高重建队列</a><br><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solution/by-sdy-r-17wh/">452. 用最少数量的箭引爆气球</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列 小顶堆</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">//降序队列  大顶堆 默认情况</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/solution/by-sdy-r-umuh/">2406. 将区间分为最少组数</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/meeting-rooms-iii/solution/by-sdy-r-xle0/">2402. 会议室 III</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124468136?spm=1001.2014.3001.5501">23. 合并k个有序链表</a></p><h4 id="数组-链表-哈希"><a href="#数组-链表-哈希" class="headerlink" title="数组&#x2F;链表&#x2F;哈希"></a>数组&#x2F;链表&#x2F;哈希</h4><p><strong>数组：</strong> 查找效率高，插入和删除效率低<br><strong>链表：</strong> 插入删除效率高，查找效率低</p><p><strong>哈希：</strong> </p><ul><li>思想：通过哈希函数得到的键值，使其能够高效查找</li><li>当键值重复时，处理哈希冲突</li><li>在C++中unordered_set 和unordered_map的底层实现时哈希表</li></ul><p><a href="https://leetcode.cn/problems/4sum-ii/solution/by-sdy-r-jlw2/">454. 四数相加 II</a><br><a href="https://leetcode.cn/problems/optimal-partition-of-string/solution/by-sdy-r-uq9h/">2405. 子字符串的最优划分</a><br><a href="https://leetcode.cn/problems/most-popular-video-creator/solution/by-sdy-r-tknt/">6221. 最流行的视频创作者</a></p><h4 id="栈-队列"><a href="#栈-队列" class="headerlink" title="栈&#x2F;队列"></a>栈&#x2F;队列</h4><p><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/solution/by-sdy-r-563t/">907. 子数组的最小值之和</a><br><a href="https://leetcode.cn/problems/parsing-a-boolean-expression/solution/c-by-sdy-r-nxof/">1106. 解析布尔表达式</a></p><h5 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h5><p>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。<br><a href="https://leetcode.cn/problems/daily-temperatures/solution/by-sdy-r-7za8/">739. 每日温度</a><br><a href="https://leetcode.cn/problems/next-greater-element-ii/solution/by-sdy-r-t3b7/">503. 下一个更大元素 II</a></p><h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><p><a href="https://blog.csdn.net/wenningker/article/details/126799292?spm=1001.2014.3001.5502">前缀树</a></p><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p><strong>并查集由两个部分构成：</strong></p><ul><li><code>find()</code>函数，发现x的根</li><li><code>Union()</code>函数，合并</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现x的根，最初每个元素的根都是自己</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfind</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[x] != x) &#123;</span><br><span class="line">            parent[x] = <span class="built_in">myfind</span>(parent,parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将y的根给x的根，将x和y合并为一堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myunion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;parent,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        parent[<span class="built_in">myfind</span>(parent,x)] = <span class="built_in">myfind</span>(parent,y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wenningker/article/details/124127763?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166597671316800186587518%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166597671316800186587518&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-124127763-null-null.nonecase&utm_term=%E5%B9%B6%E6%9F%A5%E9%9B%86&spm=1018.2226.3001.4450">并查集</a></p><p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p><p><a href="https://leetcode.cn/problems/shortest-bridge/solution/by-sdy-r-ao55/">934. 最短的桥</a> BFS+DFS</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><h3 id="双指针-滑动窗口"><a href="#双指针-滑动窗口" class="headerlink" title="双指针&#x2F;滑动窗口"></a>双指针&#x2F;滑动窗口</h3><p><strong>主要是考虑左指针往右走的条件。</strong><br><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/solution/by-sdy-r-yayj/">209. 长度最小的子数组</a></p><p><a href="https://leetcode.cn/problems/minimum-window-substring/solution/by-sdy-r-zwx8/">76. 最小覆盖子串</a></p><p><a href="https://blog.csdn.net/wenningker/article/details/124530777?spm=1001.2014.3001.5502">90. 水果成蓝</a></p><p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/by-sdy-r-tu81/">239. 滑动窗口最大值</a></p><p><a href="https://leetcode.cn/problems/longest-nice-subarray/solution/by-sdy-r-glyh/">2401. 最长优雅子数组</a></p><p><a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-sdy-r-sm3x/">915. 分割数组</a></p><p><a href="https://leetcode.cn/problems/sort-colors/solution/by-sdy-r-tg7s/">75. 颜色分类</a></p><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/kuai-man-zhi-zhen-yi-bian-sao-miao-by-sd-pwps/">19. 删除链表的倒数第 N 个结点</a></p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>对于二叉树来书，考虑遍历方式：</p><ul><li>前序遍历：先处理父节点，再处理孩子节点</li><li>中序遍历：先处理左孩子，再处理父节点，最后处理右孩子</li><li>后序遍历：先处理孩子结点，再处理父节点</li></ul><p><strong>大部分题目都是使用的后序遍历来求解：因为处理父节点时往往需要用到子节点的结果</strong></p><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/by-sdy-r-307g/">106. 从中序与后序遍历序列构造二叉树</a></p><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/solution/by-sdy-r-6m2z/">98. 验证二叉搜索树</a></p><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-sdy-r-n5e3/">236. 二叉树的最近公共祖先</a></p><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/by-sdy-r-vovn/">701. 二叉搜索树中的插入操作</a></p><p><a href="https://leetcode.cn/problems/maximum-binary-tree-ii/solution/by-sdy-r-96ic/">998. 最大二叉树 II</a></p><p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/by-sdy-r-x7yd/">538. 把二叉搜索树转换为累加树</a></p><p><a href="https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/solution/c-by-sdy-r-osdi/">6242. 二叉搜索树最近节点查询</a><br>序列化二叉搜索树</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><table><thead><tr><th>操作</th><th>结果</th><th>特性</th></tr></thead><tbody><tr><td>~</td><td>取反，0变为1，1变为0</td><td></td></tr><tr><td>a&amp;b</td><td>且，ab同时为1时才取1</td><td>a &amp; b &lt;&#x3D; min(a,b)，交换律、结合律，越取越小</td></tr><tr><td>a 或 b</td><td>a和b其中有一个为1，最终结果就是1</td><td>越取越大</td></tr><tr><td>a ^ b</td><td>a和b相同时为1，不同为0</td><td></td></tr><tr><td>&lt;&lt; 和 &gt;&gt;</td><td>左移一位，相当于*2，右移一位，相当于&#x2F;2</td><td></td></tr></tbody></table><p><a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/solution/by-sdy-r-6vt8/">2419. 按位与最大的最长子数组</a></p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p><strong>根据题意模拟，主要是代码细节要注意。</strong></p><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/solution/by-sdy-r-g20f/">59. 螺旋矩阵 II</a></p><p><a href="https://leetcode.cn/problems/EXvqDp/solution/by-sdy-r-wlw0/">LCP 63. 弹珠游戏</a></p><p><a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/by-sdy-r-yemm/">1441. 用栈操作构建数组</a></p><p><a href="https://leetcode.cn/problems/k-th-symbol-in-grammar/solution/by-sdy-r-alxj/">779. 第K个语法符号</a></p><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/solution/by-sdy-r-a32l/">6222. 美丽整数的最小增量</a></p><p><a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution/by-sdy-r-lrwi/">1620. 网络信号最好的坐标</a></p><p><a href="https://leetcode.cn/problems/global-and-local-inversions/solution/c-by-sdy-r-8gqu/">775. 全局倒置与局部倒置</a></p><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>主要多考虑组合数学</p><p><strong>从起点到终点的所有路径：给定一个$n$和一个$k，n$代表要走的步数，$k$代表终点，从0出发，每次可以选择往左走或者往右走，走到$k$，有多少种路径？</strong></p><ol><li>假设$a$等于往右走的步数，往左走的步数为$k-a$,走到$n$时的步数为$a-(k-a)&#x3D;a$，$a&#x3D;(k+n)&#x2F;2$</li><li>当且仅当$(k+n)$为偶数时有解</li><li>等价于从$k$步里面选$a$步往右走，所以结果是$C^{(k+n)&#x2F;2}_k$</li></ol><p><a href="https://leetcode.cn/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/solution/by-sdy-r-dytx/">2400. 恰好移动 k 步到达某一位置的方法数目</a></p><p><strong>C++如何计算组合数？</strong></p><p>从<code>n</code>个里面选<code>m</code>个，当前这个选，就变为从<code>n-1</code>个里面选<code>m-1</code>个，当前不选，就变成从<code>n-1</code>个里面选<code>m</code>个。</p><p>根据公式:：$C_n^m&#x3D;C^m_{n-1}+C_{n-1}^{m-1}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res[<span class="number">67</span>][<span class="number">67</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span> || m==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(res[n][m] != <span class="number">0</span>)<span class="keyword">return</span> res[n][m];<span class="comment">//保存状态</span></span><br><span class="line">    <span class="keyword">return</span> res[n][m] = <span class="built_in">C</span>(n<span class="number">-1</span>,m)+ <span class="built_in">C</span>(n<span class="number">-1</span>,m<span class="number">-1</span>);<span class="comment">//赋值给res[n][m]并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>,<span class="built_in">C</span>(<span class="number">6</span>,<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排序不等式：</strong><br>$a_1 \leq a_2 \leq … \leq a_n$<br>$b_1 \leq b_2 \leq … \leq b_n$</p><p>最大值&#x3D; $a_1b_1+a_2b_2+…+a_nb_n$<br>最小值&#x3D; $a_1b_n+a_2b_{n-1}+…+a_nb_1$</p><p><strong>求解最大公约数和最小公倍数</strong></p><ul><li>最大公约数：数组中所有数都能整除的最大数</li><li>最小公倍数：数组中所有数的最小倍数</li></ul><p>$a和b的最小公倍数&#x3D;a*b&#x2F;(a和b的最大公约数)$<br>求解最大公约数使用<code>gcd(a,b)</code>函数</p><p><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/solution/-by-sdy-r-z1sc/">902. 最大为 N 的数字组合</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/">6234. 最小公倍数为 K 的子数组数目</a></p><p><a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">2447. 最大公因数等于 K 的子数组数目</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DFS-回溯&quot;&gt;&lt;a href=&quot;#DFS-回溯&quot; class=&quot;headerlink&quot; title=&quot;DFS&amp;#x2F;回溯&quot;&gt;&lt;/a&gt;DFS&amp;#x2F;回溯&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;以整数拆分为例：&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/../i</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>C++实现一个简单的线程池</title>
    <link href="http://example.com/2022/09/15/C++%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/09/15/C++%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-09-15T07:33:02.000Z</published>
    <updated>2023-08-16T09:02:22.022Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/../imgs/image-8.png" alt="Alt text"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="任务结构体"><a href="#任务结构体" class="headerlink" title="任务结构体"></a>任务结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务结构体</span></span><br><span class="line"><span class="keyword">using</span>  callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Task</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Task</span>(callback function,<span class="type">void</span>* arg):</span><br><span class="line">    <span class="built_in">function</span>(function),<span class="built_in">arg</span>(arg)&#123;&#125;</span><br><span class="line">    <span class="comment">//函数指针</span></span><br><span class="line">    callback function;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//取出任务</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取当前任务的个数，内联函数不会进行压栈，通过代码替换实现</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">taskNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;<span class="comment">//添加互斥锁</span></span><br><span class="line">    queue&lt;Task&gt; m_taskQ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line">    <span class="comment">//给线程池添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getBusyNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLiveNum</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//工作的线程任务函数</span></span><br><span class="line">    <span class="comment">//静态成员函数定义时就分配地址，普通成员函数只有实例化才有地址</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程任务函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="comment">//单个线程退出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaskQueue* taskQ;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="type">pthread_t</span> managerID;<span class="comment">//管理者线程ID</span></span><br><span class="line">    <span class="type">pthread_t</span>* threadID;<span class="comment">//工作线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum;<span class="comment">//最小线程数量</span></span><br><span class="line">    <span class="type">int</span> maxNum;<span class="comment">//最大线程数量</span></span><br><span class="line">    <span class="type">int</span> busyNum;<span class="comment">//忙的线程个数</span></span><br><span class="line">    <span class="type">int</span> liveNum;<span class="comment">//存活的线程个数</span></span><br><span class="line">    <span class="type">int</span> exitNum;<span class="comment">//要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool;<span class="comment">//锁定整个线程池</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty;<span class="comment">//任务队列是否为空</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NUMBER = <span class="number">2</span>;<span class="comment">//每次创建线程的数量</span></span><br><span class="line">    <span class="type">bool</span> shutdown;<span class="comment">//是不是要销毁线程池，销毁为1，不销毁为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()&#123;</span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task&amp; task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(callback f,<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//访问任务队列之前先加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    m_taskQ.<span class="built_in">push</span>(<span class="built_in">Task</span>(f,arg));</span><br><span class="line">    <span class="comment">//访问结束解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Task t;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">if</span>(!m_taskQ.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        t = m_taskQ.<span class="built_in">front</span>();</span><br><span class="line">        m_taskQ.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="type">int</span> min,<span class="type">int</span> max)&#123;</span><br><span class="line">        <span class="comment">//实例化任务队列</span></span><br><span class="line">        taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(taskQ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat tackqueue error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        threadID = <span class="keyword">new</span> <span class="type">pthread_t</span>[max];</span><br><span class="line">        <span class="keyword">if</span>(threadID == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;creat threadpool error...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(threadID,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">pthread_t</span>) * max);</span><br><span class="line">        minNum = min;</span><br><span class="line">        maxNum = max;</span><br><span class="line">        busyNum = <span class="number">0</span>;</span><br><span class="line">        liveNum = min;</span><br><span class="line">        exitNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;mutexPool,<span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">           <span class="built_in">pthread_cond_init</span>(&amp;notEmpty,<span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;mutex or condition init fail...&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        shutdown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程，参数：线程，线程的属性，线程要执行的函数，该函数传入的参数</span></span><br><span class="line">        <span class="comment">//成功返回0，失败返回非0值</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;managerID,<span class="literal">NULL</span>,manager,<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; minNum;++i)&#123;</span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;threadID[i],<span class="literal">NULL</span>,worker,<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()&#123;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    shutdown = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//回收管理者线程</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(managerID,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//唤醒阻塞的工作线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; liveNum;++i)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//销毁线程和进程</span></span><br><span class="line">    <span class="keyword">if</span>(threadID) <span class="keyword">delete</span>[]threadID;</span><br><span class="line">    <span class="keyword">if</span>(taskQ) <span class="keyword">delete</span> taskQ;</span><br><span class="line">    <span class="comment">//销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutexPool);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给线程池添加任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里访问任务队列不需要再加锁，因为再任务队列的添加操作里已经加了锁</span></span><br><span class="line">    <span class="comment">//pthread_mutex_lock(&amp;mutexPool);</span></span><br><span class="line">    <span class="keyword">if</span>(shutdown)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加任务</span></span><br><span class="line">    taskQ-&gt;<span class="built_in">addTask</span>(task);</span><br><span class="line">    <span class="comment">//有任务了唤醒工作线程</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取线程池中工作的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getBusyNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="comment">//这里不能直接返回，否则会发生死锁</span></span><br><span class="line">    <span class="type">int</span> busyNum = <span class="keyword">this</span>-&gt;busyNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池中活着的线程个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ThreadPool::getLiveNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="type">int</span> liveNum = <span class="keyword">this</span>-&gt;liveNum;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> liveNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工作的线程任务函数</span></span><br><span class="line"><span class="comment">//这里需要把pool传进来是因为这个函数是静态成员函数，无法访问非静态成员变量</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::worker</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt; (arg);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//因为每一个线程都需要对这个线程池进行操作，所以这里要对线程池加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//当前任务队列是否为空，且线程池没有被关闭</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="comment">//阻塞工作线程</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;notEmpty,&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="comment">//判断是否要销毁线程(该线程被唤醒之后)</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断线程池是否关闭了</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从任务队列中取出一个任务</span></span><br><span class="line">        Task task = pool-&gt;taskQ-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line">        <span class="comment">//忙的线程数加一</span></span><br><span class="line">        pool-&gt;busyNum++;</span><br><span class="line">        <span class="comment">//用完解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot;start working...\n&quot;</span>;</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);</span><br><span class="line">        <span class="comment">//delete task.arg;</span></span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务执行完毕</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        pool-&gt;busyNum--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理者线程任务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadPool::manager</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="built_in">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown)&#123;</span><br><span class="line">        <span class="comment">//每隔三秒检测一次</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//取出线程池中的任务数量和当前线程的数量</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//任务数量</span></span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;taskQ-&gt;<span class="built_in">taskNumber</span>();</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        <span class="comment">//取出忙的线程数量</span></span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="comment">//添加线程</span></span><br><span class="line">        <span class="comment">//任务的个数大于存活的线程数&amp;&amp;存活的线程数小于最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;maxNum &amp;&amp;</span><br><span class="line">            i &lt; pool-&gt;NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadID[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;threadID[i],<span class="literal">NULL</span>,worker,pool);</span><br><span class="line">                    counter++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//销毁线程</span></span><br><span class="line">        <span class="comment">//忙的线程*2小于存活的线程数&amp;&amp;存活的线程数大于最小线程数</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum * <span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = pool-&gt;NUMBER;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; pool-&gt;NUMBER;++i)&#123;</span><br><span class="line">                <span class="comment">//唤醒线程，然后销毁,因为工作的线程没被阻塞，这里唤醒被阻塞的线程</span></span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单个线程退出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程的ID</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; maxNum;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(threadID[i] == tid)&#123;</span><br><span class="line">            threadID[i] = <span class="number">0</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;threadExit() called,&quot;</span>&lt;&lt;tid&lt;&lt;<span class="string">&quot;exiting...\n&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(arg);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;thread&quot;</span>&lt;&lt;<span class="built_in">to_string</span>(<span class="built_in">pthread_self</span>())&lt;&lt;<span class="string">&quot;working,number=&quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span>* num = <span class="keyword">new</span> <span class="built_in">int</span>(i + <span class="number">100</span>);</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>(taskFunc,num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/../imgs/image-8.png&quot; alt=&quot;Alt text&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;任务结构体&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>Trie树</title>
    <link href="http://example.com/2022/09/10/Trie%E6%A0%91/"/>
    <id>http://example.com/2022/09/10/Trie%E6%A0%91/</id>
    <published>2022-09-10T07:33:02.000Z</published>
    <updated>2023-08-16T08:57:35.826Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p></blockquote><p><strong>前缀树的3个基本性质：</strong></p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。 </li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p><strong>时间复杂度：</strong> $O(L)$, $L$是字符串的长度<br><strong>空间复杂度：</strong>$O(n^2)$,最差情况下每个字符串都不相同。</p><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-lfool-k6hb/">leetcode208 实现前缀树</a></p><p><img src="/../imgs/image-9.png" alt="Alt text"></p><p><strong>如何去实现一个前缀树？</strong></p><ul><li>每个结点包含的东西：该节点是否是最后一个、该节点的子节点有哪些。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="built_in">Node</span>():<span class="built_in">isEnd</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">        child.<span class="built_in">resize</span>(<span class="number">26</span>);<span class="comment">//小写字母最多有26个</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ch : child)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch)<span class="keyword">delete</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标记当前结点是否是字符串最后一位</span></span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="comment">//有哪些孩子节点</span></span><br><span class="line">    vector&lt;Node*&gt; child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><strong>这里为什么不用存储当前结点代表的字符呢？</strong><br>因为当查到到当前节点时，说明查找的这个一个字符已经存在。换句话说，该节点的字符存储在父节点中。</li></ul><p><strong>实现初始化、查找某一个字符串是否在该树中、查找某一个前缀是否在该树中、插入一个字符串。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Trie</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">                p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> Node;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某一个字符串是否在该树中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找某一个前缀是否在该树中</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Node* p = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : prefix)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意内存泄漏问题</strong></p><ul><li>在构造函数里构造新的结点，在析构函数中释放</li><li>孩子结点每一个都要释放</li></ul><p><code>vector&lt;Node*&gt; child</code>，也可以用哈希表替代，<code>unordered_set&lt;Node*&gt;  child</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字</summary>
      
    
    
    
    <category term="data_structure" scheme="http://example.com/categories/data-structure/"/>
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C++刷题常用技巧（自用）</title>
    <link href="http://example.com/2022/08/30/%E3%80%90c++%E3%80%91%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2022/08/30/%E3%80%90c++%E3%80%91%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-08-30T07:33:02.000Z</published>
    <updated>2023-08-16T09:14:23.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> N = INT_MIN;</span><br><span class="line"><span class="type">int</span> N = INT_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出</span></span><br></pre></td></tr></table></figure><h3 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h3 id="字符串和数值之间的转换"><a href="#字符串和数值之间的转换" class="headerlink" title="字符串和数值之间的转换"></a>字符串和数值之间的转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="type">int</span> number = <span class="built_in">stoi</span>(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h3 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">56</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">56</span>) - nums.<span class="built_in">begin</span>(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h3 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), str.<span class="built_in">begin</span>(), ::<span class="built_in">tolower</span>());</span><br></pre></td></tr></table></figure><h3 id="小根堆和大根堆"><a href="#小根堆和大根堆" class="headerlink" title="小根堆和大根堆"></a>小根堆和大根堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//greater比较器</span></span><br></pre></td></tr></table></figure><h3 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="c-11的特性"><a href="#c-11的特性" class="headerlink" title="c++11的特性"></a>c++11的特性</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).<span class="built_in">to_string</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).<span class="built_in">to_ulong</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h3><p>将字符串按照空格分隔</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.<span class="built_in">c_str</span>(), <span class="built_in">strlen</span>(a.<span class="built_in">c_str</span>()));</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">cout&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;endl;</span><br><span class="line"><span class="comment">//12 59 36</span></span><br></pre></td></tr></table></figure><h3 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="comment">//将num存储到str中</span></span><br><span class="line">string s = str;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h3 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; node_)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;node&gt; tt;</span><br><span class="line">    tt.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.<span class="built_in">push_back</span>(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">sort</span>(tt.<span class="built_in">begin</span>(), tt.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        cout&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; node_)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout&lt;&lt;pq.<span class="built_in">top</span>().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.<span class="built_in">top</span>().b&lt;&lt;endl;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组按列排序"><a href="#二维数组按列排序" class="headerlink" title="二维数组按列排序"></a>二维数组按列排序</h3><p><strong>按照第一列排序，如果第一列相等按照第二列排序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[](vector&lt;<span class="type">int</span>&gt;&amp;v1,vector&lt;<span class="type">int</span>&gt;&amp;v2)&#123;<span class="keyword">if</span>(v1[<span class="number">0</span>] != v2[<span class="number">0</span>])<span class="keyword">return</span> v1[<span class="number">0</span>]&lt;v2[<span class="number">0</span>];<span class="keyword">else</span> <span class="keyword">return</span> v1[<span class="number">1</span>]&lt;v2[<span class="number">1</span>];&#125;);</span><br></pre></td></tr></table></figure><h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>要包含头文件<code>#include&lt;algorithm&gt;</code>，该函数没有返回值。<br>如果是二维数组，按照行翻转，比如第一行翻转之后到最后一行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reverse[first,last);</span><br></pre></td></tr></table></figure><h3 id="的区别"><a href="#的区别" class="headerlink" title=".,-&gt;的区别"></a><code>.</code>,<code>-&gt;</code>的区别</h3><p>实例和指针的区别。<br><code>A.B</code>则A为对象或者结构体； 点号（<code>.</code>）：左边必须为实体。<br><code>A-&gt;B</code>则A为指针，<code>-&gt;</code>是成员提取，<code>A-&gt;B</code>是提取<code>A</code>中的成员<code>B</code>，<code>A</code>只能是指向类、结构、联合的指针； 箭头（<code>-&gt;</code>）：左边必须为指针。</p><h3 id="排序，同时保留原坐标"><a href="#排序，同时保留原坐标" class="headerlink" title="排序，同时保留原坐标"></a>排序，同时保留原坐标</h3><p><code>sort(ids.begin(),ids.end(),[&amp;](int i,int j)&#123;return nums2[i] &lt; nums2[j];&#125;);</code><br>此时ids[0]就是原数组中最小数的坐标<br>或者是：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"><span class="comment">//第一个位置放数值，第二个位置放坐标</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h3 id="function-函数的用法"><a href="#function-函数的用法" class="headerlink" title="function 函数的用法"></a>function 函数的用法</h3><p>std::function是一个通用的多态函数包装器，可以调用普通函数、Lambda函数、仿函数、bind对象、类的成员函数和指向数据成员的指针，function定义在名为<code>function.h</code>头文件中。是一个模板，在创建function实例时，必须指明类型，如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func<span class="comment">//表示接受两个int，返回一个int的可调用函数</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; func = [&amp;](<span class="type">int</span> a,<span class="type">int</span> b)&#123;&#125;;<span class="comment">//可以等于某个匿名函数</span></span><br></pre></td></tr></table></figure><p>使用function函数可以不需要将主函数中的参数传入，直接以引用的方式捕获就可以。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;自带的宏常量&quot;&gt;&lt;a href=&quot;#自带的宏常量&quot; class=&quot;headerlink&quot; title=&quot;自带的宏常量&quot;&gt;&lt;/a&gt;自带的宏常量&lt;/h3&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数和虚函数表</title>
    <link href="http://example.com/2022/08/26/%E3%80%90c++%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/"/>
    <id>http://example.com/2022/08/26/%E3%80%90c++%E3%80%91%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88%E5%A4%9A%E6%80%81%EF%BC%89/</id>
    <published>2022-08-26T07:33:02.000Z</published>
    <updated>2023-08-16T09:06:56.610Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>静态多态</strong>：静态多态是指在编译时实现的多态，比如函数重载，看似是调用同一个函数其实是在调用不同的。<br><strong>动态多态</strong>：动态多态是在运行中实现的，当一个父类对象的引用或者指针接收不同的对象(父类对象or子类对象)后，调用相同的函数会调用不同的函数。</p><h4 id="重载、重写、重定义"><a href="#重载、重写、重定义" class="headerlink" title="重载、重写、重定义"></a>重载、重写、重定义</h4><p><img src="/../imgs/image-10.png"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>虚函数和纯虚函数的作用</strong></p><ul><li>定义一个函数为虚函数，不代表函数为不被实现的函数。<code>virtual void foo() ;</code></li><li>定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。</li><li>定义一个函数为纯虚函数，才代表函数没有被实现。<code>virtual void foo() = 0;</code></li><li>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();  </span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/image-11.png"></p><p><strong>基类A里面有一个虚函数表，用数组实现，存放的是子类虚函数指针。</strong></p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> var</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><img src="/../imgs/image-12.png"><br>其中成员函数放在代码区，为该类的所有对象公有，即不管新建多少个该类的对象，所对应的都是同一个函数存储区的函数。而成员变量则为各个对象所私有，即每新建一个对象都会新建一块内存区用来存储var值。在调用成员函数时，程序会根据类的类型，找到对应代码区所对应的函数并进行调用。<br><strong>如果是普通函数的调用，子类继承父类之后会调用父类的函数。</strong><br>那么虚函数又是怎么实现的呢？对于</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">virtul <span class="type">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> var</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>其内存布局为：<br><img src="/../imgs/image-13.png"><br>虚函数表指针<code>vptr</code>。这个指针指向一张名为“虚函数表”（vtbl）的表，而表中的数据则为函数指针，存储了虚函数<code>fun_b()</code>具体实现所对应的位置。<br>注意，普通函数、虚函数、虚函数表都是同一个类的所有对象公有的，只有成员变量和虚函数表指针是每个对象私有的，<strong>sizeof的值也只包括vptr和var所占内存的大小</strong>（也是个常出现的问题），并且vptr通常会在对象内存的最起始位置。<br>另外，当类有多个虚函数时，仍然只有一个虚函数表指针vptr，而此时的虚函数表vtbl中会有多个函数指针，分别指向对应的虚函数实现区域。在重复一遍虚函数实现的过程：通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。</p><h3 id="析构函数和构造函数可以是虚函数吗？"><a href="#析构函数和构造函数可以是虚函数吗？" class="headerlink" title="析构函数和构造函数可以是虚函数吗？"></a>析构函数和构造函数可以是虚函数吗？</h3><p><strong>答案是构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</strong><br>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。<strong>那么在构造函数完成之前，vptr是没有值的，也就无法通过vptr找到作为虚函数的构造函数所在的代码区，所以构造函数只能作为普通函数存放在类所指定的代码区中。</strong><br>那么为什么析构函数推荐最好设置为虚函数呢？当我们delete()的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当时是希望可以调用派生类的析构函数对新定义的成员进行析构。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> data) :<span class="built_in">data</span>(data) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(data);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用A类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用A类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//using A::A;//使用基类的构造函数</span></span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> data) :<span class="built_in">A</span>(data) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用B类的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(data);</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用B类的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A* a = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用结果如下：</p><p><img src="/../imgs/image-14.png"></p><p>基类指针指向子类，调用基类的析构函数，导致内存泄漏。</p><p>改为：<code>virtual ~A()</code></p><p><img src="/../imgs/image-15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;静态多态&lt;/strong&gt;：静态多态是指在编译时实现的多态，比如函数重载，看似是调用同一个函数其实是在调用不同的。&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++运算符重载的一些规则</title>
    <link href="http://example.com/2022/08/16/%E3%80%90c++%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99/"/>
    <id>http://example.com/2022/08/16/%E3%80%90c++%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%99/</id>
    <published>2022-08-16T07:33:02.000Z</published>
    <updated>2023-08-16T09:08:42.626Z</updated>
    
    <content type="html"><![CDATA[<p><strong>C++规定重载后的运算符的操作对象必须至少有一个使用户定义的类型</strong><br><img src="https://img-blog.csdnimg.cn/940626e5206a45a891a57a12ed3ee9f6.png" alt="在这里插入图片描述"></p><p><strong>&lt;&lt;运算符的重载</strong><br>使用全局函数(友元函数)进行重载<br><code>s.operator&lt;&lt;(cout);</code>可以简写为：<code>s&lt;&lt;out;</code><br><code>MyClass&amp; operator+(MyClass&amp; s1,MyClass&amp; s2)</code>：调用时：<br><code>s1+s2</code>等价于<code>s1.operator+(s2)</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> data):<span class="built_in">data</span>(data)&#123;&#125;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os)&#123;</span><br><span class="line">os&lt;&lt;data&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(MyClass&amp; s,ostream&amp; os)&#123;</span><br><span class="line">os&lt;&lt;data&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> os;<span class="comment">//为了重复调用所以必须要返回os</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">MyClass <span class="title">s</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">s.<span class="keyword">operator</span>&lt;&lt;(cout);<span class="comment">//s&lt;&lt;out;</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>=,[],-&gt;,()</code>这几个符号只能在成员函数中进行重载，即有一个默认参数一定是类。</strong><br>为什么？<br><a href="https://blog.csdn.net/u014610226/article/details/47679323">为什么不能在类外重载</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;C++规定重载后的运算符的操作对象必须至少有一个使用户定义的类型&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/940626e5206a45a891a57a12ed3ee9f6.png&quot; alt=&quot;在这里</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>左值和右值</title>
    <link href="http://example.com/2022/08/15/%E3%80%90c++%E3%80%91%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    <id>http://example.com/2022/08/15/%E3%80%90c++%E3%80%91%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/</id>
    <published>2022-08-15T07:33:02.000Z</published>
    <updated>2023-08-16T09:14:17.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><p><strong>左值：有地址的值</strong></p><p><strong>右值：只能放在等式右边的值</strong></p><ul><li>常量</li><li>将亡值</li><li>算术表达式<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;<span class="comment">//i左值，10右值</span></span><br><span class="line"><span class="type">int</span> j = <span class="built_in">f</span>();<span class="comment">//将亡值，用完即销</span></span><br></pre></td></tr></table></figure><strong>函数返回值为左值引用，就可以放在等式左边</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">GetValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="built_in">GetValue</span>();</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line"><span class="built_in">GetValue</span>() = <span class="number">5</span>;<span class="comment">//左值引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">GetValue</span>() &lt;&lt; endl;<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>非const引用，只能引用左值</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; value)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);<span class="comment">//报错,正确 f(const int&amp; value);</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><p><code>const</code>加左值引用，可以兼容右值，相当于创建了一个临时变量，然后进行左值引用。<code>int tmp = 10;f(tmp);</code><br>左值引用仅仅接受左值，右值引用仅仅接受右值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span>&amp;&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; value)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;兼容左值和右值引用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">MyPrint</span>(a);<span class="comment">//左值引用</span></span><br><span class="line"><span class="built_in">MyPrint</span>(<span class="number">10</span>);<span class="comment">//右值引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>移动语义用来传递所有权，仅仅移动对象，而不进行复制</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递所有权</span></span><br><span class="line"><span class="comment">//仅仅移动对象，而不复制，提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* data) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Creat!\n&quot;</span>);</span><br><span class="line">m_size = <span class="built_in">strlen</span>(data);</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_data, data,m_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;copy\n&quot;</span>);</span><br><span class="line">m_size = other.m_size;</span><br><span class="line">m_data = <span class="keyword">new</span> <span class="type">char</span>[m_size];</span><br><span class="line"><span class="built_in">memcpy</span>(m_data, other.m_data, m_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动语义</span></span><br><span class="line"><span class="built_in">String</span>(String&amp;&amp; other) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;move\n&quot;</span>);</span><br><span class="line">m_size = other.m_size;</span><br><span class="line">m_data = other.m_data;</span><br><span class="line">other.m_size = <span class="number">0</span>;</span><br><span class="line">other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>() &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;String的析构函数\n&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> m_data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* m_data;</span><br><span class="line"><span class="type">int</span> m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENT</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ENT</span>(String&amp;&amp; data):<span class="built_in">m_data</span>(<span class="built_in">move</span>(data))&#123;</span><br><span class="line"><span class="comment">//这里要将data转换成一个右值才会调用移动构造函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;R Printf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ENT</span>(<span class="type">const</span> String&amp; data):<span class="built_in">m_data</span>(data)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ENT Printf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">String m_data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">String <span class="title">s</span><span class="params">(<span class="string">&quot;abd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">ENT <span class="title">t1</span><span class="params">(s)</span></span>;<span class="comment">//调用了Creat和copy</span></span><br><span class="line"><span class="function">ENT <span class="title">t2</span><span class="params">(<span class="string">&quot;abd&quot;</span>)</span></span>;<span class="comment">//调用了Creat和move</span></span><br><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function">String <span class="title">str1</span><span class="params">(move(str))</span></span>;</span><br><span class="line">cout &lt;&lt; str.m_size &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;左值和右值&quot;&gt;&lt;a href=&quot;#左值和右值&quot; class=&quot;headerlink&quot; title=&quot;左值和右值&quot;&gt;&lt;/a&gt;左值和右值&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;左值：有地址的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右值：只能放在等式右边的值&lt;/st</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>计算复杂性原理学习笔记</title>
    <link href="http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/"/>
    <id>http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/</id>
    <published>2022-06-15T16:38:52.000Z</published>
    <updated>2023-08-16T03:47:35.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><ul><li><p>一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上的一个单元。</p></li><li><p>一个图灵机是根据它的读写头所在的单元进行操作的，它或者改变单元中的字符，或者移动它的读写头到相邻的一个单元，也就是说，图灵机的复杂性度量是由比特运算决定的。</p></li></ul><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p><strong>随着问题规模的增大，算法执行时间增长的快慢。它可以用来表示一个算法运行的时间效率。大</strong>$O$用来表示算法执行的最坏时间复杂度。</p><p>多项式时间：$O(n^{O(1)})$ </p><h3 id="问题分类："><a href="#问题分类：" class="headerlink" title="问题分类："></a>问题分类：</h3><p><strong>P（polynominal）</strong>：确定性图灵机在多项式时间内可解决的问题</p><p><strong>NP（Nondeterministic polynominal 非确定多项式）</strong>：多项式时间内可验证</p><ul><li><p>非确定算法是可以做非确定运算的算法，在非确定算法的一个步骤中，算法可以不确定地对一个变量赋值0或者1，在这样的赋值以后，算法的计算过程分解成两个分开的计算路径，每一条对应一种可能的赋值。假设非确定性算法进行k次非确定性运算，那么可以产生$2^k$种不同的确定性计算路径。如果存在至少一条导致判定的结论为“是”的计算路径，那么我们称这个非确定算法接受这个输入，如果不存在，那么这个算法就拒绝这个输入。</p></li><li><p>一个非确定性算的时间复杂度是所有导致判定结论为“是”的计算路径种最短运行时间。</p></li></ul><p><strong>EXP</strong>：指数时间内能解决</p><p><strong>R</strong>：有限时间内解决</p><ul><li><p>$P \subseteq NP$：存在多项式时间算法问题，总能在多项式时间内验证。</p></li><li><p>$NP\subseteq  EXP \subseteq R$</p></li></ul><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><p>该类问题不知道存不存在一个多项式时间的算法，但是给出一个解S，我们可以在多项式时间内验证S是否是问题P的一个解。</p><p><strong>NP-hard问题：</strong> 比所有的NP问题都要难的问题。所有的NP问题都可以多项式<strong>归约</strong>到NP-hard问题。如果NP-hard问题存在多项式时间算法，那么所有的NP问题都会存在多项式时间算法。</p><p><strong>NP-complete问题：</strong> 既属于NP又属于NP-hard的问题</p><p><img src="/../imgs/image-2.png"></p><p><mark>P &#x3D; NP</mark>   or <mark>P ≠ NP</mark> ？</p><blockquote><p><strong>有没有什么问题属于NP-hard，但是不属于NP？</strong></p><p>停机问题：给定一个程序和输入，判定运行是否终止，不可判定，所以不属于NP。</p><p><strong>图同构问题和因数问题，既没有结果表明属于P，也没有结果表明属于NP-完全</strong></p></blockquote><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p><strong>定义：</strong> 语言$L \subseteq {0,1}^*$多项式时间卡普归约到语言$L’ \subseteq {0,1}^*$，记为$L \leq_p L’$，如果存在多项式时间可计算的函数$f:{0,1}^* \to {0,1}^*  $使得对任意的$x \in {0,1}^*$均有$x\in L$当且仅当$f(x)\in L’$。多项式时间卡普规约也可以简称为多项时间规约。</p><p>如果$L \leq_p L’$对任意的$L\in NP$成立，则称$L’$是NP-难的，如果$L’$是NP-难的且$L’\in NP$，则称$L’$是NP-完全的。</p><p>换句话说，如果A问题是一个NP-hard问题，我们想要得到B问题也是一个NP-hard问题，假设$x$是A问题的一个解，那么我们能在多项式时间内从$x$推出B问题的一个解$f(x)$，反过来，如果我们有B问题的一个解$y$，那么我们能在多项式时间内从$y$推出A问题的一个解$x$。从而有B问题是NP-hard问题。</p><h3 id="针对NP-hard问题我们有什么解决方法"><a href="#针对NP-hard问题我们有什么解决方法" class="headerlink" title="针对NP-hard问题我们有什么解决方法"></a>针对NP-hard问题我们有什么解决方法</h3><p><strong>判定问题：</strong> 一个问题的解只有“是”或者“否”。</p><p><strong>最优化问题：</strong> 求最优解（最大或者最小）。</p><p>同一个问题的判定问题和最优化问题在计算复杂性方面是<mark>等价</mark>的。</p><p>因为假设判定问题是多项式可解，那么只需要枚举n次解，即可得到最优化问题的解。<br>总有某一个解k是可满足的，k+1(最大值问题)是不可满足的，此时k就是解。</p><h4 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h4><ol><li>当一个问题被证实为NP-完全问题，其精确算法多半使用分支界定、动态规划等算法设计，时间复杂度为指数级。</li><li>对于每一个问题，可以先假设其有多项式时间算法，并去设计该算法。</li></ol><h4 id="参数算法"><a href="#参数算法" class="headerlink" title="参数算法"></a>参数算法</h4><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><p>NP-hard问题求最优解比较困难（从算法运行时间角度），所以可以考虑设计近似算法求解。近似算法不花费指数时间寻找优化问题的最优解，而是在多项式时间内求得一个近似最优解。</p><blockquote><p><strong>启发式算法和近似算法</strong></p><ul><li><p>近似算法性能比一般是可以通过严格的理论证明得到或者估计出范围的，而启发式算法不存在这样的理论分析结果，评价启发式算法性能的好换往往是依靠对问题的不同实例输入所进行数值模拟。</p></li><li><p>近似算法通常是用来求解优化问题，而启发式算法不仅可用于求解优化问题，还可以用于处理判定问题。</p></li></ul><p><strong>比如，设计一个可满足性问题近似算法没有意义，相关的启发式算法可以有效处理可满足问题的一大部分实例，但是不能保证可以在多项式时间内处理问题的所有实例。</strong></p></blockquote><p><strong>近似性能比：</strong> $r(A)&#x3D;max{A(I)&#x2F;opt(I),opt(I)&#x2F;A(I)}$。$A(I),opt(I)$分别表示算法A输出的一个问题P的解，和问题P的最优解。</p><p><strong>不可近似性：</strong> 求解某一个优化问题的任意一个近似算法性能比的下界。</p><p><strong>依据不可近似性，优化问题可以分为：</strong></p><ul><li><p>PTAS：近似性能比可以无限逼近于1</p></li><li><p>APX：有常数近似性能比</p></li><li><p>APX-C：某些问题的近似性能比无法突破一个界</p></li></ul><h5 id="如何求解不可近似性："><a href="#如何求解不可近似性：" class="headerlink" title="如何求解不可近似性："></a>如何求解不可近似性：</h5><ul><li><p>从NP-完全问题去规约</p><ul><li>如果优化问题A具有NP-难间隙$[\alpha,\beta],0 \leq \alpha \leq \beta$，那么问题A不存在多项式时间$(\beta&#x2F;\alpha)$-近似算法，除非$P&#x3D;NP$。</li></ul></li><li><p>间隙放大与保持</p></li></ul><p><img src="/../imgs/image-3.png"></p><h5 id="APX-完全性"><a href="#APX-完全性" class="headerlink" title="APX-完全性"></a>APX-完全性</h5><p>对于某些问题，存在求解他们的具有常数性能比的近似算法（APX），去证明他们的某种程度的不可以近似性。</p><blockquote><p>顶点覆盖问题不存在一个近似性能比小于2的近似算法，即MVC问题近似性能比下界为2，那么我们为什么要去证明其APX-完全性质呢？上诉说的某种程度往往是限定于度，且度越小越好，从解决问题的角度考虑，在小度图上都无法近似，大度图上一般也是无法近似的。</p></blockquote><p><strong>L规约的定义</strong></p><p>Let two $NP$ optimization problems $\Lambda$ and $\Pi$ and there are two polynomial-time transformation $h$ and $g$ satisfying the following conditions:</p><ol><li><p>$h$ maps an instance $x$ of $\Lambda$ to an instance $h(x)$ of $\Pi$ such that:<br>$opt_{\Pi}(h(x)) \leq \alpha \cdot opt_{\Lambda}(x)$</p></li><li><p>$g$ maps solutions of $\Pi$ for instance $h(x)$ to solutions of $\Lambda$ for instance $x$. For every feasible solution $y$ of $h(x)$ with objective value $m_{\Pi}(h(x),y)&#x3D; c_{2}$, we can find a solution $g(y)$ of $x$ in polynomial time with $m_{\Lambda}(x,g(y))&#x3D; c_{1}$ such that:<br>$|opt_{\Lambda}(x)-c_{1}| \leq \beta \cdot |opt_{\Pi}(h(x)) - c_{2}|$</p></li></ol><h5 id="rho-ln-n-不可近似性"><a href="#rho-ln-n-不可近似性" class="headerlink" title="$(\rho ln n)$-不可近似性"></a>$(\rho ln n)$-不可近似性</h5><p>有一类组合优化问题，对其中的每一个问题都存在一个正实数$\rho$，使得它没有多项式时间$(\rho ln n)$-近似算法。如，最小集合覆盖问题。</p><h5 id="n-c-不可近似性"><a href="#n-c-不可近似性" class="headerlink" title="$n^c$-不可近似性"></a>$n^c$-不可近似性</h5><p>图着色问题和最大团问题都不存在$n^c$-近似算法，$c&gt;0$。</p><p><strong>针对近似算法，我们通常是找到近似算法的下界，然后去设计近似算法不断去逼近下界。</strong></p><h3 id="backgroud"><a href="#backgroud" class="headerlink" title="backgroud"></a>backgroud</h3><ol><li><p>Introduction</p><p>Computational complexity theory studies the inherent difficulty of computational problems. It analyzes and classifies problems based on the computational resources required to solve them, such as time and space. Understanding problem complexity helps computer scientists design efficient algorithms and determine theoretical limitations of computation.</p></li><li><p>Time Complexity</p><p>Time complexity refers to the number of computation steps required for an algorithm to solve a problem as a function of input size n. Common time complexity functions include constant O(1), logarithmic O(log n), linear O(n), quadratic O(n^2), and exponential O(2^n).</p></li><li><p>Space Complexity</p><p>Space complexity analyzes the auxiliary memory space needed by an algorithm, in addition to its input. Space complexity is commonly expressed using Big O notation as well.</p></li><li><p>P vs. NP Problem</p><p>P represents complexity class of problems solvable in polynomial time by a deterministic Turing machine. NP consists of problems verifiable in polynomial time given the right solution. The P vs NP problem asks whether P &#x3D; NP, i.e. are efficiently verifiable problems also efficiently solvable. It is considered one of the most important open problems in computer science and mathematics.</p></li><li><p>NP-complete and NP-hard</p><p>NP-complete problems are the most difficult problems in NP. NP-hard problems are at least as difficult as NP-complete ones. No efficient solutions are known for NP-complete or NP-hard problems.</p></li><li><p>Reductions</p><p>Reduction shows equivalence between computational problems. Polynomial time reductions are often used to prove NP-completeness.</p></li><li><p>Major Complexity Classes</p><p>Some key complexity classes are:</p><ul><li>P: polynomial time solvable problems</li><li>NP: verifiable in polynomial time</li><li>co-NP: complement of NP</li><li>PSPACE: solvable with polynomial space</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图灵机&quot;&gt;&lt;a href=&quot;#图灵机&quot; class=&quot;headerlink&quot; title=&quot;图灵机&quot;&gt;&lt;/a&gt;图灵机&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上</summary>
      
    
    
    
    <category term="tcs" scheme="http://example.com/categories/tcs/"/>
    
    
  </entry>
  
  <entry>
    <title>递归问题的时间复杂度分析</title>
    <link href="http://example.com/2021/10/05/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/10/05/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98%E5%8F%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2021-10-05T07:33:02.000Z</published>
    <updated>2023-08-16T09:23:25.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归分析"><a href="#递归分析" class="headerlink" title="递归分析"></a>递归分析</h2><p><strong>递归问题可分为以下三个步骤分析：</strong></p><p>1、递归函数功能</p><p>2、递归终止条件</p><p>3、递归关系式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n！</span></span><br><span class="line"><span class="comment">//1、递归函数功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//关系式f(n)=n*f(n-1)</span></span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">f</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次可以跳上1级台阶，也可以跳上2级。求该跳上一个n级的台阶总共有多少种跳法。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="comment">//这里如果写成n==1返回1，则当n==2的时候，会调用到f（0），而f（0）又会调用到f（-1）和f（-2）从而变成死循环</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">//关系式f(n)=f(n-1)+f(n-2)</span></span><br><span class="line">    <span class="comment">//第一次选择跳一个台阶，后面有f（n-1）种跳法，选择跳2个台阶，后面有f（n-2）种跳法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(n<span class="number">-1</span>)+<span class="built_in">f</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>递归问题能找到递归关系式的，是否都能用动态规划的思想去解决？</strong></p><p>目前没遇到无法用动态规划去改写的问题。通常递归问题的时间复杂度都比较高。</p><h2 id="递归的时间复杂度"><a href="#递归的时间复杂度" class="headerlink" title="递归的时间复杂度"></a>递归的时间复杂度</h2><p>master公式的使用：</p><p><code>T(n)=a*T(n/b)+O(n^d)</code></p><ul><li><p><code> log(b,a)&gt;d-&gt;复杂度为O(n^log(b,a))</code></p></li><li><p><code>log(b,a)=d-&gt;复杂度为O(n^d*logn)</code></p></li><li><p><code>log(b,a)&gt;d-&gt;复杂度为O(n^d)</code></p></li></ul><p>推导如下：</p><p><img src="/../imgs/image-16.png"><br><img src="/../imgs/image-17.png"></p><p><strong>n级台阶的问题时间复杂度分析</strong></p><p><img src="/../imgs/image-18.png"></p><p>该时间复杂度是一个指数复杂度。很多时候递归的时间复杂度都很高，所以可以用动态规划来改写。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>,p=<span class="number">1</span>,k=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m=p;</span><br><span class="line">            p=k;</span><br><span class="line">            k=m+p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;递归分析&quot;&gt;&lt;a href=&quot;#递归分析&quot; class=&quot;headerlink&quot; title=&quot;递归分析&quot;&gt;&lt;/a&gt;递归分析&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;递归问题可分为以下三个步骤分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、递归函数功能&lt;/p&gt;
&lt;p&gt;2、递归终</summary>
      
    
    
    
    <category term="algorithm" scheme="http://example.com/categories/algorithm/"/>
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++深拷贝和浅拷贝</title>
    <link href="http://example.com/2021/09/18/c++%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2021/09/18/c++%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-09-18T07:33:02.000Z</published>
    <updated>2023-08-16T09:25:13.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两个的区别"><a href="#两个的区别" class="headerlink" title="两个的区别"></a>两个的区别</h2><ul><li>在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有<code>指针</code>时，浅拷贝是可行的，但当数据成员中有指针时，如果采用简单的浅拷贝，<code>则两类中的两个指针将指向同一个地址</code>，当对象快结束时，会调用两次析构函数，从而导致指针悬挂现象，所以，此时，必须采用深拷贝。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//系统默认的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();<span class="comment">//default构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp;rhs);<span class="comment">//copy构造函数  浅拷贝函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget &amp;rhs);<span class="comment">//copy assignment操作符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;<span class="comment">//调用default函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>;<span class="comment">//调用copy构造函数</span></span><br><span class="line"><span class="comment">//w2还不存在，所以调用的是copy</span></span><br><span class="line">w1=w2;<span class="comment">//调用copy assignment操作符</span></span><br><span class="line"><span class="comment">//赋值函数，是在对象已经存在的情况下才会进行调用</span></span><br><span class="line">Widget w3=w2;<span class="comment">//调用copy构造函数</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>深拷贝和浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来存储数据，从而也就解决了指针悬挂的问题。<code>当数据成员中有指针时，必须要用深拷贝。</code></li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>c++默认的拷贝构造函数是浅拷贝<ul><li>浅拷贝就是对象数据成员之间的简单复制，如你设计了一个类而没有通过它的复制构造函数，当用该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝，如：</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _data):<span class="built_in">data</span>(_data)&#123;&#125;<span class="comment">//传入一个值_data，然后把_data的值给data</span></span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    A b=a;<span class="comment">//仅仅是数据成员之间的赋值</span></span><br><span class="line">    <span class="comment">//b.data=5;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深拷贝</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _size):<span class="built_in">size</span>(_size)</span><br><span class="line">    &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];<span class="comment">//指针变量名 = new type[内存单元个数]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []data;</span><br><span class="line">    &#125;<span class="comment">//析构时释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span>,b</span>=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注：这里的b&#x3D;a会造成未定义行为，因为类A中的copy构造函数是编译器生成的，所以b &#x3D; a执行的是一个浅拷贝的过程。</li></ul><p><code>这里b的指针和a的指针指向了堆上的同一块内存，a和b析构时，b先把data执行的分配的内存释放了一次，而后a析构时又将这块已经被释放的内存再释放一次，对同一块内存执行2次以上释放的结果是未定义的，所以这会导致内存泄漏或程序崩溃。</code></p><p><strong>深拷贝就是指当拷贝的对象中有对其他资源（如堆、文件、系统等）的引用时，对象另外开辟一块新的资源，而不再对拷贝对象中有对其他资源的引用的指针或引用进行单纯的赋值。</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> _size):<span class="built_in">size</span>(_size)</span><br><span class="line">    &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];<span class="comment">//指针变量名 = new type[内存单元个数]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;_A):<span class="built_in">size</span>(_A.size)</span><br><span class="line">    &#123;</span><br><span class="line">data = <span class="keyword">new</span> <span class="type">int</span>[size];<span class="comment">//开辟了一个新的空间</span></span><br><span class="line">    &#125;<span class="comment">//深拷贝</span></span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> []data;</span><br><span class="line">    &#125;<span class="comment">//析构时释放资源</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span>,b</span>=a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;两个的区别&quot;&gt;&lt;a href=&quot;#两个的区别&quot; class=&quot;headerlink&quot; title=&quot;两个的区别&quot;&gt;&lt;/a&gt;两个的区别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据</summary>
      
    
    
    
    <category term="cpp" scheme="http://example.com/categories/cpp/"/>
    
    
  </entry>
  
</feed>
