<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2024-11-19T02:15:39.387Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Cloud: 断路器</title>
    <link href="https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/"/>
    <id>https://kelinkong.github.io/2024/11/19/Spring-Cloud-%E6%96%AD%E8%B7%AF%E5%99%A8/</id>
    <published>2024-11-19T01:07:12.000Z</published>
    <updated>2024-11-19T02:15:39.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="断路器（Circuit-Breaker）简介"><a href="#断路器（Circuit-Breaker）简介" class="headerlink" title="断路器（Circuit Breaker）简介"></a>断路器（Circuit Breaker）简介</h3><p><strong>断路器</strong>是一种用于防止分布式系统中的故障扩散的机制。它借鉴了电路中的断路器原理，当某个服务出现故障或响应异常时，断路器会主动中断请求链路，避免故障传播到整个系统，保护系统的可用性和稳定性。</p><p>断路器通常在微服务架构中使用，结合服务治理框架（如 Spring Cloud Hystrix、Resilience4j 等）实现。</p><hr><h3 id="断路器的核心概念"><a href="#断路器的核心概念" class="headerlink" title="断路器的核心概念"></a>断路器的核心概念</h3><p>断路器有三种状态：<strong>关闭（Closed）</strong>、<strong>打开（Open）</strong> 和 <strong>半开（Half-Open）</strong>。</p><ol><li><p><strong>关闭状态（Closed）</strong>：</p><ul><li>默认状态，服务正常时断路器处于关闭状态。</li><li>请求直接转发到目标服务。</li><li>如果在一定时间内连续发生错误（如超时、异常等）超过预设阈值，断路器会进入<strong>打开状态</strong>。</li></ul></li><li><p><strong>打开状态（Open）</strong>：</p><ul><li>当断路器打开时，请求不再转发到目标服务，而是直接失败或返回预设的降级结果。</li><li>断路器会在打开状态维持一段时间（冷却时间），然后进入<strong>半开状态</strong>。</li></ul></li><li><p><strong>半开状态（Half-Open）</strong>：</p><ul><li>冷却时间结束后，断路器会允许少量请求通过，测试目标服务是否恢复。</li><li>如果测试请求成功率达到预期，断路器会切换回关闭状态。</li><li>如果测试请求仍然失败，则断路器重新进入打开状态。</li></ul></li></ol><hr><h3 id="断路器的作用"><a href="#断路器的作用" class="headerlink" title="断路器的作用"></a>断路器的作用</h3><ol><li><p><strong>避免级联故障</strong>：<br>当某个服务发生故障时，断路器能够切断请求，防止故障扩散到其他服务，保护系统的整体稳定性。</p></li><li><p><strong>快速失败</strong>：<br>在目标服务不可用时，断路器立即返回失败结果或降级响应，避免用户长时间等待，提高用户体验。</p></li><li><p><strong>系统保护</strong>：<br>减少对故障服务的访问压力，避免因请求积压导致服务雪崩。</p></li></ol><hr><h3 id="断路器的关键指标"><a href="#断路器的关键指标" class="headerlink" title="断路器的关键指标"></a>断路器的关键指标</h3><ol><li><p><strong>失败率</strong>：<br>一段时间内的失败请求占比。如果失败率超过阈值，断路器进入打开状态。</p></li><li><p><strong>请求数量</strong>：<br>设置触发断路器的最小请求数，确保断路器在足够的请求量下判断服务是否故障。</p></li><li><p><strong>熔断时间（冷却时间）</strong>：<br>指断路器打开后保持不再发送请求的时间，熔断时间过后进入半开状态。</p></li><li><p><strong>恢复检测</strong>：<br>在半开状态下，通过少量请求测试服务是否恢复，避免因误判直接恢复全部流量。</p></li></ol><hr><h3 id="常见断路器框架"><a href="#常见断路器框架" class="headerlink" title="常见断路器框架"></a>常见断路器框架</h3><ol><li><p><strong>Hystrix（已停止维护）</strong>：</p><ul><li>Netflix 开发，支持熔断器、线程隔离、请求缓存、请求合并等功能。</li><li>使用广泛，但因功能复杂导致性能损耗高，现已被 Resilience4j 替代。</li></ul></li><li><p><strong>Resilience4j</strong>：</p><ul><li>轻量级 Java 熔断器库，支持断路器、限流、重试、超时等功能。</li><li>性能优于 Hystrix，更适合现代微服务架构。</li></ul></li><li><p><strong>Spring Cloud Circuit Breaker</strong>：</p><ul><li>Spring 官方的断路器抽象层，支持多种断路器实现，如 Resilience4j 和 Sentinel。</li></ul></li></ol><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li><p><strong>微服务调用失败</strong>：<br>处理服务超时、响应错误等异常情况，防止用户请求被无限制地转发到失败服务。</p></li><li><p><strong>高并发场景</strong>：<br>在流量激增时对服务降级，保护系统核心功能。</p></li><li><p><strong>依赖外部资源</strong>：<br>调用第三方接口或外部服务时，避免对其过度依赖导致自身系统故障。</p></li></ol><hr><h3 id="断路器的优缺点"><a href="#断路器的优缺点" class="headerlink" title="断路器的优缺点"></a>断路器的优缺点</h3><p><strong>优点</strong>：</p><ul><li>防止服务雪崩。</li><li>提升系统稳定性。</li><li>提高用户体验，避免长时间等待。</li></ul><p><strong>缺点</strong>：</p><ul><li>增加系统复杂度。</li><li>需要合理设置阈值，否则可能引发误判。</li><li>引入额外的延迟（如熔断检测）。</li></ul><hr><h3 id="实现示例（使用-Resilience4j）"><a href="#实现示例（使用-Resilience4j）" class="headerlink" title="实现示例（使用 Resilience4j）"></a>实现示例（使用 Resilience4j）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CircuitBreaker(name = &quot;paymentService&quot;, fallbackMethod = &quot;paymentFallback&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用目标服务</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://payment-service/pay&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentFallback</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Payment service is currently unavailable. Please try again later.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @CircuitBreaker 注解指定断路器名称和降级方法，当目标服务出现异常时返回降级响应。</p><hr><p>通过断路器，分布式系统可以更好地处理服务故障和性能问题，确保高可用性和用户体验。</p><p>参考文档：<a href="https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/index.md">Resilience4j</a></p><h2 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h2><p><img src="/../imgs/image-68.png"></p><p>配置断路器</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">circuitbreaker:</span> <span class="comment"># 降级熔断</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">        <span class="attr">failure-rate-threshold:</span> <span class="number">50</span> <span class="comment"># 调用失败达到50%后打开断路器</span></span><br><span class="line">        <span class="attr">sliding-window-type:</span> <span class="string">count_based</span> <span class="comment"># 滑动窗口类型</span></span><br><span class="line">        <span class="attr">sliding-window-size:</span> <span class="number">6</span> <span class="comment"># 滑动窗口大小 count_based6个请求 time_base6秒</span></span><br><span class="line">        <span class="attr">minimum-number-of-calls:</span> <span class="number">6</span> <span class="comment"># 每个滑动窗口的周期</span></span><br><span class="line">        <span class="attr">automatic-transition-from-open-to-half-open-enabled:</span> <span class="literal">true</span> <span class="comment"># 开始过度到半开状态</span></span><br><span class="line">        <span class="attr">wait-duration-in-open-state:</span> <span class="string">5s</span> <span class="comment"># 从开启到半开启需要5s</span></span><br><span class="line">        <span class="attr">permitted-number-of-calls-in-half-open-state:</span> <span class="number">2</span> <span class="comment">#半开状态允许通过的最大请求数</span></span><br><span class="line">        <span class="attr">record-exceptions:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">java.lang.Exception</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">    <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">base-config:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;断路器（Circuit-Breaker）简介&quot;&gt;&lt;a href=&quot;#断路器（Circuit-Breaker）简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud: OpenFeign</title>
    <link href="https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/"/>
    <id>https://kelinkong.github.io/2024/11/14/Spring-Cloud-OpenFeign/</id>
    <published>2024-11-14T10:18:20.000Z</published>
    <updated>2024-11-19T01:00:01.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenFeign介绍"><a href="#OpenFeign介绍" class="headerlink" title="OpenFeign介绍"></a>OpenFeign介绍</h2><p>OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 Netflix Feign，支持与 Spring Cloud 一起使用。它简化了 HTTP 服务调用的过程，可以通过定义接口来调用远程服务，而不需要手写复杂的 HTTP 请求代码。开发者只需定义接口并使用注解来配置 HTTP 请求的细节。</p><p>在 Spring Cloud 中，OpenFeign 作为微服务间通信的一个常用工具，尤其适合构建基于 REST 的微服务应用。</p><h3 id="OpenFeign-相对-RestTemplate-LoadBalanced-的优势"><a href="#OpenFeign-相对-RestTemplate-LoadBalanced-的优势" class="headerlink" title="OpenFeign 相对 RestTemplate + @LoadBalanced 的优势"></a>OpenFeign 相对 RestTemplate + @LoadBalanced 的优势</h3><p>即便 <code>RestTemplate</code> 可以通过 <code>@LoadBalanced</code> 实现负载均衡，OpenFeign 仍然在以下方面具备优势：</p><ol><li><p><strong>声明式语法简洁性</strong>：OpenFeign 使用接口和注解定义请求，可以省去大量手动编写 URL 和方法的代码，特别是在大型项目中，显著减少重复代码。</p></li><li><p><strong>熔断与容错支持</strong>：OpenFeign 默认集成了 Hystrix 等容错机制，可以在微服务调用中轻松实现熔断功能。而在 <code>RestTemplate</code> 中实现熔断需要手动配置，例如结合 <code>CircuitBreaker</code> 进行实现，稍显繁琐。</p></li><li><p><strong>可扩展性</strong>：OpenFeign 提供了更强的扩展支持，如全局请求拦截器（<code>RequestInterceptor</code>）、超时设置等，可通过注解或配置文件集中管理。而 <code>RestTemplate</code> 则需要通过 <code>ClientHttpRequestInterceptor</code> 来手动添加拦截器，配置相对复杂。</p></li><li><p><strong>可维护性和测试性</strong>：OpenFeign 将远程服务抽象为接口，使得服务之间的依赖关系更清晰，测试时可以轻松进行 Mock，不需要关心实现细节。而在 <code>RestTemplate</code> 中进行类似的 Mock 测试时，需要为每个请求配置更多细节。</p></li></ol><h2 id="使用-OpenFeign"><a href="#使用-OpenFeign" class="headerlink" title="使用 OpenFeign"></a>使用 OpenFeign</h2><p>首先，我们需要在 pom.xml 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们可以在 Spring Boot 项目中定义一个接口，该接口将定义远程服务的 API。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;cloud-provider-payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/pay/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 <code>@FeignClient</code> 注解定义了一个 Feign 客户端，<code>name</code> 属性指定了服务提供者的服务名，<code>@GetMapping</code> 注解定义了一个 GET 请求，<code>@PathVariable</code> 注解用于获取请求参数。</p><p>最后，我们可以在 Controller 中注入该接口，并调用远程服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title function_">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们注入了 <code>PaymentFeignService</code> 接口，并调用了 <code>getPaymentById</code> 方法，实现了远程服务的调用。</p><p><strong>OpenFeign天然支持负载均衡</strong>，只需要在配置文件中配置服务提供者的服务名即可，无需关心具体的 IP 和端口。</p><h2 id="配置超时时间"><a href="#配置超时时间" class="headerlink" title="配置超时时间"></a>配置超时时间</h2><p>调用服务的超时时间是一个重要的配置，可以避免因为网络延迟导致的性能问题。</p><p>在 OpenFeign 中，我们可以通过配置文件来设置超时时间，例如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">        <span class="attr">client:</span></span><br><span class="line">            <span class="attr">config:</span></span><br><span class="line">            <span class="attr">default:</span> <span class="comment"># 全局配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">            <span class="attr">my-service:</span> <span class="comment"># 指定服务配置</span></span><br><span class="line">                <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">                <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们设置了默认的超时时间为 5 秒。</p><p>openFeign的默认超时时间是60s。</p><h2 id="配置重试机制"><a href="#配置重试机制" class="headerlink" title="配置重试机制"></a>配置重试机制</h2><p>在 OpenFeign 中，可以设置重试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OpenFeignConfig.java</span></span><br><span class="line"><span class="keyword">public</span> OpenFeignConfig&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重试机制</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Retryer <span class="title function_">myRetryer</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retryer</span>.Default(<span class="number">100</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志记录级别</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 更换默认的client</span><br><span class="line">在 OpenFeign 中，我们可以通过配置文件来更换默认的 client，例如：</span><br><span class="line">```yaml</span><br><span class="line">cloud:</span><br><span class="line">    openfeign:</span><br><span class="line">        httpclient:</span><br><span class="line">            hc5:</span><br><span class="line">                enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们通过 <code>cloud.openfeign.httpclient.hc5.enabled</code> 属性来启用 HttpClient 5.x 版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenFeign介绍&quot;&gt;&lt;a href=&quot;#OpenFeign介绍&quot; class=&quot;headerlink&quot; title=&quot;OpenFeign介绍&quot;&gt;&lt;/a&gt;OpenFeign介绍&lt;/h2&gt;&lt;p&gt;OpenFeign 是一个声明式的 HTTP 客户端工具，集成了 N</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud:服务注册与发现</title>
    <link href="https://kelinkong.github.io/2024/11/14/Spring-Cloud-%E6%96%B0%E5%A2%9E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/"/>
    <id>https://kelinkong.github.io/2024/11/14/Spring-Cloud-%E6%96%B0%E5%A2%9E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9D%97/</id>
    <published>2024-11-14T02:51:57.000Z</published>
    <updated>2024-11-14T08:12:26.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务之间的通信"><a href="#微服务之间的通信" class="headerlink" title="微服务之间的通信"></a>微服务之间的通信</h2><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate是Spring提供的用于访问Rest服务的客户端模板工具集。</p><p>添加配置类<code>RestTemplateConfig</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要用配置类？而不是每次使用<code>RestTemplate</code>时都创建一个新的实例？</p><blockquote><p>因为<code>RestTemplate</code>的实例化是一个比较耗时的操作，如果每次使用都创建一个新的实例，会影响性能。</p><p>RestTemplate 是设计为线程安全的，能够在多个线程之间共享。通过定义一个单例的 RestTemplate，可以确保多个线程安全地访问同一个实例，而不需要担心并发问题。</p><p>使用配置类可以集中管理 RestTemplate 的配置，比如超时设置、拦截器、消息转换器等。这使得应用程序的配置更加一致和易于维护。</p></blockquote><ol><li>创建一个<code>RestTemplate</code>实例，并注入到Spring容器中。</li><li>使用<code>RestTemplate</code>发送HTTP请求，并接收响应。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateClient</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/user/name&quot;</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RestTemplate</code> 是 Spring 框架中的一个类，用于在客户端上发送 HTTP 请求并处理响应。它支持多种 HTTP 请求方法，主要包括以下几种：</p><h4 id="1-GET-请求"><a href="#1-GET-请求" class="headerlink" title="1. GET 请求"></a>1. <code>GET</code> 请求</h4><p>用于从服务器获取资源。<code>RestTemplate</code> 提供了 <code>getForObject</code> 和 <code>getForEntity</code> 方法：</p><ul><li><p>**<code>getForObject</code>**：返回指定类型的对象（自动转换）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://example.com/resource&quot;</span>, String.class);</span><br></pre></td></tr></table></figure></li><li><p>**<code>getForEntity</code>**：返回 <code>ResponseEntity</code> 对象，其中包含 HTTP 状态码、头部信息和实体内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(<span class="string">&quot;http://example.com/resource&quot;</span>, String.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-POST-请求"><a href="#2-POST-请求" class="headerlink" title="2. POST 请求"></a>2. <code>POST</code> 请求</h4><p>用于向服务器提交数据，<code>RestTemplate</code> 提供了 <code>postForObject</code> 和 <code>postForEntity</code> 方法：</p><ul><li><p>**<code>postForObject</code>**：提交数据后返回响应的实体内容（转换为指定类型）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> restTemplate.postForObject(<span class="string">&quot;http://example.com/resource&quot;</span>, requestBody, String.class);</span><br></pre></td></tr></table></figure></li><li><p>**<code>postForEntity</code>**：提交数据后返回 <code>ResponseEntity</code>，包含状态码、头部信息和实体内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(<span class="string">&quot;http://example.com/resource&quot;</span>, requestBody, String.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-PUT-请求"><a href="#3-PUT-请求" class="headerlink" title="3. PUT 请求"></a>3. <code>PUT</code> 请求</h4><p>用于更新服务器上的资源，<code>RestTemplate</code> 提供了 <code>put</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restTemplate.put(<span class="string">&quot;http://example.com/resource/&#123;id&#125;&quot;</span>, updatedResource, id);</span><br></pre></td></tr></table></figure><p><code>PUT</code> 请求通常不返回响应内容，因此 <code>put</code> 方法的返回类型为 <code>void</code>。</p><h4 id="4-DELETE-请求"><a href="#4-DELETE-请求" class="headerlink" title="4. DELETE 请求"></a>4. <code>DELETE</code> 请求</h4><p>用于删除服务器上的资源，<code>RestTemplate</code> 提供了 <code>delete</code> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">restTemplate.delete(<span class="string">&quot;http://example.com/resource/&#123;id&#125;&quot;</span>, id);</span><br></pre></td></tr></table></figure><p>同样，<code>DELETE</code> 请求通常不返回响应内容，因此 <code>delete</code> 方法的返回类型为 <code>void</code>。</p><h2 id="提取通用模块"><a href="#提取通用模块" class="headerlink" title="提取通用模块"></a>提取通用模块</h2><p>将所有使用的通用模块提取到一个单独的模块中，方便其他模块引用。</p><ol><li>创建一个新的模块，命名为<code>common</code>。</li><li>将通用模块的代码复制到<code>common</code>模块中。</li><li>在其他模块中添加<code>common</code>模块的依赖。</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="consul介绍"><a href="#consul介绍" class="headerlink" title="consul介绍"></a>consul介绍</h2><p>Consul 是 HashiCorp 公司提供的一款开源的服务发现和配置管理工具。它提供了一种简单的方式来注册和发现服务，并提供了服务健康检查功能。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="https://developer.hashicorp.com/consul/install?product_intent=consul">consul下载链接</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap hashicorp/tap</span><br><span class="line">brew install hashicorp/tap/consul</span><br></pre></td></tr></table></figure><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>启动consul：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>访问：<br><a href="http://localhost:8500/">http://localhost:8500</a></p><p>配置文件地址：<a href="https://cloud.spring.io/spring-cloud-consul/reference/html/">Spring- cloud-consul</a></p><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><ol><li>添加依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>配置文件<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span>         <span class="comment"># Consul 的地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span>              <span class="comment"># Consul 的端口号</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">my-service</span>   <span class="comment"># 服务名，可随项目需求更改</span></span><br><span class="line">        <span class="attr">health-check-interval:</span> <span class="string">10s</span> <span class="comment"># 健康检查时间间隔</span></span><br></pre></td></tr></table></figure></li><li>在主启动类上添加 @EnableDiscoveryClient 注解，Spring Boot 应用启动时会自动将服务注册到 Consul。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServiceApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyServiceApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过 @LoadBalanced 注解和 RestTemplate 或 Feign 客户端来进行服务调用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p>服务消费者需要依赖服务提供者的服务名，而不是具体的IP和端口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PAYMENT_URL</span> <span class="operator">=</span> <span class="string">&quot;http://cloud-provider-payment&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">// 注入RestTemplate</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pay/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData <span class="title function_">addOrder</span><span class="params">(PayDTO payDTO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="string">&quot;/pay/add&quot;</span>, payDTO, ResultData.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="consul-配置"><a href="#consul-配置" class="headerlink" title="consul 配置"></a>consul 配置</h2><p>使用 Consul 作为配置管理工具，可以将应用的配置信息集中存储在 Consul 中，应用从 Consul 读取配置，而不是依赖本地文件。Spring Cloud 提供了 <code>spring-cloud-starter-consul-config</code> 模块，方便与 Consul 集成，以下是如何配置和使用 Consul 来进行配置管理的步骤：</p><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><p>在 <code>pom.xml</code> 中添加 Consul 配置依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-配置-Consul-连接"><a href="#2-配置-Consul-连接" class="headerlink" title="2. 配置 Consul 连接"></a>2. 配置 Consul 连接</h3><p>在 <code>application.yml</code> 或 <code>application.properties</code> 中配置 Consul 的连接地址和一些关键设置：</p><p>这里也可以在<code>bootstrap.yml</code>中配置：<code>bootstrap.yaml</code>的优先级高于<code>application.yaml</code>。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span>         <span class="comment"># Consul 的主机地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span>              <span class="comment"># Consul 的端口</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>         <span class="comment"># 启用 Consul 配置管理</span></span><br><span class="line">        <span class="attr">default-context:</span> <span class="string">application</span>  <span class="comment"># 默认上下文（通用配置）</span></span><br><span class="line">        <span class="attr">profile-separator:</span> <span class="string">&#x27;-&#x27;</span>        <span class="comment"># 配置文件和环境的分隔符</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">yaml</span>                  <span class="comment"># 配置格式 (yaml 或 properties)</span></span><br><span class="line">        <span class="attr">fail-fast:</span> <span class="literal">true</span>               <span class="comment"># 启动时加载配置失败是否立即失败</span></span><br></pre></td></tr></table></figure><h3 id="3-在-Consul-中存储配置"><a href="#3-在-Consul-中存储配置" class="headerlink" title="3. 在 Consul 中存储配置"></a>3. 在 Consul 中存储配置</h3><p>Consul 的配置管理使用 Key-Value 存储系统。将配置文件内容以键值对形式存储在 Consul 中，格式如下：</p><h4 id="Key-结构"><a href="#Key-结构" class="headerlink" title="Key 结构"></a>Key 结构</h4><p>Consul 中的键通常按以下路径结构组织：</p><ul><li><code>config/&#123;application-name&#125;/&#123;profile&#125;/data</code></li></ul><p>例如，应用名为 <code>my-app</code>，环境为 <code>dev</code> 的配置路径为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config/my-app/dev/data</span><br></pre></td></tr></table></figure><h4 id="存储配置"><a href="#存储配置" class="headerlink" title="存储配置"></a>存储配置</h4><p>可以通过 Consul 的 Web UI 或命令行将配置写入 Consul。在 Web UI 中可以添加键值对，也可以使用 <code>curl</code> 命令来添加配置。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -X PUT --data-binary @application.yml http://localhost:8500/v1/kv/config/my-app/data</span><br></pre></td></tr></table></figure><p>将配置数据 <code>application.yml</code> 上传到 Consul 的 <code>config/my-app/data</code> 路径。</p><h3 id="4-Consul-配置的层次结构"><a href="#4-Consul-配置的层次结构" class="headerlink" title="4. Consul 配置的层次结构"></a>4. Consul 配置的层次结构</h3><p>Consul 的配置会覆盖，层次结构为：</p><ul><li><code>config/application/</code>：通用配置（所有应用和环境共享）。</li><li><code>config/&#123;application-name&#125;/</code>：特定应用的配置。</li><li><code>config/&#123;application-name&#125;/&#123;profile&#125;/</code>：特定应用的特定环境配置（如 <code>dev</code>、<code>prod</code>）。</li></ul><h3 id="5-读取配置"><a href="#5-读取配置" class="headerlink" title="5. 读取配置"></a>5. 读取配置</h3><p>在 Spring Boot 应用中，不需要额外的代码来读取 Consul 配置。Spring Cloud Consul Config 会自动将 Consul 中的配置加载到 Spring 的 <code>Environment</code> 中，和 <code>application.yml</code> 或 <code>application.properties</code> 中的配置一样使用。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从 Consul 加载的配置会自动生效</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;Hello from Consul&quot;</span></span><br></pre></td></tr></table></figure><p>在应用中，可以像平常一样使用 <code>@Value</code> 注解或 <code>@ConfigurationProperties</code> 注解获取配置值：在data中写：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">atguigu:</span></span><br><span class="line">    <span class="attr">info:</span> <span class="string">&quot;Hello from Consul&quot;</span></span><br></pre></td></tr></table></figure><p>获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;atguigu.info&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-配置动态刷新"><a href="#6-配置动态刷新" class="headerlink" title="6. 配置动态刷新"></a>6. 配置动态刷新</h3><p>Spring Cloud Consul 支持配置的动态刷新。如果 Consul 中的配置发生变化，可以自动更新应用中的配置值。启用动态刷新需要在 <code>@RefreshScope</code> 注解的支持下：</p><ol><li>在需要动态刷新的 Bean 类上添加 <code>@RefreshScope</code> 注解。</li><li>默认配置会每 60 秒刷新一次，可以在 <code>application.yml</code> 中通过 <code>spring.cloud.consul.config.watch-delay</code> 配置刷新频率（单位为毫秒）。</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">watch-delay:</span> <span class="number">1000</span>    <span class="comment"># 每秒检查一次配置更新</span></span><br></pre></td></tr></table></figure><p>在需要动态刷新的配置类上使用 <code>@RefreshScope</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;my.config.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String configValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/config&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getConfigValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> configValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个配置不是持久化的，当服务重启后，配置不会保留。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微服务之间的通信&quot;&gt;&lt;a href=&quot;#微服务之间的通信&quot; class=&quot;headerlink&quot; title=&quot;微服务之间的通信&quot;&gt;&lt;/a&gt;微服务之间的通信&lt;/h2&gt;&lt;h3 id=&quot;RestTemplate&quot;&gt;&lt;a href=&quot;#RestTemplate&quot; cla</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud：base工程</title>
    <link href="https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/"/>
    <id>https://kelinkong.github.io/2024/11/13/Spring-Cloud%EF%BC%9Abase%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-11-13T07:31:35.000Z</published>
    <updated>2024-11-14T02:34:21.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h2><p>使用Idea做为编译器，创建一个新的Spring Cloud项目。</p><p>版本选择：</p><p><img src="/../imgs/image-67.png"></p><h3 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew services start mysql</span><br></pre></td></tr></table></figure><p><strong>查看mysql版本</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select VERSION();</span><br><span class="line">+-----------+</span><br><span class="line">| VERSION() |</span><br><span class="line">+-----------+</span><br><span class="line">| 9.0.1     |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>创建数据库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database db2024;</span><br></pre></td></tr></table></figure><p><strong>创建表</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_pay</span><br><span class="line">(</span><br><span class="line">    id          INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    pay_no      VARCHAR(50) NOT NULL COMMENT &#x27;支付流水号&#x27;,</span><br><span class="line">    order_no    VARCHAR(50) NOT NULL COMMENT &#x27;订单流水号&#x27;,</span><br><span class="line">    user_id     INT DEFAULT 1 NULL COMMENT &#x27;用户账号ID&#x27;,</span><br><span class="line">    amount      DECIMAL(8, 2) DEFAULT 9.90 NOT NULL COMMENT &#x27;交易金额&#x27;,</span><br><span class="line">    deleted     TINYINT UNSIGNED DEFAULT &#x27;0&#x27; NOT NULL COMMENT &#x27;删除标志, 默认0不删除,1删除&#x27;,</span><br><span class="line">    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;</span><br><span class="line">)</span><br><span class="line">COMMENT &#x27;支付交易表&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自动生成mapper和实体类"><a href="#自动生成mapper和实体类" class="headerlink" title="自动生成mapper和实体类"></a>自动生成mapper和实体类</h2><p>创建一个mybatis-generator模块，自动生成mapper和实体类。</p><p>使用<code>mybatis-generator-maven-plugin</code>插件。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在maven中，双击<code>mybatis-generator:generate</code>即可生成。</p><p>配置文件在<code>src/main/resources/generator/generatorConfig.xml</code>。</p><h2 id="新建一个微服务流程"><a href="#新建一个微服务流程" class="headerlink" title="新建一个微服务流程"></a>新建一个微服务流程</h2><ol><li>新建一个模块，例如：pay-service。</li><li>更改pom.xml文件，添加依赖。</li><li>写yml配置文件。</li><li>编写启动类。</li><li>编写业务代码。</li></ol><h2 id="Swager3"><a href="#Swager3" class="headerlink" title="Swager3"></a>Swager3</h2><p>Swager是一个API文档生成工具，可以通过注解生成API文档。</p><p>常用注解：</p><ul><li><code>@Tag</code>：用在类上，说明该类的作用。</li><li><code>@Operation</code>：用在方法上，说明方法的作用。</li><li><code>@Parameter</code>：用在方法参数上，说明参数的作用。</li><li><code>Schema</code>：用在实体类上，说明实体类的作用。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController()</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pay&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;支付微服务模块&quot;, description = &quot;支付crud操作&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PayService payService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增&quot;, description = &quot;新增支付流水, 参数是JSON字符串&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> PayDTO payDTO)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> payService.add(payDTO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>写配置类，配置Swagger3。</p><p>进入地址：<a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p><p>在网页上可以看到生成的API文档。点击try it out可以测试接口。</p><h2 id="时间格式问题"><a href="#时间格式问题" class="headerlink" title="时间格式问题"></a>时间格式问题</h2><h3 id="使用-JsonFormat注解"><a href="#使用-JsonFormat注解" class="headerlink" title="使用@JsonFormat注解"></a>使用<code>@JsonFormat</code>注解</h3><p>在实体类中添加注解，指定时间格式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br></pre></td></tr></table></figure><h3 id="在application-yml中配置"><a href="#在application-yml中配置" class="headerlink" title="在application.yml中配置"></a>在application.yml中配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jackson:</span></span><br><span class="line">        <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">        <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br></pre></td></tr></table></figure><h2 id="统一返回值"><a href="#统一返回值" class="headerlink" title="统一返回值"></a>统一返回值</h2><p>现在主流的返回值需要包括：</p><ul><li>code：状态码</li><li>data：数据</li><li>message：消息</li><li>timestamp：时间戳（调用接口的时间）</li></ul><p>状态码一般是枚举类型。</p><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>编写枚举类的技巧：举值-构造-遍历。</p><h2 id="全局异常处理和返回"><a href="#全局异常处理和返回" class="headerlink" title="全局异常处理和返回"></a>全局异常处理和返回</h2><p>定义一个全局异常处理类，继承<code>ResponseEntityExceptionHandler</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> <span class="keyword">extends</span> <span class="title class_">ResponseEntityExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;全局异常处理：&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(<span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生异常时，会调用<code>handleException</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开发前准备&quot;&gt;&lt;a href=&quot;#开发前准备&quot; class=&quot;headerlink&quot; title=&quot;开发前准备&quot;&gt;&lt;/a&gt;开发前准备&lt;/h2&gt;&lt;p&gt;使用Idea做为编译器，创建一个新的Spring Cloud项目。&lt;/p&gt;
&lt;p&gt;版本选择：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-配置文件</title>
    <link href="https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://kelinkong.github.io/2024/11/13/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2024-11-13T01:50:41.000Z</published>
    <updated>2024-11-13T02:14:32.002Z</updated>
    
    <content type="html"><![CDATA[<p>基于SpringBoot的Java学习笔记-配置文件</p><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-1-config.html">配置文件</a></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot的默认配置文件在：<code>src/main/resources/application.properties</code></p><p>关于Spring Boot应用的配置内容都可以集中在该文件中了，根据我们引入的不同Starter模块，可以在这里定义诸如：容器端口名、数据库链接信息、日志级别等各种配置信息。比如，我们需要自定义web模块的服务端口号，可以在<code>application.properties</code>中添加<code>server.port=8888</code>来指定服务端口为8888，也可以通过<code>spring.application.name=hello</code>来指定应用名（该名字在Spring Cloud应用中会被注册为服务名）。</p><p>也可以使用yaml文件来配置。</p><p>如：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line">  <span class="attr">context-path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">shutdown:</span></span><br><span class="line">    <span class="attr">graceful:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8889</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><p>对应的application.properties文件：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br><span class="line"><span class="attr">server.context-path</span>=<span class="string">/hello</span></span><br><span class="line"><span class="attr">server.shutdown.graceful</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.port</span>=<span class="string">8889</span></span><br><span class="line"><span class="attr">server.shutdown.timeout</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">server.shutdown.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.shutdown.path</span>=<span class="string">/shutdown</span></span><br></pre></td></tr></table></figure><h3 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h3><p>在配置文件中可以定义一些自定义参数，如</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">book.name</span>=<span class="string">Spring Boot 2.x</span></span><br></pre></td></tr></table></figure><p>在Java代码中可以通过<code>@Value</code>注解来获取配置文件中的参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;book.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String bookName;</span><br></pre></td></tr></table></figure><p>还可以使用随机数</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在启动应用时，可以通过命令行参数来覆盖配置文件中的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar myapp.jar --server.port=8888</span><br></pre></td></tr></table></figure><p><code>--</code>后面的参数会覆盖配置文件中的参数。</p><h3 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>在Spring Boot中多环境配置文件名需要满足<code>application-&#123;profile&#125;.properties</code>的格式，其中<code>&#123;profile&#125;</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li><li><code>application.properties</code>：默认环境</li></ul><p>在<code>application.properties</code>中通过<code>spring.profiles.active</code>来指定当前环境，如：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h3><p>Spring Boot会按照如下顺序加载配置文件：</p><ul><li>命令行中传入的参数。</li><li>SPRING_APPLICATION_JSON中的属性。SPRING_APPLICATION_JSON是以JSON格式配置在系统环境变量中的内容。</li><li>java:comp&#x2F;env中的JNDI属性。</li><li>Java的系统属性，可以通过System.getProperties()获得的内容。</li><li>操作系统的环境变量</li><li>通过random.*配置的随机属性</li><li>位于当前应用jar包之外，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之内，针对不同{profile}环境的配置文件内容，例如：application-{profile}.properties或是YAML定义的配置文件</li><li>位于当前应用jar包之外的application.properties和YAML配置内容</li><li>位于当前应用jar包之内的application.properties和YAML配置内容</li><li>在@Configuration注解修改的类中，通过@PropertySource注解定义的属性</li><li>应用默认属性，使用SpringApplication.setDefaultProperties定义的内容</li></ul><h2 id="加密敏感信息"><a href="#加密敏感信息" class="headerlink" title="加密敏感信息"></a>加密敏感信息</h2><p>参考：<a href="https://www.didispace.com/spring-boot-2/2-5-jasypt.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0%E5%AF%86">Spring Boot 2.x敏感信息加密</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于SpringBoot的Java学习笔记-配置文件&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.didispace.com/spring-boot-2/2-1-config.html&quot;&gt;配置文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-使用langchain-chatchat和ollama构建大模型</title>
    <link href="https://kelinkong.github.io/2024/11/07/lvvm-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/07/lvvm-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-07T11:14:13.000Z</published>
    <updated>2024-11-08T00:26:58.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>github地址：</strong></p><p>langchina-chatchat地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></p><p>ollama地址：<a href="https://github.com/ollama/ollama">ollama</a></p><h2 id="使用langchain-chatchat和ollama构建大模型"><a href="#使用langchain-chatchat和ollama构建大模型" class="headerlink" title="使用langchain-chatchat和ollama构建大模型"></a>使用langchain-chatchat和ollama构建大模型</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>langchain-chatchat</strong></p><p>langchain-chatchat在0.3版本之后支持使用pip安装，这里推荐创建一个新的虚拟环境来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create -n langchain python=3.10</span><br><span class="line">conda activate langchain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install langchain-chatchat -U</span><br></pre></td></tr></table></figure><p><strong>ollama</strong></p><p>ollama的安装比较简单，只需要使用pip安装即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ollama</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>langchain-chatchat</strong></p><p><strong>初始化</strong>，建议创建一个空的文件夹来进行初始化。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat init</span><br></pre></td></tr></table></figure><p>该命令会执行以下操作：</p><ul><li>创建所有需要的数据目录</li><li>复制 samples 知识库内容</li><li>生成默认 yaml 配置文件</li></ul><p><strong>修改配置文件</strong></p><p>具体每个配置文件的作用可以到github仓库查看，这里只列出需要修改的配置文件。</p><p>在文件<code>model_settings.yaml</code>中，修改:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">platform_name:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">platform_type:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">api_base_url:</span> <span class="string">http://127.0.0.1:11434/v1</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">EMPTY</span></span><br><span class="line">  <span class="attr">api_proxy:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">api_concurrencies:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">auto_detect_model:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">llm_models:</span> <span class="comment"># 本地部署的模型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwen2</span></span><br><span class="line">  <span class="attr">embed_models:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">quentinz/bge-large-zh-v1.5</span> <span class="comment"># 嵌入模型</span></span><br><span class="line">  <span class="attr">text2image_models:</span> []</span><br><span class="line">  <span class="attr">image2text_models:</span> []</span><br><span class="line">  <span class="attr">rerank_models:</span> []</span><br><span class="line">  <span class="attr">speech2text_models:</span> []</span><br><span class="line">  <span class="attr">text2speech_models:</span> []</span><br></pre></td></tr></table></figure><p>前面的默认模型可以不修改，开启自动检测后，会自动检测ollama中的模型。</p><p><strong>ollama</strong></p><p>加载大语言模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run qwen2</span><br></pre></td></tr></table></figure><p>如果本地没有部署，会自动下载模型。打开浏览器查看是否正确启动：<a href="http://localhost:11434/">http://localhost:11434</a></p><p>加载嵌入模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama pull quentinz/bge-large-zh-v1.5:latest</span><br></pre></td></tr></table></figure><p>嵌入模型不需要运行，只需要下载即可。</p><blockquote><p>嵌入模型（例如 quentinz&#x2F;bge-large-zh-v1.5）的主要作用是将文本转换成向量表示，这种向量表示也叫做“嵌入” (embedding)。这些嵌入可以捕捉到文本的语义信息，以便在不同的 NLP 任务中进行高效的相似度计算和语义搜索。</p><p>quentinz&#x2F;bge-large-zh-v1.5 可以用于生成中文文本的嵌入。例如，当输入一句中文文本时，该模型会输出一个向量（embedding），我们可以利用这个向量来完成以下操作</p></blockquote><h3 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h3><p>在生成知识库之前，要先确保ollama已经正确启动，使用默认的向量数据库，需要下载驱动，在pycharm中点击info.db，根据提示下载驱动即可。</p><p>使用<code>chatchat</code>命令生成知识库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat kb -r</span><br></pre></td></tr></table></figure><p>这里可能会遇到各种bug，自行到社区issue中查找解决方案。如果没有解决方案，可以给社区提issue。</p><p>出现以下提示表示生成成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">知识库名称      ：samples</span><br><span class="line">知识库类型      ：faiss</span><br><span class="line">向量模型：      ：bge-large-zh-v1.5</span><br><span class="line">知识库路径      ：/root/anaconda3/envs/chatchat/lib/python3.11/site-packages/chatchat/data/knowledge_base/samples</span><br><span class="line">文件总数量      ：47</span><br><span class="line">入库文件数      ：42</span><br><span class="line">知识条目数      ：740</span><br><span class="line">用时            ：0:02:29.701002</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">总计用时        ：0:02:33.414425</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat start -a</span><br></pre></td></tr></table></figure><p>运行成功之后，可以在网页上进行知识库配置、对话等。</p><p>其余功能有待摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;langchina-chatchat地址：&lt;a href=&quot;https:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大模型有关的一些工具链</title>
    <link href="https://kelinkong.github.io/2024/11/07/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>https://kelinkong.github.io/2024/11/07/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-11-07T02:36:51.000Z</published>
    <updated>2024-11-12T07:07:28.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大模型的汇总仓库"><a href="#大模型的汇总仓库" class="headerlink" title="大模型的汇总仓库"></a>大模型的汇总仓库</h2><p><a href="https://github.com/ikaijua/Awesome-AITools/blob/main/README-CN.md">awesome AI</a></p><h2 id="使用大模型做具体场景助手"><a href="#使用大模型做具体场景助手" class="headerlink" title="使用大模型做具体场景助手"></a>使用大模型做具体场景助手</h2><p>使用开源工具来实现具体场景下的 AI 助手，流程可以简化如下：</p><ol><li><p>Prompt 工程</p><ul><li>流程：设计并优化 prompt，让大模型生成符合需求的答案，进行 prompt 测试和调整。</li><li>工具：可以使用 OpenAI API（如 GPT-3 开源替代品）结合 LangChain 或 LlamaIndex（前称 GPT Index）来管理和优化 prompt。</li></ul></li><li><p>构建知识库</p><ul><li>流程：收集和清洗数据，将信息分块后存入知识库，并生成索引以便高效检索。</li><li>工具：<ul><li>Elasticsearch 或 FAISS：用于分块后的数据存储和快速检索。</li><li>Haystack 或 LlamaIndex：可用于索引管理，便于与生成模型集成。</li></ul></li></ul></li><li><p>检索增强生成（RAG）</p><ul><li>流程：通过检索模块先找到相关信息片段，再输入生成模型生成回答，增强内容准确性。</li><li>工具：Haystack 或 LangChain，集成检索与生成，提供基于上下文的回答。</li></ul></li><li><p>大模型微调</p><ul><li>流程：将场景相关数据准备好后对大模型进行微调，使其适应具体领域或场景。</li><li>工具：<ul><li>Hugging Face Transformers：用于加载和微调模型。</li><li>Hugging Face Datasets：用于管理和预处理训练数据。</li></ul></li></ul></li><li><p>模型量化</p><ul><li>流程：在部署前对模型进行量化，以减小模型体积并加快推理速度。</li><li>工具：BitsAndBytes（4&#x2F;8 位量化）、ONNX Runtime（支持量化优化）。</li></ul></li><li><p>部署</p><ul><li>流程：将微调和量化后的模型部署在服务器或云端。</li><li>工具：<ul><li>FastAPI 或 Flask：用于搭建 API 服务。</li><li>Docker：用于容器化部署，保证环境一致性。</li><li>Hugging Face Inference（如使用推理服务器）或 ONNX Runtime（加速推理）。</li></ul></li></ul></li></ol><p>简化流程示例</p><p>设计 prompt → 构建知识库 → RAG 检索 → 大模型微调 → 模型量化 → 部署</p><p>这些步骤结合开源工具能够实现高效的 AI 助手。</p><h2 id="ollama"><a href="#ollama" class="headerlink" title="ollama"></a>ollama</h2><h3 id="ollama简介"><a href="#ollama简介" class="headerlink" title="ollama简介"></a>ollama简介</h3><p>ollama用来部署和运行大型语言模型，它提供了一个简单的命令行工具，可以用来运行模型、查看模型列表、下载模型等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计 prompt → 构建知识库 → RAG 检索 → Ollama 微调 → Ollama 量化 → Ollama 部署</span><br></pre></td></tr></table></figure><p>官网地址：<a href="https://ollama.com/">ollama</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行一个模型，如果本地不存在该模型，会自动到仓库下载，仓库地址：<br><a href="https://ollama.com/library">ollama模型仓库</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run llama3-8b-8192</span><br></pre></td></tr></table></figure><p>一些指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看模型列表</span></span><br><span class="line">ollama list</span><br><span class="line"><span class="comment"># 查看当前运行的模型</span></span><br><span class="line">ollama ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># -h 查看帮助</span></span><br><span class="line">serve       Start ollama</span><br><span class="line">create      Create a model from a Modelfile</span><br><span class="line">show        Show information <span class="keyword">for</span> a model</span><br><span class="line">run         Run a model</span><br><span class="line">stop        Stop a running model</span><br><span class="line">pull        Pull a model from a registry</span><br><span class="line">push        Push a model to a registry</span><br><span class="line">list        List models</span><br><span class="line">ps          List running models</span><br><span class="line"><span class="built_in">cp</span>          Copy a model</span><br><span class="line"><span class="built_in">rm</span>          Remove a model</span><br><span class="line"><span class="built_in">help</span>        Help about any <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>查看ollama是否正确启动：<a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a></p><h2 id="open-webui"><a href="#open-webui" class="headerlink" title="open-webui"></a>open-webui</h2><p>open-webui提供了一个简单的web界面，可以用来查看模型列表、运行模型等。</p><p>仓库地址：<a href="https://github.com/open-webui/open-webui">open-webui</a></p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install open-webui</span><br><span class="line">open-webui serve</span><br></pre></td></tr></table></figure><h2 id="modelscope"><a href="#modelscope" class="headerlink" title="modelscope"></a>modelscope</h2><p>官网地址：<a href="https://modelscope.ai/">modelscope</a></p><p>github地址：<a href="https://github.com/modelscope/modelscope/tree/master">modelscope</a></p><h3 id="modelscope简介"><a href="#modelscope简介" class="headerlink" title="modelscope简介"></a>modelscope简介</h3><p>modelscope是一个 “模型即服务”(MaaS) 平台，旨在汇集来自 AI 社区的最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。ModelScope 库使开发人员能够通过丰富的 API 设计执行推理、训练和评估，从而促进跨不同 AI 领域的最先进模型的统一体验。</p><p>ModelScope Library 为模型贡献者提供了必要的分层 API，以便将来自 CV、NLP、语音、多模态以及科学计算的模型集成到 ModelScope 生态系统中。所有这些不同模型的实现都以一种简单统一访问的方式进行封装，用户只需几行代码即可完成模型推理、微调和评估。同时，灵活的模块化设计使得在必要时也可以自定义模型训练推理过程中的不同组件。</p><h3 id="安装和使用-1"><a href="#安装和使用-1" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>在ModelScope Hub 中有很多可以训练的模型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n modelscope python=3.10</span><br><span class="line">conda activate modelscope</span><br></pre></td></tr></table></figure><p>模型下载需要先配置好Git LFS。</p><blockquote><p>git lfs 是一个 Git 的扩展，它用来存储大文件。它的设计目标是让 Git 能够更好地管理大文件，而不是让 Git 成为一个文件存储系统。Git LFS 通过将大文件存储在远程服务器上，而不是存储在 Git 仓库中，来解决 Git 仓库过大的问题。</p></blockquote><p>之后就可以下载用来训练的模型，和github上的代码一样，可以直接使用git clone。</p><p>训练好的模型（微调）在部署时，通常还需要量化，这样才能在较小的设备上运行。</p><h2 id="langchain和langchain-chatchat"><a href="#langchain和langchain-chatchat" class="headerlink" title="langchain和langchain-chatchat"></a>langchain和langchain-chatchat</h2><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>这里有一个简单的教程:<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">langchain</a>，可以用来构建一个简单的LLM（Large Language Model）应用。</p><p>核心就是构建链，链可以包含各种处理步骤，例如模型、解析器和提示。</p><h3 id="langchain-chatchat"><a href="#langchain-chatchat" class="headerlink" title="langchain-chatchat"></a>langchain-chatchat</h3><p>仓库地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-files">langchain-chatchat</a></p><p>一种利用 langchain 思想实现的基于本地知识库的问答应用，目标期望建立一套对中文场景与开源模型支持友好、可离线运行的知识库问答解决方案。</p><p><strong>原理：</strong><br><img src="/../imgs/image-65.png"><br><img src="/../imgs/image-66.png"></p><p>在这个项目中，并不涉及模型的微调。模型微调参考：<a href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/">llvm-微调大模型</a></p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>官网地址：<a href="https://www.dify.ai/">Dify</a></p><p>github地址：<a href="https://github.com/langgenius/dify">Dify</a></p><p>官方文档：<a href="https://docs.dify.ai/">Dify文档</a></p><p>Dify 是一款开源的大语言模型(LLM) 应用开发平台。它融合了后端即服务（Backend as Service）和 LLMOps 的理念，使开发者可以快速搭建生产级的生成式 AI 应用。即使你是非技术人员，也能参与到 AI 应用的定义和数据运营过程中。</p><p>由于 Dify 内置了构建 LLM 应用所需的关键技术栈，包括对数百个模型的支持、直观的 Prompt 编排界面、高质量的 RAG 引擎、稳健的 Agent 框架、灵活的流程编排，并同时提供了一套易用的界面和 API。这为开发者节省了许多重复造轮子的时间，使其可以专注在创新和业务需求上。</p><p>dify支持ollama，可以直接使用本地部署的模型。</p><h2 id="Groqcloud"><a href="#Groqcloud" class="headerlink" title="Groqcloud"></a>Groqcloud</h2><p>官网地址：<a href="https://console.groq.com/playground">Groqcloud</a></p><p>GroqCloud 是由 Groq 公司提供的云服务，专注于快速 AI 推理。它利用 Groq 的语言处理单元（LPU）硬件和相关软件，推理速度很快，而且API便宜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大模型的汇总仓库&quot;&gt;&lt;a href=&quot;#大模型的汇总仓库&quot; class=&quot;headerlink&quot; title=&quot;大模型的汇总仓库&quot;&gt;&lt;/a&gt;大模型的汇总仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ikaijua/Awesome-AI</summary>
      
    
    
    
    <category term="llvm" scheme="https://kelinkong.github.io/categories/llvm/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 LCEL 构建一个简单的 LLM 应用</title>
    <link href="https://kelinkong.github.io/2024/11/06/llvm-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/11/06/llvm-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/</id>
    <published>2024-11-06T01:43:04.000Z</published>
    <updated>2024-11-07T08:36:32.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h2><p>教程来源于：<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">LangChain</a></p><h2 id="使用-LCEL-构建一个简单的-LLM-应用"><a href="#使用-LCEL-构建一个简单的-LLM-应用" class="headerlink" title="使用 LCEL 构建一个简单的 LLM 应用"></a>使用 LCEL 构建一个简单的 LLM 应用</h2><p>langchain的简单使用。</p><h3 id="什么是LangChain？"><a href="#什么是LangChain？" class="headerlink" title="什么是LangChain？"></a>什么是LangChain？</h3><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>在本教程中，会创建一个简单的LLM（Large Language Model）应用。</p><p>主要分为：prompt、model、parser</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langserve <span class="keyword">import</span> add_routes</span><br><span class="line"><span class="keyword">from</span> langchain_groq <span class="keyword">import</span> ChatGroq</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_TRACING_V2&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line">os.environ[<span class="string">&quot;GROQ_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create prompt template</span></span><br><span class="line">system_template = <span class="string">&quot;Translate the following into &#123;language&#125;:&quot;</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    <span class="string">&quot;system&quot;</span>, system_template,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create model</span></span><br><span class="line">model = ChatGroq(model=<span class="string">&quot;llama3-8b-8192&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create output parser</span></span><br><span class="line">parser = StrOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create chain</span></span><br><span class="line">chain = prompt_template | model | parser</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create FastAPI app</span></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&quot;LangChain OpenAI API&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A FastAPI app that uses LangChain and OpenAI to translate text.&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add routes</span></span><br><span class="line">add_routes(</span><br><span class="line">    app,</span><br><span class="line">    chain,</span><br><span class="line">    path=<span class="string">&quot;/chain&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the LangChain OpenAI API&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run FastAPI app</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单教程&quot;&gt;&lt;a href=&quot;#简单教程&quot; class=&quot;headerlink&quot; title=&quot;简单教程&quot;&gt;&lt;/a&gt;简单教程&lt;/h2&gt;&lt;p&gt;教程来源于：&lt;a href=&quot;https://www.langchain.com.cn/docs/tutorials/llm</summary>
      
    
    
    
    <category term="llvm" scheme="https://kelinkong.github.io/categories/llvm/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-微调大模型</title>
    <link href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-01T06:35:34.000Z</published>
    <updated>2024-11-07T10:43:56.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h2><p>源代码来自:<a href="https://www.cnblogs.com/obullxl/p/18312594/NTopic2024071801">老牛同学</a></p><p>使用开源大模型 Qwen2-0.5B 的示例，实现了一个基于微调和 RAG（Retrieval-Augmented Generation）的文本分类助手。以下是各部分的详细解释：</p><h3 id="1-引入必要库"><a href="#1-引入必要库" class="headerlink" title="1. 引入必要库"></a>1. 引入必要库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> swanlab.integration.huggingface <span class="keyword">import</span> SwanLabCallback</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, TaskType, get_peft_model</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, TrainingArguments, Trainer, DataCollatorForSeq2Seq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> swanlab</span><br></pre></td></tr></table></figure><p>这部分代码引入了主要用于微调、训练和生成文本的库，包括 <code>transformers</code>、<code>peft</code>（主要用于 LoRA 微调）、<code>datasets</code>（用于处理数据集），以及 <code>swanlab</code> 用于回调和日志记录。</p><h3 id="2-设置路径和设备"><a href="#2-设置路径和设备" class="headerlink" title="2. 设置路径和设备"></a>2. 设置路径和设备</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_DIR = <span class="string">&#x27;D:\\ModelSpace\\Qwen2&#x27;</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><p>设置模型的根目录和设备名称。设备名称判断系统是否支持 CUDA（GPU 加速），如果不支持则使用 CPU。</p><p>在mac中使用mps加速</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-数据集格式转换函数"><a href="#3-数据集格式转换函数" class="headerlink" title="3. 数据集格式转换函数"></a>3. 数据集格式转换函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dataset_jsonl_transfer</span>(<span class="params">origin_path, new_path</span>):</span><br><span class="line">    messages = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            data = json.loads(line)</span><br><span class="line">            text = data[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">            catagory = data[<span class="string">&quot;category&quot;</span>]</span><br><span class="line">            output = data[<span class="string">&quot;output&quot;</span>]</span><br><span class="line">            message = &#123;</span><br><span class="line">                <span class="string">&quot;input&quot;</span>: <span class="string">f&quot;文本:<span class="subst">&#123;text&#125;</span>,分类选项列表:<span class="subst">&#123;catagory&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="string">&quot;output&quot;</span>: output,</span><br><span class="line">            &#125;</span><br><span class="line">            messages.append(message)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(new_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> messages:</span><br><span class="line">            file.write(json.dumps(message, ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>dataset_jsonl_transfer</code> 函数用于将原始 JSON 数据转换成微调所需的数据格式。原始文件的每行包含一个 JSON 对象，函数将其读取、重构并保存成新的 JSONL 格式文件，每行包含一个示例数据。</p><h3 id="4-数据预处理函数"><a href="#4-数据预处理函数" class="headerlink" title="4. 数据预处理函数"></a>4. 数据预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_func</span>(<span class="params">example</span>):</span><br><span class="line">    MAX_LENGTH = <span class="number">384</span></span><br><span class="line">    instruction = tokenizer(<span class="string">f&quot;&lt;|im_start|&gt;system\n你是一个文本分类领域的专家...<span class="subst">&#123;example[<span class="string">&#x27;input&#x27;</span>]&#125;</span>&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    response = tokenizer(<span class="string">f&quot;<span class="subst">&#123;example[<span class="string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    input_ids = instruction[<span class="string">&quot;input_ids&quot;</span>] + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    attention_mask = instruction[<span class="string">&quot;attention_mask&quot;</span>] + response[<span class="string">&quot;attention_mask&quot;</span>] + [<span class="number">1</span>]</span><br><span class="line">    labels = [-<span class="number">100</span>] * <span class="built_in">len</span>(instruction[<span class="string">&quot;input_ids&quot;</span>]) + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_ids) &gt; MAX_LENGTH:</span><br><span class="line">        input_ids, attention_mask, labels = input_ids[:MAX_LENGTH], attention_mask[:MAX_LENGTH], labels[:MAX_LENGTH]</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;input_ids&quot;</span>: input_ids, <span class="string">&quot;attention_mask&quot;</span>: attention_mask, <span class="string">&quot;labels&quot;</span>: labels&#125;</span><br></pre></td></tr></table></figure><p><code>process_func</code> 函数将数据处理成大模型可以接受的格式，包含 <code>input_ids</code>、<code>attention_mask</code> 和 <code>labels</code>。这里模拟了一个对话输入，用户提问，助手返回分类输出。如果序列长度超出最大限制 <code>MAX_LENGTH</code>，进行截断。</p><h3 id="5-加载模型和分词器"><a href="#5-加载模型和分词器" class="headerlink" title="5. 加载模型和分词器"></a>5. 加载模型和分词器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_dir = os.path.join(BASE_DIR, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_dir, use_fast=<span class="literal">False</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_dir, device_map=device, torch_dtype=torch.bfloat16)</span><br><span class="line">model.enable_input_require_grads()</span><br></pre></td></tr></table></figure><p>加载模型和分词器，将 <code>bfloat16</code> 用于精度，以减少 GPU 占用量。<code>model.enable_input_require_grads()</code> 开启梯度检查点支持，以节省内存。</p><h3 id="6-加载和处理数据集"><a href="#6-加载和处理数据集" class="headerlink" title="6. 加载和处理数据集"></a>6. 加载和处理数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;train.jsonl&#x27;</span>)</span><br><span class="line">test_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;test.jsonl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(train_dataset_path, train_jsonl_new_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(test_dataset_path, test_jsonl_new_path)</span><br><span class="line"></span><br><span class="line">train_df = pd.read_json(train_jsonl_new_path, lines=<span class="literal">True</span>)</span><br><span class="line">train_ds = Dataset.from_pandas(train_df)</span><br><span class="line">train_dataset = train_ds.<span class="built_in">map</span>(process_func, remove_columns=train_ds.column_names)</span><br></pre></td></tr></table></figure><p>检查并转换数据集，将其加载为 <code>Dataset</code> 格式，并通过 <code>process_func</code> 处理成可用于训练的数据格式。</p><h3 id="7-LoRA-配置与应用"><a href="#7-LoRA-配置与应用" class="headerlink" title="7. LoRA 配置与应用"></a>7. LoRA 配置与应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = LoraConfig(</span><br><span class="line">    task_type=TaskType.CAUSAL_LM,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, ...],</span><br><span class="line">    inference_mode=<span class="literal">False</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    lora_alpha=<span class="number">32</span>,</span><br><span class="line">    lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = get_peft_model(model, config)</span><br></pre></td></tr></table></figure><p>设置并应用 LoRA（Low-Rank Adaptation）配置，用于高效微调。<code>LoRA</code> 能通过添加低秩矩阵在不改变原模型参数的情况下更新模型，适合大模型的微调。</p><h3 id="8-训练参数与-Trainer-初始化"><a href="#8-训练参数与-Trainer-初始化" class="headerlink" title="8. 训练参数与 Trainer 初始化"></a>8. 训练参数与 Trainer 初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = TrainingArguments(</span><br><span class="line">    output_dir=os.path.join(BASE_DIR, <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>),</span><br><span class="line">    per_device_train_batch_size=<span class="number">4</span>,</span><br><span class="line">    gradient_accumulation_steps=<span class="number">4</span>,</span><br><span class="line">    logging_steps=<span class="number">10</span>,</span><br><span class="line">    num_train_epochs=<span class="number">2</span>,</span><br><span class="line">    save_steps=<span class="number">100</span>,</span><br><span class="line">    learning_rate=<span class="number">1e-4</span>,</span><br><span class="line">    save_on_each_node=<span class="literal">True</span>,</span><br><span class="line">    gradient_checkpointing=<span class="literal">True</span>,</span><br><span class="line">    report_to=<span class="string">&quot;none&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">swanlab_callback = SwanLabCallback(project=<span class="string">&quot;Qwen2-FineTuning&quot;</span>, experiment_name=<span class="string">&quot;Qwen2-0.5B&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainer = Trainer(</span><br><span class="line">    model=model,</span><br><span class="line">    args=args,</span><br><span class="line">    train_dataset=train_dataset,</span><br><span class="line">    data_collator=DataCollatorForSeq2Seq(tokenizer=tokenizer, padding=<span class="literal">True</span>),</span><br><span class="line">    callbacks=[swanlab_callback],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置训练参数并创建 <code>Trainer</code> 实例，指定保存路径、batch 大小、梯度累积步数、日志记录频率、学习率等。<code>SwanLabCallback</code> 用于将训练过程发送至 <code>SwanLab</code> 进行实时监控。</p><h3 id="9-训练模型"><a href="#9-训练模型" class="headerlink" title="9. 训练模型"></a>9. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainer.train()</span><br></pre></td></tr></table></figure><p>调用 <code>.train()</code> 开始训练。</p><h3 id="10-模型推理与评估"><a href="#10-模型推理与评估" class="headerlink" title="10. 模型推理与评估"></a>10. 模型推理与评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">messages, model, tokenizer</span>):</span><br><span class="line">    text = tokenizer.apply_chat_template(messages, tokenize=<span class="literal">False</span>, add_generation_prompt=<span class="literal">True</span>)</span><br><span class="line">    model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(device)</span><br><span class="line">    generated_ids = model.generate(model_inputs.input_ids, max_new_tokens=<span class="number">512</span>)</span><br><span class="line">    generated_ids = [output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)]</span><br><span class="line">    <span class="keyword">return</span> tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>predict</code> 函数实现了模型推理功能，将输入转成模型格式后生成输出文本。</p><h3 id="11-测试集上的推理"><a href="#11-测试集上的推理" class="headerlink" title="11. 测试集上的推理"></a>11. 测试集上的推理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_json(test_jsonl_new_path, lines=<span class="literal">True</span>)[:<span class="number">10</span>]</span><br><span class="line">test_text_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> test_df.iterrows():</span><br><span class="line">    instruction = row[<span class="string">&#x27;你是一个文本分类领域的专家，你会接收到一段文本和几个潜在的分类选项列表，请输出文本内容的正确分类&#x27;</span>]</span><br><span class="line">    input_value = row[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;instruction&#125;</span>&quot;</span>&#125;, &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;input_value&#125;</span>&quot;</span>&#125;]</span><br><span class="line">    response = predict(messages, model, tokenizer)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;response&#125;</span>&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    result_text = <span class="string">f&quot;<span class="subst">&#123;messages[<span class="number">0</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">1</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">    test_text_list.append(swanlab.Text(result_text, caption=response))</span><br><span class="line"></span><br><span class="line">swanlab.log(&#123;<span class="string">&quot;Prediction&quot;</span>: test_text_list&#125;)</span><br><span class="line">swanlab.finish()</span><br></pre></td></tr></table></figure><p>在测试集上对模型进行评估，将预测结果和输入对比，并将输出文本记录到 <code>SwanLab</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微调大模型&quot;&gt;&lt;a href=&quot;#微调大模型&quot; class=&quot;headerlink&quot; title=&quot;微调大模型&quot;&gt;&lt;/a&gt;微调大模型&lt;/h2&gt;&lt;p&gt;源代码来自:&lt;a href=&quot;https://www.cnblogs.com/obullxl/p/18312594/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习基础</title>
    <link href="https://kelinkong.github.io/2024/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://kelinkong.github.io/2024/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-29T10:55:08.000Z</published>
    <updated>2024-11-01T01:55:49.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>什么是一个线性回归问题？</strong></p><p>如果把线性回归模型看作一个函数，用最简单的话说，这个函数的作用就是预测。</p><p>线性回归模型的预测过程是这样的：给定一个输入特征向量，通过线性组合得到一个预测值。</p><p>举个例子：</p><p>假设有数据集：这里我们想知道工资、年龄和贷款额度之间的关系。</p><table><thead><tr><th>工资</th><th>年龄</th><th>贷款额度</th></tr></thead><tbody><tr><td>1000</td><td>25</td><td>1000</td></tr><tr><td>2000</td><td>30</td><td>2000</td></tr><tr><td>3000</td><td>35</td><td>3000</td></tr></tbody></table><p>我们可以用线性回归模型来预测工资，假设我们的模型是这样的：<br>$y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2$</p><p>其中，$y$ 是贷款额度，$x_1$ 是工资，$x_2$ 是年龄。</p><p>我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。</p><p>这个函数就是一个线性函数，也就是线性回归模型。</p><p>$$<br>y &#x3D; w_0 + w_1 \cdot x_1 + w_2 \cdot x_2<br>  &#x3D; \sum_{i&#x3D;0}^{n} w_i \cdot x_i<br>$$</p><p>这里$w_0$是偏置项，用来调整模型的预测值。$x_0$是一个常数项，通常为1。</p><h3 id="误差值"><a href="#误差值" class="headerlink" title="误差值"></a>误差值</h3><p>误差值是指预测值与真实值之间的差距。</p><p><img src="/../imgs/image-62.png"></p><ul><li>误差与误差之间是独立的，不会相互影响。</li><li>误差的分布是正态分布，均值为0。</li></ul><p>预测与误差：</p><p>$$<br>y^i &#x3D; W^T \cdot x^i + \epsilon^i<br>$$</p><p>其中，$y^i$ 是预测值，$W^T$ 是权重向量，$x^i$ 是输入特征向量，$\epsilon^i$ 是误差。</p><p>误差服从正态分布：</p><p>$$<br>p(\epsilon^i) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(\epsilon^i)^2}{2\sigma^2})<br>$$</p><p>将误差代入预测值：</p><p>$$<br>p(y^i|x^i;W) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>$x^i;W$组合之后的概率密度函数，就是我们的模型。我们希望$x^i;W$组合之后与$y^i$越接近越好。所以希望最大化这个概率密度函数。</p><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>似然函数为什么要使用连乘？因为前面说过，误差是独立的，所以我们可以将每个样本的概率密度函数连乘起来。</p><p>$$<br>L(W) &#x3D; \prod_{i&#x3D;1}^{m} p(y^i|x^i;W)&#x3D; \prod_{i&#x3D;1}^{m} \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>对似然函数取对数，可以将连乘转换为连加：</p><p>$$<br>\log L(W) &#x3D; \sum_{i&#x3D;1}^{m} \log p(y^i|x^i;W)&#x3D; \sum_{i&#x3D;1}^{m} \log \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>展开化简：</p><p>$$<br>\log L(W) &#x3D; \frac{m}{2} \log(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><p>我们最终的目标是最大化似然函数，也就是最小化误差。前一项是常数，所以希望后一项越小越好。即：</p><p>$$<br>\min_W \frac{1}{2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><strong>什么是损失函数？</strong></p><p>损失函数也叫目标函数，是用来衡量模型预测值与真实值之间的差距的函数。</p><p>上面那个例子，我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。损失函数可以定义为：</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (y_i - \hat{y_i})^2<br>$$</p><p>使用目标值和预测值之间的平方误差作为损失函数，这个损失函数叫做均方误差（Mean Squared Error，MSE）。</p><p>其中，$m$ 是样本数量，$y_i$ 是真实值，$\hat{y_i}$ 是预测值。</p><p>对于机器学习的大部分任务，我们都是通过最小化损失函数来优化模型的参数。</p><p>如何求解损失函数？</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (W^T \cdot x^i - \hat{y_i})^2 &#x3D; \frac{1}{2m} (X \cdot W - Y)^T \cdot (X \cdot W - Y)<br>$$</p><p>其中，$X$ 是输入特征矩阵，$Y$ 是真实值矩阵。</p><p>我们的目标是找到一个合适的 $W$，使得损失函数最小化。</p><p>因此，对损失函数求导，然后令导数为0，可以得到最优解。</p><p>$$<br>\frac{\partial L(W)}{\partial W} &#x3D; \frac{1}{m} X^T \cdot (X \cdot W - Y) &#x3D; 0<br>$$</p><p>解方程，得到最优解：<br>$$<br>W &#x3D; (X^T \cdot X)^{-1} \cdot X^T \cdot Y<br>$$</p><p>但是，这个方法有一个问题，就是计算量太大。当数据量很大时，计算矩阵的逆是非常耗时的。而且，矩阵的逆不一定存在。</p><p>因此，我们通常使用梯度下降法来求解损失函数的最小值。</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p><strong>什么是梯度下降法？</strong></p><p>梯度下降法是一种常用的优化算法，用来求解损失函数的最小值。</p><p>梯度下降法的思想是：沿着梯度的反方向，不断迭代更新参数，直到损失函数的值收敛。</p><p><strong>目标函数</strong></p><p>$$<br>J(\theta_0, \theta_1) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i)^2<br>$$</p><p>其中，$h_\theta(x^i) &#x3D; \theta_0 + \theta_1 \cdot x^i$ 是模型的预测值。</p><p><strong>如何寻找合适的方向？</strong></p><p>梯度下降法的核心是求解目标函数的梯度。</p><p>分别对 $\theta_0$ 和 $\theta_1$ 求偏导数：</p><p>$$<br>\frac{\partial J(\theta_0, \theta_1)}{\partial \theta_1} &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_1<br>$$</p><p>使得梯度为0，得到最优解。因为切线方向是函数值下降最快的方向，此时梯度为0。梯度其实就是函数的导数。</p><p>注意，这里等式中的两个$\theta_j$表示两个不同的$\theta_j$，一个是当前的$\theta_j$，一个是更新后的$\theta_j$。</p><p>$$<br>\theta_j &#x3D;  \theta_j - \alpha  \frac{\partial J(\theta_j)}{\partial \theta_j}&#x3D;<br> \theta_j - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_j<br>$$</p><p>其中，$\alpha$ 是学习率，用来控制参数更新的步长，$x^i_j$表示第$i$个样本的第$j$个特征。</p><p>如果将所有的参数更新写成矩阵形式，可以得到：</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} X^T \cdot (X \cdot \theta - Y)<br>$$</p><p>这就是梯度下降法中的批量梯度下降（Batch Gradient Descent）。但是，批量梯度下降的计算量很大，因为每次迭代都要计算所有样本的梯度。</p><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降（Stochastic Gradient Descent，SGD）是梯度下降法的一种变种，它每次迭代只使用一个样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$x^i$ 是第$i$个样本的特征向量，$y^i$ 是第$i$个样本的真实值。</p><p>随机梯度下降的优点是计算速度快，但缺点是收敛速度慢，因为每次迭代的方向不一定是最优的。</p><h3 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h3><p>小批量梯度下降（Mini-batch Gradient Descent）是批量梯度下降和随机梯度下降的折中方案，每次迭代使用一小部分样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$m$ 是小批量的大小。batch size的选择对模型的训练速度有很大影响。当batch size较小时，模型的训练速度较慢；当batch size较大时，模型的训练速度较快。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>给一个代码实现：</p><p>对应上面的公式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, learning_rate=<span class="number">0.01</span>, num_iterations=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用梯度下降法训练线性回归模型</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cost_history = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">        self.theta = self.predict_step(learning_rate)</span><br><span class="line">        cost_history.append(self.compute_cost())</span><br><span class="line">        logger.info(<span class="string">&quot;第&#123;&#125;次迭代，损失值为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(_, cost_history[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回训练后的参数和损失值</span></span><br><span class="line">    <span class="keyword">return</span> self.theta, cost_history</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict_step</span>(<span class="params">self, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    每一步迭代计算梯度并更新参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 计算预测值</span></span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    <span class="comment"># 计算误差</span></span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    <span class="comment"># 计算梯度并更新参数</span></span><br><span class="line">    theta = self.theta - learning_rate * (<span class="number">1</span> / num_examples) * np.dot(self.data.T, error)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hypothesis</span>(<span class="params">data, theta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算预测值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(data, theta)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算损失, 这里使用均方误差</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    cost = (<span class="number">1</span> / (<span class="number">2</span> * num_examples)) * np.dot(error.T, error)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是一个线性回归问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把线性回归模型看作一个函数，用最简单的话说，这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：Spring MVC</title>
    <link href="https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/"/>
    <id>https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/</id>
    <published>2024-10-23T00:41:51.000Z</published>
    <updated>2024-10-23T03:40:23.783Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot第九章，Spring MVC。</p><h2 id="Spring-MVC-示意图"><a href="#Spring-MVC-示意图" class="headerlink" title="Spring MVC 示意图"></a>Spring MVC 示意图</h2><p><img src="/../imgs/image-60.png"></p><p><img src="/../imgs/image-61.png"></p><p>如果 Web 工程使用了 Spring MVC ， 那么它在启动阶段就会将注解<br><code>@RequestMapping</code> 所配置的内容保存到处理器映射（ <code>HandlerMapping</code> ）机制中去，然后等待请求的到来 ，通过拦截请求信息与<code>HandlerMapping</code>进行匹配，找到对应的处理器（它包含控制器的逻辑），并将处理器及其拦截器保存到 <code>HandlerExecution Chain</code> 对象中，返回给 <code>DispatcherServlet</code> ，这样<code>DispatcherServlet</code> 就可以运行它们了。</p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code> 是 Spring MVC 的核心组件，负责将客户端的请求分发给相应的处理器（Controller），并协调请求处理过程。它的主要职责是接收 HTTP 请求，委托给合适的处理组件，并将结果返回给客户端。<code>DispatcherServlet</code> 是前后端分离架构和传统 MVC 架构中的重要部分。</p><h3 id="DispatcherServlet-的工作原理"><a href="#DispatcherServlet-的工作原理" class="headerlink" title="DispatcherServlet 的工作原理"></a><code>DispatcherServlet</code> 的工作原理</h3><ol><li><p><strong>客户端请求到达 DispatcherServlet</strong>：</p><ul><li>当用户通过浏览器发送 HTTP 请求时，请求首先到达 <code>DispatcherServlet</code>。<code>DispatcherServlet</code> 是一个前端控制器（Front Controller），负责接收所有的请求。</li></ul></li><li><p><strong>HandlerMapping 映射请求</strong>：</p><ul><li><code>DispatcherServlet</code> 接收到请求后，开始通过 <strong>HandlerMapping</strong> 查找对应的处理器（Controller）。它根据请求的 URL 路径去匹配合适的处理器，这一步决定了应该调用哪个控制器来处理这个请求。</li></ul></li><li><p><strong>调用 HandlerAdapter</strong>：</p><ul><li>找到处理器后，<code>DispatcherServlet</code> 会通过 <strong>HandlerAdapter</strong> 调用实际的控制器方法。<code>HandlerAdapter</code> 的职责是适配处理器方法，使得它们能够被调用。不同类型的控制器方法（如注解方式的、简单映射方式的）可能需要不同的适配器。</li></ul></li><li><p><strong>Controller 处理请求</strong>：</p><ul><li>处理器（Controller）接收请求并处理业务逻辑，可能需要调用服务层、数据库等操作，最终返回一个 <code>ModelAndView</code> 对象或直接返回数据（如 JSON）。</li></ul></li><li><p>**视图解析器 (ViewResolver)**：</p><ul><li>如果处理器返回的是一个视图名，<code>DispatcherServlet</code> 会通过 <strong>ViewResolver</strong> 解析视图的名称，将其转换为具体的视图对象（如 JSP、Thymeleaf 等）。视图解析器负责确定返回页面的位置。</li></ul></li><li><p><strong>返回响应给客户端</strong>：</p><ul><li>最终，<code>DispatcherServlet</code> 将处理的结果（视图页面或数据）响应给客户端。如果返回的是视图，<code>DispatcherServlet</code> 将把数据填充到视图中，并将生成的 HTML 返回给客户端；如果是 JSON 数据，则直接响应 JSON。</li></ul></li></ol><h3 id="DispatcherServlet-的处理流程图"><a href="#DispatcherServlet-的处理流程图" class="headerlink" title="DispatcherServlet 的处理流程图"></a><code>DispatcherServlet</code> 的处理流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client Request --&gt; DispatcherServlet --&gt; HandlerMapping --&gt; Handler (Controller)</span><br><span class="line">                  --&gt; HandlerAdapter --&gt; ModelAndView --&gt; ViewResolver --&gt; Response (HTML/JSON)</span><br></pre></td></tr></table></figure><h3 id="详细的步骤"><a href="#详细的步骤" class="headerlink" title="详细的步骤"></a>详细的步骤</h3><ol><li><p><strong>初始化 DispatcherServlet</strong>：</p><ul><li>当 Spring 容器启动时，<code>DispatcherServlet</code> 作为前端控制器被初始化，它会加载配置文件，并初始化一些关键的组件，比如 <code>HandlerMapping</code> 和 <code>HandlerAdapter</code>。</li></ul></li><li><p><strong>处理请求</strong>：</p><ul><li>用户发出 HTTP 请求时，<code>DispatcherServlet</code> 会接管请求的控制权。</li></ul></li><li><p><strong>查找处理器</strong>：</p><ul><li><code>DispatcherServlet</code> 根据 <code>HandlerMapping</code> 的配置，确定哪个控制器将会处理这个请求。</li></ul></li><li><p><strong>调用控制器</strong>：</p><ul><li><code>DispatcherServlet</code> 通过 <code>HandlerAdapter</code> 来调用处理器的具体方法，处理业务逻辑。</li></ul></li><li><p><strong>返回视图或数据</strong>：</p><ul><li>控制器执行完业务逻辑后，返回视图名或数据，<code>DispatcherServlet</code> 会通过 <code>ViewResolver</code> 来解析视图，或直接返回 JSON 数据。</li></ul></li><li><p><strong>生成响应</strong>：</p><ul><li>最后，<code>DispatcherServlet</code> 将视图或数据返回给客户端。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库获取用户数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userDetail&quot;</span>;  <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DispatcherServlet</code> 会：</p><ol><li>接收到对 <code>/users/&#123;id&#125;</code> 的请求。</li><li>通过 <code>HandlerMapping</code> 映射到 <code>UserController</code> 的 <code>getUserById</code> 方法。</li><li>返回视图名 <code>userDetail</code>，然后通过 <code>ViewResolver</code> 找到实际的视图并渲染。</li></ol><h2 id="在前后端分离的项目中，Spring-MVC-是如何工作的"><a href="#在前后端分离的项目中，Spring-MVC-是如何工作的" class="headerlink" title="在前后端分离的项目中，Spring MVC 是如何工作的"></a>在前后端分离的项目中，Spring MVC 是如何工作的</h2><p>在前后端分离的项目中，Spring MVC 主要用作 <strong>后端 API</strong> 服务，专注于处理业务逻辑、数据库交互，并通过 RESTful API 接口向前端提供数据。前端和后端通过 HTTP 请求（如 <code>GET</code>、<code>POST</code> 等）进行通信，前端不再依赖于服务器渲染 HTML 页面，而是通过调用 API 获取 JSON 数据。</p><h3 id="Spring-MVC-在前后端分离中的工作流程"><a href="#Spring-MVC-在前后端分离中的工作流程" class="headerlink" title="Spring MVC 在前后端分离中的工作流程"></a>Spring MVC 在前后端分离中的工作流程</h3><ol><li><strong>前端发送请求</strong>：用户在前端应用（如基于 React、Vue、Angular 的应用）中进行操作，前端应用通过 HTTP 向后端发送请求。</li><li><strong>后端控制器接收请求</strong>：Spring MVC 的控制器接收前端请求，并调用业务逻辑或数据库，处理请求。</li><li><strong>返回 JSON 数据</strong>：后端处理完请求后，返回 JSON 格式的数据响应给前端。</li><li><strong>前端显示数据</strong>：前端应用根据后端返回的数据更新页面内容。</li></ol><h3 id="使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例"><a href="#使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例" class="headerlink" title="使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例"></a>使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例</h3><h4 id="1-Maven-依赖"><a href="#1-Maven-依赖" class="headerlink" title="1. Maven 依赖"></a>1. <strong>Maven 依赖</strong></h4><p>首先，确保 <code>pom.xml</code> 中包含以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Web Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot DevTools --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JSON 处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-控制器类"><a href="#2-控制器类" class="headerlink" title="2. 控制器类"></a>2. <strong>控制器类</strong></h4><p>在前后端分离的项目中，控制器负责接收前端的 API 请求，处理业务逻辑，并返回 JSON 响应。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设从数据库获取用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟创建用户的逻辑，通常会调用服务层</span></span><br><span class="line">        user.setId(<span class="number">1</span>);  <span class="comment">// 模拟数据库生成的用户ID</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟更新用户信息</span></span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟删除用户的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3. 模型类"></a>3. <strong>模型类</strong></h4><p>模型类用于定义实体，例如 <code>User</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-跨域配置（CORS）"><a href="#4-跨域配置（CORS）" class="headerlink" title="4. 跨域配置（CORS）"></a>4. <strong>跨域配置（CORS）</strong></h4><p>前后端分离时，通常前端和后端不在同一个域名下，因此需要处理跨域请求。我们可以通过配置 <code>CorsConfiguration</code> 来允许跨域请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)  <span class="comment">// 允许前端地址</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-前端调用示例"><a href="#5-前端调用示例" class="headerlink" title="5. 前端调用示例"></a>5. <strong>前端调用示例</strong></h4><p>假设前端使用了 Vue.js，前端可以通过 <code>axios</code> 调用 Spring MVC 提供的 RESTful API。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Info<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;&#123; user.id &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fetchUser&quot;</span>&gt;</span>Fetch User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">user</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">fetchUser</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8080/api/users/1&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">user</span> = response.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;There was an error!&quot;</span>, error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-启动后端服务"><a href="#6-启动后端服务" class="headerlink" title="6. 启动后端服务"></a>6. <strong>启动后端服务</strong></h4><p>在 Spring Boot 中，后端项目运行后将会监听 <code>http://localhost:8080</code>，可以通过调用后端的 API 接口获取用户信息，如 <code>http://localhost:8080/api/users/1</code>。</p><h4 id="7-前端调用后端接口"><a href="#7-前端调用后端接口" class="headerlink" title="7. 前端调用后端接口"></a>7. <strong>前端调用后端接口</strong></h4><p>前端（例如 <code>localhost:3000</code>）向后端发起 <code>GET</code> 请求，Spring MVC 接收到请求并调用相应的控制器方法，返回 JSON 数据，前端根据这些数据进行页面更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot第九章，Spring MVC。&lt;/p&gt;
&lt;h2 id=&quot;Spring-MVC-示意图&quot;&gt;&lt;a href=&quot;#Spring-MVC-示意图&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 示意图&quot;&gt;&lt;/a&gt;Spring</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：事务处理</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2024-10-22T07:09:09.000Z</published>
    <updated>2024-11-07T10:34:49.117Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>@Transactional</code>注解，Spring就会知道在哪里启动事务。其约定流程如图：<br><img src="/../imgs/image-58.png"></p><p>@Transactional注解的一些配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = true,                          // 是否只读</span></span><br><span class="line"><span class="meta">        timeout = 30,                             // 超时时间</span></span><br><span class="line"><span class="meta">        isolation = Isolation.READ_COMMITTED,      // 隔离级别</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED,        // 传播行为</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;SQLException.class&#125;,        // 指定回滚异常</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;IllegalStateException.class&#125;  // 指定不回滚异常</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先引入事务的隔离级别：</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务的隔离级别（Transaction Isolation Level）用于定义并发事务之间的相互影响，避免因并发执行而引发数据不一致的问题。数据库中的隔离级别定义了一个事务在执行时可以看到其他事务的修改情况，常见的隔离级别有以下四种，按隔离强度从低到高排列：</p><h3 id="1-READ-UNCOMMITTED（读未提交）"><a href="#1-READ-UNCOMMITTED（读未提交）" class="headerlink" title="1. READ UNCOMMITTED（读未提交）"></a>1. <strong>READ UNCOMMITTED（读未提交）</strong></h3><ul><li><strong>描述</strong>：在此隔离级别下，事务可以读取到其他事务尚未提交的数据（脏数据）。</li><li><strong>问题</strong>：<ul><li><strong>脏读</strong>（Dirty Read）：一个事务可以读到其他事务尚未提交的数据。如果这个事务回滚了，那么读到的数据就是无效的。</li><li><strong>不可重复读</strong>（Non-repeatable Read）：同一事务在不同时间读取相同数据时，可能得到不同结果。</li><li><strong>幻读</strong>（Phantom Read）：一个事务多次查询时可能会发现新的数据插入。</li></ul></li><li><strong>适用场景</strong>：对数据一致性要求极低的场景（很少使用）。</li></ul><h3 id="2-READ-COMMITTED（读已提交）"><a href="#2-READ-COMMITTED（读已提交）" class="headerlink" title="2. READ COMMITTED（读已提交）"></a>2. <strong>READ COMMITTED（读已提交）</strong></h3><ul><li><strong>描述</strong>：一个事务只能读取到其他事务已经提交的数据，避免脏读。</li><li><strong>问题</strong>：<ul><li><strong>不可重复读</strong>：同一事务在不同时间读取相同数据时，可能得到不同的结果。如果另一个事务在两次读取之间修改了数据，就会出现这种现象。</li><li><strong>幻读</strong>：如果一个事务在读取时，另一个事务插入了新的行，第一次查询时看不到这些行，下一次查询时就看到了。</li></ul></li><li><strong>适用场景</strong>：多数数据库（如 SQL Server 和 Oracle）默认的隔离级别，适用于读一致性要求不高但需要避免脏读的场景。</li></ul><h3 id="3-REPEATABLE-READ（可重复读）"><a href="#3-REPEATABLE-READ（可重复读）" class="headerlink" title="3. REPEATABLE READ（可重复读）"></a>3. <strong>REPEATABLE READ（可重复读）</strong></h3><ul><li><strong>描述</strong>：在整个事务期间，无论其他事务是否提交，当前事务的所有读操作都能保证是相同的数据。避免了脏读和不可重复读的问题。</li><li><strong>问题</strong>：<ul><li><strong>幻读</strong>：在同一事务中，如果另一个事务插入了新行，这些行可能会在事务的后续查询中出现。</li></ul></li><li><strong>适用场景</strong>：MySQL 默认的隔离级别，适合需要确保数据在一个事务中多次读取一致性的场景。</li></ul><h3 id="4-SERIALIZABLE（可串行化）"><a href="#4-SERIALIZABLE（可串行化）" class="headerlink" title="4. SERIALIZABLE（可串行化）"></a>4. <strong>SERIALIZABLE（可串行化）</strong></h3><ul><li><strong>描述</strong>：最高的隔离级别，强制事务串行化执行，即一个事务必须等其他事务完成后才能执行，避免了所有并发问题，包括脏读、不可重复读和幻读。</li><li><strong>问题</strong>：<ul><li>并发性能最差，多个事务几乎不能并发执行，适合数据一致性要求极高但并发量较低的场景。</li></ul></li><li><strong>适用场景</strong>：极端情况下使用，适合金融交易等需要绝对数据一致性的场景。</li></ul><h3 id="事务隔离级别总结："><a href="#事务隔离级别总结：" class="headerlink" title="事务隔离级别总结："></a>事务隔离级别总结：</h3><ul><li><strong>脏读（Dirty Read）</strong>：读取到了其他未提交事务修改的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：同一事务中，前后两次读取相同数据得到不同的结果，通常是由于其他事务更新了数据。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，如果其他事务插入了新行，这些行在事务后续查询中可能会出现。</li></ul><h3 id="四种隔离级别对问题的防护表："><a href="#四种隔离级别对问题的防护表：" class="headerlink" title="四种隔离级别对问题的防护表："></a>四种隔离级别对问题的防护表：</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>否</td><td>是</td><td>是</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>否</td><td>否</td><td>是</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>注意</strong>：隔离级别越高，事务之间的并发性越差，但数据一致性更强。选择合适的隔离级别需要权衡并发性能和数据一致性。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>假设有批量任务在处理时，如果其中一个任务出现异常，是否需要回滚整个批量任务？这就需要用到事务的传播行为。<br>通常我们只希望回滚出现异常的错误任务，而不是回滚整个批量任务。<br><img src="/../imgs/image-59.png"></p><p>事务的传播行为（Transaction Propagation Behavior）决定了当一个事务方法调用另一个事务方法时，如何处理新旧事务之间的关系。Spring 提供了多种事务传播机制，允许开发人员根据业务需求选择适当的事务行为。主要的传播行为有以下几种：</p><h3 id="1-REQUIRED"><a href="#1-REQUIRED" class="headerlink" title="1. REQUIRED"></a>1. <strong>REQUIRED</strong></h3><ul><li><p><strong>描述</strong>：如果当前已经存在事务，则加入到这个事务中。如果当前没有事务，则新建一个事务。</p></li><li><p><strong>场景</strong>：默认的传播行为，适合大部分业务场景。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 调用methodA，将在同一个事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodB()</code>调用<code>methodA()</code>时，它们共享同一个事务。如果事务成功，则一起提交；如果抛出异常，则一起回滚。</p><h3 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <strong>REQUIRES_NEW</strong></h3><ul><li><p><strong>描述</strong>：总是新建一个事务。如果当前有事务，先挂起当前事务，等新事务执行完再恢复。</p></li><li><p><strong>场景</strong>：适用于需要在事务中执行独立的操作，无论外部事务的状态如何，该事务都要独立提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将开启新事务，不依赖methodB的事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>将启动一个新的事务，与<code>methodB()</code>的事务独立。如果<code>methodB()</code>回滚，<code>methodA()</code>的事务依然可以成功提交。</p><h3 id="3-SUPPORTS"><a href="#3-SUPPORTS" class="headerlink" title="3. SUPPORTS"></a>3. <strong>SUPPORTS</strong></h3><ul><li><p><strong>描述</strong>：支持当前事务。如果当前有事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p></li><li><p><strong>场景</strong>：适用于需要根据调用者上下文决定是否在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>被<code>methodB()</code>调用时，存在事务，它将加入事务；否则，它将以非事务方式执行。</p><h3 id="4-NOT-SUPPORTED"><a href="#4-NOT-SUPPORTED" class="headerlink" title="4. NOT_SUPPORTED"></a>4. <strong>NOT_SUPPORTED</strong></h3><ul><li><p><strong>描述</strong>：总是以非事务方式执行。如果当前有事务，则将其挂起。</p></li><li><p><strong>场景</strong>：适用于某些操作不需要事务，甚至不能在事务中执行。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将以非事务方式执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>会以非事务方式执行，且不受<code>methodB()</code>事务的影响。</p><h3 id="5-MANDATORY"><a href="#5-MANDATORY" class="headerlink" title="5. MANDATORY"></a>5. <strong>MANDATORY</strong></h3><ul><li><p><strong>描述</strong>：强制要求当前存在事务。如果没有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于必须在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 必须在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>只能在已有事务的上下文中执行。如果直接调用<code>methodA()</code>时没有事务，会抛出异常。</p><h3 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. <strong>NEVER</strong></h3><ul><li><p><strong>描述</strong>：强制不允许存在事务。如果有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于不允许事务存在的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 将抛出异常，因为methodB有事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>在事务中执行，则会抛出异常。</p><h3 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. <strong>NESTED</strong></h3><ul><li><p><strong>描述</strong>：如果当前有事务，则在当前事务中嵌套一个子事务；如果当前没有事务，则新建一个事务。嵌套事务可以单独回滚，而不影响外部事务。</p></li><li><p><strong>场景</strong>：适用于希望在主事务中有嵌套事务，子事务可以单独提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将作为methodB的嵌套事务执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>作为<code>methodB()</code>的嵌套事务执行，可以独立回滚，但如果<code>methodB()</code>回滚，<code>methodA()</code>也会回滚。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>当前有事务则加入，没有则创建新事务（默认）。</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>总是新建一个事务，挂起当前事务。</td></tr><tr><td><strong>SUPPORTS</strong></td><td>当前有事务则加入，没有事务则以非事务方式执行。</td></tr><tr><td><strong>NOT_SUPPORTED</strong></td><td>总是以非事务方式执行，挂起当前事务。</td></tr><tr><td><strong>MANDATORY</strong></td><td>当前有事务则加入，没有则抛出异常。</td></tr><tr><td><strong>NEVER</strong></td><td>总是以非事务方式执行，当前有事务则抛出异常。</td></tr><tr><td><strong>NESTED</strong></td><td>嵌套事务，允许回滚子事务但不影响父事务。</td></tr></tbody></table><h3 id="示例项目中使用-Transactional："><a href="#示例项目中使用-Transactional：" class="headerlink" title="示例项目中使用 @Transactional："></a>示例项目中使用 <code>@Transactional</code>：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建订单的逻辑</span></span><br><span class="line">        paymentService.processPayment(); <span class="comment">// 调用另一个事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 处理支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>createOrder()</code>使用<code>REQUIRED</code>传播行为，而<code>processPayment()</code>使用<code>REQUIRES_NEW</code>，即<code>processPayment()</code>将运行在一个独立的事务中。</p><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？"><a href="#在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？" class="headerlink" title="在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？"></a>在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？</h3><p>在 Spring Boot 中，<code>@Transactional</code> 注解用于管理事务边界，而 <code>@Transactional(readOnly = true)</code> 和 <code>@Transactional</code> 之间的主要区别在于<strong>事务的读写属性</strong>，从而影响数据库的操作方式和性能优化。具体来说：</p><p><code>@Transactional(readOnly = true)</code>：</p><ul><li><strong>只读事务</strong>：指定该事务仅用于查询操作，即不会涉及对数据库的更新、插入或删除操作。</li><li><strong>性能优化</strong>：Spring 在只读事务中可能对底层数据库连接进行优化，例如关闭脏数据检测等，提高查询性能。</li><li><strong>数据库支持</strong>：某些数据库可以通过只读事务进行额外的性能优化，但要确保该事务中不包含写操作（更新、插入、删除），否则会抛出异常。</li><li><strong>应用场景</strong>：适用于不需要更改数据的服务层方法，比如获取用户列表、查看订单信息等操作。</li></ul><p><code>@Transactional</code> (默认 <code>readOnly = false</code>)：</p><ul><li><strong>读写事务</strong>：支持所有数据库操作，包括查询、插入、更新、删除。</li><li><strong>数据一致性</strong>：该事务在执行过程中会进行数据一致性检查，确保数据库在事务中所有操作要么全部成功，要么在出现异常时全部回滚。</li><li><strong>性能考虑</strong>：因为存在数据修改操作，事务提交时会涉及更多一致性检查和资源锁定，性能开销通常高于只读事务。</li><li><strong>应用场景</strong>：适用于需要更改数据的操作，比如更新用户信息、添加新订单等。</li></ul><p><strong>在 Spring 中，@Transactional(readOnly &#x3D; true) 默认不会改变事务的隔离级别。它只指定了当前事务是“只读”的，主要目的是在执行查询操作时，利用数据库的优化机制提升性能。</strong></p><p>在mysql中事务的隔离级别默认是<code>REPEATABLE READ</code>，事务的默认传播行为是<code>REQUIRED</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;@Transactional&lt;/code&gt;注解，Spring就会知道在哪里启动事务。其约定流程如图：&lt;br&gt;&lt;img src=&quot;/../imgs/image-58.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;@Transactional注解的一些配置：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-MyBatis</title>
    <link href="https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/"/>
    <id>https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/</id>
    <published>2024-10-22T06:46:45.000Z</published>
    <updated>2024-10-22T08:48:39.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDBC代码和参数的手动设置以及结果集的检索。</p><ol><li><p>首先添加依赖(pom.xml)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据库连接(application.yml)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/demo?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.example.entity</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建XML映射文件(<code>resources/mapper/UserMapper.xml</code>)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这个示例展示了MyBatis在Spring Boot中的基本使用，包括：</p><ol><li>Maven依赖配置</li><li>数据库连接配置</li><li>实体类定义</li><li>Mapper接口定义</li><li>XML映射文件</li><li>Service层实现</li><li>Controller层实现</li></ol><p>使用这个示例，可以：</p><ul><li>通过 GET &#x2F;users&#x2F;{id} 查询用户</li><li>通过 POST &#x2F;users 创建新用户</li></ul><p>在使用前需要确保：</p><ol><li>创建对应的数据库和表</li><li>修改数据库连接配置</li><li>启动类添加 <code>@MapperScan(&quot;com.example.mapper&quot;)</code> 注解</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的示例&quot;&gt;&lt;a href=&quot;#一个简单的示例&quot; class=&quot;headerlink&quot; title=&quot;一个简单的示例&quot;&gt;&lt;/a&gt;一个简单的示例&lt;/h2&gt;&lt;p&gt;MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDB</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：全注解下的IoC</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/</id>
    <published>2024-10-22T01:39:29.000Z</published>
    <updated>2024-10-22T08:48:39.127Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。</p><p>Spring 中把每一个<br>需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器） 。 IoC 容器需要具备两个基本的功能：</p><ul><li>通过描述管理 Bean，包括发布和获取 Bean;</li><li>通过描述完成 Bean 之间的依赖关系</li></ul><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>要求所有的 IoC 容器都需要实现接口 BeanFactory，其中定义了获取 Bean 的基本方法。</p><p>BeanFactory源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; required</span></span><br><span class="line"><span class="params">    Type)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    Boolean <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 默认情况下，Spring IoC 容器是单例的，每次返回都是同一个对象</span></span><br><span class="line">    Boolean <span class="title function_">isSingleton</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 原型模式，每次返回都是一个新的对象</span></span><br><span class="line">    Boolean <span class="title function_">isPrototype</span><span class="params">(String name)</span>;</span><br><span class="line">    Boolean <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BeanFactory中，有多个<code>getBean</code>方法，其中最常用的是：</p><ul><li><code>getBean(String name)</code>：根据 Bean 的名称获取 Bean 对象</li><li><code>getBean(Class&lt;T&gt; requiredType)</code>：根据 Bean 的类型获取 Bean 对象</li></ul><p>Spring 提供了一个更高级的 IoC 容器接口 ApplicationContext，它是 BeanFactory 的子接口，提供了更多的功能。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="/../imgs/image-53.png"></p><p>ApplicationContext 接口通过实现多个接口，提供了更多的功能，如国际化、事件传播、资源加载等。</p><p> Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中。</p><h3 id="使用AnnotationConfigApplicationContext"><a href="#使用AnnotationConfigApplicationContext" class="headerlink" title="使用AnnotationConfigApplicationContext"></a>使用AnnotationConfigApplicationContext</h3><p>AnnotationConfigApplicationContext 是一个 IoC 容器，它可以通过注解来装配 Bean 到 Spring IoC 容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建了一个基于注解的Spring IoC容器AnnotationConfigApplicationContext，并将AppConfig类作为配置类传递给它。</span></span><br><span class="line"><span class="comment">         * AppConfig.class是一个包含Spring配置的类，使用了<span class="doctag">@Configurable</span>注解，表明这是一个配置类。</span></span><br><span class="line"><span class="comment">         * 通过这种方式，Spring会扫描AppConfig类中的<span class="doctag">@Bean</span>注解，并将这些方法返回的对象注册为Spring容器中的Bean。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Spring容器中获取一个类型为User的Bean对象。</span></span><br><span class="line"><span class="comment">         * ctx.getBean(User.class)方法会根据类型查找并返回一个User类型的Bean实例。</span></span><br><span class="line"><span class="comment">         * 这个User实例是由AppConfig类中的initUser方法创建并注册到Spring容器中的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(User.class);</span><br><span class="line">        log.info(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"><a href="#在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别" class="headerlink" title="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"></a>在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别</h2><p>在 Spring 中，<code>@Bean</code> 注解通常用于定义和注册 Bean 到 IoC 容器中，而它可以出现在不同的地方。主要有两种常见的方式：</p><ol><li><strong>在配置类中使用 <code>@Bean</code> 注解</strong>（如在你的 <code>AppConfig</code> 类中）  </li><li><strong>在实体类（如 <code>User</code> 类）上使用 <code>@Component</code> 或其他派生注解</strong>，例如 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等。</li></ol><p>这两种方式的不同点主要体现在 <strong>Bean 定义和管理的灵活性、配置的集中化以及依赖管理的差异</strong>：</p><h3 id="1-在配置类中使用-Bean-注解"><a href="#1-在配置类中使用-Bean-注解" class="headerlink" title="1. 在配置类中使用 @Bean 注解"></a>1. <strong>在配置类中使用 <code>@Bean</code> 注解</strong></h3><p>使用 <code>@Bean</code> 注解在一个配置类中（如 <code>AppConfig</code>）定义 Bean 具有以下特点：</p><ul><li><p><strong>集中配置</strong>：你可以在一个地方（配置类）集中管理所有的 Bean 定义。这可以使得配置代码更加清晰和集中，尤其是在需要配置复杂依赖的场景中。</p></li><li><p><strong>灵活性</strong>：配置类中的 <code>@Bean</code> 方法可以让你灵活地定义 Bean，比如在 Bean 创建时通过方法参数注入依赖，或根据某些条件决定返回的对象。这种方式更加灵活，可以使用逻辑控制返回哪个 Bean 实例。</p></li><li><p><strong>可定制性</strong>：通过 <code>@Bean</code>，你可以完全控制对象的创建过程，甚至可以在创建时执行一些逻辑，或者根据应用的某些条件配置不同的 Bean 实例。</p></li><li><p><strong>多实例管理</strong>：你可以在配置类中通过不同的方法名或 <code>@Bean</code> 注解的 <code>name</code> 属性来为同一个类型注册多个不同的 Bean。</p></li><li><p><strong>明确的生命周期控制</strong>：在配置类中，你还可以使用 <code>@PostConstruct</code>, <code>@PreDestroy</code> 等注解来明确控制 Bean 的生命周期。</p></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">initUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;kelin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setGender((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在-User-类中使用-Component-或其他注解"><a href="#2-在-User-类中使用-Component-或其他注解" class="headerlink" title="2. 在 User 类中使用 @Component 或其他注解"></a>2. <strong>在 <code>User</code> 类中使用 <code>@Component</code> 或其他注解</strong></h3><p>如果你直接在实体类（如 <code>User</code> 类）上使用 <code>@Component</code>（或 <code>@Service</code>, <code>@Controller</code> 等注解），Spring 会自动扫描并将这个类注册为 Bean。特点如下：</p><ul><li><p><strong>自动扫描与装配</strong>：<code>@Component</code> 是一个基于类的注解，意味着只要这个类被 Spring 的组件扫描路径扫描到，它就会自动注册为 Bean。你不需要手动在配置类中定义它。</p></li><li><p><strong>简单且自动化</strong>：适合简单的类，只需要标记类为组件即可，通常用于那些不需要复杂配置或初始化逻辑的 Bean。</p></li><li><p><strong>依赖注入</strong>：当使用 <code>@Component</code> 时，通常配合 <code>@Autowired</code> 注解实现自动依赖注入。虽然 <code>@Bean</code> 也可以做到类似的依赖注入，但是 <code>@Component</code> 配合自动扫描更适合规模较大的项目。</p></li><li><p><strong>更少控制权</strong>：与 <code>@Bean</code> 相比，<code>@Component</code> 提供的控制力更少。例如，你无法在定义 Bean 时动态决定返回什么实例，因为 <code>@Component</code> 只是简单地注册类到 IoC 容器中。</p></li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h3><table><thead><tr><th>特点</th><th><code>@Bean</code> 在配置类中使用</th><th><code>@Component</code> 在类中使用</th></tr></thead><tbody><tr><td><strong>注册方式</strong></td><td>手动在配置类中定义并注册 Bean</td><td>自动通过类扫描注册为 Bean</td></tr><tr><td><strong>灵活性</strong></td><td>高，方法中可以有逻辑控制 Bean 的创建</td><td>低，只能通过注解标记类为 Bean</td></tr><tr><td><strong>依赖注入</strong></td><td>可以通过方法参数手动注入依赖</td><td>使用 <code>@Autowired</code> 自动注入依赖</td></tr><tr><td><strong>配置复杂度</strong></td><td>适合复杂或条件性 Bean 定义</td><td>适合简单 Bean 自动化管理</td></tr><tr><td><strong>Bean 名称控制</strong></td><td>可以通过 <code>@Bean(name = &quot;xxx&quot;)</code> 自定义</td><td>默认 Bean 名称为类名，首字母小写</td></tr><tr><td><strong>生命周期控制</strong></td><td>可以通过 <code>@PostConstruct</code>, <code>@PreDestroy</code></td><td>需要配合额外注解管理生命周期</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>@Bean</code> 适用于更复杂、需要灵活控制的 Bean 配置</strong>。例如，需要根据某些条件创建 Bean 或者配置依赖的场景。</li><li><strong><code>@Component</code> 更适合那些不需要复杂配置、依赖自动装配的类</strong>。它的作用类似于自动注册类作为 Spring 管理的组件，适合小型组件或服务类。</li></ul><p>两者都可以实现依赖注入，但适用场景不同，使用时需要根据具体需求选择。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p><code>@ComponentScan</code> 注解是 Spring 提供的一个用于自动扫描和注册 Bean 的注解。它可以指定一个包路径，Spring 会自动扫描这个包路径下的所有类，并将标记了 <code>@Component</code> 及其派生注解的类注册为 Bean。</p><p><code>@ComponentScan</code> 注解通常与 <code>@Configuration</code> 注解一起使用，用于配置 Spring IoC 容器的自动扫描路径。</p><p>可以排除特定的 Bean 类型，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3&quot; &#125; ,</span></span><br><span class="line"><span class="meta">excludeFilters = &#123;@Filter(classes = Service.class) )</span>)</span><br></pre></td></tr></table></figure><p>以上大致是将Bean注入到Spring IoC容器中的方法。</p><h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 根据属性的类型找到对应的Bean进行注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p><code>@Autowired</code>的注入机制最基本的一条是通过类型进行注入。在IoC容器的顶级接口<code>Factory</code>中，有一个<code>getBean</code>方法，这个方法是通过类型来获取<code>Bean</code>的。</p><p>但是在Spring中，有时候我们会有多个实现类，这时候就需要通过<code>@Qualifier</code>注解来指定具体的实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;v8Engine&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被注入的Bean带有参数的构造函数，如何把参数传入呢？<br>使用@Value注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Value 注解注入参数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Engine</span><span class="params">(<span class="meta">@Value(&quot;$&#123;engine.type&#125;&quot;)</span> String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动注入 Engine Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving with engine type: &quot;</span> + engine.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><img src="/../imgs/image-54.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;kelin.com.springnotes.chapter3&quot;, lazyInit = true)</span></span><br></pre></td></tr></table></figure><p>使用lazyInit &#x3D; true，可以延迟初始化Bean，即在第一次使用Bean时才初始化。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../imgs/image-55.png"></p><h2 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h2><p><code>@Profile</code>注解可以根据不同的环境来选择不同的Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for DEV environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for PROD environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。&lt;/p&gt;
&lt;p&gt;Spring 中把每一个&lt;br&gt;需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 S</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm学习-人工神经网络</title>
    <link href="https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2024-10-18T00:47:24.000Z</published>
    <updated>2024-10-21T06:07:05.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？</p><p>我们现在假设要训练的模型是一个函数，首先考虑，这个函数的作用是什么？这个函数的输入是什么？输出是什么？</p><p>人工神经网络可以用来做分类、预测、生成等任务，现在假设我们的函数是一个分类函数，那么输入就是一个数据，输出就是这个数据属于哪个类别。</p><p>所以，训练神经网络，就是训练这个函数，让这个函数能够准确地对数据进行分类。</p><p>所谓训练，有点太拟人化了，听起来比较抽象，其实就是调整函数的参数，使得函数的输出尽可能接近真实值。</p><p>参数又是什么？这里先介绍一下神经网络的基本结构。</p><h2 id="人工神经网络的基本结构"><a href="#人工神经网络的基本结构" class="headerlink" title="人工神经网络的基本结构"></a>人工神经网络的基本结构</h2><p>人工神经网络是一种模拟人脑神经元网络的计算模型，它由多个神经元（Neuron）组成，每个神经元接收多个输入，经过加权和激活函数处理后，输出一个值。</p><h3 id="神经元（Neuron）"><a href="#神经元（Neuron）" class="headerlink" title="神经元（Neuron）"></a>神经元（Neuron）</h3><p><img src="/../imgs/image-51.png" alt="图来源于维基百科"></p><p>一个神经元的结构可以分为三个主要部分：<strong>输入</strong>、<strong>处理单元</strong>、<strong>输出</strong>。如果用前文的函数来描述，每一个神经元就是一个函数，这个函数的输入就是一个特征向量和一个权重向量，这个向量经过某种计算后，输出一个值（一个神经元的输出通常是一个标量）。</p><p>经过了什么处理呢？</p><p>对于单个神经元，其数学表达可以写为：<br>   $$<br>   y &#x3D; \text{activation}(w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b)<br>   $$</p><p>具体来看：</p><h4 id="1-输入层（Input-Layer）："><a href="#1-输入层（Input-Layer）：" class="headerlink" title="1. 输入层（Input Layer）："></a>1. <strong>输入层（Input Layer）</strong>：</h4><ul><li>神经元的输入来自前一层的神经元，或者在网络的第一层，输入是来自外部的数据。</li><li>输入信号（即特征）通过**权重(Weights)**传递到神经元。每个输入信号都有一个权重值，权重表示输入的重要性。</li></ul><p>   <strong>示例</strong>：<br>   如果我们有三个输入特征 $( a_1, a_2, a_3 )$，每个输入都有一个对应的权重 $( w_1, w_2, w_3 )$。<br>   $$<br>   z &#x3D; w_1 \cdot a_1 + w_2 \cdot a_2 + w_3 \cdot a_3 + b<br>   $$<br>   其中，$b$ 是偏置项。</p><h4 id="2-加权求和（Weighted-Sum）："><a href="#2-加权求和（Weighted-Sum）：" class="headerlink" title="2. 加权求和（Weighted Sum）："></a>2. <strong>加权求和（Weighted Sum）</strong>：</h4><ul><li>输入通过权重后，神经元会将这些加权输入进行加和，再加上一个<strong>偏置（Bias）</strong>项。</li><li>偏置用于调整激活函数的输出，让神经元的输出更加灵活，帮助网络更好地拟合数据。</li></ul><p>   <strong>数学表示</strong>：<br>   $$<br>   z &#x3D; \sum (w_i \cdot x_i) + b<br>   $$</p><p>   其中，$z$ 是加权求和的结果，$w_i$ 是权重，$x_i$ 是输入，$b$是偏置。</p><h4 id="3-激活函数（Activation-Function）："><a href="#3-激活函数（Activation-Function）：" class="headerlink" title="3. 激活函数（Activation Function）："></a>3. <strong>激活函数（Activation Function）</strong>：</h4><ul><li>加权求和后的结果$z$ 会通过一个<strong>激活函数</strong>，以增加神经元的非线性能力。</li><li>激活函数的目的是引入非线性，以便神经网络能够学习复杂的模式。常见的激活函数有 Sigmoid、ReLU、Tanh 等。</li></ul><h4 id="4-输出（Output）："><a href="#4-输出（Output）：" class="headerlink" title="4. 输出（Output）："></a>4. <strong>输出（Output）</strong>：</h4><ul><li>经过激活函数处理后的输出 $t$ 是神经元的最终结果，这个结果可以作为下一层神经元的输入，或者作为最终输出（例如分类结果或回归值）。</li><li>在输出层，输出值可以是一个分类标签（如Softmax输出的类别）或一个回归值（如预测的数值）。</li></ul><p>我们现在已经知道单个神经元（函数）做了什么工作，那么，为什么要经过加权求和、偏置又是什么、为什么要有激活函数？</p><h3 id="加权求和和偏置"><a href="#加权求和和偏置" class="headerlink" title="加权求和和偏置"></a>加权求和和偏置</h3><h4 id="1-加权求和："><a href="#1-加权求和：" class="headerlink" title="1. 加权求和："></a>1. <strong>加权求和</strong>：</h4><ul><li>加权求和是为了给不同的输入信号赋予不同的重要性。</li><li>通过调整权重，神经元可以学习到不同特征的重要性，从而更好地拟合数据。</li></ul><p>比如说，判断一个人是男人还是女人，我们可以用身高、体重、声音等特征。但是，不同的特征对性别的判断重要性是不同的，比如身高可能比声音更重要，所以我们需要通过权重来调整这些特征的重要性。</p><h4 id="2-偏置："><a href="#2-偏置：" class="headerlink" title="2. 偏置："></a>2. <strong>偏置</strong>：</h4><p>偏置的作用是让神经网络的输出有更多的灵活性，即使输入的值为零，偏置也能确保神经元的激活函数能产生非零的输出。这有助于模型更好地拟合数据。</p><p>为什么要有偏置：如果没有偏置，神经网络的输出完全依赖于输入数据。如果输入为零，输出会总是零，这样模型的表达能力受到限制。通过加入偏置，神经网络可以更好地学习复杂的模式和关系。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>目的：激活函数的主要作用是引入非线性，从而让神经网络能够处理复杂的非线性问题。</p><p>没有激活函数，神经网络只会进行线性变换，加权求和的输出只是输入的线性组合。线性模型的能力有限，无法拟合复杂的非线性数据。因此，激活函数通过对加权和进行非线性处理，使网络可以处理高度复杂的任务，如图像识别、自然语言处理等。</p><h4 id="1-ReLU（Rectified-Linear-Unit）："><a href="#1-ReLU（Rectified-Linear-Unit）：" class="headerlink" title="1. ReLU（Rectified Linear Unit）："></a>1. <strong>ReLU（Rectified Linear Unit）</strong>：</h4><p>   ReLU 是最简单的激活函数之一。它的数学表达式为：<br>   $$<br>   \text{ReLU}(z) &#x3D; \max(0, z)<br>   $$</p><ul><li>当 $z &gt; 0$，输出 $z$。</li><li>当 $z \leq 0$，输出 0。</li></ul><h4 id="2-Sigmoid："><a href="#2-Sigmoid：" class="headerlink" title="2. Sigmoid："></a>2. <strong>Sigmoid</strong>：</h4><p>   Sigmoid 是一种常用的激活函数，尤其适用于二分类任务。它的数学表达式为：<br>   $$<br>   \sigma(z) &#x3D; \frac{1}{1 + e^{-z}}<br>   $$</p><ul><li>该函数将输入 $z$ 映射到区间 (0, 1) 之间。</li><li>当 $z \to \infty$，Sigmoid 函数的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 0。</li></ul><h4 id="3-Tanh（Hyperbolic-Tangent）："><a href="#3-Tanh（Hyperbolic-Tangent）：" class="headerlink" title="3. Tanh（Hyperbolic Tangent）："></a>3. <strong>Tanh（Hyperbolic Tangent）</strong>：</h4><p>   Tanh 是另一个常用的激活函数，它将输入映射到 -1 到 1 之间。其数学表达式为：<br>   $$<br>   \tanh(z) &#x3D; \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>   $$</p><ul><li>该函数将 $z$ 映射到区间 (-1, 1)。</li><li>当 $z \to \infty$，Tanh 的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 -1。</li></ul><h4 id="这三个激活函数的行为："><a href="#这三个激活函数的行为：" class="headerlink" title="这三个激活函数的行为："></a>这三个激活函数的行为：</h4><ul><li><strong>ReLU</strong>：输出非负的值，有助于解决梯度消失问题，但可能会导致“死亡ReLU”问题（即神经元在某些区域永远输出0）。</li><li><strong>Sigmoid</strong>：适用于二分类，但在极值区域梯度容易消失。</li><li><strong>Tanh</strong>：输出范围为 (-1, 1)，通常比 Sigmoid 更有效，但仍可能存在梯度消失问题。</li></ul><p>偏置让模型产生非零输出，激活函数引入非线性，这两个因素使得神经网络能够学习复杂的模式和关系。那什么是线性模型，什么是非线性模型呢？</p><h3 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h3><p>我们先从“线性模型”的概念开始，然后再解释为什么它的能力有限，以及它为什么不能拟合复杂的非线性数据。</p><h4 id="1-线性模型是什么？"><a href="#1-线性模型是什么？" class="headerlink" title="1. 线性模型是什么？"></a>1. <strong>线性模型是什么？</strong></h4><ul><li>线性模型是一种简单的数学模型，它通过输入变量（特征）的线性组合来进行预测。</li><li>公式形式为：<br>$$<br>y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b<br>$$<br>其中：<ul><li>$y$ 是模型的输出（预测结果），</li><li>$x_1, x_2, …, x_n$ 是输入特征，</li><li>$w_1, w_2, …, w_n$ 是每个特征的权重，</li><li>$b$ 是偏置项。</li></ul></li></ul><p>   这个公式表明输出 $y$ 是输入特征的<strong>加权求和</strong>。这种模型在数据的所有关系都是线性时，表现得很好。</p><h4 id="2-线性模型的局限性"><a href="#2-线性模型的局限性" class="headerlink" title="2. 线性模型的局限性"></a>2. <strong>线性模型的局限性</strong></h4><ul><li>线性模型可以很好地处理简单的任务，比如预测身高和体重的关系，如果这两个变量之间的关系是线性的。</li><li><strong>线性关系</strong>意味着，输入特征的变化会导致输出以固定比例变化（即没有复杂的交互或非线性效应）。</li></ul><p>   例如，如果我们在二维平面上绘制一条直线，直线可以通过简单的线性方程来表示，适用于处理两个变量之间的简单比例关系。但在现实世界中，很多问题不是这样简单的线性关系。</p><h4 id="3-什么是非线性数据？"><a href="#3-什么是非线性数据？" class="headerlink" title="3. 什么是非线性数据？"></a>3. <strong>什么是非线性数据？</strong></h4><ul><li>非线性数据是指输入与输出之间的关系无法用简单的直线表示。它可能是弯曲的、复杂的、有多个转折点，或者数据之间存在高度的交互。</li><li>比如，如果想预测一个人的年收入，可能会涉及教育背景、工作经验、职位、技能等多个复杂因素，它们之间的关系是高度复杂的，这样的数据就是<strong>非线性的</strong>。</li></ul><p>   例如，如果我们用简单的线性模型来处理这个问题，它只能画出一条直线，但现实中这些因素的关系是复杂而非线性的，可能是一个波动的曲线。线性模型无法正确表达这种复杂的关系。</p><h4 id="4-为什么线性模型不能拟合复杂的非线性数据？"><a href="#4-为什么线性模型不能拟合复杂的非线性数据？" class="headerlink" title="4. 为什么线性模型不能拟合复杂的非线性数据？"></a>4. <strong>为什么线性模型不能拟合复杂的非线性数据？</strong></h4><ul><li>线性模型的核心在于它只会根据输入特征进行简单的加权和。因此，它无法捕捉到变量之间复杂的交互关系或弯曲的趋势。</li><li>举个简单的例子，假设要预测物体在抛出后的运动轨迹。物体的轨迹是抛物线（非线性），如果你用线性模型去拟合这个轨迹，结果只能是一条直线，完全无法准确描述抛物线的运动。</li><li>现实中的大多数数据，比如图像、语音、自然语言等，往往存在复杂的非线性关系，输入特征之间的交互也很复杂，线性模型无法有效捕捉这些关系。</li></ul><h4 id="5-如何解决这个问题？"><a href="#5-如何解决这个问题？" class="headerlink" title="5. 如何解决这个问题？"></a>5. <strong>如何解决这个问题？</strong></h4><ul><li>为了解决这个问题，我们需要引入<strong>非线性模型</strong>。神经网络就是一种非常强大的非线性模型，它通过<strong>激活函数</strong>（如 ReLU、Sigmoid）引入非线性，使得神经网络能够处理和拟合复杂的非线性数据。</li><li>每一层神经元通过权重和偏置计算出加权和，并通过激活函数引入非线性，逐层递进地学习输入数据的复杂模式，从而对复杂任务做出准确预测。</li></ul><p>用大白话说就是线性模型是拟合为直线的，非线性模型可以拟合为曲线的。</p><p><img src="/../imgs/image-52.png"></p><p><strong>那么，为什么加入激活函数后，神经网络就能处理非线性数据了呢？</strong></p><blockquote><p>当我们给神经网络加入激活函数后，它就能够处理复杂的非线性数据，原因很简单：</p><p>打破线性限制：如果没有激活函数，神经网络每一层的计算都是线性的（像画直线一样），无论堆叠多少层，最终的输出也只是线性组合，无法处理弯曲、复杂的模式。</p><p>激活函数引入变化：激活函数就像给网络“加了个弯”，不再只产生直线关系。比如 ReLU 会把负数变成 0，而正数保持不变，这种变化让网络能处理更复杂的情况，不再是简单的线性相加。<br>层层递进：每一层加上激活函数后，输出的结果会经过更多复杂的非线性处理。最终，网络能学会从数据中找到隐藏的复杂关系，甚至是一些人类看不到的特征。<br>简单来说，激活函数让网络能够画“曲线”，而不是只能画“直线”，这就是它能处理非线性数据的原因。</p></blockquote><p>前面提到：输出非负的值，有助于解决梯度消失问题。</p><p><strong>那么，梯度是什么？梯度消失又是什么？</strong></p><h3 id="梯度和梯度消失"><a href="#梯度和梯度消失" class="headerlink" title="梯度和梯度消失"></a>梯度和梯度消失</h3><p>我们先从<strong>梯度</strong>的概念开始，接着解释什么是<strong>梯度消失</strong>。</p><h4 id="1-什么是梯度？"><a href="#1-什么是梯度？" class="headerlink" title="1. 什么是梯度？"></a>1. <strong>什么是梯度？</strong></h4><ul><li>在神经网络中，梯度指的是损失函数（模型预测的误差）对模型参数（权重和偏置）的导数。</li><li>梯度告诉我们如何调整权重才能让损失减少，也就是说，它指示了优化方向。</li><li>比如，假设我们在爬山，梯度就像告诉我们当前所处位置的坡度和方向，帮助我们找到“山顶”（即最小的损失值）。</li></ul><h4 id="2-梯度消失是什么？"><a href="#2-梯度消失是什么？" class="headerlink" title="2. 梯度消失是什么？"></a>2. <strong>梯度消失是什么？</strong></h4><ul><li><strong>梯度消失</strong>是指当神经网络的某些层的梯度变得非常小时，网络更新参数的速度变得非常慢，甚至无法继续学习。</li><li>在训练深层神经网络时，随着误差从输出层逐层向前传播回输入层，梯度会逐渐变小。尤其是当使用像 Sigmoid 或 Tanh 这样的激活函数时，它们的导数很容易变得接近 0，导致梯度消失。</li></ul><h4 id="3-为什么梯度消失是个问题？"><a href="#3-为什么梯度消失是个问题？" class="headerlink" title="3. 为什么梯度消失是个问题？"></a>3. <strong>为什么梯度消失是个问题？</strong></h4><ul><li>梯度消失意味着，神经网络前面几层的权重几乎没有更新。这会导致这些层的学习速度非常慢，网络无法有效学习数据中的复杂特征。</li><li>如果梯度消失，模型在训练过程中就会变得“卡住”，无法通过反向传播有效优化权重，这样模型的表现也就无法提高。</li></ul><h4 id="4-为什么输出非负值可以帮助解决梯度消失？"><a href="#4-为什么输出非负值可以帮助解决梯度消失？" class="headerlink" title="4. 为什么输出非负值可以帮助解决梯度消失？"></a>4. <strong>为什么输出非负值可以帮助解决梯度消失？</strong></h4><ul><li><strong>ReLU激活函数</strong>输出非负值（即当输入大于 0 时，输出等于输入；否则输出 0）。ReLU 的导数是常数 1（对于正数部分），不会像 Sigmoid 或 Tanh 那样迅速衰减为接近 0。这意味着通过 ReLU，网络的梯度不容易消失，前面几层的学习速度也能得到保证。</li><li>换句话说，<strong>输出非负的值</strong>，特别是通过 ReLU 这样的激活函数，可以避免导数过小，从而缓解梯度消失问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-RAG学习</title>
    <link href="https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-12T03:18:19.000Z</published>
    <updated>2024-10-12T03:46:40.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h2><p>RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）和生成（Generation）相结合的技术，常用于自然语言处理任务，特别是在问答和文档生成场景中。</p><h3 id="RAG-的工作原理"><a href="#RAG-的工作原理" class="headerlink" title="RAG 的工作原理"></a>RAG 的工作原理</h3><p>RAG 将两个主要组件结合起来：</p><ul><li><p>信息检索（Retrieval）：当系统接收到问题时，首先会从一个大型的文档数据库或知识库中检索出与问题最相关的文档片段。通常会使用像 ElasticSearch 或基于 BERT 的检索模型来找到最相关的内容。</p></li><li><p>生成模型（Generation）：接下来，生成模型（通常是一个大型语言模型，如 GPT）会将检索到的文档片段作为输入，然后基于这些片段生成答案。这使得生成模型不必完全依赖其自身的训练数据，而是可以利用外部知识库中的信息来生成更准确和上下文相关的响应。</p></li></ul><p>RAG技术虽然有以上显著的优势，但它不是万能的，只是锦上添花的一种手段，因为它主<strong>要是优化了模型的输入过程，通过丰富输入信息的方式，来增强模型的输出质量。但这项技术并不改变模型本身的推理能力，不会改变模型任何的参数</strong>。</p><h2 id="RAG的实现"><a href="#RAG的实现" class="headerlink" title="RAG的实现"></a>RAG的实现</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成）的实现涉及两个关键组件：<strong>检索模块</strong>和<strong>生成模块</strong>。这两者结合起来使得模型可以利用外部知识库动态生成高质量的答案。下面是RAG的典型实现步骤：</p><h3 id="1-构建知识库（Knowledge-Base）"><a href="#1-构建知识库（Knowledge-Base）" class="headerlink" title="1. 构建知识库（Knowledge Base）"></a>1. <strong>构建知识库（Knowledge Base）</strong></h3><p>   RAG的一个关键组件是知识库。这个知识库通常包含与特定领域相关的文档、条目、百科等。它可以是各种形式的文本，比如：</p><ul><li>结构化数据（数据库条目、文档片段等）</li><li>非结构化数据（文章、书籍、PDF等）</li></ul><p>   知识库的构建可以从公开资源获取，或者从特定的领域文档中自动化提取。</p><h3 id="2-检索模块（Retriever）"><a href="#2-检索模块（Retriever）" class="headerlink" title="2. 检索模块（Retriever）"></a>2. <strong>检索模块（Retriever）</strong></h3><p>   检索模块的作用是从知识库中找到与用户问题相关的内容。RAG的检索过程通常分为以下几步：</p><ul><li><p><strong>问题向量化</strong>：当用户提出问题时，首先将问题转化为向量表示（Embedding）。通常使用预训练的语言模型（如BERT、RoBERTa）将问题编码为一个固定大小的向量。</p></li><li><p><strong>文档向量化</strong>：在准备阶段，知识库中的每个文档片段（通常是小的段落或句子）也会被提前转化为向量表示，并保存在向量数据库中。</p></li><li><p><strong>检索相关文档</strong>：通过计算用户问题的向量与知识库中所有文档片段向量之间的相似度（例如余弦相似度），从知识库中找到与问题最相关的文档片段。这通常使用近似最近邻搜索算法（如FAISS）来加速检索。</p></li></ul><p>   <strong>典型检索工具</strong>：</p><ul><li><strong>BM25</strong>：一种经典的信息检索算法，基于词频和逆文档频率（TF-IDF）来衡量文档与查询的相关性。</li><li><strong>Dense Retrieval</strong>：基于深度学习的检索方式，使用语言模型（如BERT）生成的稠密向量表示进行检索。</li></ul><h3 id="3-生成模块（Generator）"><a href="#3-生成模块（Generator）" class="headerlink" title="3. 生成模块（Generator）"></a>3. <strong>生成模块（Generator）</strong></h3><p>   在检索到相关文档片段后，生成模块负责结合这些片段生成最终的答案。生成模块通常基于预训练的大型语言模型（如GPT、T5等）。具体步骤如下：</p><ul><li><p><strong>输入拼接</strong>：将原始用户问题和检索到的文档片段一起作为输入，拼接成一个完整的输入序列，提供给生成模型。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户问题：&quot;什么是机器学习？&quot;</span><br><span class="line">检索到的文档片段：</span><br><span class="line">1. &quot;机器学习是一种通过数据训练算法的技术，用于预测和分类。&quot;</span><br><span class="line">2. &quot;常见的机器学习算法包括线性回归、决策树、神经网络等。&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>生成答案</strong>：生成模型接收这个拼接后的输入，然后基于它生成一个回答。由于检索到的片段为模型提供了上下文，生成的答案将更加准确和领域相关。例如，生成模型可能会输出：“机器学习是一种通过数据训练算法以进行预测和分类的技术，常用算法有线性回归和神经网络。”</p></li></ul><h3 id="4-训练RAG模型"><a href="#4-训练RAG模型" class="headerlink" title="4. 训练RAG模型"></a>4. <strong>训练RAG模型</strong></h3><p>   训练RAG模型的过程中，使用标准的生成任务损失函数（如交叉熵）对生成模块进行优化，并对检索和生成过程进行端到端的联合训练。具体来说：</p><ul><li><strong>监督学习</strong>：训练集通常由问题和答案对组成，同时包含一些相关的文档片段。模型在训练过程中不仅学习如何生成高质量的答案，还会优化检索阶段，使其能选择最相关的文档。</li><li><strong>检索优化</strong>：通过将检索模块与生成模块结合在一起，可以通过生成模块的反馈来优化检索阶段，从而逐步改进文档选择的相关性。</li><li><strong>联合训练</strong>：在一些实现中，检索器和生成器可以联合训练，从而使得检索器学习到更适合生成器的相关文档。</li></ul><h3 id="5-推理过程（Inference-Pipeline）"><a href="#5-推理过程（Inference-Pipeline）" class="headerlink" title="5. 推理过程（Inference Pipeline）"></a>5. <strong>推理过程（Inference Pipeline）</strong></h3><p>   在实际推理过程中，RAG系统通常按以下步骤执行：</p><ul><li><strong>问题输入</strong>：用户提出问题（如“人工智能的主要应用是什么？”）。</li><li><strong>检索文档</strong>：检索模块从知识库中找到与该问题相关的文档片段（如从AI相关文档中找到有关AI应用的片段）。</li><li><strong>生成答案</strong>：将用户问题和检索到的文档片段传递给生成模块，生成基于这些片段的答案。</li><li><strong>返回结果</strong>：最终，RAG系统将生成的答案返回给用户。</li></ul><h3 id="6-RAG的架构图示意"><a href="#6-RAG的架构图示意" class="headerlink" title="6. RAG的架构图示意"></a>6. <strong>RAG的架构图示意</strong></h3><p>RAG的架构可以简要表示为如下流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+    用户问题     +------------------+</span><br><span class="line">|  文档知识库      |  -------------&gt;  |   检索模块（Retriever） |</span><br><span class="line">+------------------+                   +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                      检索到的文档片段</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                     |  生成模块（Generator） |</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                          最终答案</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                           用户</span><br></pre></td></tr></table></figure><h3 id="7-RAG的实际应用"><a href="#7-RAG的实际应用" class="headerlink" title="7. RAG的实际应用"></a>7. <strong>RAG的实际应用</strong></h3><p>RAG的架构非常适合需要结合外部知识生成回答的任务，如：</p><ul><li><strong>领域问答系统</strong>：在法律、医学、金融等特定领域，RAG可以利用专业文档库进行高质量回答。</li><li><strong>文档生成和扩展</strong>：RAG可以根据输入问题生成具有参考资料的文档内容。</li><li><strong>对话系统</strong>：通过结合知识库，RAG能够在对话中生成更加丰富的内容和背景信息。</li></ul><p>通过以上过程，RAG可以有效结合知识库和生成模型，增强生成任务的知识性和准确性，同时灵活处理领域知识扩展问题。</p><h2 id="大模型微调和RAG对比"><a href="#大模型微调和RAG对比" class="headerlink" title="大模型微调和RAG对比"></a>大模型微调和RAG对比</h2><p>将通用大模型调整为某个特定领域的大模型可以通过两种常见的方法来实现：<code>RAG（Retrieval-Augmented Generation）</code>和大模型微调。两者有不同的侧重点和应用场景。以下是它们的区别：</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a>RAG（检索增强生成）</h3><p>核心思路：<br>RAG通过结合外部知识库与生成模型来增强模型的知识能力，而不改变原有的大模型参数。它会先从特定领域的知识库中检索与问题相关的信息，再基于这些检索到的内容由生成模型生成答案。这种方法不需要直接修改模型本身。</p><p>适用场景：RAG特别适用于知识动态更新较快或知识领域非常广泛的场景。它允许你快速将大模型应用于特定领域，而无需重新训练模型。例如：</p><ul><li>医学、法律、金融等领域，可以通过检索领域文档来增强模型的特定领域能力。</li><li>实时问答或需要最新知识时，RAG可以通过检索更新的知识库提供答案。</li></ul><p>优点：</p><ul><li>不需要重新训练大模型，降低计算成本。</li><li>可以即时应用于不同领域，只需准备领域特定的知识库。</li><li>动态扩展模型的知识，知识库可随时更新，增强模型的实时性和灵活性。</li></ul><p>缺点：</p><ul><li>模型仍依赖于外部知识库的质量和准确性。</li><li>检索部分可能导致效率低下，尤其在大型知识库中。</li></ul><h3 id="大模型微调"><a href="#大模型微调" class="headerlink" title="大模型微调"></a>大模型微调</h3><p>核心思路：大模型微调（Fine-tuning）是通过在特定领域的数据上对通用大模型进行进一步训练，来调整其权重，使其更适合该领域的任务。这种方法会直接改变模型的参数，使模型在特定领域表现更好。</p><p>适用场景：微调适合那些希望模型能够在特定领域有深度理解或执行特定任务的情况。微调后的模型可以直接生成该领域的高质量内容，而无需依赖外部检索。例如：</p><ul><li>某些领域的文本生成、分类、或者预测任务需要模型具备细致的专业知识，微调能够提高模型在这些任务中的表现。</li><li>特定领域的对话系统或写作助手。</li></ul><p>优点：</p><ul><li>通过专门的数据进行训练，模型可以深度适应某个领域，提升其在该领域的表现。</li><li>模型的响应可以是自主生成的，不依赖外部资源，具有更高的效率。</li></ul><p>缺点：</p><ul><li>需要大量的领域特定数据进行训练，数据收集成本高。</li><li>微调模型的计算开销大，尤其是大型模型。</li><li>一旦领域知识发生变化，模型需要重新微调，更新过程相对繁琐。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要使用Java实现场景化的RAG（检索增强生成），每个场景对应不同的知识库，底层采用OpenAI大模型，文档检索数据库使用Elasticsearch，开发工作可以分为以下几步：</p><h3 id="1-管理不同场景的知识库"><a href="#1-管理不同场景的知识库" class="headerlink" title="1. 管理不同场景的知识库"></a>1. <strong>管理不同场景的知识库</strong></h3><ul><li><p><strong>场景区分</strong>：每个场景的知识库可能包含不同的数据集。因此，你需要在Elasticsearch中为每个场景创建单独的索引，便于检索时知道该查询对应哪个知识库。</p></li><li><p><strong>Elasticsearch索引创建</strong>：</p><ul><li>针对每个场景创建不同的索引。例如，你可以为“医学场景”和“法律场景”分别创建索引<code>medical_documents</code>和<code>legal_documents</code>。</li><li>在索引中插入文档片段，并将场景信息作为元数据存储，以便后续检索时区分不同场景。</li></ul></li></ul><p>   <strong>示例：为不同场景创建索引并插入文档</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Elasticsearch client 初始化</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">    RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建医学场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">medicalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>);</span><br><span class="line">client.indices().create(medicalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建法律场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">legalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;legal_documents&quot;</span>);</span><br><span class="line">client.indices().create(legalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文档到医学场景的索引</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">medicalDocRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>).id(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    .source(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Medical Document&quot;</span>, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;This is a medical document about diseases.&quot;</span>);</span><br><span class="line">client.index(medicalDocRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure></p><h3 id="2-实现检索模块（Retriever）"><a href="#2-实现检索模块（Retriever）" class="headerlink" title="2. 实现检索模块（Retriever）"></a>2. <strong>实现检索模块（Retriever）</strong></h3><ul><li><p><strong>场景选择</strong>：在用户提问时，根据问题确定使用哪个场景的知识库进行检索。可以通过用户输入的特定关键词或上下文来选择相应的场景。例如，如果用户问的是法律相关问题，就选择“法律场景”的知识库。</p></li><li><p><strong>检索文档</strong>：根据用户的输入，从指定场景的知识库中检索相关文档。可以使用Elasticsearch的Java API，根据用户问题在特定索引中进行查询，提取与问题最相关的文档片段。</p></li></ul><p>   <strong>示例：根据场景进行检索</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">retrieveDocuments</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexName</span> <span class="operator">=</span> scene.equals(<span class="string">&quot;medical&quot;</span>) ? <span class="string">&quot;medical_documents&quot;</span> : <span class="string">&quot;legal_documents&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(indexName);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;content&quot;</span>, userQuery));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">    List&lt;String&gt; retrievedDocs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">        retrievedDocs.add(hit.getSourceAsMap().get(<span class="string">&quot;content&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retrievedDocs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-生成模块的实现（OpenAI-大模型调用）"><a href="#3-生成模块的实现（OpenAI-大模型调用）" class="headerlink" title="3. 生成模块的实现（OpenAI 大模型调用）"></a>3. <strong>生成模块的实现（OpenAI 大模型调用）</strong></h3><ul><li><p><strong>OpenAI 模型调用</strong>：当检索到相关的文档片段后，接下来要调用OpenAI的大模型生成答案。你需要将用户问题和检索到的文档片段拼接，作为模型的输入，让模型基于这些片段生成相关的答案。</p></li><li><p><strong>API 集成</strong>：使用Java的HTTP客户端（例如HttpClient）发送请求到OpenAI的API，并获取生成的答案。</p></li></ul><p>   <strong>示例：调用OpenAI大模型API生成答案</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateAnswer</span><span class="params">(String userQuery, List&lt;String&gt; retrievedDocs)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(userQuery);</span><br><span class="line">    <span class="keyword">for</span> (String doc : retrievedDocs) &#123;</span><br><span class="line">        prompt.append(<span class="string">&quot;\n&quot;</span>).append(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">    <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://api.openai.com/v1/completions&quot;</span>))</span><br><span class="line">        .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_OPENAI_API_KEY&quot;</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;&#123;\&quot;model\&quot;: \&quot;gpt-3.5-turbo\&quot;, \&quot;prompt\&quot;: \&quot;&quot;</span> + prompt.toString() + <span class="string">&quot;\&quot;, \&quot;max_tokens\&quot;: 100&#125;&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    <span class="keyword">return</span> response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-实现RAG逻辑"><a href="#4-实现RAG逻辑" class="headerlink" title="4. 实现RAG逻辑"></a>4. <strong>实现RAG逻辑</strong></h3><ul><li><p><strong>场景选择与文档检索</strong>：根据用户问题选择场景，调用相应场景的知识库，检索相关的文档片段。</p></li><li><p><strong>生成答案</strong>：将用户问题与检索到的文档片段拼接，通过OpenAI大模型生成最终答案。</p></li></ul><p>   <strong>示例：综合检索与生成</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processRAGPipeline</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 根据场景检索文档</span></span><br><span class="line">    List&lt;String&gt; retrievedDocs = retrieveDocuments(userQuery, scene);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用生成模块</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> generateAnswer(userQuery, retrievedDocs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-支持不同场景的用户接口"><a href="#5-支持不同场景的用户接口" class="headerlink" title="5. 支持不同场景的用户接口"></a>5. <strong>支持不同场景的用户接口</strong></h3><ul><li><p><strong>API设计</strong>：你可以为外部应用提供一个统一的接口，支持不同场景的知识库选择。用户可以在请求中指定场景，或让系统根据用户输入自动选择合适的场景。</p></li><li><p><strong>Spring Boot API集成</strong>：使用Spring Boot开发REST API，接收用户请求，并根据请求中的场景信息来调用相应的检索和生成模块。</p></li></ul><p>   <strong>示例：Spring Boot REST API</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RagController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/ask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">askQuestion</span><span class="params">(<span class="meta">@RequestBody</span> QuestionRequest request)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scene</span> <span class="operator">=</span> request.getScene();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userQuery</span> <span class="operator">=</span> request.getQuery();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行RAG流程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> processRAGPipeline(userQuery, scene);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuestionRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String scene;</span><br><span class="line">    <span class="keyword">private</span> String query;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-监控和优化"><a href="#6-监控和优化" class="headerlink" title="6. 监控和优化"></a>6. <strong>监控和优化</strong></h3><ul><li><strong>检索效率优化</strong>：通过优化Elasticsearch查询、配置向量检索或提升索引结构来提高检索效率。</li><li><strong>生成性能优化</strong>：对OpenAI生成的答案进行适当的后处理，例如剪短生成结果，或者通过上下文增强生成效果。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了实现一个基于Java语言、OpenAI大模型和Elasticsearch的RAG系统，你需要完成以下开发工作：</p><ol><li><strong>管理不同场景的知识库</strong>：为每个场景建立不同的Elasticsearch索引。</li><li><strong>实现检索模块</strong>：根据场景检索知识库中的文档片段。</li><li><strong>实现生成模块</strong>：通过调用OpenAI的API生成最终答案。</li><li><strong>实现综合RAG逻辑</strong>：将检索和生成模块结合，构建统一的流程。</li><li><strong>开发用户接口</strong>：通过REST API为用户提供对不同场景的RAG支持。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是RAG&quot;&gt;&lt;a href=&quot;#什么是RAG&quot; class=&quot;headerlink&quot; title=&quot;什么是RAG&quot;&gt;&lt;/a&gt;什么是RAG&lt;/h2&gt;&lt;p&gt;RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>大模型API封装学习</title>
    <link href="https://kelinkong.github.io/2024/10/10/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/10/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-10T10:28:42.000Z</published>
    <updated>2024-10-11T10:20:10.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现背景"><a href="#实现背景" class="headerlink" title="实现背景"></a>实现背景</h2><p>假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理异步请求。</p><p>为什么要做API封装？</p><blockquote><ol><li>保护模型：避免直接暴露模型，保护模型的安全性。</li><li>降低耦合：将模型与业务逻辑分离，降低耦合度。</li><li>与原有的系统对接：将模型封装成API，方便与其他系统对接。</li></ol></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>以下是一个基于 Spring WebFlux 封装 OpenAI API 的完整实现例子，使用 Gradle 管理，项目目录结构为 vo、client 和 biz。</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> └── main</span><br><span class="line">     ├── java</span><br><span class="line">     │    └── com</span><br><span class="line">     │         └── example</span><br><span class="line">     │              ├── controller</span><br><span class="line">     │              │    └── OpenAIController.java</span><br><span class="line">     │              ├── biz</span><br><span class="line">     │              │    └── OpenAIService.java</span><br><span class="line">     │              ├── client</span><br><span class="line">     │              │    └── WebClientConfig.java</span><br><span class="line">     │              └── vo</span><br><span class="line">     │                   ├── PromptRequest.java</span><br><span class="line">     │                   └── CompletionResponse.java</span><br><span class="line">     └── resources</span><br><span class="line">          └── application.yml</span><br></pre></td></tr></table></figure><p><strong>配置 WebClient 类 (client&#x2F;WebClientConfig.java)</strong></p><p>WebClientConfig 用于配置 WebClient，这个类将负责与 OpenAI API 的连接。</p><p><strong>业务逻辑 (biz&#x2F;OpenAIService.java)</strong></p><p>OpenAIService 类用于封装调用 OpenAI API 的逻辑，并且通过 WebClient 处理流式响应，返回 <code>Flux&lt;String&gt;</code>。</p><p><strong>数据传输对象 (DTO) (<code>vo/PromptRequest.java</code> 和 <code>vo/CompletionResponse.java</code>)</strong></p><p><code>PromptRequest.java</code>：定义发送给 OpenAI API 的请求体数据结构。</p><p><code>CompletionResponse.java</code>：定义从 OpenAI API 接收到的响应数据结构</p><h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><h3 id="响应的数据结构"><a href="#响应的数据结构" class="headerlink" title="响应的数据结构"></a>响应的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Choice&gt; choices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Choice</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private List&lt;Choice&gt; choices;</code> 在<code>CompletionResponse</code>类中扮演以下几个重要角色：</p><ol><li>表示响应中的数据结构：</li></ol><ul><li>choices 字段表示 OpenAI API 响应中的一个重要部分。根据 OpenAI API 的响应格式，生成的文本是以 choices 的形式返回的，每一个 Choice 对象包含一段生成的文本。</li></ul><ol start="2"><li>封装多个 Choice 对象：</li></ol><ul><li>由于 OpenAI API 可以生成多个结果（多个选择），因此需要用 List<Choice> 来封装这些生成的结果。List 是一个集合类，允许存储多个 Choice 对象，每个对象代表一个生成的文本。</li></ul><ol start="3"><li>将 JSON 映射为 Java 对象：</li></ol><ul><li>当 OpenAI API 返回一个包含 choices 的 JSON 数组时，Spring WebFlux 的 WebClient 会将 JSON 映射为 Java 对象。List<Choice> 对应的是 JSON 中的数组，Choice 类中的 text 字段对应 JSON 中每个选项的文本内容。</li></ul><p>假设 OpenAI API 的响应如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the first generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the second generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据这个 JSON 结构：</p><p><code>choices</code> 是一个数组（List），每个数组元素对应一个 Choice 对象。<br><code>Choice</code> 对象中有一个 text 字段，存储生成的文本。<br><code>private List&lt;Choice&gt; choices</code>; 在这里就是用来存储和处理这个数组，代表生成的多个文本结果。</p><p><strong>在程序中的作用</strong></p><p>当调用 OpenAI 的 API 并接收响应时，Spring 的反序列化机制会将 JSON 数据自动映射到 <code>CompletionResponse</code> <code>中。choices</code> 字段将包含多个生成的文本，每个文本存储在一个 <code>Choice</code> 对象中。</p><p>可以通过以下方式访问生成的文本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompletionResponse</span> <span class="variable">response</span> <span class="operator">=</span> ... <span class="comment">// 从 API 获取响应</span></span><br><span class="line">List&lt;CompletionResponse.Choice&gt; choices = response.getChoices();</span><br><span class="line"><span class="keyword">for</span> (CompletionResponse.Choice choice : choices) &#123;</span><br><span class="line">    System.out.println(choice.getText());  <span class="comment">// 输出每个生成的文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以逐个处理生成的文本结果。</p><h3 id="请求的数据结构"><a href="#请求的数据结构" class="headerlink" title="请求的数据结构"></a>请求的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromptRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String model; <span class="comment">// text-davinci-003  gpt-3.5-turbo  code-davinci-002</span></span><br><span class="line">    <span class="keyword">private</span> String prompt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max_tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top_p;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebClient-配置"><a href="#WebClient-配置" class="headerlink" title="WebClient 配置"></a>WebClient 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.openai.com/v1&quot;</span>)  <span class="comment">// OpenAI API base URL</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_API_KEY&quot;</span>)  <span class="comment">// 替换为你的 OpenAI API Key</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 WebClient？</strong></p><p><code>WebClient</code> 是 Spring WebFlux 提供的一个响应式、非阻塞的 HTTP 客户端，允许应用程序与外部服务进行交互。相比于传统的 RestTemplate，<code>WebClient</code> 能更好地支持异步操作，特别适合处理高并发、低延迟的应用场景。</p><p><code>WebClient </code>允许我们以编程的方式发起 HTTP 请求并处理响应。可以发送 GET、POST、PUT、DELETE 等各种 HTTP 请求，且可以处理 JSON、XML 或其他格式的数据。</p><h4 id="WebClient-的使用步骤"><a href="#WebClient-的使用步骤" class="headerlink" title="WebClient 的使用步骤"></a>WebClient 的使用步骤</h4><ol><li>创建 <code>WebClient</code> 实例：通过 <code>WebClient.Builder</code> 创建 <code>WebClient</code> 实例，可以配置 <code>baseUrl</code>、<code>header</code> 等信息。</li><li>发起请求：使用 <code>WebClient</code> 实例发起请求，可以发送 GET、POST 等请求。</li><li>处理响应：通过 <code>retrieve()</code> 方法获取响应，可以处理响应数据。</li></ol><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WebClient 实例</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望只返回一个结果（比如从 API 返回的单个 JSON 对象），使用 Mono 来处理</span></span><br><span class="line">Mono&lt;String&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/endpoint&quot;</span>)</span><br><span class="line">    .retrieve()  <span class="comment">// 提取响应体</span></span><br><span class="line">    .bodyToMono(String.class);  <span class="comment">// 将响应体转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望返回多个结果（比如从 API 返回的 JSON 数组），使用 Flux 来处理</span></span><br><span class="line">Flux&lt;MyResponseObject&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/stream-endpoint&quot;</span>)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToFlux(MyResponseObject.class);  <span class="comment">// 将响应体映射为多个对象</span></span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.subscribe(res -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Response: &quot;</span> + res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mono 或 Flux：</p><p>Mono 和 Flux 是响应式编程模型中的核心部分，分别表示单个元素（Mono）或多个元素（Flux）的异步序列。</p><p>这些序列是“惰性”的，意味着它们不会在定义时立刻执行。只有当你“订阅”它们时，数据才会开始流动，或者说，操作才会被真正执行。<br><code>subscribe()</code> 方法：</p><p><code>subscribe() </code>是触发响应式流的关键操作。当你调用 <code>subscribe()</code>，整个请求流程才会被激活和执行。</p><p><code>subscribe()</code> 的参数是一个 Consumer，表示当有数据发出时，你可以定义如何处理这些数据。在这个例子中，res 就是 HTTP 响应体的结果。</p><h3 id="假设和前端进行交互，controller如下"><a href="#假设和前端进行交互，controller如下" class="headerlink" title="假设和前端进行交互，controller如下"></a>假设和前端进行交互，controller如下</h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/openai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIController</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/generate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">generateText</span><span class="params">(<span class="meta">@RequestBody</span> PromptRequest request)</span> &#123;</span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 OpenAIService，并逐步推送生成的文本内容</span></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(request);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(</span><br><span class="line">            <span class="comment">// 这是一个 Lambda 表达式，表示每当 Flux&lt;String&gt; 中有新的文本片段 result，服务器会执行这个代码块：</span></span><br><span class="line">                result -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        emitter.send(SseEmitter.event().data(result));  <span class="comment">// 将生成的文本片段作为 SSE 事件发送到客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        emitter.completeWithError(e);  <span class="comment">// 处理异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="comment">// 每次 Flux 产生新文本段时，调用这个回调函数，将该段文本发送给客户端。</span></span><br><span class="line">                emitter::completeWithError,  <span class="comment">// 处理错误</span></span><br><span class="line">                emitter::complete  <span class="comment">// 完成</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端发送请求后，服务器返回一个 SseEmitter 对象，告诉客户端这将是一个持续的数据流。</span></span><br><span class="line"><span class="comment">         * SseEmitter 用于推送多次数据（在文本逐步生成的过程中）。</span></span><br><span class="line"><span class="comment">         * 当推送完毕后，SseEmitter 会通过 complete() 方法关闭连接。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SseEmitter"><a href="#SseEmitter" class="headerlink" title="SseEmitter"></a>SseEmitter</h4><p><code>SseEmitter</code> 是 Spring 提供的一个类，用于处理 <code>Server-Sent Events (SSE)</code>，一种服务器端推送技术。<br>通过 <code>SseEmitter</code>，服务器可以持续向客户端发送事件，而客户端只需要建立一次连接即可接收多个事件。<br>SSE 是基于 HTTP 协议的持久连接，这使它在实时数据更新场景中非常有用，例如股票价格、社交媒体通知、实时聊天消息等。</p><h3 id="服务类-biz-OpenAIService-java"><a href="#服务类-biz-OpenAIService-java" class="headerlink" title="服务类 (biz/OpenAIService.java)"></a>服务类 (<code>biz/OpenAIService.java</code>)</h3><ul><li>连接是单向的，服务器推送数据，客户端接收数据。</li><li>客户端通过 <code>EventSource API</code> 来接收服务器推送的事件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给其他组件调用，发送请求到 OpenAI API 并流式返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promptRequest 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flux&lt;String&gt; 返回流式响应的每一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">generateText</span><span class="params">(PromptRequest promptRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/completions&quot;</span>)</span><br><span class="line">                .bodyValue(promptRequest)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToFlux(CompletionResponse.class)  <span class="comment">// 将响应映射为 CompletionResponse 对象</span></span><br><span class="line">                .flatMap(response -&gt; Flux.just(response.getChoices().get(<span class="number">0</span>).getText()));  <span class="comment">// 获取响应的文本部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的组件如何调用这个服务类？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.anothercomponent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.biz.OpenAIService;</span><br><span class="line"><span class="keyword">import</span> com.example.vo.PromptRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherComponent</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPrompt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PromptRequest</span> <span class="variable">promptRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PromptRequest</span>();</span><br><span class="line">        promptRequest.setModel(<span class="string">&quot;text-davinci-003&quot;</span>);</span><br><span class="line">        promptRequest.setPrompt(<span class="string">&quot;Explain quantum physics in simple terms.&quot;</span>);</span><br><span class="line">        promptRequest.setMax_tokens(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(promptRequest);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(response -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理每一个返回的文本块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Generated Text: &quot;</span> + response);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现背景&quot;&gt;&lt;a href=&quot;#实现背景&quot; class=&quot;headerlink&quot; title=&quot;实现背景&quot;&gt;&lt;/a&gt;实现背景&lt;/h2&gt;&lt;p&gt;假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-gradle</title>
    <link href="https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/"/>
    <id>https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/</id>
    <published>2024-10-10T03:30:04.000Z</published>
    <updated>2024-10-10T06:11:54.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h3><p>Gradle是一个强大的、基于JVM的构建自动化工具。它使用Groovy或Kotlin语言来编写构建脚本，相较于传统的XML配置方式，更加灵活和易于阅读。</p><h3 id="Gradle核心概念"><a href="#Gradle核心概念" class="headerlink" title="Gradle核心概念"></a>Gradle核心概念</h3><ul><li>项目（Project）：一个Gradle构建的最小单位。</li><li>任务（Task）：构建过程中的具体操作，如编译、测试、打包等。</li><li>构建文件（build.gradle）：定义项目配置和任务的脚本文件。</li><li>插件（Plugin）：扩展Gradle功能的模块，如Java插件、Android插件等。</li></ul><p>Gradle 里的任何东西都是基于这两个基础概念: <code>projects</code> ( 项目 ) 和 <code>tasks</code> ( 任务 ) 。每一个构建都是由一个或多个 <code>projects</code> 构成的，每一个 <code>project</code> 是由一个或多个 <code>tasks</code> 构成的。一个 <code>project</code> 可以代表一个 JAR ，一个网页应用，一个发布的 ZIP 压缩包等。一个<code>tasks</code>就是一段可执行的代码，比如编译代码、运行测试、打包等。</p><p>gradle命令行基本格式：<code>gradle 任务名称</code> ，比如 <code>gradle clean</code>（清空所有编译、打包生成的文件） ，<code>gradle build -x test</code>（跳过测试构建构建）</p><p><code>build.gradle</code>文件是 Gradle 构建脚本的核心，它可以用来定义项目的构建逻辑、依赖管理、插件管理等内容。 该文件通常位于项目根目录下。<br>执行Gradle命令的时候，会默认加载当前目录下的<code>build.gradle</code>脚本文件，你也可以通过 -b 参数指定想要加载执行的文件。</p><p><code>Gradle插件</code>是一种可重用的构建逻辑，它可以提供各种功能来简化构建过程。Gradle中有丰富的插件，例如：application 插件可以打包可执行的Java应用程序,war 插件可以打包Web应用程序。除了官方插件之外，还有很多第三方插件。</p><p><code>Gradle Wrapper</code>是Gradle的一个特性，它能够让我们在不安装Gradle的情况下运行Gradle构建。它是一个shell脚本和一个二进制文件，可以自动下载指定版本的Gradle，并使用该版本运行Gradle构建。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="Project（项目）"><a href="#Project（项目）" class="headerlink" title="Project（项目）"></a>Project（项目）</h3><p>定义: Gradle构建的最小单位，代表一个需要构建的软件系统。</p><p>组成:</p><ul><li>build.gradle文件: 定义项目配置和任务的脚本文件。</li><li>子项目: 一个项目可以包含多个子项目。</li></ul><p>作用:</p><ul><li>组织构建逻辑：将整个构建过程划分成不同的项目，方便管理。</li><li>定义依赖关系：不同项目之间可以存在依赖关系。</li></ul><h3 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h3><p>定义: 构建过程中的具体操作，是构建的原子单位。</p><p>作用:</p><ul><li>编译源代码</li><li>运行测试</li><li>生成jar包</li><li>打包war包</li><li>自定义任务</li></ul><p>特点:</p><ul><li>有序执行：任务之间可以有依赖关系，确保执行顺序。</li><li>可配置：可以通过参数来配置任务的行为。</li><li>可复用：可以将任务定义为公共任务，在多个项目中共享。</li></ul><h3 id="Plugin（插件）"><a href="#Plugin（插件）" class="headerlink" title="Plugin（插件）"></a>Plugin（插件）</h3><p>定义: 扩展Gradle功能的模块，提供特定领域的构建支持。</p><p>作用:</p><ul><li>添加新的任务：比如Java插件添加了compileJava、test等任务。</li><li>提供新的配置项：比如Java插件提供了sourceSets配置。</li><li>定义新的约定：比如Java插件定义了源代码和资源的默认目录结构。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">//  通过应用这个插件，Gradle知道这是一个Java项目，并会自动配置一些默认的任务和约定。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123; <span class="comment">// 配置仓库。</span></span><br><span class="line">    mavenCentral() <span class="comment">// mavenCentral() 表示使用Maven中央仓库。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">// 声明依赖。</span></span><br><span class="line">    implementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Hello, Gradle!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项目"><a href="#多项目" class="headerlink" title="多项目"></a>多项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-project</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── core</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── web</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">└── build.gradle</span><br></pre></td></tr></table></figure><p>类似cmake的多项目构建，每个项目都有自己的<code>build.gradle</code>文件，根目录下的<code>settings.gradle</code>文件用来定义项目的结构。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;core&#x27;</span>, <span class="string">&#x27;web&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多个脚本"><a href="#多个脚本" class="headerlink" title="多个脚本"></a>多个脚本</h3><p>当依赖项过多时，可以将依赖项提取到一个单独的文件中，然后在<code>build.gradle</code>中引入（<code>dependencies.gradle</code>）。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;dependencies.gradle&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>脚本包含: apply from语句告诉Gradle去包含另一个脚本文件，就好像把那个脚本文件的内容直接复制粘贴到当前脚本中一样。</li><li>执行顺序: apply from语句通常放在 plugins 块之后，这样被包含的脚本就可以访问插件提供的功能。</li></ul><p>在build脚本中引用 <code>gradle.properties</code></p><ul><li>直接使用属性: Gradle会自动将 <code>gradle.properties</code> 中定义的属性加载到当前构建脚本的上下文中，可以直接使用 <code>$propertyName</code> 的方式引用。</li><li>使用 <code>ext</code> 对象: Gradle提供了一个 <code>ext</code> 对象，可以用来存储自定义的属性。可以在 <code>build.gradle</code> 中将 g<code>radle.properties</code> 中的属性赋值给 <code>ext</code> 对象，然后通过 <code>ext.propertyName</code> 的方式引用。</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gradle.properties</span></span><br><span class="line">version=<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">myProperty=value</span><br><span class="line"></span><br><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">println <span class="string">&quot;Project version: $version&quot;</span></span><br><span class="line"></span><br><span class="line">ext.myCustomProperty = <span class="string">&quot;custom value&quot;</span></span><br><span class="line">println <span class="string">&quot;Custom property: $&#123;ext.myCustomProperty&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="buildscript"><a href="#buildscript" class="headerlink" title="buildscript"></a>buildscript</h3><p>在Gradle构建脚本中，buildscript 块主要用于配置构建脚本本身的依赖和环境。它定义了构建脚本在执行过程中所需要的资源。</p><p>ext {} 和 repositories {} 是 buildscript 块中的两个重要的配置块：</p><ul><li>ext {}： 用于定义扩展属性。这些属性可以在整个构建脚本中被引用，提供了一种灵活的方式来存储和共享配置信息。</li><li>repositories {}： 用于配置仓库地址。这些仓库是 Gradle 下载插件和依赖的来源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Gradle&quot;&gt;&lt;a href=&quot;#什么是Gradle&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Axios学习笔记</title>
    <link href="https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-08T06:57:00.000Z</published>
    <updated>2024-10-08T07:38:18.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。</p><p>教程参考：<a href="https://www.axios-http.cn/docs/intro">Axios教程</a></p><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p><strong>promise是什么？</strong>(简要理解，详细理解放到后面)</p><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这里还是以项目中的实际使用为例。</p><p>首先看一个完整的HTTP请求示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /login <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>   <span class="comment">// 请求行</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span>    <span class="comment">// 请求头</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json <span class="comment">// 指明请求体的格式</span></span><br><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt; <span class="comment">// 指明身份验证信息</span></span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">// 请求体</span></span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john_doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;secret123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中，需要发送请求到后端，所以需要配置一个axios实例，这样可以统一配置请求头等信息。<a href="https://www.axios-http.cn/docs/req_config">请求配置参考</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE_URL</span> = <span class="string">&#x27;http://localhost:8080/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义实例的默认配置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="参数传递位置"><a href="#参数传递位置" class="headerlink" title="参数传递位置"></a>参数传递位置</h3><p><strong>Query参数</strong>：在URL中传递参数，如<code>/project?userId=1</code>，后端使用<code>@RequestParam</code>接收</p><ul><li>位置：参数作为查询字符串附加在 URL 之后，例如：&#x2F;project?userId&#x3D;12345。</li><li>用途：通常用于 GET 请求，适合传递简单的键值对参数。</li></ul><p><strong>路径参数</strong>：在URL中传递参数，如<code>/project/1</code>, 后端使用<code>@PathVariable</code>接收</p><ul><li>位置：参数作为 URL 路径的一部分，例如：&#x2F;project&#x2F;12345。</li><li>用途：通常用于 RESTful API 中的资源标识，适合传递资源 ID 等信息</li></ul><p><strong>请求体参数</strong>：在请求体中传递参数，如<code>&#123;userId: 1&#125;</code>, 后端使用<code>@RequestBody</code>接收</p><ul><li>位置：参数作为请求体的一部分，例如：{userId: 12345}。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Query 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getProjectsByUserId</span> = (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">get</span>(<span class="string">`/project`</span>, &#123; </span><br><span class="line">        <span class="attr">params</span>: &#123;</span><br><span class="line">            <span class="attr">userId</span>: userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路径参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">deleteProjectById</span> = (<span class="params">projectId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">delete</span>(<span class="string">`/project/<span class="subst">$&#123;projectId&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用请求体参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addProject</span> = (<span class="params">project</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">post</span>(<span class="string">`/project/add`</span>, project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以在请求或响应被 then 或 catch 处理前拦截它们。</p><p>在项目中使用到了请求拦截器，每次请求时自动将 token 添加到请求头中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>响应拦截器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>Axios返回的是一个Promise对象，所以可以使用<code>then</code>和<code>catch</code>方法处理响应。</p><p>一个响应结构应该包含如下信息：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是服务器响应头</span></span><br><span class="line">  <span class="comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是 `axios` 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>.then()</code>方法处理响应：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在项目中没有使用统一的错误处理机制，所以错误处理参考：<a href="https://www.axios-http.cn/docs/handling_errors">错误处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。&lt;/p&gt;
&lt;p&gt;教程参考：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="frontend" scheme="https://kelinkong.github.io/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-JWT</title>
    <link href="https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/"/>
    <id>https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/</id>
    <published>2024-10-08T02:00:10.000Z</published>
    <updated>2024-10-08T03:56:44.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java实战项目中，对于登陆操作，想要达到下面的效果：</p><ul><li>登陆成功后，登陆的状态保持一段时间，不需要重复登陆</li></ul><p>实现登陆保持功能可以使用session和cookie，但是这种方式有一些问题：</p><ul><li>session和cookie是存储在服务端的，如果服务端重启，session和cookie会丢失</li><li>对于分布式系统，session和cookie需要做共享，增加了复杂度</li></ul><p>所以在该项目中，我使用JWT做登陆保持。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JWT（JSON Web Token）是一种基于JSON的开放标准（RFC 7519），用于在网络上传输声明的一种方式。JWT是一种轻量级的身份验证和授权的方式，可以在用户和服务器之间传递安全可靠的信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>一旦 JWT 签发了，就不能撤回，除非改密钥。（在到期时间之前，都是有效的）</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>用户登录时，服务器验证用户身份。</li><li>如果验证通过，服务器生成一个包含用户信息的 JWT 并返回给客户端。</li><li>客户端将 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。(可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。)</li><li>服务器每次根据 Token 验证用户身份，无需存储任何会话信息。</li></ul><h3 id="前端需要做什么？"><a href="#前端需要做什么？" class="headerlink" title="前端需要做什么？"></a>前端需要做什么？</h3><p>前端需要在用户登录成功后，将服务器返回的 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。</p><p>用户登陆成功后，将服务器返回的 Token 存储在本地存储中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, token);</span><br></pre></td></tr></table></figure><p>后续请求时，需要在请求头携带token。</p><p>如果每一个请求都手动去携带 Token，会很麻烦，所以可以使用 Axios 拦截器来实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><p>后端需要实现以下功能：</p><ul><li>JWT工具类，用于生成和解析（验证）Token</li><li>过滤器，用于过滤前端所有的请求，验证Token的有效性</li><li>Web配置，将过滤器注册到Spring容器中</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h4><p>生成和解析Token的工具类，使用了 jjwt 库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//设置密钥（要想非对称加密这里换成私钥）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收业务数据,生成token并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;claims&quot;</span>, claims) <span class="comment">//token中加入用户信息</span></span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>)) <span class="comment">//设置超时时间</span></span><br><span class="line">                .sign(Algorithm.HMAC256(KEY)); <span class="comment">//设置加密类型及密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收token,验证token,并返回业务数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">//去除token的前缀标记&quot;Bearer &quot;</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">newToken</span> <span class="operator">=</span> token.contains(<span class="string">&quot;Bearer &quot;</span>)?token.substring(<span class="string">&quot;Bearer &quot;</span>.length()):token;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(KEY))</span><br><span class="line">                .build()</span><br><span class="line">                .verify(newToken)</span><br><span class="line">                .getClaim(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">                .asMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器用于过滤前端所有的请求，验证Token的有效性。</p><p>创建一个认证对象，将用户信息放入认证对象中，然后将认证对象放入SecurityContextHolder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is called by the filter chain to filter the request.</span></span><br><span class="line"><span class="comment">        * 所有的请求都会经过这个方法，我们可以在这里进行token的解析和用户的认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getTokenFromRequest(request);</span><br><span class="line">        logger.info(<span class="string">&quot;Token: &quot;</span> + token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">                <span class="keyword">if</span> (claims != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> getAuthentication(claims);</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                response.getWriter().write(<span class="string">&quot;Token expired&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to extract the token from the request.</span></span><br><span class="line"><span class="comment">        * 从请求中提取token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTokenFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bearerToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bearerToken != <span class="literal">null</span> &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to create an authentication object.</span></span><br><span class="line"><span class="comment">        * 创建一个认证对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// Implement token parsing and authentication creation logic</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(claims, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web配置"><a href="#Web配置" class="headerlink" title="Web配置"></a>Web配置</h4><ul><li>将过滤器注册到Spring容器中。</li><li>跨域配置。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Configures the security filter chain that carries out authentication and authorization.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http the HttpSecurity object to configure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the SecurityFilterChain object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if an error occurs during configuration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/api/user/login&quot;</span>).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))</span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:9000&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(List.of(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setAllowedHeaders(List.of(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWT结构示例"><a href="#JWT结构示例" class="headerlink" title="JWT结构示例"></a>JWT结构示例</h2><p>JWT 由三部分组成，分别是 Header、Payload 和 Signature，它们之间使用 . 分隔。</p><p><strong>示例</strong></p><ol><li>Header：头部包含 JWT 的类型和使用的签名算法<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Header 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li><li>Payload：它包含用户的声明信息，例如用户的 ID、用户名等。这些信息通常包括注册声明、自定义声明等<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Payload 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure></li><li>Signature：签名是对 Header 和 Payload 的签名，防止数据被篡改<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Signature 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure>最终生成的 JWT 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure></li></ol><p>解码后的结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header: &#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">Payload: &#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">Signature: HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java实战项目中，对于登陆操作，想要达到下面的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登陆成功后，登陆的状态保持一段时间，不需要重复登陆&lt;/l</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
</feed>
