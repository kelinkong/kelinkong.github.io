<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-16T02:58:34.480Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用hexo和github搭建静态博客</title>
    <link href="http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/08/16/%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-08-16T01:54:10.363Z</published>
    <updated>2023-08-16T02:58:34.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><ol><li>从官网下载安装</li><li>使用nvm<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install node # 安装最新版本</span><br><span class="line">nvm use node # 使用最新版本</span><br></pre></td></tr></table></figure></li><li>使用 curl 方式安装最新版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></li></ol><h2 id="设置hexo"><a href="#设置hexo" class="headerlink" title="设置hexo"></a>设置hexo</h2><ol><li>安装<br><code>npm install -g hexo-cli</code></li><li>初始化<br><code>hexo init &lt;folder&gt;</code></li></ol><h2 id="设置Github"><a href="#设置Github" class="headerlink" title="设置Github"></a>设置Github</h2><ol><li><p>创建一个同名仓库。例如我的GitHub名字是kelinkong，新建一个仓库<code>kelinkong.github.io</code></p></li><li><p>将地址设置到delpoy</p><p> 地址格式: <code>git@github.com:username/username.github.io.git</code></p><p> 默认分支: <code>main</code></p></li><li><p>部署之前需要安装<code>npm install hexo-deployer-git --save</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:kelinkong/kelinkong.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure></li></ol><h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>我这里使用的是maupassant主题。地址:<a href="https://github.com/tufu9441/maupassant-hexo">https://github.com/tufu9441/maupassant-hexo</a></p><p>设置步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass-next --save</span><br></pre></td></tr></table></figure><p>在项目的_config.yaml设置中，将themes改为maupassant</p><h2 id="部署和预览"><a href="#部署和预览" class="headerlink" title="部署和预览"></a>部署和预览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g</span><br><span class="line">hexo s # 本地预览</span><br><span class="line">hexo d # 发布到github</span><br></pre></td></tr></table></figure><h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt; <span class="comment">#初始化文件夹</span></span><br><span class="line"></span><br><span class="line">hexo new &lt;title&gt; <span class="comment">#新建文章</span></span><br><span class="line"></span><br><span class="line">hexo server (hexo s)  <span class="comment"># 启动本地服务器,用于博客预览</span></span><br><span class="line"></span><br><span class="line">hexo deploy (hexo d)  <span class="comment"># 部署博客到GitHub等托管平台</span></span><br><span class="line"></span><br><span class="line">hexo clean  <span class="comment"># 清除缓存和已生成的静态文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合命令</span></span><br><span class="line">hexo d -g <span class="comment">#生成部署</span></span><br><span class="line">hexo s -g <span class="comment">#生成预览</span></span><br><span class="line"></span><br><span class="line">hexo list &lt;<span class="built_in">type</span>&gt;   <span class="comment"># 查看文章列表</span></span><br><span class="line"></span><br><span class="line">hexo new page categories <span class="comment"># 新建分类</span></span><br><span class="line"></span><br><span class="line">hexo new page tags <span class="comment"># 新建tag</span></span><br></pre></td></tr></table></figure><p>注意：每一个分类和tag都需要建立对应的新目录和index.md文件</p><p><strong>文章标识：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date: 2020-01-01 12:00:00  </span><br><span class="line">categories: 分类1  </span><br><span class="line">tags: [标签1, 标签2]</span><br></pre></td></tr></table></figure><h2 id="针对maupassant主题"><a href="#针对maupassant主题" class="headerlink" title="针对maupassant主题"></a>针对maupassant主题</h2><ol><li>修改logo：在主题的配置文件中，修改<code>avatar: /img/logo.jpg</code></li><li>如果需要识别Latex格式的公式，在文章index添加<code>mathjax: true  </code></li></ol><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="如何在vscode中快速粘贴图片到markdown文档？"><a href="#如何在vscode中快速粘贴图片到markdown文档？" class="headerlink" title="如何在vscode中快速粘贴图片到markdown文档？"></a>如何在vscode中快速粘贴图片到markdown文档？</h3><p>参考连接: <a href="https://juejin.cn/post/7244809769794289721">https://juejin.cn/post/7244809769794289721</a></p><p>打开<code>markdown.copyFiles.destination</code>设置，我这里是在<code>_posts</code>文件夹下新建了一个<code>img</code>文件夹专门用来存储图片。对应设置如下:<br><img src="/img/image.png"><br>该配置是一个对象，key 使用 Glob 语法，表示匹配的 Markdown 文档；value 则表示所匹配的这些 Markdown 文档，它们的图片文件存放目录，可以使用一些简单的变量。</p><h3 id="如何设置about-me"><a href="#如何设置about-me" class="headerlink" title="如何设置about me"></a>如何设置about me</h3><p><code>hexo new page about</code></p><h3 id="如何设置rss订阅"><a href="#如何设置rss订阅" class="headerlink" title="如何设置rss订阅"></a>如何设置rss订阅</h3><p><code>npm install hexo-generator-feed</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装nodejs&quot;&gt;&lt;a href=&quot;#安装nodejs&quot; class=&quot;headerlink&quot; title=&quot;安装nodejs&quot;&gt;&lt;/a&gt;安装nodejs&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从官网下载安装&lt;/li&gt;
&lt;li&gt;使用nvm&lt;figure class=&quot;hig</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo Cannot GET/</title>
    <link href="http://example.com/2023/08/15/hexo_Cannot_GET/"/>
    <id>http://example.com/2023/08/15/hexo_Cannot_GET/</id>
    <published>2023-08-15T07:33:02.000Z</published>
    <updated>2023-08-16T02:46:44.770Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong></p><p>在hexo搭建博客的过程中，出现Cannot GET&#x2F;xxx的错误。</p><h3 id="查看是否缺少组件"><a href="#查看是否缺少组件" class="headerlink" title="查看是否缺少组件"></a>查看是否缺少组件</h3><ol><li><p>到public目录下找到xxx文件是否存在，我的错误是<code>Cannot GET/</code>，所以去找<code>index.html</code>是否存在。</p></li><li><p>不存在，执行<code>hexo clean &amp;&amp; hexo g</code>重新生成</p></li><li><p>还是不存在，执行<code>npm audit fix</code>或者是<code>npm ls --depth 0</code>，查看是否缺少组件。通过<code>npm install hexo-xxx-xxx</code>安装</p></li><li><p>执行完毕后发现我并不缺少组件。尝试其他解决办法。</p></li></ol><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p><code>config–&gt;index.js</code>中的 <code>assetsPublicPath: &#39;/&#39;</code>改成<code>assetsPublicPath: ‘./’</code></p><h3 id="没有文件"><a href="#没有文件" class="headerlink" title="没有文件"></a>没有文件</h3><p>在路径<code>\source\_posts\</code>中至少需要存放一篇文档，否则会出现<code>Cannot GET/</code>错误。</p><h3 id="nodejs等级太高"><a href="#nodejs等级太高" class="headerlink" title="nodejs等级太高"></a>nodejs等级太高</h3><p>官方文档参考链接：<a href="https://hexo.io/zh-cn/docs/index.html">https://hexo.io/zh-cn/docs/index.html</a></p><p><img src="/img/image-1.png"></p><h3 id="文件名问题"><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h3><p>将所有markdown文件的名称替换为英文</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在hexo搭建博客的过程中，出现Cannot GET&amp;#x2F;xxx的错误。&lt;/p&gt;
&lt;h3 id=&quot;查看是否缺少组件&quot;&gt;&lt;a href=&quot;#查看是否缺少组件&quot; class=&quot;headerlink&quot; title=&quot;查</summary>
      
    
    
    
    <category term="solutions" scheme="http://example.com/categories/solutions/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Computational Complexity Theory</title>
    <link href="http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/"/>
    <id>http://example.com/2022/06/15/Notes_on_Computational_Complexity_Theory/</id>
    <published>2022-06-15T16:38:52.000Z</published>
    <updated>2023-08-16T02:43:35.920Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><ul><li><p>一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上的一个单元。</p></li><li><p>一个图灵机是根据它的读写头所在的单元进行操作的，它或者改变单元中的字符，或者移动它的读写头到相邻的一个单元，也就是说，图灵机的复杂性度量是由比特运算决定的。</p></li></ul><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p><strong>随着问题规模的增大，算法执行时间增长的快慢。它可以用来表示一个算法运行的时间效率。大</strong>$O$用来表示算法执行的最坏时间复杂度。</p><p>多项式时间：$O(n^{O(1)})$ </p><h3 id="问题分类："><a href="#问题分类：" class="headerlink" title="问题分类："></a>问题分类：</h3><p><strong>P（polynominal）</strong>：确定性图灵机在多项式时间内可解决的问题</p><p><strong>NP（Nondeterministic polynominal 非确定多项式）</strong>：多项式时间内可验证</p><ul><li><p>非确定算法是可以做非确定运算的算法，在非确定算法的一个步骤中，算法可以不确定地对一个变量赋值0或者1，在这样的赋值以后，算法的计算过程分解成两个分开的计算路径，每一条对应一种可能的赋值。假设非确定性算法进行k次非确定性运算，那么可以产生$2^k$种不同的确定性计算路径。如果存在至少一条导致判定的结论为“是”的计算路径，那么我们称这个非确定算法接受这个输入，如果不存在，那么这个算法就拒绝这个输入。</p></li><li><p>一个非确定性算的时间复杂度是所有导致判定结论为“是”的计算路径种最短运行时间。</p></li></ul><p><strong>EXP</strong>：指数时间内能解决</p><p><strong>R</strong>：有限时间内解决</p><ul><li><p>$P \subseteq NP$：存在多项式时间算法问题，总能在多项式时间内验证。</p></li><li><p>$NP\subseteq  EXP \subseteq R$</p></li></ul><h3 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h3><p>该类问题不知道存不存在一个多项式时间的算法，但是给出一个解S，我们可以在多项式时间内验证S是否是问题P的一个解。</p><p><strong>NP-hard问题：</strong> 比所有的NP问题都要难的问题。所有的NP问题都可以多项式<strong>归约</strong>到NP-hard问题。如果NP-hard问题存在多项式时间算法，那么所有的NP问题都会存在多项式时间算法。</p><p><strong>NP-complete问题：</strong> 既属于NP又属于NP-hard的问题</p><p><img src="/img/image-2.png" alt="Alt text"></p><p><mark>P &#x3D; NP</mark>   or <mark>P ≠ NP</mark> ？</p><blockquote><p><strong>有没有什么问题属于NP-hard，但是不属于NP？</strong></p><p>停机问题：给定一个程序和输入，判定运行是否终止，不可判定，所以不属于NP。</p><p><strong>图同构问题和因数问题，既没有结果表明属于P，也没有结果表明属于NP-完全</strong></p></blockquote><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p><strong>定义：</strong> 语言$L \subseteq {0,1}^*$多项式时间卡普归约到语言$L’ \subseteq {0,1}^*$，记为$L \leq_p L’$，如果存在多项式时间可计算的函数$f:{0,1}^* \to {0,1}^*  $使得对任意的$x \in {0,1}^*$均有$x\in L$当且仅当$f(x)\in L’$。多项式时间卡普规约也可以简称为多项时间规约。</p><p>如果$L \leq_p L’$对任意的$L\in NP$成立，则称$L’$是NP-难的，如果$L’$是NP-难的且$L’\in NP$，则称$L’$是NP-完全的。</p><p>换句话说，如果A问题是一个NP-hard问题，我们想要得到B问题也是一个NP-hard问题，假设$x$是A问题的一个解，那么我们能在多项式时间内从$x$推出B问题的一个解$f(x)$，反过来，如果我们有B问题的一个解$y$，那么我们能在多项式时间内从$y$推出A问题的一个解$x$。从而有B问题是NP-hard问题。</p><h3 id="针对NP-hard问题我们有什么解决方法"><a href="#针对NP-hard问题我们有什么解决方法" class="headerlink" title="针对NP-hard问题我们有什么解决方法"></a>针对NP-hard问题我们有什么解决方法</h3><p><strong>判定问题：</strong> 一个问题的解只有“是”或者“否”。</p><p><strong>最优化问题：</strong> 求最优解（最大或者最小）。</p><p>同一个问题的判定问题和最优化问题在计算复杂性方面是<mark>等价</mark>的。</p><p>因为假设判定问题是多项式可解，那么只需要枚举n次解，即可得到最优化问题的解。<br>总有某一个解k是可满足的，k+1(最大值问题)是不可满足的，此时k就是解。</p><h4 id="精确算法"><a href="#精确算法" class="headerlink" title="精确算法"></a>精确算法</h4><ol><li>当一个问题被证实为NP-完全问题，其精确算法多半使用分支界定、动态规划等算法设计，时间复杂度为指数级。</li><li>对于每一个问题，可以先假设其有多项式时间算法，并去设计该算法。</li></ol><h4 id="参数算法"><a href="#参数算法" class="headerlink" title="参数算法"></a>参数算法</h4><h4 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h4><p>NP-hard问题求最优解比较困难（从算法运行时间角度），所以可以考虑设计近似算法求解。近似算法不花费指数时间寻找优化问题的最优解，而是在多项式时间内求得一个近似最优解。</p><blockquote><p><strong>启发式算法和近似算法</strong></p><ul><li><p>近似算法性能比一般是可以通过严格的理论证明得到或者估计出范围的，而启发式算法不存在这样的理论分析结果，评价启发式算法性能的好换往往是依靠对问题的不同实例输入所进行数值模拟。</p></li><li><p>近似算法通常是用来求解优化问题，而启发式算法不仅可用于求解优化问题，还可以用于处理判定问题。</p></li></ul><p><strong>比如，设计一个可满足性问题近似算法没有意义，相关的启发式算法可以有效处理可满足问题的一大部分实例，但是不能保证可以在多项式时间内处理问题的所有实例。</strong></p></blockquote><p><strong>近似性能比：</strong> $r(A)&#x3D;max{A(I)&#x2F;opt(I),opt(I)&#x2F;A(I)}$。$A(I),opt(I)$分别表示算法A输出的一个问题P的解，和问题P的最优解。</p><p><strong>不可近似性：</strong> 求解某一个优化问题的任意一个近似算法性能比的下界。</p><p><strong>依据不可近似性，优化问题可以分为：</strong></p><ul><li><p>PTAS：近似性能比可以无限逼近于1</p></li><li><p>APX：有常数近似性能比</p></li><li><p>APX-C：某些问题的近似性能比无法突破一个界</p></li></ul><h5 id="如何求解不可近似性："><a href="#如何求解不可近似性：" class="headerlink" title="如何求解不可近似性："></a>如何求解不可近似性：</h5><ul><li><p>从NP-完全问题去规约</p><ul><li>如果优化问题A具有NP-难间隙$[\alpha,\beta],0 \leq \alpha \leq \beta$，那么问题A不存在多项式时间$(\beta&#x2F;\alpha)$-近似算法，除非$P&#x3D;NP$。</li></ul></li><li><p>间隙放大与保持</p></li></ul><p><img src="/img/image-3.png" alt="Alt text"></p><h5 id="APX-完全性"><a href="#APX-完全性" class="headerlink" title="APX-完全性"></a>APX-完全性</h5><p>对于某些问题，存在求解他们的具有常数性能比的近似算法（APX），去证明他们的某种程度的不可以近似性。</p><blockquote><p>顶点覆盖问题不存在一个近似性能比小于2的近似算法，即MVC问题近似性能比下界为2，那么我们为什么要去证明其APX-完全性质呢？上诉说的某种程度往往是限定于度，且度越小越好，从解决问题的角度考虑，在小度图上都无法近似，大度图上一般也是无法近似的。</p></blockquote><p><strong>L规约的定义</strong></p><p>Let two $NP$ optimization problems $\Lambda$ and $\Pi$ and there are two polynomial-time transformation $h$ and $g$ satisfying the following conditions:</p><ol><li><p>$h$ maps an instance $x$ of $\Lambda$ to an instance $h(x)$ of $\Pi$ such that:<br>$opt_{\Pi}(h(x)) \leq \alpha \cdot opt_{\Lambda}(x)$</p></li><li><p>$g$ maps solutions of $\Pi$ for instance $h(x)$ to solutions of $\Lambda$ for instance $x$. For every feasible solution $y$ of $h(x)$ with objective value $m_{\Pi}(h(x),y)&#x3D; c_{2}$, we can find a solution $g(y)$ of $x$ in polynomial time with $m_{\Lambda}(x,g(y))&#x3D; c_{1}$ such that:<br>$|opt_{\Lambda}(x)-c_{1}| \leq \beta \cdot |opt_{\Pi}(h(x)) - c_{2}|$</p></li></ol><h5 id="rho-ln-n-不可近似性"><a href="#rho-ln-n-不可近似性" class="headerlink" title="$(\rho ln n)$-不可近似性"></a>$(\rho ln n)$-不可近似性</h5><p>有一类组合优化问题，对其中的每一个问题都存在一个正实数$\rho$，使得它没有多项式时间$(\rho ln n)$-近似算法。如，最小集合覆盖问题。</p><h5 id="n-c-不可近似性"><a href="#n-c-不可近似性" class="headerlink" title="$n^c$-不可近似性"></a>$n^c$-不可近似性</h5><p>图着色问题和最大团问题都不存在$n^c$-近似算法，$c&gt;0$。</p><p><strong>针对近似算法，我们通常是找到近似算法的下界，然后去设计近似算法不断去逼近下界。</strong></p><h3 id="backgroud"><a href="#backgroud" class="headerlink" title="backgroud"></a>backgroud</h3><ol><li><p>Introduction</p><p>Computational complexity theory studies the inherent difficulty of computational problems. It analyzes and classifies problems based on the computational resources required to solve them, such as time and space. Understanding problem complexity helps computer scientists design efficient algorithms and determine theoretical limitations of computation.</p></li><li><p>Time Complexity</p><p>Time complexity refers to the number of computation steps required for an algorithm to solve a problem as a function of input size n. Common time complexity functions include constant O(1), logarithmic O(log n), linear O(n), quadratic O(n^2), and exponential O(2^n).</p></li><li><p>Space Complexity</p><p>Space complexity analyzes the auxiliary memory space needed by an algorithm, in addition to its input. Space complexity is commonly expressed using Big O notation as well.</p></li><li><p>P vs. NP Problem</p><p>P represents complexity class of problems solvable in polynomial time by a deterministic Turing machine. NP consists of problems verifiable in polynomial time given the right solution. The P vs NP problem asks whether P &#x3D; NP, i.e. are efficiently verifiable problems also efficiently solvable. It is considered one of the most important open problems in computer science and mathematics.</p></li><li><p>NP-complete and NP-hard</p><p>NP-complete problems are the most difficult problems in NP. NP-hard problems are at least as difficult as NP-complete ones. No efficient solutions are known for NP-complete or NP-hard problems.</p></li><li><p>Reductions</p><p>Reduction shows equivalence between computational problems. Polynomial time reductions are often used to prove NP-completeness.</p></li><li><p>Major Complexity Classes</p><p>Some key complexity classes are:</p><ul><li>P: polynomial time solvable problems</li><li>NP: verifiable in polynomial time</li><li>co-NP: complement of NP</li><li>PSPACE: solvable with polynomial space</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;图灵机&quot;&gt;&lt;a href=&quot;#图灵机&quot; class=&quot;headerlink&quot; title=&quot;图灵机&quot;&gt;&lt;/a&gt;图灵机&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个图灵机计算所涉及的所有输入、输出和计算过程中产生的数据都存储在有限个存储带上，存储一个字符需要占用一个存储带上</summary>
      
    
    
    
    <category term="tcs" scheme="http://example.com/categories/tcs/"/>
    
    
  </entry>
  
</feed>
