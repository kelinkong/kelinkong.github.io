<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kelin&#39;s blog</title>
  
  
  <link href="https://kelinkong.github.io/atom.xml" rel="self"/>
  
  <link href="https://kelinkong.github.io/"/>
  <updated>2024-11-08T00:26:58.423Z</updated>
  <id>https://kelinkong.github.io/</id>
  
  <author>
    <name>kelin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>llvm-使用langchain-chatchat和ollama构建大模型</title>
    <link href="https://kelinkong.github.io/2024/11/07/lvvm-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/07/lvvm-%E4%BD%BF%E7%94%A8langchain-chatchat%E5%92%8Collama%E6%9E%84%E5%BB%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-07T11:14:13.000Z</published>
    <updated>2024-11-08T00:26:58.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><strong>github地址：</strong></p><p>langchina-chatchat地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></p><p>ollama地址：<a href="https://github.com/ollama/ollama">ollama</a></p><h2 id="使用langchain-chatchat和ollama构建大模型"><a href="#使用langchain-chatchat和ollama构建大模型" class="headerlink" title="使用langchain-chatchat和ollama构建大模型"></a>使用langchain-chatchat和ollama构建大模型</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><strong>langchain-chatchat</strong></p><p>langchain-chatchat在0.3版本之后支持使用pip安装，这里推荐创建一个新的虚拟环境来安装。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create -n langchain python=3.10</span><br><span class="line">conda activate langchain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">pip install langchain-chatchat -U</span><br></pre></td></tr></table></figure><p><strong>ollama</strong></p><p>ollama的安装比较简单，只需要使用pip安装即可。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ollama</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>langchain-chatchat</strong></p><p><strong>初始化</strong>，建议创建一个空的文件夹来进行初始化。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat init</span><br></pre></td></tr></table></figure><p>该命令会执行以下操作：</p><ul><li>创建所有需要的数据目录</li><li>复制 samples 知识库内容</li><li>生成默认 yaml 配置文件</li></ul><p><strong>修改配置文件</strong></p><p>具体每个配置文件的作用可以到github仓库查看，这里只列出需要修改的配置文件。</p><p>在文件<code>model_settings.yaml</code>中，修改:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">platform_name:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">platform_type:</span> <span class="string">ollama</span></span><br><span class="line">  <span class="attr">api_base_url:</span> <span class="string">http://127.0.0.1:11434/v1</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">EMPTY</span></span><br><span class="line">  <span class="attr">api_proxy:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">api_concurrencies:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">auto_detect_model:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">llm_models:</span> <span class="comment"># 本地部署的模型</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">qwen2</span></span><br><span class="line">  <span class="attr">embed_models:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">quentinz/bge-large-zh-v1.5</span> <span class="comment"># 嵌入模型</span></span><br><span class="line">  <span class="attr">text2image_models:</span> []</span><br><span class="line">  <span class="attr">image2text_models:</span> []</span><br><span class="line">  <span class="attr">rerank_models:</span> []</span><br><span class="line">  <span class="attr">speech2text_models:</span> []</span><br><span class="line">  <span class="attr">text2speech_models:</span> []</span><br></pre></td></tr></table></figure><p>前面的默认模型可以不修改，开启自动检测后，会自动检测ollama中的模型。</p><p><strong>ollama</strong></p><p>加载大语言模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run qwen2</span><br></pre></td></tr></table></figure><p>如果本地没有部署，会自动下载模型。打开浏览器查看是否正确启动：<a href="http://localhost:11434/">http://localhost:11434</a></p><p>加载嵌入模型：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama pull quentinz/bge-large-zh-v1.5:latest</span><br></pre></td></tr></table></figure><p>嵌入模型不需要运行，只需要下载即可。</p><blockquote><p>嵌入模型（例如 quentinz&#x2F;bge-large-zh-v1.5）的主要作用是将文本转换成向量表示，这种向量表示也叫做“嵌入” (embedding)。这些嵌入可以捕捉到文本的语义信息，以便在不同的 NLP 任务中进行高效的相似度计算和语义搜索。</p><p>quentinz&#x2F;bge-large-zh-v1.5 可以用于生成中文文本的嵌入。例如，当输入一句中文文本时，该模型会输出一个向量（embedding），我们可以利用这个向量来完成以下操作</p></blockquote><h3 id="生成知识库"><a href="#生成知识库" class="headerlink" title="生成知识库"></a>生成知识库</h3><p>在生成知识库之前，要先确保ollama已经正确启动，使用默认的向量数据库，需要下载驱动，在pycharm中点击info.db，根据提示下载驱动即可。</p><p>使用<code>chatchat</code>命令生成知识库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat kb -r</span><br></pre></td></tr></table></figure><p>这里可能会遇到各种bug，自行到社区issue中查找解决方案。如果没有解决方案，可以给社区提issue。</p><p>出现以下提示表示生成成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line">知识库名称      ：samples</span><br><span class="line">知识库类型      ：faiss</span><br><span class="line">向量模型：      ：bge-large-zh-v1.5</span><br><span class="line">知识库路径      ：/root/anaconda3/envs/chatchat/lib/python3.11/site-packages/chatchat/data/knowledge_base/samples</span><br><span class="line">文件总数量      ：47</span><br><span class="line">入库文件数      ：42</span><br><span class="line">知识条目数      ：740</span><br><span class="line">用时            ：0:02:29.701002</span><br><span class="line">----------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">总计用时        ：0:02:33.414425</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chatchat start -a</span><br></pre></td></tr></table></figure><p>运行成功之后，可以在网页上进行知识库配置、对话等。</p><p>其余功能有待摸索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;github地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;langchina-chatchat地址：&lt;a href=&quot;https:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>大模型有关的一些工具链</title>
    <link href="https://kelinkong.github.io/2024/11/07/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
    <id>https://kelinkong.github.io/2024/11/07/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%85%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7%E9%93%BE/</id>
    <published>2024-11-07T02:36:51.000Z</published>
    <updated>2024-11-12T07:07:28.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大模型的汇总仓库"><a href="#大模型的汇总仓库" class="headerlink" title="大模型的汇总仓库"></a>大模型的汇总仓库</h2><p><a href="https://github.com/ikaijua/Awesome-AITools/blob/main/README-CN.md">awesome AI</a></p><h2 id="使用大模型做具体场景助手"><a href="#使用大模型做具体场景助手" class="headerlink" title="使用大模型做具体场景助手"></a>使用大模型做具体场景助手</h2><p>使用开源工具来实现具体场景下的 AI 助手，流程可以简化如下：</p><ol><li><p>Prompt 工程</p><ul><li>流程：设计并优化 prompt，让大模型生成符合需求的答案，进行 prompt 测试和调整。</li><li>工具：可以使用 OpenAI API（如 GPT-3 开源替代品）结合 LangChain 或 LlamaIndex（前称 GPT Index）来管理和优化 prompt。</li></ul></li><li><p>构建知识库</p><ul><li>流程：收集和清洗数据，将信息分块后存入知识库，并生成索引以便高效检索。</li><li>工具：<ul><li>Elasticsearch 或 FAISS：用于分块后的数据存储和快速检索。</li><li>Haystack 或 LlamaIndex：可用于索引管理，便于与生成模型集成。</li></ul></li></ul></li><li><p>检索增强生成（RAG）</p><ul><li>流程：通过检索模块先找到相关信息片段，再输入生成模型生成回答，增强内容准确性。</li><li>工具：Haystack 或 LangChain，集成检索与生成，提供基于上下文的回答。</li></ul></li><li><p>大模型微调</p><ul><li>流程：将场景相关数据准备好后对大模型进行微调，使其适应具体领域或场景。</li><li>工具：<ul><li>Hugging Face Transformers：用于加载和微调模型。</li><li>Hugging Face Datasets：用于管理和预处理训练数据。</li></ul></li></ul></li><li><p>模型量化</p><ul><li>流程：在部署前对模型进行量化，以减小模型体积并加快推理速度。</li><li>工具：BitsAndBytes（4&#x2F;8 位量化）、ONNX Runtime（支持量化优化）。</li></ul></li><li><p>部署</p><ul><li>流程：将微调和量化后的模型部署在服务器或云端。</li><li>工具：<ul><li>FastAPI 或 Flask：用于搭建 API 服务。</li><li>Docker：用于容器化部署，保证环境一致性。</li><li>Hugging Face Inference（如使用推理服务器）或 ONNX Runtime（加速推理）。</li></ul></li></ul></li></ol><p>简化流程示例</p><p>设计 prompt → 构建知识库 → RAG 检索 → 大模型微调 → 模型量化 → 部署</p><p>这些步骤结合开源工具能够实现高效的 AI 助手。</p><h2 id="ollama"><a href="#ollama" class="headerlink" title="ollama"></a>ollama</h2><h3 id="ollama简介"><a href="#ollama简介" class="headerlink" title="ollama简介"></a>ollama简介</h3><p>ollama用来部署和运行大型语言模型，它提供了一个简单的命令行工具，可以用来运行模型、查看模型列表、下载模型等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设计 prompt → 构建知识库 → RAG 检索 → Ollama 微调 → Ollama 量化 → Ollama 部署</span><br></pre></td></tr></table></figure><p>官网地址：<a href="https://ollama.com/">ollama</a></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>运行一个模型，如果本地不存在该模型，会自动到仓库下载，仓库地址：<br><a href="https://ollama.com/library">ollama模型仓库</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ollama run llama3-8b-8192</span><br></pre></td></tr></table></figure><p>一些指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看模型列表</span></span><br><span class="line">ollama list</span><br><span class="line"><span class="comment"># 查看当前运行的模型</span></span><br><span class="line">ollama ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># -h 查看帮助</span></span><br><span class="line">serve       Start ollama</span><br><span class="line">create      Create a model from a Modelfile</span><br><span class="line">show        Show information <span class="keyword">for</span> a model</span><br><span class="line">run         Run a model</span><br><span class="line">stop        Stop a running model</span><br><span class="line">pull        Pull a model from a registry</span><br><span class="line">push        Push a model to a registry</span><br><span class="line">list        List models</span><br><span class="line">ps          List running models</span><br><span class="line"><span class="built_in">cp</span>          Copy a model</span><br><span class="line"><span class="built_in">rm</span>          Remove a model</span><br><span class="line"><span class="built_in">help</span>        Help about any <span class="built_in">command</span></span><br></pre></td></tr></table></figure><p>查看ollama是否正确启动：<a href="http://127.0.0.1:11434/">http://127.0.0.1:11434</a></p><h2 id="open-webui"><a href="#open-webui" class="headerlink" title="open-webui"></a>open-webui</h2><p>open-webui提供了一个简单的web界面，可以用来查看模型列表、运行模型等。</p><p>仓库地址：<a href="https://github.com/open-webui/open-webui">open-webui</a></p><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install open-webui</span><br><span class="line">open-webui serve</span><br></pre></td></tr></table></figure><h2 id="modelscope"><a href="#modelscope" class="headerlink" title="modelscope"></a>modelscope</h2><p>官网地址：<a href="https://modelscope.ai/">modelscope</a></p><p>github地址：<a href="https://github.com/modelscope/modelscope/tree/master">modelscope</a></p><h3 id="modelscope简介"><a href="#modelscope简介" class="headerlink" title="modelscope简介"></a>modelscope简介</h3><p>modelscope是一个 “模型即服务”(MaaS) 平台，旨在汇集来自 AI 社区的最先进的机器学习模型，并简化在实际应用中使用 AI 模型的流程。ModelScope 库使开发人员能够通过丰富的 API 设计执行推理、训练和评估，从而促进跨不同 AI 领域的最先进模型的统一体验。</p><p>ModelScope Library 为模型贡献者提供了必要的分层 API，以便将来自 CV、NLP、语音、多模态以及科学计算的模型集成到 ModelScope 生态系统中。所有这些不同模型的实现都以一种简单统一访问的方式进行封装，用户只需几行代码即可完成模型推理、微调和评估。同时，灵活的模块化设计使得在必要时也可以自定义模型训练推理过程中的不同组件。</p><h3 id="安装和使用-1"><a href="#安装和使用-1" class="headerlink" title="安装和使用"></a>安装和使用</h3><p>在ModelScope Hub 中有很多可以训练的模型。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n modelscope python=3.10</span><br><span class="line">conda activate modelscope</span><br></pre></td></tr></table></figure><p>模型下载需要先配置好Git LFS。</p><blockquote><p>git lfs 是一个 Git 的扩展，它用来存储大文件。它的设计目标是让 Git 能够更好地管理大文件，而不是让 Git 成为一个文件存储系统。Git LFS 通过将大文件存储在远程服务器上，而不是存储在 Git 仓库中，来解决 Git 仓库过大的问题。</p></blockquote><p>之后就可以下载用来训练的模型，和github上的代码一样，可以直接使用git clone。</p><p>训练好的模型（微调）在部署时，通常还需要量化，这样才能在较小的设备上运行。</p><h2 id="langchain和langchain-chatchat"><a href="#langchain和langchain-chatchat" class="headerlink" title="langchain和langchain-chatchat"></a>langchain和langchain-chatchat</h2><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>这里有一个简单的教程:<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">langchain</a>，可以用来构建一个简单的LLM（Large Language Model）应用。</p><p>核心就是构建链，链可以包含各种处理步骤，例如模型、解析器和提示。</p><h3 id="langchain-chatchat"><a href="#langchain-chatchat" class="headerlink" title="langchain-chatchat"></a>langchain-chatchat</h3><p>仓库地址：<a href="https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-files">langchain-chatchat</a></p><p>一种利用 langchain 思想实现的基于本地知识库的问答应用，目标期望建立一套对中文场景与开源模型支持友好、可离线运行的知识库问答解决方案。</p><p><strong>原理：</strong><br><img src="/../imgs/image-65.png"><br><img src="/../imgs/image-66.png"></p><p>在这个项目中，并不涉及模型的微调。模型微调参考：<a href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/">llvm-微调大模型</a></p><h2 id="Dify"><a href="#Dify" class="headerlink" title="Dify"></a>Dify</h2><p>官网地址：<a href="https://www.dify.ai/">Dify</a></p><p>github地址：<a href="https://github.com/langgenius/dify">Dify</a></p><p>官方文档：<a href="https://docs.dify.ai/">Dify文档</a></p><p>Dify 是一款开源的大语言模型(LLM) 应用开发平台。它融合了后端即服务（Backend as Service）和 LLMOps 的理念，使开发者可以快速搭建生产级的生成式 AI 应用。即使你是非技术人员，也能参与到 AI 应用的定义和数据运营过程中。</p><p>由于 Dify 内置了构建 LLM 应用所需的关键技术栈，包括对数百个模型的支持、直观的 Prompt 编排界面、高质量的 RAG 引擎、稳健的 Agent 框架、灵活的流程编排，并同时提供了一套易用的界面和 API。这为开发者节省了许多重复造轮子的时间，使其可以专注在创新和业务需求上。</p><p>dify支持ollama，可以直接使用本地部署的模型。</p><h2 id="Groqcloud"><a href="#Groqcloud" class="headerlink" title="Groqcloud"></a>Groqcloud</h2><p>官网地址：<a href="https://console.groq.com/playground">Groqcloud</a></p><p>GroqCloud 是由 Groq 公司提供的云服务，专注于快速 AI 推理。它利用 Groq 的语言处理单元（LPU）硬件和相关软件，推理速度很快，而且API便宜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大模型的汇总仓库&quot;&gt;&lt;a href=&quot;#大模型的汇总仓库&quot; class=&quot;headerlink&quot; title=&quot;大模型的汇总仓库&quot;&gt;&lt;/a&gt;大模型的汇总仓库&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ikaijua/Awesome-AI</summary>
      
    
    
    
    <category term="llvm" scheme="https://kelinkong.github.io/categories/llvm/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 LCEL 构建一个简单的 LLM 应用</title>
    <link href="https://kelinkong.github.io/2024/11/06/llvm-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/"/>
    <id>https://kelinkong.github.io/2024/11/06/llvm-%E4%BD%BF%E7%94%A8LCEL-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-LLM-%E5%BA%94%E7%94%A8/</id>
    <published>2024-11-06T01:43:04.000Z</published>
    <updated>2024-11-07T08:36:32.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单教程"><a href="#简单教程" class="headerlink" title="简单教程"></a>简单教程</h2><p>教程来源于：<a href="https://www.langchain.com.cn/docs/tutorials/llm_chain/">LangChain</a></p><h2 id="使用-LCEL-构建一个简单的-LLM-应用"><a href="#使用-LCEL-构建一个简单的-LLM-应用" class="headerlink" title="使用 LCEL 构建一个简单的 LLM 应用"></a>使用 LCEL 构建一个简单的 LLM 应用</h2><p>langchain的简单使用。</p><h3 id="什么是LangChain？"><a href="#什么是LangChain？" class="headerlink" title="什么是LangChain？"></a>什么是LangChain？</h3><p>langchain是一个用于构建自然语言处理（NLP）应用的工具包。它提供了一种简单的方法来构建NLP应用，无需编写复杂的代码。langchain的核心是一个称为“链”的概念，链是一系列处理步骤，每个步骤都接收输入并生成输出。链可以包含各种处理步骤，例如模型、解析器和提示。</p><p>在本教程中，会创建一个简单的LLM（Large Language Model）应用。</p><p>主要分为：prompt、model、parser</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langserve <span class="keyword">import</span> add_routes</span><br><span class="line"><span class="keyword">from</span> langchain_groq <span class="keyword">import</span> ChatGroq</span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_TRACING_V2&quot;</span>] = <span class="string">&quot;true&quot;</span></span><br><span class="line">os.environ[<span class="string">&quot;LANGCHAIN_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line">os.environ[<span class="string">&quot;GROQ_API_KEY&quot;</span>] = getpass.getpass()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create prompt template</span></span><br><span class="line">system_template = <span class="string">&quot;Translate the following into &#123;language&#125;:&quot;</span></span><br><span class="line">prompt_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    <span class="string">&quot;system&quot;</span>, system_template,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>, <span class="string">&quot;&#123;text&#125;&quot;</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create model</span></span><br><span class="line">model = ChatGroq(model=<span class="string">&quot;llama3-8b-8192&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create output parser</span></span><br><span class="line">parser = StrOutputParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create chain</span></span><br><span class="line">chain = prompt_template | model | parser</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create FastAPI app</span></span><br><span class="line">app = FastAPI(</span><br><span class="line">    title=<span class="string">&quot;LangChain OpenAI API&quot;</span>,</span><br><span class="line">    description=<span class="string">&quot;A FastAPI app that uses LangChain and OpenAI to translate text.&quot;</span>,</span><br><span class="line">    version=<span class="string">&quot;0.1.0&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add routes</span></span><br><span class="line">add_routes(</span><br><span class="line">    app,</span><br><span class="line">    chain,</span><br><span class="line">    path=<span class="string">&quot;/chain&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">read_root</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Welcome to the LangChain OpenAI API&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run FastAPI app</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> uvicorn</span><br><span class="line">    uvicorn.run(app, host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简单教程&quot;&gt;&lt;a href=&quot;#简单教程&quot; class=&quot;headerlink&quot; title=&quot;简单教程&quot;&gt;&lt;/a&gt;简单教程&lt;/h2&gt;&lt;p&gt;教程来源于：&lt;a href=&quot;https://www.langchain.com.cn/docs/tutorials/llm</summary>
      
    
    
    
    <category term="llvm" scheme="https://kelinkong.github.io/categories/llvm/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-微调大模型</title>
    <link href="https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>https://kelinkong.github.io/2024/11/01/llvm-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-11-01T06:35:34.000Z</published>
    <updated>2024-11-07T10:43:56.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微调大模型"><a href="#微调大模型" class="headerlink" title="微调大模型"></a>微调大模型</h2><p>源代码来自:<a href="https://www.cnblogs.com/obullxl/p/18312594/NTopic2024071801">老牛同学</a></p><p>使用开源大模型 Qwen2-0.5B 的示例，实现了一个基于微调和 RAG（Retrieval-Augmented Generation）的文本分类助手。以下是各部分的详细解释：</p><h3 id="1-引入必要库"><a href="#1-引入必要库" class="headerlink" title="1. 引入必要库"></a>1. 引入必要库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> swanlab.integration.huggingface <span class="keyword">import</span> SwanLabCallback</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> LoraConfig, TaskType, get_peft_model</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, TrainingArguments, Trainer, DataCollatorForSeq2Seq</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> swanlab</span><br></pre></td></tr></table></figure><p>这部分代码引入了主要用于微调、训练和生成文本的库，包括 <code>transformers</code>、<code>peft</code>（主要用于 LoRA 微调）、<code>datasets</code>（用于处理数据集），以及 <code>swanlab</code> 用于回调和日志记录。</p><h3 id="2-设置路径和设备"><a href="#2-设置路径和设备" class="headerlink" title="2. 设置路径和设备"></a>2. 设置路径和设备</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BASE_DIR = <span class="string">&#x27;D:\\ModelSpace\\Qwen2&#x27;</span></span><br><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br></pre></td></tr></table></figure><p>设置模型的根目录和设备名称。设备名称判断系统是否支持 CUDA（GPU 加速），如果不支持则使用 CPU。</p><p>在mac中使用mps加速</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;mps&quot;</span> <span class="keyword">if</span> torch.backends.mps.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-数据集格式转换函数"><a href="#3-数据集格式转换函数" class="headerlink" title="3. 数据集格式转换函数"></a>3. 数据集格式转换函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dataset_jsonl_transfer</span>(<span class="params">origin_path, new_path</span>):</span><br><span class="line">    messages = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(origin_path, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">            data = json.loads(line)</span><br><span class="line">            text = data[<span class="string">&quot;text&quot;</span>]</span><br><span class="line">            catagory = data[<span class="string">&quot;category&quot;</span>]</span><br><span class="line">            output = data[<span class="string">&quot;output&quot;</span>]</span><br><span class="line">            message = &#123;</span><br><span class="line">                <span class="string">&quot;input&quot;</span>: <span class="string">f&quot;文本:<span class="subst">&#123;text&#125;</span>,分类选项列表:<span class="subst">&#123;catagory&#125;</span>&quot;</span>,</span><br><span class="line">                <span class="string">&quot;output&quot;</span>: output,</span><br><span class="line">            &#125;</span><br><span class="line">            messages.append(message)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(new_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> message <span class="keyword">in</span> messages:</span><br><span class="line">            file.write(json.dumps(message, ensure_ascii=<span class="literal">False</span>) + <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>dataset_jsonl_transfer</code> 函数用于将原始 JSON 数据转换成微调所需的数据格式。原始文件的每行包含一个 JSON 对象，函数将其读取、重构并保存成新的 JSONL 格式文件，每行包含一个示例数据。</p><h3 id="4-数据预处理函数"><a href="#4-数据预处理函数" class="headerlink" title="4. 数据预处理函数"></a>4. 数据预处理函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_func</span>(<span class="params">example</span>):</span><br><span class="line">    MAX_LENGTH = <span class="number">384</span></span><br><span class="line">    instruction = tokenizer(<span class="string">f&quot;&lt;|im_start|&gt;system\n你是一个文本分类领域的专家...<span class="subst">&#123;example[<span class="string">&#x27;input&#x27;</span>]&#125;</span>&lt;|im_end|&gt;\n&lt;|im_start|&gt;assistant\n&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    response = tokenizer(<span class="string">f&quot;<span class="subst">&#123;example[<span class="string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span>, add_special_tokens=<span class="literal">False</span>)</span><br><span class="line">    input_ids = instruction[<span class="string">&quot;input_ids&quot;</span>] + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    attention_mask = instruction[<span class="string">&quot;attention_mask&quot;</span>] + response[<span class="string">&quot;attention_mask&quot;</span>] + [<span class="number">1</span>]</span><br><span class="line">    labels = [-<span class="number">100</span>] * <span class="built_in">len</span>(instruction[<span class="string">&quot;input_ids&quot;</span>]) + response[<span class="string">&quot;input_ids&quot;</span>] + [tokenizer.pad_token_id]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(input_ids) &gt; MAX_LENGTH:</span><br><span class="line">        input_ids, attention_mask, labels = input_ids[:MAX_LENGTH], attention_mask[:MAX_LENGTH], labels[:MAX_LENGTH]</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;input_ids&quot;</span>: input_ids, <span class="string">&quot;attention_mask&quot;</span>: attention_mask, <span class="string">&quot;labels&quot;</span>: labels&#125;</span><br></pre></td></tr></table></figure><p><code>process_func</code> 函数将数据处理成大模型可以接受的格式，包含 <code>input_ids</code>、<code>attention_mask</code> 和 <code>labels</code>。这里模拟了一个对话输入，用户提问，助手返回分类输出。如果序列长度超出最大限制 <code>MAX_LENGTH</code>，进行截断。</p><h3 id="5-加载模型和分词器"><a href="#5-加载模型和分词器" class="headerlink" title="5. 加载模型和分词器"></a>5. 加载模型和分词器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_dir = os.path.join(BASE_DIR, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>)</span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_dir, use_fast=<span class="literal">False</span>, trust_remote_code=<span class="literal">True</span>)</span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_dir, device_map=device, torch_dtype=torch.bfloat16)</span><br><span class="line">model.enable_input_require_grads()</span><br></pre></td></tr></table></figure><p>加载模型和分词器，将 <code>bfloat16</code> 用于精度，以减少 GPU 占用量。<code>model.enable_input_require_grads()</code> 开启梯度检查点支持，以节省内存。</p><h3 id="6-加载和处理数据集"><a href="#6-加载和处理数据集" class="headerlink" title="6. 加载和处理数据集"></a>6. 加载和处理数据集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;train.jsonl&#x27;</span>)</span><br><span class="line">test_jsonl_new_path = os.path.join(BASE_DIR, <span class="string">&#x27;test.jsonl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(train_dataset_path, train_jsonl_new_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(test_jsonl_new_path):</span><br><span class="line">    dataset_jsonl_transfer(test_dataset_path, test_jsonl_new_path)</span><br><span class="line"></span><br><span class="line">train_df = pd.read_json(train_jsonl_new_path, lines=<span class="literal">True</span>)</span><br><span class="line">train_ds = Dataset.from_pandas(train_df)</span><br><span class="line">train_dataset = train_ds.<span class="built_in">map</span>(process_func, remove_columns=train_ds.column_names)</span><br></pre></td></tr></table></figure><p>检查并转换数据集，将其加载为 <code>Dataset</code> 格式，并通过 <code>process_func</code> 处理成可用于训练的数据格式。</p><h3 id="7-LoRA-配置与应用"><a href="#7-LoRA-配置与应用" class="headerlink" title="7. LoRA 配置与应用"></a>7. LoRA 配置与应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">config = LoraConfig(</span><br><span class="line">    task_type=TaskType.CAUSAL_LM,</span><br><span class="line">    target_modules=[<span class="string">&quot;q_proj&quot;</span>, <span class="string">&quot;k_proj&quot;</span>, ...],</span><br><span class="line">    inference_mode=<span class="literal">False</span>,</span><br><span class="line">    r=<span class="number">8</span>,</span><br><span class="line">    lora_alpha=<span class="number">32</span>,</span><br><span class="line">    lora_dropout=<span class="number">0.1</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">model = get_peft_model(model, config)</span><br></pre></td></tr></table></figure><p>设置并应用 LoRA（Low-Rank Adaptation）配置，用于高效微调。<code>LoRA</code> 能通过添加低秩矩阵在不改变原模型参数的情况下更新模型，适合大模型的微调。</p><h3 id="8-训练参数与-Trainer-初始化"><a href="#8-训练参数与-Trainer-初始化" class="headerlink" title="8. 训练参数与 Trainer 初始化"></a>8. 训练参数与 Trainer 初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = TrainingArguments(</span><br><span class="line">    output_dir=os.path.join(BASE_DIR, <span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;Qwen2-0.5B&#x27;</span>),</span><br><span class="line">    per_device_train_batch_size=<span class="number">4</span>,</span><br><span class="line">    gradient_accumulation_steps=<span class="number">4</span>,</span><br><span class="line">    logging_steps=<span class="number">10</span>,</span><br><span class="line">    num_train_epochs=<span class="number">2</span>,</span><br><span class="line">    save_steps=<span class="number">100</span>,</span><br><span class="line">    learning_rate=<span class="number">1e-4</span>,</span><br><span class="line">    save_on_each_node=<span class="literal">True</span>,</span><br><span class="line">    gradient_checkpointing=<span class="literal">True</span>,</span><br><span class="line">    report_to=<span class="string">&quot;none&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">swanlab_callback = SwanLabCallback(project=<span class="string">&quot;Qwen2-FineTuning&quot;</span>, experiment_name=<span class="string">&quot;Qwen2-0.5B&quot;</span>)</span><br><span class="line"></span><br><span class="line">trainer = Trainer(</span><br><span class="line">    model=model,</span><br><span class="line">    args=args,</span><br><span class="line">    train_dataset=train_dataset,</span><br><span class="line">    data_collator=DataCollatorForSeq2Seq(tokenizer=tokenizer, padding=<span class="literal">True</span>),</span><br><span class="line">    callbacks=[swanlab_callback],</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>配置训练参数并创建 <code>Trainer</code> 实例，指定保存路径、batch 大小、梯度累积步数、日志记录频率、学习率等。<code>SwanLabCallback</code> 用于将训练过程发送至 <code>SwanLab</code> 进行实时监控。</p><h3 id="9-训练模型"><a href="#9-训练模型" class="headerlink" title="9. 训练模型"></a>9. 训练模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trainer.train()</span><br></pre></td></tr></table></figure><p>调用 <code>.train()</code> 开始训练。</p><h3 id="10-模型推理与评估"><a href="#10-模型推理与评估" class="headerlink" title="10. 模型推理与评估"></a>10. 模型推理与评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">messages, model, tokenizer</span>):</span><br><span class="line">    text = tokenizer.apply_chat_template(messages, tokenize=<span class="literal">False</span>, add_generation_prompt=<span class="literal">True</span>)</span><br><span class="line">    model_inputs = tokenizer([text], return_tensors=<span class="string">&quot;pt&quot;</span>).to(device)</span><br><span class="line">    generated_ids = model.generate(model_inputs.input_ids, max_new_tokens=<span class="number">512</span>)</span><br><span class="line">    generated_ids = [output_ids[<span class="built_in">len</span>(input_ids):] <span class="keyword">for</span> input_ids, output_ids <span class="keyword">in</span> <span class="built_in">zip</span>(model_inputs.input_ids, generated_ids)]</span><br><span class="line">    <span class="keyword">return</span> tokenizer.batch_decode(generated_ids, skip_special_tokens=<span class="literal">True</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><code>predict</code> 函数实现了模型推理功能，将输入转成模型格式后生成输出文本。</p><h3 id="11-测试集上的推理"><a href="#11-测试集上的推理" class="headerlink" title="11. 测试集上的推理"></a>11. 测试集上的推理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_json(test_jsonl_new_path, lines=<span class="literal">True</span>)[:<span class="number">10</span>]</span><br><span class="line">test_text_list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> test_df.iterrows():</span><br><span class="line">    instruction = row[<span class="string">&#x27;你是一个文本分类领域的专家，你会接收到一段文本和几个潜在的分类选项列表，请输出文本内容的正确分类&#x27;</span>]</span><br><span class="line">    input_value = row[<span class="string">&#x27;input&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;instruction&#125;</span>&quot;</span>&#125;, &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;input_value&#125;</span>&quot;</span>&#125;]</span><br><span class="line">    response = predict(messages, model, tokenizer)</span><br><span class="line">    messages.append(&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;response&#125;</span>&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    result_text = <span class="string">f&quot;<span class="subst">&#123;messages[<span class="number">0</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">1</span>]&#125;</span>\n\n<span class="subst">&#123;messages[<span class="number">2</span>]&#125;</span>&quot;</span></span><br><span class="line">    test_text_list.append(swanlab.Text(result_text, caption=response))</span><br><span class="line"></span><br><span class="line">swanlab.log(&#123;<span class="string">&quot;Prediction&quot;</span>: test_text_list&#125;)</span><br><span class="line">swanlab.finish()</span><br></pre></td></tr></table></figure><p>在测试集上对模型进行评估，将预测结果和输入对比，并将输出文本记录到 <code>SwanLab</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;微调大模型&quot;&gt;&lt;a href=&quot;#微调大模型&quot; class=&quot;headerlink&quot; title=&quot;微调大模型&quot;&gt;&lt;/a&gt;微调大模型&lt;/h2&gt;&lt;p&gt;源代码来自:&lt;a href=&quot;https://www.cnblogs.com/obullxl/p/18312594/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>机器学习基础</title>
    <link href="https://kelinkong.github.io/2024/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>https://kelinkong.github.io/2024/10/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</id>
    <published>2024-10-29T10:55:08.000Z</published>
    <updated>2024-11-01T01:55:49.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><p><strong>什么是一个线性回归问题？</strong></p><p>如果把线性回归模型看作一个函数，用最简单的话说，这个函数的作用就是预测。</p><p>线性回归模型的预测过程是这样的：给定一个输入特征向量，通过线性组合得到一个预测值。</p><p>举个例子：</p><p>假设有数据集：这里我们想知道工资、年龄和贷款额度之间的关系。</p><table><thead><tr><th>工资</th><th>年龄</th><th>贷款额度</th></tr></thead><tbody><tr><td>1000</td><td>25</td><td>1000</td></tr><tr><td>2000</td><td>30</td><td>2000</td></tr><tr><td>3000</td><td>35</td><td>3000</td></tr></tbody></table><p>我们可以用线性回归模型来预测工资，假设我们的模型是这样的：<br>$y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2$</p><p>其中，$y$ 是贷款额度，$x_1$ 是工资，$x_2$ 是年龄。</p><p>我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。</p><p>这个函数就是一个线性函数，也就是线性回归模型。</p><p>$$<br>y &#x3D; w_0 + w_1 \cdot x_1 + w_2 \cdot x_2<br>  &#x3D; \sum_{i&#x3D;0}^{n} w_i \cdot x_i<br>$$</p><p>这里$w_0$是偏置项，用来调整模型的预测值。$x_0$是一个常数项，通常为1。</p><h3 id="误差值"><a href="#误差值" class="headerlink" title="误差值"></a>误差值</h3><p>误差值是指预测值与真实值之间的差距。</p><p><img src="/../imgs/image-62.png"></p><ul><li>误差与误差之间是独立的，不会相互影响。</li><li>误差的分布是正态分布，均值为0。</li></ul><p>预测与误差：</p><p>$$<br>y^i &#x3D; W^T \cdot x^i + \epsilon^i<br>$$</p><p>其中，$y^i$ 是预测值，$W^T$ 是权重向量，$x^i$ 是输入特征向量，$\epsilon^i$ 是误差。</p><p>误差服从正态分布：</p><p>$$<br>p(\epsilon^i) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(\epsilon^i)^2}{2\sigma^2})<br>$$</p><p>将误差代入预测值：</p><p>$$<br>p(y^i|x^i;W) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>$x^i;W$组合之后的概率密度函数，就是我们的模型。我们希望$x^i;W$组合之后与$y^i$越接近越好。所以希望最大化这个概率密度函数。</p><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>似然函数为什么要使用连乘？因为前面说过，误差是独立的，所以我们可以将每个样本的概率密度函数连乘起来。</p><p>$$<br>L(W) &#x3D; \prod_{i&#x3D;1}^{m} p(y^i|x^i;W)&#x3D; \prod_{i&#x3D;1}^{m} \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>对似然函数取对数，可以将连乘转换为连加：</p><p>$$<br>\log L(W) &#x3D; \sum_{i&#x3D;1}^{m} \log p(y^i|x^i;W)&#x3D; \sum_{i&#x3D;1}^{m} \log \frac{1}{\sqrt{2\pi\sigma^2}} \exp(-\frac{(y^i - W^T \cdot x^i)^2}{2\sigma^2})<br>$$</p><p>展开化简：</p><p>$$<br>\log L(W) &#x3D; \frac{m}{2} \log(2\pi\sigma^2) - \frac{1}{2\sigma^2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><p>我们最终的目标是最大化似然函数，也就是最小化误差。前一项是常数，所以希望后一项越小越好。即：</p><p>$$<br>\min_W \frac{1}{2} \sum_{i&#x3D;1}^{m} (y^i - W^T \cdot x^i)^2<br>$$</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p><strong>什么是损失函数？</strong></p><p>损失函数也叫目标函数，是用来衡量模型预测值与真实值之间的差距的函数。</p><p>上面那个例子，我们的目标是找到一个合适的 $w_1$ 和 $w_2$，使得我们的模型能够很好地预测工资。损失函数可以定义为：</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (y_i - \hat{y_i})^2<br>$$</p><p>使用目标值和预测值之间的平方误差作为损失函数，这个损失函数叫做均方误差（Mean Squared Error，MSE）。</p><p>其中，$m$ 是样本数量，$y_i$ 是真实值，$\hat{y_i}$ 是预测值。</p><p>对于机器学习的大部分任务，我们都是通过最小化损失函数来优化模型的参数。</p><p>如何求解损失函数？</p><p>$$<br>L(w) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (W^T \cdot x^i - \hat{y_i})^2 &#x3D; \frac{1}{2m} (X \cdot W - Y)^T \cdot (X \cdot W - Y)<br>$$</p><p>其中，$X$ 是输入特征矩阵，$Y$ 是真实值矩阵。</p><p>我们的目标是找到一个合适的 $W$，使得损失函数最小化。</p><p>因此，对损失函数求导，然后令导数为0，可以得到最优解。</p><p>$$<br>\frac{\partial L(W)}{\partial W} &#x3D; \frac{1}{m} X^T \cdot (X \cdot W - Y) &#x3D; 0<br>$$</p><p>解方程，得到最优解：<br>$$<br>W &#x3D; (X^T \cdot X)^{-1} \cdot X^T \cdot Y<br>$$</p><p>但是，这个方法有一个问题，就是计算量太大。当数据量很大时，计算矩阵的逆是非常耗时的。而且，矩阵的逆不一定存在。</p><p>因此，我们通常使用梯度下降法来求解损失函数的最小值。</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p><strong>什么是梯度下降法？</strong></p><p>梯度下降法是一种常用的优化算法，用来求解损失函数的最小值。</p><p>梯度下降法的思想是：沿着梯度的反方向，不断迭代更新参数，直到损失函数的值收敛。</p><p><strong>目标函数</strong></p><p>$$<br>J(\theta_0, \theta_1) &#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i)^2<br>$$</p><p>其中，$h_\theta(x^i) &#x3D; \theta_0 + \theta_1 \cdot x^i$ 是模型的预测值。</p><p><strong>如何寻找合适的方向？</strong></p><p>梯度下降法的核心是求解目标函数的梯度。</p><p>分别对 $\theta_0$ 和 $\theta_1$ 求偏导数：</p><p>$$<br>\frac{\partial J(\theta_0, \theta_1)}{\partial \theta_1} &#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_1<br>$$</p><p>使得梯度为0，得到最优解。因为切线方向是函数值下降最快的方向，此时梯度为0。梯度其实就是函数的导数。</p><p>注意，这里等式中的两个$\theta_j$表示两个不同的$\theta_j$，一个是当前的$\theta_j$，一个是更新后的$\theta_j$。</p><p>$$<br>\theta_j &#x3D;  \theta_j - \alpha  \frac{\partial J(\theta_j)}{\partial \theta_j}&#x3D;<br> \theta_j - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (y^i - h_\theta(x^i))x^i_j<br>$$</p><p>其中，$\alpha$ 是学习率，用来控制参数更新的步长，$x^i_j$表示第$i$个样本的第$j$个特征。</p><p>如果将所有的参数更新写成矩阵形式，可以得到：</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} X^T \cdot (X \cdot \theta - Y)<br>$$</p><p>这就是梯度下降法中的批量梯度下降（Batch Gradient Descent）。但是，批量梯度下降的计算量很大，因为每次迭代都要计算所有样本的梯度。</p><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>随机梯度下降（Stochastic Gradient Descent，SGD）是梯度下降法的一种变种，它每次迭代只使用一个样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$x^i$ 是第$i$个样本的特征向量，$y^i$ 是第$i$个样本的真实值。</p><p>随机梯度下降的优点是计算速度快，但缺点是收敛速度慢，因为每次迭代的方向不一定是最优的。</p><h3 id="小批量梯度下降"><a href="#小批量梯度下降" class="headerlink" title="小批量梯度下降"></a>小批量梯度下降</h3><p>小批量梯度下降（Mini-batch Gradient Descent）是批量梯度下降和随机梯度下降的折中方案，每次迭代使用一小部分样本来更新参数。</p><p>$$<br>\theta &#x3D; \theta - \alpha \frac{1}{m} \sum_{i&#x3D;1}^{m} (h_\theta(x^i) - y^i) x^i<br>$$</p><p>其中，$m$ 是小批量的大小。batch size的选择对模型的训练速度有很大影响。当batch size较小时，模型的训练速度较慢；当batch size较大时，模型的训练速度较快。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>给一个代码实现：</p><p>对应上面的公式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, learning_rate=<span class="number">0.01</span>, num_iterations=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用梯度下降法训练线性回归模型</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cost_history = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">        self.theta = self.predict_step(learning_rate)</span><br><span class="line">        cost_history.append(self.compute_cost())</span><br><span class="line">        logger.info(<span class="string">&quot;第&#123;&#125;次迭代，损失值为&#123;&#125;&quot;</span>.<span class="built_in">format</span>(_, cost_history[-<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回训练后的参数和损失值</span></span><br><span class="line">    <span class="keyword">return</span> self.theta, cost_history</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">predict_step</span>(<span class="params">self, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    每一步迭代计算梯度并更新参数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 计算预测值</span></span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    <span class="comment"># 计算误差</span></span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    <span class="comment"># 计算梯度并更新参数</span></span><br><span class="line">    theta = self.theta - learning_rate * (<span class="number">1</span> / num_examples) * np.dot(self.data.T, error)</span><br><span class="line">    <span class="keyword">return</span> theta</span><br><span class="line"></span><br><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hypothesis</span>(<span class="params">data, theta</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算预测值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(data, theta)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_cost</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算损失, 这里使用均方误差</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    num_examples = self.data.shape[<span class="number">0</span>]</span><br><span class="line">    prediction = self.hypothesis(self.data, self.theta)</span><br><span class="line">    error = prediction - self.labels</span><br><span class="line">    cost = (<span class="number">1</span> / (<span class="number">2</span> * num_examples)) * np.dot(error.T, error)</span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线性回归&quot;&gt;&lt;a href=&quot;#线性回归&quot; class=&quot;headerlink&quot; title=&quot;线性回归&quot;&gt;&lt;/a&gt;线性回归&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是一个线性回归问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把线性回归模型看作一个函数，用最简单的话说，这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：Spring MVC</title>
    <link href="https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/"/>
    <id>https://kelinkong.github.io/2024/10/23/Spring-Boot%EF%BC%9ASpring-MVC/</id>
    <published>2024-10-23T00:41:51.000Z</published>
    <updated>2024-10-23T03:40:23.783Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot第九章，Spring MVC。</p><h2 id="Spring-MVC-示意图"><a href="#Spring-MVC-示意图" class="headerlink" title="Spring MVC 示意图"></a>Spring MVC 示意图</h2><p><img src="/../imgs/image-60.png"></p><p><img src="/../imgs/image-61.png"></p><p>如果 Web 工程使用了 Spring MVC ， 那么它在启动阶段就会将注解<br><code>@RequestMapping</code> 所配置的内容保存到处理器映射（ <code>HandlerMapping</code> ）机制中去，然后等待请求的到来 ，通过拦截请求信息与<code>HandlerMapping</code>进行匹配，找到对应的处理器（它包含控制器的逻辑），并将处理器及其拦截器保存到 <code>HandlerExecution Chain</code> 对象中，返回给 <code>DispatcherServlet</code> ，这样<code>DispatcherServlet</code> 就可以运行它们了。</p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code> 是 Spring MVC 的核心组件，负责将客户端的请求分发给相应的处理器（Controller），并协调请求处理过程。它的主要职责是接收 HTTP 请求，委托给合适的处理组件，并将结果返回给客户端。<code>DispatcherServlet</code> 是前后端分离架构和传统 MVC 架构中的重要部分。</p><h3 id="DispatcherServlet-的工作原理"><a href="#DispatcherServlet-的工作原理" class="headerlink" title="DispatcherServlet 的工作原理"></a><code>DispatcherServlet</code> 的工作原理</h3><ol><li><p><strong>客户端请求到达 DispatcherServlet</strong>：</p><ul><li>当用户通过浏览器发送 HTTP 请求时，请求首先到达 <code>DispatcherServlet</code>。<code>DispatcherServlet</code> 是一个前端控制器（Front Controller），负责接收所有的请求。</li></ul></li><li><p><strong>HandlerMapping 映射请求</strong>：</p><ul><li><code>DispatcherServlet</code> 接收到请求后，开始通过 <strong>HandlerMapping</strong> 查找对应的处理器（Controller）。它根据请求的 URL 路径去匹配合适的处理器，这一步决定了应该调用哪个控制器来处理这个请求。</li></ul></li><li><p><strong>调用 HandlerAdapter</strong>：</p><ul><li>找到处理器后，<code>DispatcherServlet</code> 会通过 <strong>HandlerAdapter</strong> 调用实际的控制器方法。<code>HandlerAdapter</code> 的职责是适配处理器方法，使得它们能够被调用。不同类型的控制器方法（如注解方式的、简单映射方式的）可能需要不同的适配器。</li></ul></li><li><p><strong>Controller 处理请求</strong>：</p><ul><li>处理器（Controller）接收请求并处理业务逻辑，可能需要调用服务层、数据库等操作，最终返回一个 <code>ModelAndView</code> 对象或直接返回数据（如 JSON）。</li></ul></li><li><p>**视图解析器 (ViewResolver)**：</p><ul><li>如果处理器返回的是一个视图名，<code>DispatcherServlet</code> 会通过 <strong>ViewResolver</strong> 解析视图的名称，将其转换为具体的视图对象（如 JSP、Thymeleaf 等）。视图解析器负责确定返回页面的位置。</li></ul></li><li><p><strong>返回响应给客户端</strong>：</p><ul><li>最终，<code>DispatcherServlet</code> 将处理的结果（视图页面或数据）响应给客户端。如果返回的是视图，<code>DispatcherServlet</code> 将把数据填充到视图中，并将生成的 HTML 返回给客户端；如果是 JSON 数据，则直接响应 JSON。</li></ul></li></ol><h3 id="DispatcherServlet-的处理流程图"><a href="#DispatcherServlet-的处理流程图" class="headerlink" title="DispatcherServlet 的处理流程图"></a><code>DispatcherServlet</code> 的处理流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client Request --&gt; DispatcherServlet --&gt; HandlerMapping --&gt; Handler (Controller)</span><br><span class="line">                  --&gt; HandlerAdapter --&gt; ModelAndView --&gt; ViewResolver --&gt; Response (HTML/JSON)</span><br></pre></td></tr></table></figure><h3 id="详细的步骤"><a href="#详细的步骤" class="headerlink" title="详细的步骤"></a>详细的步骤</h3><ol><li><p><strong>初始化 DispatcherServlet</strong>：</p><ul><li>当 Spring 容器启动时，<code>DispatcherServlet</code> 作为前端控制器被初始化，它会加载配置文件，并初始化一些关键的组件，比如 <code>HandlerMapping</code> 和 <code>HandlerAdapter</code>。</li></ul></li><li><p><strong>处理请求</strong>：</p><ul><li>用户发出 HTTP 请求时，<code>DispatcherServlet</code> 会接管请求的控制权。</li></ul></li><li><p><strong>查找处理器</strong>：</p><ul><li><code>DispatcherServlet</code> 根据 <code>HandlerMapping</code> 的配置，确定哪个控制器将会处理这个请求。</li></ul></li><li><p><strong>调用控制器</strong>：</p><ul><li><code>DispatcherServlet</code> 通过 <code>HandlerAdapter</code> 来调用处理器的具体方法，处理业务逻辑。</li></ul></li><li><p><strong>返回视图或数据</strong>：</p><ul><li>控制器执行完业务逻辑后，返回视图名或数据，<code>DispatcherServlet</code> 会通过 <code>ViewResolver</code> 来解析视图，或直接返回 JSON 数据。</li></ul></li><li><p><strong>生成响应</strong>：</p><ul><li>最后，<code>DispatcherServlet</code> 将视图或数据返回给客户端。</li></ul></li></ol><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟从数据库获取用户数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;userDetail&quot;</span>;  <span class="comment">// 返回视图名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>DispatcherServlet</code> 会：</p><ol><li>接收到对 <code>/users/&#123;id&#125;</code> 的请求。</li><li>通过 <code>HandlerMapping</code> 映射到 <code>UserController</code> 的 <code>getUserById</code> 方法。</li><li>返回视图名 <code>userDetail</code>，然后通过 <code>ViewResolver</code> 找到实际的视图并渲染。</li></ol><h2 id="在前后端分离的项目中，Spring-MVC-是如何工作的"><a href="#在前后端分离的项目中，Spring-MVC-是如何工作的" class="headerlink" title="在前后端分离的项目中，Spring MVC 是如何工作的"></a>在前后端分离的项目中，Spring MVC 是如何工作的</h2><p>在前后端分离的项目中，Spring MVC 主要用作 <strong>后端 API</strong> 服务，专注于处理业务逻辑、数据库交互，并通过 RESTful API 接口向前端提供数据。前端和后端通过 HTTP 请求（如 <code>GET</code>、<code>POST</code> 等）进行通信，前端不再依赖于服务器渲染 HTML 页面，而是通过调用 API 获取 JSON 数据。</p><h3 id="Spring-MVC-在前后端分离中的工作流程"><a href="#Spring-MVC-在前后端分离中的工作流程" class="headerlink" title="Spring MVC 在前后端分离中的工作流程"></a>Spring MVC 在前后端分离中的工作流程</h3><ol><li><strong>前端发送请求</strong>：用户在前端应用（如基于 React、Vue、Angular 的应用）中进行操作，前端应用通过 HTTP 向后端发送请求。</li><li><strong>后端控制器接收请求</strong>：Spring MVC 的控制器接收前端请求，并调用业务逻辑或数据库，处理请求。</li><li><strong>返回 JSON 数据</strong>：后端处理完请求后，返回 JSON 格式的数据响应给前端。</li><li><strong>前端显示数据</strong>：前端应用根据后端返回的数据更新页面内容。</li></ol><h3 id="使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例"><a href="#使用-Spring-Boot-和-Spring-MVC-构建一个-RESTful-API-的示例" class="headerlink" title="使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例"></a>使用 Spring Boot 和 Spring MVC 构建一个 RESTful API 的示例</h3><h4 id="1-Maven-依赖"><a href="#1-Maven-依赖" class="headerlink" title="1. Maven 依赖"></a>1. <strong>Maven 依赖</strong></h4><p>首先，确保 <code>pom.xml</code> 中包含以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Web Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot DevTools --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- JSON 处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-控制器类"><a href="#2-控制器类" class="headerlink" title="2. 控制器类"></a>2. <strong>控制器类</strong></h4><p>在前后端分离的项目中，控制器负责接收前端的 API 请求，处理业务逻辑，并返回 JSON 响应。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 假设从数据库获取用户</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟创建用户的逻辑，通常会调用服务层</span></span><br><span class="line">        user.setId(<span class="number">1</span>);  <span class="comment">// 模拟数据库生成的用户ID</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED).body(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">updateUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id, <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟更新用户信息</span></span><br><span class="line">        user.setId(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟删除用户的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.noContent().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-模型类"><a href="#3-模型类" class="headerlink" title="3. 模型类"></a>3. <strong>模型类</strong></h4><p>模型类用于定义实体，例如 <code>User</code> 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-跨域配置（CORS）"><a href="#4-跨域配置（CORS）" class="headerlink" title="4. 跨域配置（CORS）"></a>4. <strong>跨域配置（CORS）</strong></h4><p>前后端分离时，通常前端和后端不在同一个域名下，因此需要处理跨域请求。我们可以通过配置 <code>CorsConfiguration</code> 来允许跨域请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:3000&quot;</span>)  <span class="comment">// 允许前端地址</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-前端调用示例"><a href="#5-前端调用示例" class="headerlink" title="5. 前端调用示例"></a>5. <strong>前端调用示例</strong></h4><p>假设前端使用了 Vue.js，前端可以通过 <code>axios</code> 调用 Spring MVC 提供的 RESTful API。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>User Info<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID: &#123;&#123; user.id &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: &#123;&#123; user.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: &#123;&#123; user.age &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fetchUser&quot;</span>&gt;</span>Fetch User<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">user</span>: <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">fetchUser</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8080/api/users/1&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">this</span>.<span class="property">user</span> = response.<span class="property">data</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;There was an error!&quot;</span>, error);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="6-启动后端服务"><a href="#6-启动后端服务" class="headerlink" title="6. 启动后端服务"></a>6. <strong>启动后端服务</strong></h4><p>在 Spring Boot 中，后端项目运行后将会监听 <code>http://localhost:8080</code>，可以通过调用后端的 API 接口获取用户信息，如 <code>http://localhost:8080/api/users/1</code>。</p><h4 id="7-前端调用后端接口"><a href="#7-前端调用后端接口" class="headerlink" title="7. 前端调用后端接口"></a>7. <strong>前端调用后端接口</strong></h4><p>前端（例如 <code>localhost:3000</code>）向后端发起 <code>GET</code> 请求，Spring MVC 接收到请求并调用相应的控制器方法，返回 JSON 数据，前端根据这些数据进行页面更新。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot第九章，Spring MVC。&lt;/p&gt;
&lt;h2 id=&quot;Spring-MVC-示意图&quot;&gt;&lt;a href=&quot;#Spring-MVC-示意图&quot; class=&quot;headerlink&quot; title=&quot;Spring MVC 示意图&quot;&gt;&lt;/a&gt;Spring</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：事务处理</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2024-10-22T07:09:09.000Z</published>
    <updated>2024-11-07T10:34:49.117Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>@Transactional</code>注解，Spring就会知道在哪里启动事务。其约定流程如图：<br><img src="/../imgs/image-58.png"></p><p>@Transactional注解的一些配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        readOnly = true,                          // 是否只读</span></span><br><span class="line"><span class="meta">        timeout = 30,                             // 超时时间</span></span><br><span class="line"><span class="meta">        isolation = Isolation.READ_COMMITTED,      // 隔离级别</span></span><br><span class="line"><span class="meta">        propagation = Propagation.REQUIRED,        // 传播行为</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;SQLException.class&#125;,        // 指定回滚异常</span></span><br><span class="line"><span class="meta">        noRollbackFor = &#123;IllegalStateException.class&#125;  // 指定不回滚异常</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先引入事务的隔离级别：</p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务的隔离级别（Transaction Isolation Level）用于定义并发事务之间的相互影响，避免因并发执行而引发数据不一致的问题。数据库中的隔离级别定义了一个事务在执行时可以看到其他事务的修改情况，常见的隔离级别有以下四种，按隔离强度从低到高排列：</p><h3 id="1-READ-UNCOMMITTED（读未提交）"><a href="#1-READ-UNCOMMITTED（读未提交）" class="headerlink" title="1. READ UNCOMMITTED（读未提交）"></a>1. <strong>READ UNCOMMITTED（读未提交）</strong></h3><ul><li><strong>描述</strong>：在此隔离级别下，事务可以读取到其他事务尚未提交的数据（脏数据）。</li><li><strong>问题</strong>：<ul><li><strong>脏读</strong>（Dirty Read）：一个事务可以读到其他事务尚未提交的数据。如果这个事务回滚了，那么读到的数据就是无效的。</li><li><strong>不可重复读</strong>（Non-repeatable Read）：同一事务在不同时间读取相同数据时，可能得到不同结果。</li><li><strong>幻读</strong>（Phantom Read）：一个事务多次查询时可能会发现新的数据插入。</li></ul></li><li><strong>适用场景</strong>：对数据一致性要求极低的场景（很少使用）。</li></ul><h3 id="2-READ-COMMITTED（读已提交）"><a href="#2-READ-COMMITTED（读已提交）" class="headerlink" title="2. READ COMMITTED（读已提交）"></a>2. <strong>READ COMMITTED（读已提交）</strong></h3><ul><li><strong>描述</strong>：一个事务只能读取到其他事务已经提交的数据，避免脏读。</li><li><strong>问题</strong>：<ul><li><strong>不可重复读</strong>：同一事务在不同时间读取相同数据时，可能得到不同的结果。如果另一个事务在两次读取之间修改了数据，就会出现这种现象。</li><li><strong>幻读</strong>：如果一个事务在读取时，另一个事务插入了新的行，第一次查询时看不到这些行，下一次查询时就看到了。</li></ul></li><li><strong>适用场景</strong>：多数数据库（如 SQL Server 和 Oracle）默认的隔离级别，适用于读一致性要求不高但需要避免脏读的场景。</li></ul><h3 id="3-REPEATABLE-READ（可重复读）"><a href="#3-REPEATABLE-READ（可重复读）" class="headerlink" title="3. REPEATABLE READ（可重复读）"></a>3. <strong>REPEATABLE READ（可重复读）</strong></h3><ul><li><strong>描述</strong>：在整个事务期间，无论其他事务是否提交，当前事务的所有读操作都能保证是相同的数据。避免了脏读和不可重复读的问题。</li><li><strong>问题</strong>：<ul><li><strong>幻读</strong>：在同一事务中，如果另一个事务插入了新行，这些行可能会在事务的后续查询中出现。</li></ul></li><li><strong>适用场景</strong>：MySQL 默认的隔离级别，适合需要确保数据在一个事务中多次读取一致性的场景。</li></ul><h3 id="4-SERIALIZABLE（可串行化）"><a href="#4-SERIALIZABLE（可串行化）" class="headerlink" title="4. SERIALIZABLE（可串行化）"></a>4. <strong>SERIALIZABLE（可串行化）</strong></h3><ul><li><strong>描述</strong>：最高的隔离级别，强制事务串行化执行，即一个事务必须等其他事务完成后才能执行，避免了所有并发问题，包括脏读、不可重复读和幻读。</li><li><strong>问题</strong>：<ul><li>并发性能最差，多个事务几乎不能并发执行，适合数据一致性要求极高但并发量较低的场景。</li></ul></li><li><strong>适用场景</strong>：极端情况下使用，适合金融交易等需要绝对数据一致性的场景。</li></ul><h3 id="事务隔离级别总结："><a href="#事务隔离级别总结：" class="headerlink" title="事务隔离级别总结："></a>事务隔离级别总结：</h3><ul><li><strong>脏读（Dirty Read）</strong>：读取到了其他未提交事务修改的数据。</li><li><strong>不可重复读（Non-repeatable Read）</strong>：同一事务中，前后两次读取相同数据得到不同的结果，通常是由于其他事务更新了数据。</li><li><strong>幻读（Phantom Read）</strong>：在同一事务中，如果其他事务插入了新行，这些行在事务后续查询中可能会出现。</li></ul><h3 id="四种隔离级别对问题的防护表："><a href="#四种隔离级别对问题的防护表：" class="headerlink" title="四种隔离级别对问题的防护表："></a>四种隔离级别对问题的防护表：</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td><strong>READ UNCOMMITTED</strong></td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>READ COMMITTED</strong></td><td>否</td><td>是</td><td>是</td></tr><tr><td><strong>REPEATABLE READ</strong></td><td>否</td><td>否</td><td>是</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>注意</strong>：隔离级别越高，事务之间的并发性越差，但数据一致性更强。选择合适的隔离级别需要权衡并发性能和数据一致性。</p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>假设有批量任务在处理时，如果其中一个任务出现异常，是否需要回滚整个批量任务？这就需要用到事务的传播行为。<br>通常我们只希望回滚出现异常的错误任务，而不是回滚整个批量任务。<br><img src="/../imgs/image-59.png"></p><p>事务的传播行为（Transaction Propagation Behavior）决定了当一个事务方法调用另一个事务方法时，如何处理新旧事务之间的关系。Spring 提供了多种事务传播机制，允许开发人员根据业务需求选择适当的事务行为。主要的传播行为有以下几种：</p><h3 id="1-REQUIRED"><a href="#1-REQUIRED" class="headerlink" title="1. REQUIRED"></a>1. <strong>REQUIRED</strong></h3><ul><li><p><strong>描述</strong>：如果当前已经存在事务，则加入到这个事务中。如果当前没有事务，则新建一个事务。</p></li><li><p><strong>场景</strong>：默认的传播行为，适合大部分业务场景。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 调用methodA，将在同一个事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodB()</code>调用<code>methodA()</code>时，它们共享同一个事务。如果事务成功，则一起提交；如果抛出异常，则一起回滚。</p><h3 id="2-REQUIRES-NEW"><a href="#2-REQUIRES-NEW" class="headerlink" title="2. REQUIRES_NEW"></a>2. <strong>REQUIRES_NEW</strong></h3><ul><li><p><strong>描述</strong>：总是新建一个事务。如果当前有事务，先挂起当前事务，等新事务执行完再恢复。</p></li><li><p><strong>场景</strong>：适用于需要在事务中执行独立的操作，无论外部事务的状态如何，该事务都要独立提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将开启新事务，不依赖methodB的事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>将启动一个新的事务，与<code>methodB()</code>的事务独立。如果<code>methodB()</code>回滚，<code>methodA()</code>的事务依然可以成功提交。</p><h3 id="3-SUPPORTS"><a href="#3-SUPPORTS" class="headerlink" title="3. SUPPORTS"></a>3. <strong>SUPPORTS</strong></h3><ul><li><p><strong>描述</strong>：支持当前事务。如果当前有事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</p></li><li><p><strong>场景</strong>：适用于需要根据调用者上下文决定是否在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>被<code>methodB()</code>调用时，存在事务，它将加入事务；否则，它将以非事务方式执行。</p><h3 id="4-NOT-SUPPORTED"><a href="#4-NOT-SUPPORTED" class="headerlink" title="4. NOT_SUPPORTED"></a>4. <strong>NOT_SUPPORTED</strong></h3><ul><li><p><strong>描述</strong>：总是以非事务方式执行。如果当前有事务，则将其挂起。</p></li><li><p><strong>场景</strong>：适用于某些操作不需要事务，甚至不能在事务中执行。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将以非事务方式执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>会以非事务方式执行，且不受<code>methodB()</code>事务的影响。</p><h3 id="5-MANDATORY"><a href="#5-MANDATORY" class="headerlink" title="5. MANDATORY"></a>5. <strong>MANDATORY</strong></h3><ul><li><p><strong>描述</strong>：强制要求当前存在事务。如果没有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于必须在事务中执行的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 必须在methodB的事务中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>只能在已有事务的上下文中执行。如果直接调用<code>methodA()</code>时没有事务，会抛出异常。</p><h3 id="6-NEVER"><a href="#6-NEVER" class="headerlink" title="6. NEVER"></a>6. <strong>NEVER</strong></h3><ul><li><p><strong>描述</strong>：强制不允许存在事务。如果有事务，则抛出异常。</p></li><li><p><strong>场景</strong>：适用于不允许事务存在的操作。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// 将抛出异常，因为methodB有事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：如果<code>methodA()</code>在事务中执行，则会抛出异常。</p><h3 id="7-NESTED"><a href="#7-NESTED" class="headerlink" title="7. NESTED"></a>7. <strong>NESTED</strong></h3><ul><li><p><strong>描述</strong>：如果当前有事务，则在当前事务中嵌套一个子事务；如果当前没有事务，则新建一个事务。嵌套事务可以单独回滚，而不影响外部事务。</p></li><li><p><strong>场景</strong>：适用于希望在主事务中有嵌套事务，子事务可以单独提交或回滚。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法A业务逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法B业务逻辑</span></span><br><span class="line">    methodA();  <span class="comment">// methodA将作为methodB的嵌套事务执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>   <strong>解释</strong>：<code>methodA()</code>作为<code>methodB()</code>的嵌套事务执行，可以独立回滚，但如果<code>methodB()</code>回滚，<code>methodA()</code>也会回滚。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>当前有事务则加入，没有则创建新事务（默认）。</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>总是新建一个事务，挂起当前事务。</td></tr><tr><td><strong>SUPPORTS</strong></td><td>当前有事务则加入，没有事务则以非事务方式执行。</td></tr><tr><td><strong>NOT_SUPPORTED</strong></td><td>总是以非事务方式执行，挂起当前事务。</td></tr><tr><td><strong>MANDATORY</strong></td><td>当前有事务则加入，没有则抛出异常。</td></tr><tr><td><strong>NEVER</strong></td><td>总是以非事务方式执行，当前有事务则抛出异常。</td></tr><tr><td><strong>NESTED</strong></td><td>嵌套事务，允许回滚子事务但不影响父事务。</td></tr></tbody></table><h3 id="示例项目中使用-Transactional："><a href="#示例项目中使用-Transactional：" class="headerlink" title="示例项目中使用 @Transactional："></a>示例项目中使用 <code>@Transactional</code>：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建订单的逻辑</span></span><br><span class="line">        paymentService.processPayment(); <span class="comment">// 调用另一个事务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 处理支付逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>createOrder()</code>使用<code>REQUIRED</code>传播行为，而<code>processPayment()</code>使用<code>REQUIRES_NEW</code>，即<code>processPayment()</code>将运行在一个独立的事务中。</p><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><h3 id="在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？"><a href="#在Spring-boot中Transactional-readOnly-true-和-Transactional有什么区别？" class="headerlink" title="在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？"></a>在Spring@ boot中Transactional(readOnly &#x3D; true)和@Transactional有什么区别？</h3><p>在 Spring Boot 中，<code>@Transactional</code> 注解用于管理事务边界，而 <code>@Transactional(readOnly = true)</code> 和 <code>@Transactional</code> 之间的主要区别在于<strong>事务的读写属性</strong>，从而影响数据库的操作方式和性能优化。具体来说：</p><p><code>@Transactional(readOnly = true)</code>：</p><ul><li><strong>只读事务</strong>：指定该事务仅用于查询操作，即不会涉及对数据库的更新、插入或删除操作。</li><li><strong>性能优化</strong>：Spring 在只读事务中可能对底层数据库连接进行优化，例如关闭脏数据检测等，提高查询性能。</li><li><strong>数据库支持</strong>：某些数据库可以通过只读事务进行额外的性能优化，但要确保该事务中不包含写操作（更新、插入、删除），否则会抛出异常。</li><li><strong>应用场景</strong>：适用于不需要更改数据的服务层方法，比如获取用户列表、查看订单信息等操作。</li></ul><p><code>@Transactional</code> (默认 <code>readOnly = false</code>)：</p><ul><li><strong>读写事务</strong>：支持所有数据库操作，包括查询、插入、更新、删除。</li><li><strong>数据一致性</strong>：该事务在执行过程中会进行数据一致性检查，确保数据库在事务中所有操作要么全部成功，要么在出现异常时全部回滚。</li><li><strong>性能考虑</strong>：因为存在数据修改操作，事务提交时会涉及更多一致性检查和资源锁定，性能开销通常高于只读事务。</li><li><strong>应用场景</strong>：适用于需要更改数据的操作，比如更新用户信息、添加新订单等。</li></ul><p><strong>在 Spring 中，@Transactional(readOnly &#x3D; true) 默认不会改变事务的隔离级别。它只指定了当前事务是“只读”的，主要目的是在执行查询操作时，利用数据库的优化机制提升性能。</strong></p><p>在mysql中事务的隔离级别默认是<code>REPEATABLE READ</code>，事务的默认传播行为是<code>REQUIRED</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用&lt;code&gt;@Transactional&lt;/code&gt;注解，Spring就会知道在哪里启动事务。其约定流程如图：&lt;br&gt;&lt;img src=&quot;/../imgs/image-58.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;@Transactional注解的一些配置：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-MyBatis</title>
    <link href="https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/"/>
    <id>https://kelinkong.github.io/2024/10/22/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis/</id>
    <published>2024-10-22T06:46:45.000Z</published>
    <updated>2024-10-22T08:48:39.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h2><p>MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDBC代码和参数的手动设置以及结果集的检索。</p><ol><li><p>首先添加依赖(pom.xml)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据库连接(application.yml)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/demo?useSSL=false</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  type-aliases-package: com.example.entity</span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.entity;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(Long id)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建XML映射文件(<code>resources/mapper/UserMapper.xml</code>)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        INSERT INTO user (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.example.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        userService.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>这个示例展示了MyBatis在Spring Boot中的基本使用，包括：</p><ol><li>Maven依赖配置</li><li>数据库连接配置</li><li>实体类定义</li><li>Mapper接口定义</li><li>XML映射文件</li><li>Service层实现</li><li>Controller层实现</li></ol><p>使用这个示例，可以：</p><ul><li>通过 GET &#x2F;users&#x2F;{id} 查询用户</li><li>通过 POST &#x2F;users 创建新用户</li></ul><p>在使用前需要确保：</p><ol><li>创建对应的数据库和表</li><li>修改数据库连接配置</li><li>启动类添加 <code>@MapperScan(&quot;com.example.mapper&quot;)</code> 注解</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一个简单的示例&quot;&gt;&lt;a href=&quot;#一个简单的示例&quot; class=&quot;headerlink&quot; title=&quot;一个简单的示例&quot;&gt;&lt;/a&gt;一个简单的示例&lt;/h2&gt;&lt;p&gt;MyBatis是一个流行的持久层框架，它支持自定义SQL、存储过程和高级映射，消除了几乎所有的JDB</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Boot：全注解下的IoC</title>
    <link href="https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/"/>
    <id>https://kelinkong.github.io/2024/10/22/Spring-Boot%EF%BC%9A%E5%85%A8%E6%B3%A8%E8%A7%A3%E4%B8%8B%E7%9A%84loc/</id>
    <published>2024-10-22T01:39:29.000Z</published>
    <updated>2024-10-22T08:48:39.127Z</updated>
    
    <content type="html"><![CDATA[<p>深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。</p><p>Spring 中把每一个<br>需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 Spring IoC 容器（或者简称 IoC 容器） 。 IoC 容器需要具备两个基本的功能：</p><ul><li>通过描述管理 Bean，包括发布和获取 Bean;</li><li>通过描述完成 Bean 之间的依赖关系</li></ul><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>要求所有的 IoC 容器都需要实现接口 BeanFactory，其中定义了获取 Bean 的基本方法。</p><p>BeanFactory源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(String name, Class&lt;T&gt; required</span></span><br><span class="line"><span class="params">    Type)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line">    Boolean <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 默认情况下，Spring IoC 容器是单例的，每次返回都是同一个对象</span></span><br><span class="line">    Boolean <span class="title function_">isSingleton</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="comment">// 原型模式，每次返回都是一个新的对象</span></span><br><span class="line">    Boolean <span class="title function_">isPrototype</span><span class="params">(String name)</span>;</span><br><span class="line">    Boolean <span class="title function_">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BeanFactory中，有多个<code>getBean</code>方法，其中最常用的是：</p><ul><li><code>getBean(String name)</code>：根据 Bean 的名称获取 Bean 对象</li><li><code>getBean(Class&lt;T&gt; requiredType)</code>：根据 Bean 的类型获取 Bean 对象</li></ul><p>Spring 提供了一个更高级的 IoC 容器接口 ApplicationContext，它是 BeanFactory 的子接口，提供了更多的功能。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p><img src="/../imgs/image-53.png"></p><p>ApplicationContext 接口通过实现多个接口，提供了更多的功能，如国际化、事件传播、资源加载等。</p><p> Spring Boot 当中我们主要是通过注解来装配 Bean 到 Spring IoC 容器中。</p><h3 id="使用AnnotationConfigApplicationContext"><a href="#使用AnnotationConfigApplicationContext" class="headerlink" title="使用AnnotationConfigApplicationContext"></a>使用AnnotationConfigApplicationContext</h3><p>AnnotationConfigApplicationContext 是一个 IoC 容器，它可以通过注解来装配 Bean 到 Spring IoC 容器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建了一个基于注解的Spring IoC容器AnnotationConfigApplicationContext，并将AppConfig类作为配置类传递给它。</span></span><br><span class="line"><span class="comment">         * AppConfig.class是一个包含Spring配置的类，使用了<span class="doctag">@Configurable</span>注解，表明这是一个配置类。</span></span><br><span class="line"><span class="comment">         * 通过这种方式，Spring会扫描AppConfig类中的<span class="doctag">@Bean</span>注解，并将这些方法返回的对象注册为Spring容器中的Bean。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从Spring容器中获取一个类型为User的Bean对象。</span></span><br><span class="line"><span class="comment">         * ctx.getBean(User.class)方法会根据类型查找并返回一个User类型的Bean实例。</span></span><br><span class="line"><span class="comment">         * 这个User实例是由AppConfig类中的initUser方法创建并注册到Spring容器中的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> ctx.getBean(User.class);</span><br><span class="line">        log.info(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"><a href="#在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别" class="headerlink" title="在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别"></a>在配置类中使用注解装配Bean和在Bean类上使用注解装配Bean的区别</h2><p>在 Spring 中，<code>@Bean</code> 注解通常用于定义和注册 Bean 到 IoC 容器中，而它可以出现在不同的地方。主要有两种常见的方式：</p><ol><li><strong>在配置类中使用 <code>@Bean</code> 注解</strong>（如在你的 <code>AppConfig</code> 类中）  </li><li><strong>在实体类（如 <code>User</code> 类）上使用 <code>@Component</code> 或其他派生注解</strong>，例如 <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等。</li></ol><p>这两种方式的不同点主要体现在 <strong>Bean 定义和管理的灵活性、配置的集中化以及依赖管理的差异</strong>：</p><h3 id="1-在配置类中使用-Bean-注解"><a href="#1-在配置类中使用-Bean-注解" class="headerlink" title="1. 在配置类中使用 @Bean 注解"></a>1. <strong>在配置类中使用 <code>@Bean</code> 注解</strong></h3><p>使用 <code>@Bean</code> 注解在一个配置类中（如 <code>AppConfig</code>）定义 Bean 具有以下特点：</p><ul><li><p><strong>集中配置</strong>：你可以在一个地方（配置类）集中管理所有的 Bean 定义。这可以使得配置代码更加清晰和集中，尤其是在需要配置复杂依赖的场景中。</p></li><li><p><strong>灵活性</strong>：配置类中的 <code>@Bean</code> 方法可以让你灵活地定义 Bean，比如在 Bean 创建时通过方法参数注入依赖，或根据某些条件决定返回的对象。这种方式更加灵活，可以使用逻辑控制返回哪个 Bean 实例。</p></li><li><p><strong>可定制性</strong>：通过 <code>@Bean</code>，你可以完全控制对象的创建过程，甚至可以在创建时执行一些逻辑，或者根据应用的某些条件配置不同的 Bean 实例。</p></li><li><p><strong>多实例管理</strong>：你可以在配置类中通过不同的方法名或 <code>@Bean</code> 注解的 <code>name</code> 属性来为同一个类型注册多个不同的 Bean。</p></li><li><p><strong>明确的生命周期控制</strong>：在配置类中，你还可以使用 <code>@PostConstruct</code>, <code>@PreDestroy</code> 等注解来明确控制 Bean 的生命周期。</p></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">initUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;kelin&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">25</span>);</span><br><span class="line">        user.setGender((<span class="type">byte</span>) <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-在-User-类中使用-Component-或其他注解"><a href="#2-在-User-类中使用-Component-或其他注解" class="headerlink" title="2. 在 User 类中使用 @Component 或其他注解"></a>2. <strong>在 <code>User</code> 类中使用 <code>@Component</code> 或其他注解</strong></h3><p>如果你直接在实体类（如 <code>User</code> 类）上使用 <code>@Component</code>（或 <code>@Service</code>, <code>@Controller</code> 等注解），Spring 会自动扫描并将这个类注册为 Bean。特点如下：</p><ul><li><p><strong>自动扫描与装配</strong>：<code>@Component</code> 是一个基于类的注解，意味着只要这个类被 Spring 的组件扫描路径扫描到，它就会自动注册为 Bean。你不需要手动在配置类中定义它。</p></li><li><p><strong>简单且自动化</strong>：适合简单的类，只需要标记类为组件即可，通常用于那些不需要复杂配置或初始化逻辑的 Bean。</p></li><li><p><strong>依赖注入</strong>：当使用 <code>@Component</code> 时，通常配合 <code>@Autowired</code> 注解实现自动依赖注入。虽然 <code>@Bean</code> 也可以做到类似的依赖注入，但是 <code>@Component</code> 配合自动扫描更适合规模较大的项目。</p></li><li><p><strong>更少控制权</strong>：与 <code>@Bean</code> 相比，<code>@Component</code> 提供的控制力更少。例如，你无法在定义 Bean 时动态决定返回什么实例，因为 <code>@Component</code> 只是简单地注册类到 IoC 容器中。</p></li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. <strong>主要区别</strong></h3><table><thead><tr><th>特点</th><th><code>@Bean</code> 在配置类中使用</th><th><code>@Component</code> 在类中使用</th></tr></thead><tbody><tr><td><strong>注册方式</strong></td><td>手动在配置类中定义并注册 Bean</td><td>自动通过类扫描注册为 Bean</td></tr><tr><td><strong>灵活性</strong></td><td>高，方法中可以有逻辑控制 Bean 的创建</td><td>低，只能通过注解标记类为 Bean</td></tr><tr><td><strong>依赖注入</strong></td><td>可以通过方法参数手动注入依赖</td><td>使用 <code>@Autowired</code> 自动注入依赖</td></tr><tr><td><strong>配置复杂度</strong></td><td>适合复杂或条件性 Bean 定义</td><td>适合简单 Bean 自动化管理</td></tr><tr><td><strong>Bean 名称控制</strong></td><td>可以通过 <code>@Bean(name = &quot;xxx&quot;)</code> 自定义</td><td>默认 Bean 名称为类名，首字母小写</td></tr><tr><td><strong>生命周期控制</strong></td><td>可以通过 <code>@PostConstruct</code>, <code>@PreDestroy</code></td><td>需要配合额外注解管理生命周期</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>@Bean</code> 适用于更复杂、需要灵活控制的 Bean 配置</strong>。例如，需要根据某些条件创建 Bean 或者配置依赖的场景。</li><li><strong><code>@Component</code> 更适合那些不需要复杂配置、依赖自动装配的类</strong>。它的作用类似于自动注册类作为 Spring 管理的组件，适合小型组件或服务类。</li></ul><p>两者都可以实现依赖注入，但适用场景不同，使用时需要根据具体需求选择。</p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="ComponentScan"></a>ComponentScan</h2><p><code>@ComponentScan</code> 注解是 Spring 提供的一个用于自动扫描和注册 Bean 的注解。它可以指定一个包路径，Spring 会自动扫描这个包路径下的所有类，并将标记了 <code>@Component</code> 及其派生注解的类注册为 Bean。</p><p><code>@ComponentScan</code> 注解通常与 <code>@Configuration</code> 注解一起使用，用于配置 Spring IoC 容器的自动扫描路径。</p><p>可以排除特定的 Bean 类型，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.springboot.chapter3&quot; &#125; ,</span></span><br><span class="line"><span class="meta">excludeFilters = &#123;@Filter(classes = Service.class) )</span>)</span><br></pre></td></tr></table></figure><p>以上大致是将Bean注入到Spring IoC容器中的方法。</p><h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>一个简单的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 根据属性的类型找到对应的Bean进行注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Autowired注解"><a href="#Autowired注解" class="headerlink" title="@Autowired注解"></a>@Autowired注解</h3><p><code>@Autowired</code>的注入机制最基本的一条是通过类型进行注入。在IoC容器的顶级接口<code>Factory</code>中，有一个<code>getBean</code>方法，这个方法是通过类型来获取<code>Bean</code>的。</p><p>但是在Spring中，有时候我们会有多个实现类，这时候就需要通过<code>@Qualifier</code>注解来指定具体的实现类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;v8Engine&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果被注入的Bean带有参数的构造函数，如何把参数传入呢？<br>使用@Value注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 @Value 注解注入参数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Engine</span><span class="params">(<span class="meta">@Value(&quot;$&#123;engine.type&#125;&quot;)</span> String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动注入 Engine Bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Car is driving with engine type: &quot;</span> + engine.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p><img src="/../imgs/image-54.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;kelin.com.springnotes.chapter3&quot;, lazyInit = true)</span></span><br></pre></td></tr></table></figure><p>使用lazyInit &#x3D; true，可以延迟初始化Bean，即在第一次使用Bean时才初始化。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/../imgs/image-55.png"></p><h2 id="使用-Profile"><a href="#使用-Profile" class="headerlink" title="使用@Profile"></a>使用@Profile</h2><p><code>@Profile</code>注解可以根据不同的环境来选择不同的Bean。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for DEV environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProdDataSourceConfig</span> <span class="keyword">implements</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Setting up data source for PROD environment. &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;深入浅出Spring Boot 2.x学习笔记，第三章，Spring Boot：全注解下的loc。&lt;/p&gt;
&lt;p&gt;Spring 中把每一个&lt;br&gt;需要管理的对象称为 Spring Bean （简称 Bean ），而 Spring 管理这些 Bean 的 容器，被我们称为 S</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm学习-人工神经网络</title>
    <link href="https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://kelinkong.github.io/2024/10/18/llvm-%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2024-10-18T00:47:24.000Z</published>
    <updated>2024-10-21T06:07:05.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？</p><p>我们现在假设要训练的模型是一个函数，首先考虑，这个函数的作用是什么？这个函数的输入是什么？输出是什么？</p><p>人工神经网络可以用来做分类、预测、生成等任务，现在假设我们的函数是一个分类函数，那么输入就是一个数据，输出就是这个数据属于哪个类别。</p><p>所以，训练神经网络，就是训练这个函数，让这个函数能够准确地对数据进行分类。</p><p>所谓训练，有点太拟人化了，听起来比较抽象，其实就是调整函数的参数，使得函数的输出尽可能接近真实值。</p><p>参数又是什么？这里先介绍一下神经网络的基本结构。</p><h2 id="人工神经网络的基本结构"><a href="#人工神经网络的基本结构" class="headerlink" title="人工神经网络的基本结构"></a>人工神经网络的基本结构</h2><p>人工神经网络是一种模拟人脑神经元网络的计算模型，它由多个神经元（Neuron）组成，每个神经元接收多个输入，经过加权和激活函数处理后，输出一个值。</p><h3 id="神经元（Neuron）"><a href="#神经元（Neuron）" class="headerlink" title="神经元（Neuron）"></a>神经元（Neuron）</h3><p><img src="/../imgs/image-51.png" alt="图来源于维基百科"></p><p>一个神经元的结构可以分为三个主要部分：<strong>输入</strong>、<strong>处理单元</strong>、<strong>输出</strong>。如果用前文的函数来描述，每一个神经元就是一个函数，这个函数的输入就是一个特征向量和一个权重向量，这个向量经过某种计算后，输出一个值（一个神经元的输出通常是一个标量）。</p><p>经过了什么处理呢？</p><p>对于单个神经元，其数学表达可以写为：<br>   $$<br>   y &#x3D; \text{activation}(w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b)<br>   $$</p><p>具体来看：</p><h4 id="1-输入层（Input-Layer）："><a href="#1-输入层（Input-Layer）：" class="headerlink" title="1. 输入层（Input Layer）："></a>1. <strong>输入层（Input Layer）</strong>：</h4><ul><li>神经元的输入来自前一层的神经元，或者在网络的第一层，输入是来自外部的数据。</li><li>输入信号（即特征）通过**权重(Weights)**传递到神经元。每个输入信号都有一个权重值，权重表示输入的重要性。</li></ul><p>   <strong>示例</strong>：<br>   如果我们有三个输入特征 $( a_1, a_2, a_3 )$，每个输入都有一个对应的权重 $( w_1, w_2, w_3 )$。<br>   $$<br>   z &#x3D; w_1 \cdot a_1 + w_2 \cdot a_2 + w_3 \cdot a_3 + b<br>   $$<br>   其中，$b$ 是偏置项。</p><h4 id="2-加权求和（Weighted-Sum）："><a href="#2-加权求和（Weighted-Sum）：" class="headerlink" title="2. 加权求和（Weighted Sum）："></a>2. <strong>加权求和（Weighted Sum）</strong>：</h4><ul><li>输入通过权重后，神经元会将这些加权输入进行加和，再加上一个<strong>偏置（Bias）</strong>项。</li><li>偏置用于调整激活函数的输出，让神经元的输出更加灵活，帮助网络更好地拟合数据。</li></ul><p>   <strong>数学表示</strong>：<br>   $$<br>   z &#x3D; \sum (w_i \cdot x_i) + b<br>   $$</p><p>   其中，$z$ 是加权求和的结果，$w_i$ 是权重，$x_i$ 是输入，$b$是偏置。</p><h4 id="3-激活函数（Activation-Function）："><a href="#3-激活函数（Activation-Function）：" class="headerlink" title="3. 激活函数（Activation Function）："></a>3. <strong>激活函数（Activation Function）</strong>：</h4><ul><li>加权求和后的结果$z$ 会通过一个<strong>激活函数</strong>，以增加神经元的非线性能力。</li><li>激活函数的目的是引入非线性，以便神经网络能够学习复杂的模式。常见的激活函数有 Sigmoid、ReLU、Tanh 等。</li></ul><h4 id="4-输出（Output）："><a href="#4-输出（Output）：" class="headerlink" title="4. 输出（Output）："></a>4. <strong>输出（Output）</strong>：</h4><ul><li>经过激活函数处理后的输出 $t$ 是神经元的最终结果，这个结果可以作为下一层神经元的输入，或者作为最终输出（例如分类结果或回归值）。</li><li>在输出层，输出值可以是一个分类标签（如Softmax输出的类别）或一个回归值（如预测的数值）。</li></ul><p>我们现在已经知道单个神经元（函数）做了什么工作，那么，为什么要经过加权求和、偏置又是什么、为什么要有激活函数？</p><h3 id="加权求和和偏置"><a href="#加权求和和偏置" class="headerlink" title="加权求和和偏置"></a>加权求和和偏置</h3><h4 id="1-加权求和："><a href="#1-加权求和：" class="headerlink" title="1. 加权求和："></a>1. <strong>加权求和</strong>：</h4><ul><li>加权求和是为了给不同的输入信号赋予不同的重要性。</li><li>通过调整权重，神经元可以学习到不同特征的重要性，从而更好地拟合数据。</li></ul><p>比如说，判断一个人是男人还是女人，我们可以用身高、体重、声音等特征。但是，不同的特征对性别的判断重要性是不同的，比如身高可能比声音更重要，所以我们需要通过权重来调整这些特征的重要性。</p><h4 id="2-偏置："><a href="#2-偏置：" class="headerlink" title="2. 偏置："></a>2. <strong>偏置</strong>：</h4><p>偏置的作用是让神经网络的输出有更多的灵活性，即使输入的值为零，偏置也能确保神经元的激活函数能产生非零的输出。这有助于模型更好地拟合数据。</p><p>为什么要有偏置：如果没有偏置，神经网络的输出完全依赖于输入数据。如果输入为零，输出会总是零，这样模型的表达能力受到限制。通过加入偏置，神经网络可以更好地学习复杂的模式和关系。</p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>目的：激活函数的主要作用是引入非线性，从而让神经网络能够处理复杂的非线性问题。</p><p>没有激活函数，神经网络只会进行线性变换，加权求和的输出只是输入的线性组合。线性模型的能力有限，无法拟合复杂的非线性数据。因此，激活函数通过对加权和进行非线性处理，使网络可以处理高度复杂的任务，如图像识别、自然语言处理等。</p><h4 id="1-ReLU（Rectified-Linear-Unit）："><a href="#1-ReLU（Rectified-Linear-Unit）：" class="headerlink" title="1. ReLU（Rectified Linear Unit）："></a>1. <strong>ReLU（Rectified Linear Unit）</strong>：</h4><p>   ReLU 是最简单的激活函数之一。它的数学表达式为：<br>   $$<br>   \text{ReLU}(z) &#x3D; \max(0, z)<br>   $$</p><ul><li>当 $z &gt; 0$，输出 $z$。</li><li>当 $z \leq 0$，输出 0。</li></ul><h4 id="2-Sigmoid："><a href="#2-Sigmoid：" class="headerlink" title="2. Sigmoid："></a>2. <strong>Sigmoid</strong>：</h4><p>   Sigmoid 是一种常用的激活函数，尤其适用于二分类任务。它的数学表达式为：<br>   $$<br>   \sigma(z) &#x3D; \frac{1}{1 + e^{-z}}<br>   $$</p><ul><li>该函数将输入 $z$ 映射到区间 (0, 1) 之间。</li><li>当 $z \to \infty$，Sigmoid 函数的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 0。</li></ul><h4 id="3-Tanh（Hyperbolic-Tangent）："><a href="#3-Tanh（Hyperbolic-Tangent）：" class="headerlink" title="3. Tanh（Hyperbolic Tangent）："></a>3. <strong>Tanh（Hyperbolic Tangent）</strong>：</h4><p>   Tanh 是另一个常用的激活函数，它将输入映射到 -1 到 1 之间。其数学表达式为：<br>   $$<br>   \tanh(z) &#x3D; \frac{e^z - e^{-z}}{e^z + e^{-z}}<br>   $$</p><ul><li>该函数将 $z$ 映射到区间 (-1, 1)。</li><li>当 $z \to \infty$，Tanh 的输出接近 1。</li><li>当 $z \to -\infty$，输出接近 -1。</li></ul><h4 id="这三个激活函数的行为："><a href="#这三个激活函数的行为：" class="headerlink" title="这三个激活函数的行为："></a>这三个激活函数的行为：</h4><ul><li><strong>ReLU</strong>：输出非负的值，有助于解决梯度消失问题，但可能会导致“死亡ReLU”问题（即神经元在某些区域永远输出0）。</li><li><strong>Sigmoid</strong>：适用于二分类，但在极值区域梯度容易消失。</li><li><strong>Tanh</strong>：输出范围为 (-1, 1)，通常比 Sigmoid 更有效，但仍可能存在梯度消失问题。</li></ul><p>偏置让模型产生非零输出，激活函数引入非线性，这两个因素使得神经网络能够学习复杂的模式和关系。那什么是线性模型，什么是非线性模型呢？</p><h3 id="线性模型和非线性模型"><a href="#线性模型和非线性模型" class="headerlink" title="线性模型和非线性模型"></a>线性模型和非线性模型</h3><p>我们先从“线性模型”的概念开始，然后再解释为什么它的能力有限，以及它为什么不能拟合复杂的非线性数据。</p><h4 id="1-线性模型是什么？"><a href="#1-线性模型是什么？" class="headerlink" title="1. 线性模型是什么？"></a>1. <strong>线性模型是什么？</strong></h4><ul><li>线性模型是一种简单的数学模型，它通过输入变量（特征）的线性组合来进行预测。</li><li>公式形式为：<br>$$<br>y &#x3D; w_1 \cdot x_1 + w_2 \cdot x_2 + \dots + w_n \cdot x_n + b<br>$$<br>其中：<ul><li>$y$ 是模型的输出（预测结果），</li><li>$x_1, x_2, …, x_n$ 是输入特征，</li><li>$w_1, w_2, …, w_n$ 是每个特征的权重，</li><li>$b$ 是偏置项。</li></ul></li></ul><p>   这个公式表明输出 $y$ 是输入特征的<strong>加权求和</strong>。这种模型在数据的所有关系都是线性时，表现得很好。</p><h4 id="2-线性模型的局限性"><a href="#2-线性模型的局限性" class="headerlink" title="2. 线性模型的局限性"></a>2. <strong>线性模型的局限性</strong></h4><ul><li>线性模型可以很好地处理简单的任务，比如预测身高和体重的关系，如果这两个变量之间的关系是线性的。</li><li><strong>线性关系</strong>意味着，输入特征的变化会导致输出以固定比例变化（即没有复杂的交互或非线性效应）。</li></ul><p>   例如，如果我们在二维平面上绘制一条直线，直线可以通过简单的线性方程来表示，适用于处理两个变量之间的简单比例关系。但在现实世界中，很多问题不是这样简单的线性关系。</p><h4 id="3-什么是非线性数据？"><a href="#3-什么是非线性数据？" class="headerlink" title="3. 什么是非线性数据？"></a>3. <strong>什么是非线性数据？</strong></h4><ul><li>非线性数据是指输入与输出之间的关系无法用简单的直线表示。它可能是弯曲的、复杂的、有多个转折点，或者数据之间存在高度的交互。</li><li>比如，如果想预测一个人的年收入，可能会涉及教育背景、工作经验、职位、技能等多个复杂因素，它们之间的关系是高度复杂的，这样的数据就是<strong>非线性的</strong>。</li></ul><p>   例如，如果我们用简单的线性模型来处理这个问题，它只能画出一条直线，但现实中这些因素的关系是复杂而非线性的，可能是一个波动的曲线。线性模型无法正确表达这种复杂的关系。</p><h4 id="4-为什么线性模型不能拟合复杂的非线性数据？"><a href="#4-为什么线性模型不能拟合复杂的非线性数据？" class="headerlink" title="4. 为什么线性模型不能拟合复杂的非线性数据？"></a>4. <strong>为什么线性模型不能拟合复杂的非线性数据？</strong></h4><ul><li>线性模型的核心在于它只会根据输入特征进行简单的加权和。因此，它无法捕捉到变量之间复杂的交互关系或弯曲的趋势。</li><li>举个简单的例子，假设要预测物体在抛出后的运动轨迹。物体的轨迹是抛物线（非线性），如果你用线性模型去拟合这个轨迹，结果只能是一条直线，完全无法准确描述抛物线的运动。</li><li>现实中的大多数数据，比如图像、语音、自然语言等，往往存在复杂的非线性关系，输入特征之间的交互也很复杂，线性模型无法有效捕捉这些关系。</li></ul><h4 id="5-如何解决这个问题？"><a href="#5-如何解决这个问题？" class="headerlink" title="5. 如何解决这个问题？"></a>5. <strong>如何解决这个问题？</strong></h4><ul><li>为了解决这个问题，我们需要引入<strong>非线性模型</strong>。神经网络就是一种非常强大的非线性模型，它通过<strong>激活函数</strong>（如 ReLU、Sigmoid）引入非线性，使得神经网络能够处理和拟合复杂的非线性数据。</li><li>每一层神经元通过权重和偏置计算出加权和，并通过激活函数引入非线性，逐层递进地学习输入数据的复杂模式，从而对复杂任务做出准确预测。</li></ul><p>用大白话说就是线性模型是拟合为直线的，非线性模型可以拟合为曲线的。</p><p><img src="/../imgs/image-52.png"></p><p><strong>那么，为什么加入激活函数后，神经网络就能处理非线性数据了呢？</strong></p><blockquote><p>当我们给神经网络加入激活函数后，它就能够处理复杂的非线性数据，原因很简单：</p><p>打破线性限制：如果没有激活函数，神经网络每一层的计算都是线性的（像画直线一样），无论堆叠多少层，最终的输出也只是线性组合，无法处理弯曲、复杂的模式。</p><p>激活函数引入变化：激活函数就像给网络“加了个弯”，不再只产生直线关系。比如 ReLU 会把负数变成 0，而正数保持不变，这种变化让网络能处理更复杂的情况，不再是简单的线性相加。<br>层层递进：每一层加上激活函数后，输出的结果会经过更多复杂的非线性处理。最终，网络能学会从数据中找到隐藏的复杂关系，甚至是一些人类看不到的特征。<br>简单来说，激活函数让网络能够画“曲线”，而不是只能画“直线”，这就是它能处理非线性数据的原因。</p></blockquote><p>前面提到：输出非负的值，有助于解决梯度消失问题。</p><p><strong>那么，梯度是什么？梯度消失又是什么？</strong></p><h3 id="梯度和梯度消失"><a href="#梯度和梯度消失" class="headerlink" title="梯度和梯度消失"></a>梯度和梯度消失</h3><p>我们先从<strong>梯度</strong>的概念开始，接着解释什么是<strong>梯度消失</strong>。</p><h4 id="1-什么是梯度？"><a href="#1-什么是梯度？" class="headerlink" title="1. 什么是梯度？"></a>1. <strong>什么是梯度？</strong></h4><ul><li>在神经网络中，梯度指的是损失函数（模型预测的误差）对模型参数（权重和偏置）的导数。</li><li>梯度告诉我们如何调整权重才能让损失减少，也就是说，它指示了优化方向。</li><li>比如，假设我们在爬山，梯度就像告诉我们当前所处位置的坡度和方向，帮助我们找到“山顶”（即最小的损失值）。</li></ul><h4 id="2-梯度消失是什么？"><a href="#2-梯度消失是什么？" class="headerlink" title="2. 梯度消失是什么？"></a>2. <strong>梯度消失是什么？</strong></h4><ul><li><strong>梯度消失</strong>是指当神经网络的某些层的梯度变得非常小时，网络更新参数的速度变得非常慢，甚至无法继续学习。</li><li>在训练深层神经网络时，随着误差从输出层逐层向前传播回输入层，梯度会逐渐变小。尤其是当使用像 Sigmoid 或 Tanh 这样的激活函数时，它们的导数很容易变得接近 0，导致梯度消失。</li></ul><h4 id="3-为什么梯度消失是个问题？"><a href="#3-为什么梯度消失是个问题？" class="headerlink" title="3. 为什么梯度消失是个问题？"></a>3. <strong>为什么梯度消失是个问题？</strong></h4><ul><li>梯度消失意味着，神经网络前面几层的权重几乎没有更新。这会导致这些层的学习速度非常慢，网络无法有效学习数据中的复杂特征。</li><li>如果梯度消失，模型在训练过程中就会变得“卡住”，无法通过反向传播有效优化权重，这样模型的表现也就无法提高。</li></ul><h4 id="4-为什么输出非负值可以帮助解决梯度消失？"><a href="#4-为什么输出非负值可以帮助解决梯度消失？" class="headerlink" title="4. 为什么输出非负值可以帮助解决梯度消失？"></a>4. <strong>为什么输出非负值可以帮助解决梯度消失？</strong></h4><ul><li><strong>ReLU激活函数</strong>输出非负值（即当输入大于 0 时，输出等于输入；否则输出 0）。ReLU 的导数是常数 1（对于正数部分），不会像 Sigmoid 或 Tanh 那样迅速衰减为接近 0。这意味着通过 ReLU，网络的梯度不容易消失，前面几层的学习速度也能得到保证。</li><li>换句话说，<strong>输出非负的值</strong>，特别是通过 ReLU 这样的激活函数，可以避免导数过小，从而缓解梯度消失问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习大模型相关的知识，很多教程都会提到人工神经网络。读研时总是听到训练神经网络之类的词，那这个训练，到底是训练什么呢？&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm-RAG学习</title>
    <link href="https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/12/llvm-RAG%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-12T03:18:19.000Z</published>
    <updated>2024-10-12T03:46:40.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是RAG"><a href="#什么是RAG" class="headerlink" title="什么是RAG"></a>什么是RAG</h2><p>RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）和生成（Generation）相结合的技术，常用于自然语言处理任务，特别是在问答和文档生成场景中。</p><h3 id="RAG-的工作原理"><a href="#RAG-的工作原理" class="headerlink" title="RAG 的工作原理"></a>RAG 的工作原理</h3><p>RAG 将两个主要组件结合起来：</p><ul><li><p>信息检索（Retrieval）：当系统接收到问题时，首先会从一个大型的文档数据库或知识库中检索出与问题最相关的文档片段。通常会使用像 ElasticSearch 或基于 BERT 的检索模型来找到最相关的内容。</p></li><li><p>生成模型（Generation）：接下来，生成模型（通常是一个大型语言模型，如 GPT）会将检索到的文档片段作为输入，然后基于这些片段生成答案。这使得生成模型不必完全依赖其自身的训练数据，而是可以利用外部知识库中的信息来生成更准确和上下文相关的响应。</p></li></ul><p>RAG技术虽然有以上显著的优势，但它不是万能的，只是锦上添花的一种手段，因为它主<strong>要是优化了模型的输入过程，通过丰富输入信息的方式，来增强模型的输出质量。但这项技术并不改变模型本身的推理能力，不会改变模型任何的参数</strong>。</p><h2 id="RAG的实现"><a href="#RAG的实现" class="headerlink" title="RAG的实现"></a>RAG的实现</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成）的实现涉及两个关键组件：<strong>检索模块</strong>和<strong>生成模块</strong>。这两者结合起来使得模型可以利用外部知识库动态生成高质量的答案。下面是RAG的典型实现步骤：</p><h3 id="1-构建知识库（Knowledge-Base）"><a href="#1-构建知识库（Knowledge-Base）" class="headerlink" title="1. 构建知识库（Knowledge Base）"></a>1. <strong>构建知识库（Knowledge Base）</strong></h3><p>   RAG的一个关键组件是知识库。这个知识库通常包含与特定领域相关的文档、条目、百科等。它可以是各种形式的文本，比如：</p><ul><li>结构化数据（数据库条目、文档片段等）</li><li>非结构化数据（文章、书籍、PDF等）</li></ul><p>   知识库的构建可以从公开资源获取，或者从特定的领域文档中自动化提取。</p><h3 id="2-检索模块（Retriever）"><a href="#2-检索模块（Retriever）" class="headerlink" title="2. 检索模块（Retriever）"></a>2. <strong>检索模块（Retriever）</strong></h3><p>   检索模块的作用是从知识库中找到与用户问题相关的内容。RAG的检索过程通常分为以下几步：</p><ul><li><p><strong>问题向量化</strong>：当用户提出问题时，首先将问题转化为向量表示（Embedding）。通常使用预训练的语言模型（如BERT、RoBERTa）将问题编码为一个固定大小的向量。</p></li><li><p><strong>文档向量化</strong>：在准备阶段，知识库中的每个文档片段（通常是小的段落或句子）也会被提前转化为向量表示，并保存在向量数据库中。</p></li><li><p><strong>检索相关文档</strong>：通过计算用户问题的向量与知识库中所有文档片段向量之间的相似度（例如余弦相似度），从知识库中找到与问题最相关的文档片段。这通常使用近似最近邻搜索算法（如FAISS）来加速检索。</p></li></ul><p>   <strong>典型检索工具</strong>：</p><ul><li><strong>BM25</strong>：一种经典的信息检索算法，基于词频和逆文档频率（TF-IDF）来衡量文档与查询的相关性。</li><li><strong>Dense Retrieval</strong>：基于深度学习的检索方式，使用语言模型（如BERT）生成的稠密向量表示进行检索。</li></ul><h3 id="3-生成模块（Generator）"><a href="#3-生成模块（Generator）" class="headerlink" title="3. 生成模块（Generator）"></a>3. <strong>生成模块（Generator）</strong></h3><p>   在检索到相关文档片段后，生成模块负责结合这些片段生成最终的答案。生成模块通常基于预训练的大型语言模型（如GPT、T5等）。具体步骤如下：</p><ul><li><p><strong>输入拼接</strong>：将原始用户问题和检索到的文档片段一起作为输入，拼接成一个完整的输入序列，提供给生成模型。例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户问题：&quot;什么是机器学习？&quot;</span><br><span class="line">检索到的文档片段：</span><br><span class="line">1. &quot;机器学习是一种通过数据训练算法的技术，用于预测和分类。&quot;</span><br><span class="line">2. &quot;常见的机器学习算法包括线性回归、决策树、神经网络等。&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>生成答案</strong>：生成模型接收这个拼接后的输入，然后基于它生成一个回答。由于检索到的片段为模型提供了上下文，生成的答案将更加准确和领域相关。例如，生成模型可能会输出：“机器学习是一种通过数据训练算法以进行预测和分类的技术，常用算法有线性回归和神经网络。”</p></li></ul><h3 id="4-训练RAG模型"><a href="#4-训练RAG模型" class="headerlink" title="4. 训练RAG模型"></a>4. <strong>训练RAG模型</strong></h3><p>   训练RAG模型的过程中，使用标准的生成任务损失函数（如交叉熵）对生成模块进行优化，并对检索和生成过程进行端到端的联合训练。具体来说：</p><ul><li><strong>监督学习</strong>：训练集通常由问题和答案对组成，同时包含一些相关的文档片段。模型在训练过程中不仅学习如何生成高质量的答案，还会优化检索阶段，使其能选择最相关的文档。</li><li><strong>检索优化</strong>：通过将检索模块与生成模块结合在一起，可以通过生成模块的反馈来优化检索阶段，从而逐步改进文档选择的相关性。</li><li><strong>联合训练</strong>：在一些实现中，检索器和生成器可以联合训练，从而使得检索器学习到更适合生成器的相关文档。</li></ul><h3 id="5-推理过程（Inference-Pipeline）"><a href="#5-推理过程（Inference-Pipeline）" class="headerlink" title="5. 推理过程（Inference Pipeline）"></a>5. <strong>推理过程（Inference Pipeline）</strong></h3><p>   在实际推理过程中，RAG系统通常按以下步骤执行：</p><ul><li><strong>问题输入</strong>：用户提出问题（如“人工智能的主要应用是什么？”）。</li><li><strong>检索文档</strong>：检索模块从知识库中找到与该问题相关的文档片段（如从AI相关文档中找到有关AI应用的片段）。</li><li><strong>生成答案</strong>：将用户问题和检索到的文档片段传递给生成模块，生成基于这些片段的答案。</li><li><strong>返回结果</strong>：最终，RAG系统将生成的答案返回给用户。</li></ul><h3 id="6-RAG的架构图示意"><a href="#6-RAG的架构图示意" class="headerlink" title="6. RAG的架构图示意"></a>6. <strong>RAG的架构图示意</strong></h3><p>RAG的架构可以简要表示为如下流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------------+    用户问题     +------------------+</span><br><span class="line">|  文档知识库      |  -------------&gt;  |   检索模块（Retriever） |</span><br><span class="line">+------------------+                   +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                      检索到的文档片段</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                     |  生成模块（Generator） |</span><br><span class="line">                                     +------------------+</span><br><span class="line">                                              |</span><br><span class="line">                                              |</span><br><span class="line">                                          最终答案</span><br><span class="line">                                              |</span><br><span class="line">                                              v</span><br><span class="line">                                           用户</span><br></pre></td></tr></table></figure><h3 id="7-RAG的实际应用"><a href="#7-RAG的实际应用" class="headerlink" title="7. RAG的实际应用"></a>7. <strong>RAG的实际应用</strong></h3><p>RAG的架构非常适合需要结合外部知识生成回答的任务，如：</p><ul><li><strong>领域问答系统</strong>：在法律、医学、金融等特定领域，RAG可以利用专业文档库进行高质量回答。</li><li><strong>文档生成和扩展</strong>：RAG可以根据输入问题生成具有参考资料的文档内容。</li><li><strong>对话系统</strong>：通过结合知识库，RAG能够在对话中生成更加丰富的内容和背景信息。</li></ul><p>通过以上过程，RAG可以有效结合知识库和生成模型，增强生成任务的知识性和准确性，同时灵活处理领域知识扩展问题。</p><h2 id="大模型微调和RAG对比"><a href="#大模型微调和RAG对比" class="headerlink" title="大模型微调和RAG对比"></a>大模型微调和RAG对比</h2><p>将通用大模型调整为某个特定领域的大模型可以通过两种常见的方法来实现：<code>RAG（Retrieval-Augmented Generation）</code>和大模型微调。两者有不同的侧重点和应用场景。以下是它们的区别：</p><h3 id="RAG（检索增强生成）"><a href="#RAG（检索增强生成）" class="headerlink" title="RAG（检索增强生成）"></a>RAG（检索增强生成）</h3><p>核心思路：<br>RAG通过结合外部知识库与生成模型来增强模型的知识能力，而不改变原有的大模型参数。它会先从特定领域的知识库中检索与问题相关的信息，再基于这些检索到的内容由生成模型生成答案。这种方法不需要直接修改模型本身。</p><p>适用场景：RAG特别适用于知识动态更新较快或知识领域非常广泛的场景。它允许你快速将大模型应用于特定领域，而无需重新训练模型。例如：</p><ul><li>医学、法律、金融等领域，可以通过检索领域文档来增强模型的特定领域能力。</li><li>实时问答或需要最新知识时，RAG可以通过检索更新的知识库提供答案。</li></ul><p>优点：</p><ul><li>不需要重新训练大模型，降低计算成本。</li><li>可以即时应用于不同领域，只需准备领域特定的知识库。</li><li>动态扩展模型的知识，知识库可随时更新，增强模型的实时性和灵活性。</li></ul><p>缺点：</p><ul><li>模型仍依赖于外部知识库的质量和准确性。</li><li>检索部分可能导致效率低下，尤其在大型知识库中。</li></ul><h3 id="大模型微调"><a href="#大模型微调" class="headerlink" title="大模型微调"></a>大模型微调</h3><p>核心思路：大模型微调（Fine-tuning）是通过在特定领域的数据上对通用大模型进行进一步训练，来调整其权重，使其更适合该领域的任务。这种方法会直接改变模型的参数，使模型在特定领域表现更好。</p><p>适用场景：微调适合那些希望模型能够在特定领域有深度理解或执行特定任务的情况。微调后的模型可以直接生成该领域的高质量内容，而无需依赖外部检索。例如：</p><ul><li>某些领域的文本生成、分类、或者预测任务需要模型具备细致的专业知识，微调能够提高模型在这些任务中的表现。</li><li>特定领域的对话系统或写作助手。</li></ul><p>优点：</p><ul><li>通过专门的数据进行训练，模型可以深度适应某个领域，提升其在该领域的表现。</li><li>模型的响应可以是自主生成的，不依赖外部资源，具有更高的效率。</li></ul><p>缺点：</p><ul><li>需要大量的领域特定数据进行训练，数据收集成本高。</li><li>微调模型的计算开销大，尤其是大型模型。</li><li>一旦领域知识发生变化，模型需要重新微调，更新过程相对繁琐。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要使用Java实现场景化的RAG（检索增强生成），每个场景对应不同的知识库，底层采用OpenAI大模型，文档检索数据库使用Elasticsearch，开发工作可以分为以下几步：</p><h3 id="1-管理不同场景的知识库"><a href="#1-管理不同场景的知识库" class="headerlink" title="1. 管理不同场景的知识库"></a>1. <strong>管理不同场景的知识库</strong></h3><ul><li><p><strong>场景区分</strong>：每个场景的知识库可能包含不同的数据集。因此，你需要在Elasticsearch中为每个场景创建单独的索引，便于检索时知道该查询对应哪个知识库。</p></li><li><p><strong>Elasticsearch索引创建</strong>：</p><ul><li>针对每个场景创建不同的索引。例如，你可以为“医学场景”和“法律场景”分别创建索引<code>medical_documents</code>和<code>legal_documents</code>。</li><li>在索引中插入文档片段，并将场景信息作为元数据存储，以便后续检索时区分不同场景。</li></ul></li></ul><p>   <strong>示例：为不同场景创建索引并插入文档</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Elasticsearch client 初始化</span></span><br><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">    RestClient.builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建医学场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">medicalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>);</span><br><span class="line">client.indices().create(medicalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建法律场景的索引</span></span><br><span class="line"><span class="type">CreateIndexRequest</span> <span class="variable">legalIndexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;legal_documents&quot;</span>);</span><br><span class="line">client.indices().create(legalIndexRequest, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文档到医学场景的索引</span></span><br><span class="line"><span class="type">IndexRequest</span> <span class="variable">medicalDocRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;medical_documents&quot;</span>).id(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    .source(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Medical Document&quot;</span>, <span class="string">&quot;content&quot;</span>, <span class="string">&quot;This is a medical document about diseases.&quot;</span>);</span><br><span class="line">client.index(medicalDocRequest, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure></p><h3 id="2-实现检索模块（Retriever）"><a href="#2-实现检索模块（Retriever）" class="headerlink" title="2. 实现检索模块（Retriever）"></a>2. <strong>实现检索模块（Retriever）</strong></h3><ul><li><p><strong>场景选择</strong>：在用户提问时，根据问题确定使用哪个场景的知识库进行检索。可以通过用户输入的特定关键词或上下文来选择相应的场景。例如，如果用户问的是法律相关问题，就选择“法律场景”的知识库。</p></li><li><p><strong>检索文档</strong>：根据用户的输入，从指定场景的知识库中检索相关文档。可以使用Elasticsearch的Java API，根据用户问题在特定索引中进行查询，提取与问题最相关的文档片段。</p></li></ul><p>   <strong>示例：根据场景进行检索</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">retrieveDocuments</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">indexName</span> <span class="operator">=</span> scene.equals(<span class="string">&quot;medical&quot;</span>) ? <span class="string">&quot;medical_documents&quot;</span> : <span class="string">&quot;legal_documents&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(indexName);</span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    searchSourceBuilder.query(QueryBuilders.matchQuery(<span class="string">&quot;content&quot;</span>, userQuery));</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">hits</span> <span class="operator">=</span> searchResponse.getHits();</span><br><span class="line">    List&lt;String&gt; retrievedDocs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">        retrievedDocs.add(hit.getSourceAsMap().get(<span class="string">&quot;content&quot;</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retrievedDocs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-生成模块的实现（OpenAI-大模型调用）"><a href="#3-生成模块的实现（OpenAI-大模型调用）" class="headerlink" title="3. 生成模块的实现（OpenAI 大模型调用）"></a>3. <strong>生成模块的实现（OpenAI 大模型调用）</strong></h3><ul><li><p><strong>OpenAI 模型调用</strong>：当检索到相关的文档片段后，接下来要调用OpenAI的大模型生成答案。你需要将用户问题和检索到的文档片段拼接，作为模型的输入，让模型基于这些片段生成相关的答案。</p></li><li><p><strong>API 集成</strong>：使用Java的HTTP客户端（例如HttpClient）发送请求到OpenAI的API，并获取生成的答案。</p></li></ul><p>   <strong>示例：调用OpenAI大模型API生成答案</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateAnswer</span><span class="params">(String userQuery, List&lt;String&gt; retrievedDocs)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(userQuery);</span><br><span class="line">    <span class="keyword">for</span> (String doc : retrievedDocs) &#123;</span><br><span class="line">        prompt.append(<span class="string">&quot;\n&quot;</span>).append(doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line">    <span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder()</span><br><span class="line">        .uri(URI.create(<span class="string">&quot;https://api.openai.com/v1/completions&quot;</span>))</span><br><span class="line">        .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">        .header(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_OPENAI_API_KEY&quot;</span>)</span><br><span class="line">        .POST(HttpRequest.BodyPublishers.ofString(<span class="string">&quot;&#123;\&quot;model\&quot;: \&quot;gpt-3.5-turbo\&quot;, \&quot;prompt\&quot;: \&quot;&quot;</span> + prompt.toString() + <span class="string">&quot;\&quot;, \&quot;max_tokens\&quot;: 100&#125;&quot;</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line">    <span class="keyword">return</span> response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-实现RAG逻辑"><a href="#4-实现RAG逻辑" class="headerlink" title="4. 实现RAG逻辑"></a>4. <strong>实现RAG逻辑</strong></h3><ul><li><p><strong>场景选择与文档检索</strong>：根据用户问题选择场景，调用相应场景的知识库，检索相关的文档片段。</p></li><li><p><strong>生成答案</strong>：将用户问题与检索到的文档片段拼接，通过OpenAI大模型生成最终答案。</p></li></ul><p>   <strong>示例：综合检索与生成</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">processRAGPipeline</span><span class="params">(String userQuery, String scene)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 根据场景检索文档</span></span><br><span class="line">    List&lt;String&gt; retrievedDocs = retrieveDocuments(userQuery, scene);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用生成模块</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> generateAnswer(userQuery, retrievedDocs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-支持不同场景的用户接口"><a href="#5-支持不同场景的用户接口" class="headerlink" title="5. 支持不同场景的用户接口"></a>5. <strong>支持不同场景的用户接口</strong></h3><ul><li><p><strong>API设计</strong>：你可以为外部应用提供一个统一的接口，支持不同场景的知识库选择。用户可以在请求中指定场景，或让系统根据用户输入自动选择合适的场景。</p></li><li><p><strong>Spring Boot API集成</strong>：使用Spring Boot开发REST API，接收用户请求，并根据请求中的场景信息来调用相应的检索和生成模块。</p></li></ul><p>   <strong>示例：Spring Boot REST API</strong><br>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RagController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/ask&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">askQuestion</span><span class="params">(<span class="meta">@RequestBody</span> QuestionRequest request)</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">scene</span> <span class="operator">=</span> request.getScene();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userQuery</span> <span class="operator">=</span> request.getQuery();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行RAG流程</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">answer</span> <span class="operator">=</span> processRAGPipeline(userQuery, scene);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">QuestionRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String scene;</span><br><span class="line">    <span class="keyword">private</span> String query;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-监控和优化"><a href="#6-监控和优化" class="headerlink" title="6. 监控和优化"></a>6. <strong>监控和优化</strong></h3><ul><li><strong>检索效率优化</strong>：通过优化Elasticsearch查询、配置向量检索或提升索引结构来提高检索效率。</li><li><strong>生成性能优化</strong>：对OpenAI生成的答案进行适当的后处理，例如剪短生成结果，或者通过上下文增强生成效果。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了实现一个基于Java语言、OpenAI大模型和Elasticsearch的RAG系统，你需要完成以下开发工作：</p><ol><li><strong>管理不同场景的知识库</strong>：为每个场景建立不同的Elasticsearch索引。</li><li><strong>实现检索模块</strong>：根据场景检索知识库中的文档片段。</li><li><strong>实现生成模块</strong>：通过调用OpenAI的API生成最终答案。</li><li><strong>实现综合RAG逻辑</strong>：将检索和生成模块结合，构建统一的流程。</li><li><strong>开发用户接口</strong>：通过REST API为用户提供对不同场景的RAG支持。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是RAG&quot;&gt;&lt;a href=&quot;#什么是RAG&quot; class=&quot;headerlink&quot; title=&quot;什么是RAG&quot;&gt;&lt;/a&gt;什么是RAG&lt;/h2&gt;&lt;p&gt;RAG（Retrieval-Augmented Generation）是一种将信息检索（Retrieval）</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>大模型API封装学习</title>
    <link href="https://kelinkong.github.io/2024/10/10/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/"/>
    <id>https://kelinkong.github.io/2024/10/10/llvm-%E5%A4%A7%E6%A8%A1%E5%9E%8BAPI%E5%B0%81%E8%A3%85%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-10-10T10:28:42.000Z</published>
    <updated>2024-10-11T10:20:10.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现背景"><a href="#实现背景" class="headerlink" title="实现背景"></a>实现背景</h2><p>假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理异步请求。</p><p>为什么要做API封装？</p><blockquote><ol><li>保护模型：避免直接暴露模型，保护模型的安全性。</li><li>降低耦合：将模型与业务逻辑分离，降低耦合度。</li><li>与原有的系统对接：将模型封装成API，方便与其他系统对接。</li></ol></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>以下是一个基于 Spring WebFlux 封装 OpenAI API 的完整实现例子，使用 Gradle 管理，项目目录结构为 vo、client 和 biz。</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line"> └── main</span><br><span class="line">     ├── java</span><br><span class="line">     │    └── com</span><br><span class="line">     │         └── example</span><br><span class="line">     │              ├── controller</span><br><span class="line">     │              │    └── OpenAIController.java</span><br><span class="line">     │              ├── biz</span><br><span class="line">     │              │    └── OpenAIService.java</span><br><span class="line">     │              ├── client</span><br><span class="line">     │              │    └── WebClientConfig.java</span><br><span class="line">     │              └── vo</span><br><span class="line">     │                   ├── PromptRequest.java</span><br><span class="line">     │                   └── CompletionResponse.java</span><br><span class="line">     └── resources</span><br><span class="line">          └── application.yml</span><br></pre></td></tr></table></figure><p><strong>配置 WebClient 类 (client&#x2F;WebClientConfig.java)</strong></p><p>WebClientConfig 用于配置 WebClient，这个类将负责与 OpenAI API 的连接。</p><p><strong>业务逻辑 (biz&#x2F;OpenAIService.java)</strong></p><p>OpenAIService 类用于封装调用 OpenAI API 的逻辑，并且通过 WebClient 处理流式响应，返回 <code>Flux&lt;String&gt;</code>。</p><p><strong>数据传输对象 (DTO) (<code>vo/PromptRequest.java</code> 和 <code>vo/CompletionResponse.java</code>)</strong></p><p><code>PromptRequest.java</code>：定义发送给 OpenAI API 的请求体数据结构。</p><p><code>CompletionResponse.java</code>：定义从 OpenAI API 接收到的响应数据结构</p><h2 id="数据传输对象"><a href="#数据传输对象" class="headerlink" title="数据传输对象"></a>数据传输对象</h2><h3 id="响应的数据结构"><a href="#响应的数据结构" class="headerlink" title="响应的数据结构"></a>响应的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletionResponse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Choice&gt; choices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Choice</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private List&lt;Choice&gt; choices;</code> 在<code>CompletionResponse</code>类中扮演以下几个重要角色：</p><ol><li>表示响应中的数据结构：</li></ol><ul><li>choices 字段表示 OpenAI API 响应中的一个重要部分。根据 OpenAI API 的响应格式，生成的文本是以 choices 的形式返回的，每一个 Choice 对象包含一段生成的文本。</li></ul><ol start="2"><li>封装多个 Choice 对象：</li></ol><ul><li>由于 OpenAI API 可以生成多个结果（多个选择），因此需要用 List<Choice> 来封装这些生成的结果。List 是一个集合类，允许存储多个 Choice 对象，每个对象代表一个生成的文本。</li></ul><ol start="3"><li>将 JSON 映射为 Java 对象：</li></ol><ul><li>当 OpenAI API 返回一个包含 choices 的 JSON 数组时，Spring WebFlux 的 WebClient 会将 JSON 映射为 Java 对象。List<Choice> 对应的是 JSON 中的数组，Choice 类中的 text 字段对应 JSON 中每个选项的文本内容。</li></ul><p>假设 OpenAI API 的响应如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Copy code</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the first generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is the second generated text.&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>根据这个 JSON 结构：</p><p><code>choices</code> 是一个数组（List），每个数组元素对应一个 Choice 对象。<br><code>Choice</code> 对象中有一个 text 字段，存储生成的文本。<br><code>private List&lt;Choice&gt; choices</code>; 在这里就是用来存储和处理这个数组，代表生成的多个文本结果。</p><p><strong>在程序中的作用</strong></p><p>当调用 OpenAI 的 API 并接收响应时，Spring 的反序列化机制会将 JSON 数据自动映射到 <code>CompletionResponse</code> <code>中。choices</code> 字段将包含多个生成的文本，每个文本存储在一个 <code>Choice</code> 对象中。</p><p>可以通过以下方式访问生成的文本：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompletionResponse</span> <span class="variable">response</span> <span class="operator">=</span> ... <span class="comment">// 从 API 获取响应</span></span><br><span class="line">List&lt;CompletionResponse.Choice&gt; choices = response.getChoices();</span><br><span class="line"><span class="keyword">for</span> (CompletionResponse.Choice choice : choices) &#123;</span><br><span class="line">    System.out.println(choice.getText());  <span class="comment">// 输出每个生成的文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以逐个处理生成的文本结果。</p><h3 id="请求的数据结构"><a href="#请求的数据结构" class="headerlink" title="请求的数据结构"></a>请求的数据结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PromptRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String model; <span class="comment">// text-davinci-003  gpt-3.5-turbo  code-davinci-002</span></span><br><span class="line">    <span class="keyword">private</span> String prompt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max_tokens;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> top_p;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebClient-配置"><a href="#WebClient-配置" class="headerlink" title="WebClient 配置"></a>WebClient 配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebClientConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> WebClient <span class="title function_">webClient</span><span class="params">(WebClient.Builder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://api.openai.com/v1&quot;</span>)  <span class="comment">// OpenAI API base URL</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_API_KEY&quot;</span>)  <span class="comment">// 替换为你的 OpenAI API Key</span></span><br><span class="line">                .defaultHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是 WebClient？</strong></p><p><code>WebClient</code> 是 Spring WebFlux 提供的一个响应式、非阻塞的 HTTP 客户端，允许应用程序与外部服务进行交互。相比于传统的 RestTemplate，<code>WebClient</code> 能更好地支持异步操作，特别适合处理高并发、低延迟的应用场景。</p><p><code>WebClient </code>允许我们以编程的方式发起 HTTP 请求并处理响应。可以发送 GET、POST、PUT、DELETE 等各种 HTTP 请求，且可以处理 JSON、XML 或其他格式的数据。</p><h4 id="WebClient-的使用步骤"><a href="#WebClient-的使用步骤" class="headerlink" title="WebClient 的使用步骤"></a>WebClient 的使用步骤</h4><ol><li>创建 <code>WebClient</code> 实例：通过 <code>WebClient.Builder</code> 创建 <code>WebClient</code> 实例，可以配置 <code>baseUrl</code>、<code>header</code> 等信息。</li><li>发起请求：使用 <code>WebClient</code> 实例发起请求，可以发送 GET、POST 等请求。</li><li>处理响应：通过 <code>retrieve()</code> 方法获取响应，可以处理响应数据。</li></ol><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 WebClient 实例</span></span><br><span class="line"><span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> WebClient.builder()</span><br><span class="line">    .baseUrl(<span class="string">&quot;https://api.example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望只返回一个结果（比如从 API 返回的单个 JSON 对象），使用 Mono 来处理</span></span><br><span class="line">Mono&lt;String&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/endpoint&quot;</span>)</span><br><span class="line">    .retrieve()  <span class="comment">// 提取响应体</span></span><br><span class="line">    .bodyToMono(String.class);  <span class="comment">// 将响应体转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望返回多个结果（比如从 API 返回的 JSON 数组），使用 Flux 来处理</span></span><br><span class="line">Flux&lt;MyResponseObject&gt; response = webClient.get()</span><br><span class="line">    .uri(<span class="string">&quot;/stream-endpoint&quot;</span>)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToFlux(MyResponseObject.class);  <span class="comment">// 将响应体映射为多个对象</span></span><br></pre></td></tr></table></figure><h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.subscribe(res -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Response: &quot;</span> + res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mono 或 Flux：</p><p>Mono 和 Flux 是响应式编程模型中的核心部分，分别表示单个元素（Mono）或多个元素（Flux）的异步序列。</p><p>这些序列是“惰性”的，意味着它们不会在定义时立刻执行。只有当你“订阅”它们时，数据才会开始流动，或者说，操作才会被真正执行。<br><code>subscribe()</code> 方法：</p><p><code>subscribe() </code>是触发响应式流的关键操作。当你调用 <code>subscribe()</code>，整个请求流程才会被激活和执行。</p><p><code>subscribe()</code> 的参数是一个 Consumer，表示当有数据发出时，你可以定义如何处理这些数据。在这个例子中，res 就是 HTTP 响应体的结果。</p><h3 id="假设和前端进行交互，controller如下"><a href="#假设和前端进行交互，controller如下" class="headerlink" title="假设和前端进行交互，controller如下"></a>假设和前端进行交互，controller如下</h3> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/openai&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIController</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/generate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SseEmitter <span class="title function_">generateText</span><span class="params">(<span class="meta">@RequestBody</span> PromptRequest request)</span> &#123;</span><br><span class="line">        <span class="type">SseEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SseEmitter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 OpenAIService，并逐步推送生成的文本内容</span></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(request);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(</span><br><span class="line">            <span class="comment">// 这是一个 Lambda 表达式，表示每当 Flux&lt;String&gt; 中有新的文本片段 result，服务器会执行这个代码块：</span></span><br><span class="line">                result -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        emitter.send(SseEmitter.event().data(result));  <span class="comment">// 将生成的文本片段作为 SSE 事件发送到客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        emitter.completeWithError(e);  <span class="comment">// 处理异常</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="comment">// 每次 Flux 产生新文本段时，调用这个回调函数，将该段文本发送给客户端。</span></span><br><span class="line">                emitter::completeWithError,  <span class="comment">// 处理错误</span></span><br><span class="line">                emitter::complete  <span class="comment">// 完成</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端发送请求后，服务器返回一个 SseEmitter 对象，告诉客户端这将是一个持续的数据流。</span></span><br><span class="line"><span class="comment">         * SseEmitter 用于推送多次数据（在文本逐步生成的过程中）。</span></span><br><span class="line"><span class="comment">         * 当推送完毕后，SseEmitter 会通过 complete() 方法关闭连接。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SseEmitter"><a href="#SseEmitter" class="headerlink" title="SseEmitter"></a>SseEmitter</h4><p><code>SseEmitter</code> 是 Spring 提供的一个类，用于处理 <code>Server-Sent Events (SSE)</code>，一种服务器端推送技术。<br>通过 <code>SseEmitter</code>，服务器可以持续向客户端发送事件，而客户端只需要建立一次连接即可接收多个事件。<br>SSE 是基于 HTTP 协议的持久连接，这使它在实时数据更新场景中非常有用，例如股票价格、社交媒体通知、实时聊天消息等。</p><h3 id="服务类-biz-OpenAIService-java"><a href="#服务类-biz-OpenAIService-java" class="headerlink" title="服务类 (biz/OpenAIService.java)"></a>服务类 (<code>biz/OpenAIService.java</code>)</h3><ul><li>连接是单向的，服务器推送数据，客户端接收数据。</li><li>客户端通过 <code>EventSource API</code> 来接收服务器推送的事件。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenAIService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OpenAIService</span><span class="params">(WebClient webClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.webClient = webClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给其他组件调用，发送请求到 OpenAI API 并流式返回结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> promptRequest 请求体，包含模型、提示词等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Flux&lt;String&gt; 返回流式响应的每一部分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;String&gt; <span class="title function_">generateText</span><span class="params">(PromptRequest promptRequest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> webClient.post()</span><br><span class="line">                .uri(<span class="string">&quot;/completions&quot;</span>)</span><br><span class="line">                .bodyValue(promptRequest)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToFlux(CompletionResponse.class)  <span class="comment">// 将响应映射为 CompletionResponse 对象</span></span><br><span class="line">                .flatMap(response -&gt; Flux.just(response.getChoices().get(<span class="number">0</span>).getText()));  <span class="comment">// 获取响应的文本部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的组件如何调用这个服务类？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.anothercomponent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.biz.OpenAIService;</span><br><span class="line"><span class="keyword">import</span> com.example.vo.PromptRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OpenAIService openAIService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AnotherComponent</span><span class="params">(OpenAIService openAIService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.openAIService = openAIService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processPrompt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PromptRequest</span> <span class="variable">promptRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PromptRequest</span>();</span><br><span class="line">        promptRequest.setModel(<span class="string">&quot;text-davinci-003&quot;</span>);</span><br><span class="line">        promptRequest.setPrompt(<span class="string">&quot;Explain quantum physics in simple terms.&quot;</span>);</span><br><span class="line">        promptRequest.setMax_tokens(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; responseFlux = openAIService.generateText(promptRequest);</span><br><span class="line"></span><br><span class="line">        responseFlux.subscribe(response -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理每一个返回的文本块</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Generated Text: &quot;</span> + response);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现背景&quot;&gt;&lt;a href=&quot;#实现背景&quot; class=&quot;headerlink&quot; title=&quot;实现背景&quot;&gt;&lt;/a&gt;实现背景&lt;/h2&gt;&lt;p&gt;假设要做openAI的大模型API封装，可以使用Spring WebFlux提供服务，利用其非阻塞、响应式编程模型来高效处理</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-gradle</title>
    <link href="https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/"/>
    <id>https://kelinkong.github.io/2024/10/10/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-gradle/</id>
    <published>2024-10-10T03:30:04.000Z</published>
    <updated>2024-10-10T06:11:54.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><h3 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h3><p>Gradle是一个强大的、基于JVM的构建自动化工具。它使用Groovy或Kotlin语言来编写构建脚本，相较于传统的XML配置方式，更加灵活和易于阅读。</p><h3 id="Gradle核心概念"><a href="#Gradle核心概念" class="headerlink" title="Gradle核心概念"></a>Gradle核心概念</h3><ul><li>项目（Project）：一个Gradle构建的最小单位。</li><li>任务（Task）：构建过程中的具体操作，如编译、测试、打包等。</li><li>构建文件（build.gradle）：定义项目配置和任务的脚本文件。</li><li>插件（Plugin）：扩展Gradle功能的模块，如Java插件、Android插件等。</li></ul><p>Gradle 里的任何东西都是基于这两个基础概念: <code>projects</code> ( 项目 ) 和 <code>tasks</code> ( 任务 ) 。每一个构建都是由一个或多个 <code>projects</code> 构成的，每一个 <code>project</code> 是由一个或多个 <code>tasks</code> 构成的。一个 <code>project</code> 可以代表一个 JAR ，一个网页应用，一个发布的 ZIP 压缩包等。一个<code>tasks</code>就是一段可执行的代码，比如编译代码、运行测试、打包等。</p><p>gradle命令行基本格式：<code>gradle 任务名称</code> ，比如 <code>gradle clean</code>（清空所有编译、打包生成的文件） ，<code>gradle build -x test</code>（跳过测试构建构建）</p><p><code>build.gradle</code>文件是 Gradle 构建脚本的核心，它可以用来定义项目的构建逻辑、依赖管理、插件管理等内容。 该文件通常位于项目根目录下。<br>执行Gradle命令的时候，会默认加载当前目录下的<code>build.gradle</code>脚本文件，你也可以通过 -b 参数指定想要加载执行的文件。</p><p><code>Gradle插件</code>是一种可重用的构建逻辑，它可以提供各种功能来简化构建过程。Gradle中有丰富的插件，例如：application 插件可以打包可执行的Java应用程序,war 插件可以打包Web应用程序。除了官方插件之外，还有很多第三方插件。</p><p><code>Gradle Wrapper</code>是Gradle的一个特性，它能够让我们在不安装Gradle的情况下运行Gradle构建。它是一个shell脚本和一个二进制文件，可以自动下载指定版本的Gradle，并使用该版本运行Gradle构建。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="Project（项目）"><a href="#Project（项目）" class="headerlink" title="Project（项目）"></a>Project（项目）</h3><p>定义: Gradle构建的最小单位，代表一个需要构建的软件系统。</p><p>组成:</p><ul><li>build.gradle文件: 定义项目配置和任务的脚本文件。</li><li>子项目: 一个项目可以包含多个子项目。</li></ul><p>作用:</p><ul><li>组织构建逻辑：将整个构建过程划分成不同的项目，方便管理。</li><li>定义依赖关系：不同项目之间可以存在依赖关系。</li></ul><h3 id="Task（任务）"><a href="#Task（任务）" class="headerlink" title="Task（任务）"></a>Task（任务）</h3><p>定义: 构建过程中的具体操作，是构建的原子单位。</p><p>作用:</p><ul><li>编译源代码</li><li>运行测试</li><li>生成jar包</li><li>打包war包</li><li>自定义任务</li></ul><p>特点:</p><ul><li>有序执行：任务之间可以有依赖关系，确保执行顺序。</li><li>可配置：可以通过参数来配置任务的行为。</li><li>可复用：可以将任务定义为公共任务，在多个项目中共享。</li></ul><h3 id="Plugin（插件）"><a href="#Plugin（插件）" class="headerlink" title="Plugin（插件）"></a>Plugin（插件）</h3><p>定义: 扩展Gradle功能的模块，提供特定领域的构建支持。</p><p>作用:</p><ul><li>添加新的任务：比如Java插件添加了compileJava、test等任务。</li><li>提供新的配置项：比如Java插件提供了sourceSets配置。</li><li>定义新的约定：比如Java插件定义了源代码和资源的默认目录结构。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;java&#x27;</span> <span class="comment">//  通过应用这个插件，Gradle知道这是一个Java项目，并会自动配置一些默认的任务和约定。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123; <span class="comment">// 配置仓库。</span></span><br><span class="line">    mavenCentral() <span class="comment">// mavenCentral() 表示使用Maven中央仓库。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123; <span class="comment">// 声明依赖。</span></span><br><span class="line">    implementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义任务</span></span><br><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">&#x27;Hello, Gradle!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项目"><a href="#多项目" class="headerlink" title="多项目"></a>多项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-project</span><br><span class="line">├── settings.gradle</span><br><span class="line">├── core</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── web</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">└── build.gradle</span><br></pre></td></tr></table></figure><p>类似cmake的多项目构建，每个项目都有自己的<code>build.gradle</code>文件，根目录下的<code>settings.gradle</code>文件用来定义项目的结构。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;core&#x27;</span>, <span class="string">&#x27;web&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多个脚本"><a href="#多个脚本" class="headerlink" title="多个脚本"></a>多个脚本</h3><p>当依赖项过多时，可以将依赖项提取到一个单独的文件中，然后在<code>build.gradle</code>中引入（<code>dependencies.gradle</code>）。</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">apply <span class="attr">from:</span> <span class="string">&#x27;dependencies.gradle&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>脚本包含: apply from语句告诉Gradle去包含另一个脚本文件，就好像把那个脚本文件的内容直接复制粘贴到当前脚本中一样。</li><li>执行顺序: apply from语句通常放在 plugins 块之后，这样被包含的脚本就可以访问插件提供的功能。</li></ul><p>在build脚本中引用 <code>gradle.properties</code></p><ul><li>直接使用属性: Gradle会自动将 <code>gradle.properties</code> 中定义的属性加载到当前构建脚本的上下文中，可以直接使用 <code>$propertyName</code> 的方式引用。</li><li>使用 <code>ext</code> 对象: Gradle提供了一个 <code>ext</code> 对象，可以用来存储自定义的属性。可以在 <code>build.gradle</code> 中将 g<code>radle.properties</code> 中的属性赋值给 <code>ext</code> 对象，然后通过 <code>ext.propertyName</code> 的方式引用。</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gradle.properties</span></span><br><span class="line">version=<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">myProperty=value</span><br><span class="line"></span><br><span class="line"><span class="comment">// build.gradle</span></span><br><span class="line">println <span class="string">&quot;Project version: $version&quot;</span></span><br><span class="line"></span><br><span class="line">ext.myCustomProperty = <span class="string">&quot;custom value&quot;</span></span><br><span class="line">println <span class="string">&quot;Custom property: $&#123;ext.myCustomProperty&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="buildscript"><a href="#buildscript" class="headerlink" title="buildscript"></a>buildscript</h3><p>在Gradle构建脚本中，buildscript 块主要用于配置构建脚本本身的依赖和环境。它定义了构建脚本在执行过程中所需要的资源。</p><p>ext {} 和 repositories {} 是 buildscript 块中的两个重要的配置块：</p><ul><li>ext {}： 用于定义扩展属性。这些属性可以在整个构建脚本中被引用，提供了一种灵活的方式来存储和共享配置信息。</li><li>repositories {}： 用于配置仓库地址。这些仓库是 Gradle 下载插件和依赖的来源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是Gradle&quot;&gt;&lt;a href=&quot;#什么是Gradle&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Axios学习笔记</title>
    <link href="https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://kelinkong.github.io/2024/10/08/axios%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-10-08T06:57:00.000Z</published>
    <updated>2024-10-08T07:38:18.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。</p><p>教程参考：<a href="https://www.axios-http.cn/docs/intro">Axios教程</a></p><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p><strong>promise是什么？</strong>(简要理解，详细理解放到后面)</p><blockquote><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>这里还是以项目中的实际使用为例。</p><p>首先看一个完整的HTTP请求示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> /login <span class="variable constant_">HTTP</span>/<span class="number">1.1</span>   <span class="comment">// 请求行</span></span><br><span class="line"><span class="title class_">Host</span>: example.<span class="property">com</span>    <span class="comment">// 请求头</span></span><br><span class="line"><span class="title class_">Content</span>-<span class="title class_">Type</span>: application/json <span class="comment">// 指明请求体的格式</span></span><br><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt; <span class="comment">// 指明身份验证信息</span></span><br><span class="line"></span><br><span class="line">&#123;  <span class="comment">// 请求体</span></span><br><span class="line">  <span class="string">&quot;username&quot;</span>: <span class="string">&quot;john_doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;password&quot;</span>: <span class="string">&quot;secret123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中，需要发送请求到后端，所以需要配置一个axios实例，这样可以统一配置请求头等信息。<a href="https://www.axios-http.cn/docs/req_config">请求配置参考</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_BASE_URL</span> = <span class="string">&#x27;http://localhost:8080/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义实例的默认配置</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="参数传递位置"><a href="#参数传递位置" class="headerlink" title="参数传递位置"></a>参数传递位置</h3><p><strong>Query参数</strong>：在URL中传递参数，如<code>/project?userId=1</code>，后端使用<code>@RequestParam</code>接收</p><ul><li>位置：参数作为查询字符串附加在 URL 之后，例如：&#x2F;project?userId&#x3D;12345。</li><li>用途：通常用于 GET 请求，适合传递简单的键值对参数。</li></ul><p><strong>路径参数</strong>：在URL中传递参数，如<code>/project/1</code>, 后端使用<code>@PathVariable</code>接收</p><ul><li>位置：参数作为 URL 路径的一部分，例如：&#x2F;project&#x2F;12345。</li><li>用途：通常用于 RESTful API 中的资源标识，适合传递资源 ID 等信息</li></ul><p><strong>请求体参数</strong>：在请求体中传递参数，如<code>&#123;userId: 1&#125;</code>, 后端使用<code>@RequestBody</code>接收</p><ul><li>位置：参数作为请求体的一部分，例如：{userId: 12345}。</li></ul><p><strong>示例：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Query 参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getProjectsByUserId</span> = (<span class="params">userId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">get</span>(<span class="string">`/project`</span>, &#123; </span><br><span class="line">        <span class="attr">params</span>: &#123;</span><br><span class="line">            <span class="attr">userId</span>: userId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路径参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">deleteProjectById</span> = (<span class="params">projectId</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">delete</span>(<span class="string">`/project/<span class="subst">$&#123;projectId&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用请求体参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">addProject</span> = (<span class="params">project</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> instance.<span class="title function_">post</span>(<span class="string">`/project/add`</span>, project);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>拦截器可以在请求或响应被 then 或 catch 处理前拦截它们。</p><p>在项目中使用到了请求拦截器，每次请求时自动将 token 添加到请求头中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>响应拦截器：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>Axios返回的是一个Promise对象，所以可以使用<code>then</code>和<code>catch</code>方法处理响应。</p><p>一个响应结构应该包含如下信息：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  <span class="attr">data</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  <span class="attr">statusText</span>: <span class="string">&#x27;OK&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 是服务器响应头</span></span><br><span class="line">  <span class="comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是 `axios` 请求的配置信息</span></span><br><span class="line">  <span class="attr">config</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  <span class="attr">request</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>.then()</code>方法处理响应：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>在项目中没有使用统一的错误处理机制，所以错误处理参考：<a href="https://www.axios-http.cn/docs/handling_errors">错误处理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java开发实训项目中，使用到了Axios来发送请求，所以学习了Axios的使用。&lt;/p&gt;
&lt;p&gt;教程参考：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="frontend" scheme="https://kelinkong.github.io/categories/frontend/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-JWT</title>
    <link href="https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/"/>
    <id>https://kelinkong.github.io/2024/10/08/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JWT/</id>
    <published>2024-10-08T02:00:10.000Z</published>
    <updated>2024-10-08T03:56:44.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java实战项目中，对于登陆操作，想要达到下面的效果：</p><ul><li>登陆成功后，登陆的状态保持一段时间，不需要重复登陆</li></ul><p>实现登陆保持功能可以使用session和cookie，但是这种方式有一些问题：</p><ul><li>session和cookie是存储在服务端的，如果服务端重启，session和cookie会丢失</li><li>对于分布式系统，session和cookie需要做共享，增加了复杂度</li></ul><p>所以在该项目中，我使用JWT做登陆保持。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JWT（JSON Web Token）是一种基于JSON的开放标准（RFC 7519），用于在网络上传输声明的一种方式。JWT是一种轻量级的身份验证和授权的方式，可以在用户和服务器之间传递安全可靠的信息。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>一旦 JWT 签发了，就不能撤回，除非改密钥。（在到期时间之前，都是有效的）</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>用户登录时，服务器验证用户身份。</li><li>如果验证通过，服务器生成一个包含用户信息的 JWT 并返回给客户端。</li><li>客户端将 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。(可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。)</li><li>服务器每次根据 Token 验证用户身份，无需存储任何会话信息。</li></ul><h3 id="前端需要做什么？"><a href="#前端需要做什么？" class="headerlink" title="前端需要做什么？"></a>前端需要做什么？</h3><p>前端需要在用户登录成功后，将服务器返回的 JWT 存储在本地存储或 Cookie 中，并在后续请求的 Authorization 头中携带该 Token。</p><p>用户登陆成功后，将服务器返回的 Token 存储在本地存储中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, token);</span><br></pre></td></tr></table></figure><p>后续请求时，需要在请求头携带token。</p><p>如果每一个请求都手动去携带 Token，会很麻烦，所以可以使用 Axios 拦截器来实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="variable constant_">API_BASE_URL</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token) &#123;</span><br><span class="line">            config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="后端实现"><a href="#后端实现" class="headerlink" title="后端实现"></a>后端实现</h3><p>后端需要实现以下功能：</p><ul><li>JWT工具类，用于生成和解析（验证）Token</li><li>过滤器，用于过滤前端所有的请求，验证Token的有效性</li><li>Web配置，将过滤器注册到Spring容器中</li></ul><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h4><p>生成和解析Token的工具类，使用了 jjwt 库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//设置密钥（要想非对称加密这里换成私钥）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收业务数据,生成token并返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;claims&quot;</span>, claims) <span class="comment">//token中加入用户信息</span></span><br><span class="line">                .withExpiresAt(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">12</span>)) <span class="comment">//设置超时时间</span></span><br><span class="line">                .sign(Algorithm.HMAC256(KEY)); <span class="comment">//设置加密类型及密钥</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收token,验证token,并返回业务数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">parseToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">//去除token的前缀标记&quot;Bearer &quot;</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">newToken</span> <span class="operator">=</span> token.contains(<span class="string">&quot;Bearer &quot;</span>)?token.substring(<span class="string">&quot;Bearer &quot;</span>.length()):token;</span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(KEY))</span><br><span class="line">                .build()</span><br><span class="line">                .verify(newToken)</span><br><span class="line">                .getClaim(<span class="string">&quot;claims&quot;</span>)</span><br><span class="line">                .asMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>过滤器用于过滤前端所有的请求，验证Token的有效性。</p><p>创建一个认证对象，将用户信息放入认证对象中，然后将认证对象放入SecurityContextHolder中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is called by the filter chain to filter the request.</span></span><br><span class="line"><span class="comment">        * 所有的请求都会经过这个方法，我们可以在这里进行token的解析和用户的认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getTokenFromRequest(request);</span><br><span class="line">        logger.info(<span class="string">&quot;Token: &quot;</span> + token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; claims = JwtUtil.parseToken(token);</span><br><span class="line">                <span class="keyword">if</span> (claims != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> getAuthentication(claims);</span><br><span class="line">                    authentication.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (TokenExpiredException e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                response.getWriter().write(<span class="string">&quot;Token expired&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to extract the token from the request.</span></span><br><span class="line"><span class="comment">        * 从请求中提取token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getTokenFromRequest</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">bearerToken</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (bearerToken != <span class="literal">null</span> &amp;&amp; bearerToken.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> bearerToken.substring(<span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * This method is used to create an authentication object.</span></span><br><span class="line"><span class="comment">        * 创建一个认证对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(Map&lt;String, Object&gt; claims)</span> &#123;</span><br><span class="line">        <span class="comment">// Implement token parsing and authentication creation logic</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(claims, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Web配置"><a href="#Web配置" class="headerlink" title="Web配置"></a>Web配置</h4><ul><li>将过滤器注册到Spring容器中。</li><li>跨域配置。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Configures the security filter chain that carries out authentication and authorization.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> http the HttpSecurity object to configure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the SecurityFilterChain object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if an error occurs during configuration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .csrf(AbstractHttpConfigurer::disable)</span><br><span class="line">                .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                        .requestMatchers(<span class="string">&quot;/api/user/login&quot;</span>).permitAll()</span><br><span class="line">                        .anyRequest().authenticated()</span><br><span class="line">                )</span><br><span class="line">                .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))</span><br><span class="line">                .addFilterBefore(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsConfigurationSource <span class="title function_">corsConfigurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedOrigins(List.of(<span class="string">&quot;http://localhost:9000&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(List.of(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>));</span><br><span class="line">        configuration.setAllowedHeaders(List.of(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JWT结构示例"><a href="#JWT结构示例" class="headerlink" title="JWT结构示例"></a>JWT结构示例</h2><p>JWT 由三部分组成，分别是 Header、Payload 和 Signature，它们之间使用 . 分隔。</p><p><strong>示例</strong></p><ol><li>Header：头部包含 JWT 的类型和使用的签名算法<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Header 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure></li><li>Payload：它包含用户的声明信息，例如用户的 ID、用户名等。这些信息通常包括注册声明、自定义声明等<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Payload 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure></li><li>Signature：签名是对 Header 和 Payload 的签名，防止数据被篡改<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>经过 Base64Url 编码后的 Signature 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure>最终生成的 JWT 是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</span><br></pre></td></tr></table></figure></li></ol><p>解码后的结构：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header: &#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">Payload: &#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">Signature: HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java实战项目中，对于登陆操作，想要达到下面的效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;登陆成功后，登陆的状态保持一段时间，不需要重复登陆&lt;/l</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>包管理器相关</title>
    <link href="https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>https://kelinkong.github.io/2024/09/30/%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2024-09-30T03:14:49.000Z</published>
    <updated>2024-09-30T03:39:32.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。</p><p>到现在已经接触到很多包管理器，比如 <code>npm</code>、<code>yarn</code>、<code>pip</code>、<code>brew</code>、<code>apt</code>、<code>yum</code>、<code>docker</code>、<code>composer</code> 等等。</p><p>于是想到，这些包管理器都是怎么实现的呢？它们之间有什么区别呢？</p><h2 id="什么是包管理器"><a href="#什么是包管理器" class="headerlink" title="什么是包管理器"></a>什么是包管理器</h2><p>包管理器是一种工具，用于自动化管理软件包（libraries, dependencies）的下载、安装、更新和卸载。它帮助开发人员轻松处理项目所需的依赖项，确保不同的库和工具能够正确地协同工作。</p><p>如果不使用包管理器，那么就需要手动下载、安装、更新和卸载软件包，这样会导致很多问题，比如版本冲突、依赖关系、安装路径等等。</p><h2 id="包管理器的包是从哪里来的呢？"><a href="#包管理器的包是从哪里来的呢？" class="headerlink" title="包管理器的包是从哪里来的呢？"></a>包管理器的包是从哪里来的呢？</h2><p>包管理器的包通常存储在一个或多个远程仓库中，开发人员可以从这些仓库中下载所需的软件包。这些仓库通常由软件的开发者或维护者维护，确保软件包的安全性和可靠性。</p><p>有些包管理的仓库服务器在国外，下载速度可能会比较慢，所以有些国内的公司会搭建自己的镜像仓库，比如淘宝的 <code>npm</code> 镜像、阿里云的 <code>docker</code> 镜像等等。（这里涉及到更换源）</p><p>那么理论上来说，也可以在本地搭建一个仓库，然后使用包管理器从本地仓库下载软件包。</p><h2 id="包管理器的作用"><a href="#包管理器的作用" class="headerlink" title="包管理器的作用"></a>包管理器的作用</h2><ul><li>安装依赖项：根据项目的配置文件（如<code>package.json</code>、<code>pom.xml</code>等），自动下载并安装项目所需的依赖包。</li><li>版本管理：包管理器能够处理依赖包的版本，确保项目使用兼容的版本，避免版本冲突。</li><li>更新：可以检查并更新到某个包的最新版本，或者锁定在特定版本。</li><li>卸载：移除不再需要的依赖包。</li></ul><h2 id="包管理器的分类"><a href="#包管理器的分类" class="headerlink" title="包管理器的分类"></a>包管理器的分类</h2><h3 id="1-操作系统级别的包管理器"><a href="#1-操作系统级别的包管理器" class="headerlink" title="1. 操作系统级别的包管理器"></a>1. 操作系统级别的包管理器</h3><p>这些包管理器用于管理操作系统中的软件包和库，通常用于安装和管理操作系统级别的应用程序和工具。它们主要处理的是操作系统中的二进制文件或预编译的软件包</p><ul><li>APT (Advanced Package Tool)：Debian 和 Ubuntu 系统上常用的包管理器。</li><li>YUM (Yellowdog Updater, Modified)：CentOS、RHEL 系统上的包管理器。</li><li>brew：macOS 上的包管理器。</li><li>Chocolatey：Windows 上的包管理器。</li></ul><h3 id="2-编程语言级别的包管理器"><a href="#2-编程语言级别的包管理器" class="headerlink" title="2. 编程语言级别的包管理器"></a>2. 编程语言级别的包管理器</h3><p>这些包管理器用于管理编程语言中的软件包和库，通常用于安装和管理项目级别的依赖项。它们主要处理的是源代码或库文件，通常会下载源代码并编译安装。</p><ul><li>npm (Node Package Manager)：JavaScript 的包管理器，用于 Node.js 项目。</li><li>yarn：JavaScript 的包管理器，用于 Node.js 项目。</li><li>pip：Python 的包管理器。</li><li>Maven：管理 Java 项目的依赖项和构建的工具。</li><li>Gradle：更灵活的构建和依赖管理工具，适用于多种编程语言，包括 Java。</li></ul><h2 id="版本管理器"><a href="#版本管理器" class="headerlink" title="版本管理器"></a>版本管理器</h2><p>这里的版本管理器指conda、nvm、rbenv、pyenv等，它们用于管理不同版本的编程语言或工具。</p><ul><li>conda：Python 的版本管理器，用于创建和管理 Python 环境。</li><li>nvm (Node Version Manager)：Node.js 的版本管理器，用于管理 Node.js 的不同版本。</li></ul><p>在踩坑之前，我觉得conda、nvm都很麻烦，我使用一个版本的python就好了，为什么还需要去做多个版本管理？</p><p>但是在实际开发中，有一次是安装别的工具，这个工具自己下载了一个合适的python版本，并且将我默认的python版本改成了这个版本，导致我之前的项目无法运行，当时的解决方式是更换环境变量，但是这种手动的切换十分麻烦，所以版本管理器就显得很有必要了。</p><p>像node.js也是一样，不同的版本就会出现各种问题，所以本地配置往往需要很多个版本去适应不同的项目。</p><blockquote><p>使用 <code>pip</code> 在不同的 <code>Python</code> 版本（如 Python 3.10 和 Python 3.11）下安装包时，包不能直接在另一个版本下使用，因为每个 <code>Python</code> 版本有自己独立的环境和库安装路径。切换 <code>Python</code> 版本后，之前为另一个版本安装的包不会自动可用。</p><p>正确的做法是为每个 <code>Python</code> 项目指定一个独立的虚拟环境。这样可以确保每个项目拥有独立的依赖项，避免不同项目之间产生冲突或兼容性问题。虚拟环境允许隔离项目的 <code>Python</code> 版本和包管理，使得每个项目可以使用其特定的 <code>Python</code> 版本和依赖库。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>CMake算是一个包管理器吗？</strong></p><p>我们都知道Cmake的功能是用于管理项目的构建过程，它可以生成Makefile、Visual Studio项目文件等，但是它并不是一个包管理器，它只是一个构建工具。</p><p><strong>CMake并不能自动下载和安装依赖项，需要提前安装好，并且在CMakeLists.txt 中指定依赖项</strong></p><p>那么，C++是如何做包管理的呢？（程序员手动管理哈哈）</p><p>C++没有像Java、Python、JavaScript那样有一个统一的包管理器，不过有一些第三方的包管理器，比如：</p><ul><li>Conan：C++ 的包管理器，用于管理 C++ 项目的依赖项。</li><li>vcpkg：微软开发的 C++ 包管理器，用于管理 C++ 项目的依赖项。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每次配置什么环境都是从网上找个教程，然后安装教程一步步走，遇到问题继续搜索，直到配置完成。&lt;/p&gt;
&lt;p&gt;到现在已经接触到很多包管理器，比如</summary>
      
    
    
    
    
    <category term="architecture" scheme="https://kelinkong.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>Java学习笔记-AOP</title>
    <link href="https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/"/>
    <id>https://kelinkong.github.io/2024/09/30/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/</id>
    <published>2024-09-30T02:19:44.000Z</published>
    <updated>2024-10-22T06:46:03.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业务逻辑和横切关注点分离开来，提高代码的可维护性和可扩展性。</p><p>这里他举了一个例子，例如每个方法都需要统计运行时间，如果不使用AOP，那么每个方法都需要添加统计时间的代码，这样会导致代码冗余，可维护性差。使用AOP，只需要在一个地方添加统计时间的代码，就可以实现所有方法的统计时间。</p><p>这个思想和设计模式中的装饰器模式有点类似，都是在不改变原有代码的情况下，添加新的功能。</p><p>假设用装饰器模式来实现，应该怎么实现呢？</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p><strong>装饰器模式是面向对象的思想</strong>，它允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是继承关系的一个替代方案。</p><ol><li>定义 Service 接口：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>原始实现 ServiceImpl：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 原始任务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Performing the task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>定义装饰器类 ServiceDecorator：</li></ol><p>装饰器类实现了 Service 接口，并组合了一个 Service 实例。我们通过组合模式，将对原始对象的调用进行包装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceDecorator</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Service decoratedService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServiceDecorator</span><span class="params">(Service decoratedService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.decoratedService = decoratedService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用装饰器类：</li></ol><p>现在，可以使用装饰器模式为 ServiceImpl 添加统计运行时间的功能，而无需修改原始 ServiceImpl 类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用装饰器包装原始服务类</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">decoratedService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceDecorator</span>(service);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法，自动统计运行时间</span></span><br><span class="line">        decoratedService.performTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用AOP又该怎么实现呢？</p><h2 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h2><p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p><p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。</p><p>以上是我搜索到的内容，但是“面向切面编程”确实抽象，难以理解。</p><p>如果核心是不侵入原始代码去增加一些功能。</p><p>那么这里很容易联想到C++中的函数指针、回调函数以及后面出现的Lambda表达式，这些都是在函数调用时，传递的是函数的地址，而不是函数的返回值。这样就可以在函数调用前后，执行一些操作。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>这里都以Lambda表达式为例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用lambda传递行为</span></span><br><span class="line">        performTask(() -&gt; System.out.println(<span class="string">&quot;Task executed!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">performTask</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">performTask</span>([]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Task executed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者在形式上没有什么很大的区别。</p><p>但在实现上还是有一些区别：</p><table><thead><tr><th>特性</th><th>Java AOC</th><th>C++ 函数作为参数传入</th></tr></thead><tbody><tr><td>传递方式</td><td>通过实现接口或继承类创建匿名类实例</td><td>通过函数指针、函数对象、lambda 传递函数</td></tr><tr><td>类型要求</td><td>必须实现接口或继承类</td><td>直接传递函数，使用函数指针或 lambda</td></tr><tr><td>语法简洁性</td><td>Java 8 之前语法较冗长，Java 8 后可用 lambda 简化</td><td>Lambda 语法较简洁，函数指针较底层</td></tr><tr><td>捕获上下文</td><td>只能捕获 final 或 effectively final 变量</td><td>可以捕获任意上下文变量，提供闭包特性</td></tr><tr><td>灵活性</td><td>必须依赖接口或类</td><td>不需要接口，函数指针和 lambda 都可以使用</td></tr><tr><td>性能</td><td>由于会生成匿名内部类的实例，可能开销较大</td><td>函数指针直接传递，效率更高</td></tr></tbody></table><p><strong>尽管思想上相似，但两者在实现上有所不同：</strong></p><ul><li><p>Java 更加面向对象。Java 中，匿名内部类和 Lambda 本质上是依赖接口或者类的实现，体现了 Java 面向对象的特性。即便在 Java 8 之后使用 Lambda，依然是函数式接口的简化语法。这意味着 Java 的行为参数化是通过类或接口来进行的。</p></li><li><p>C++ 更加底层。C++ 允许更直接地操作函数本身，既可以通过函数指针传递行为，也可以通过 Lambda 捕获上下文变量，并将其作为参数传递。这种设计体现了 C++ 语言的灵活性，不需要依赖面向对象的设计。C++ 中的函数传递更接近于函数式编程的思想</p></li></ul><h2 id="使用AOP来实现开头提到的统计时间功能"><a href="#使用AOP来实现开头提到的统计时间功能" class="headerlink" title="使用AOP来实现开头提到的统计时间功能"></a>使用AOP来实现开头提到的统计时间功能</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 声明这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 让 Spring 容器能够管理这个切面。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutionTimeAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义切点：匹配所有在 com.example.service 包下的类和它们的所有方法</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 记录开始时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录结束时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印方法执行时间</span></span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配所有在 <code>com.example.service</code> 包下的类和它们的所有方法，所以当执行 <code>com.example.service</code> 包下的任意方法时，都会执行 <code>logExecutionTime</code> 方法。</p><h2 id="AOP的关键术语"><a href="#AOP的关键术语" class="headerlink" title="AOP的关键术语"></a>AOP的关键术语</h2><ul><li><strong>切面（Aspect）</strong>：切面是一个类，它包含了一些横切关注点（例如日志记录、事务管理）。在 Spring AOP 中，切面是通过 <code>@Aspect</code> 注解声明的 Java 类。</li><li><strong>连接点（Join Point）</strong>：连接点是在应用执行过程中能够插入切面的点。这些点可以是方法的调用、方法的执行、异常的处理等。在 Spring AOP 中，连接点总是表示方法的执行。</li><li><strong>通知（Advice）</strong>：通知是切面在特定连接点（Join Point）执行的动作。在 Spring AOP 中，有以下几种类型的通知：<ul><li><strong>前置通知（Before Advice）</strong>：在连接点之前执行的通知。</li><li><strong>后置通知（After Advice）</strong>：在连接点之后执行的通知，无论连接点是否正常执行。</li><li><strong>返回通知（After Returning Advice）</strong>：在连接点正常执行后执行的通知。</li><li><strong>异常通知（After Throwing Advice）</strong>：在连接点抛出异常后执行的通知。</li><li><strong>环绕通知（Around Advice）</strong>：在连接点之前和之后执行的通知。</li></ul></li><li><strong>切点（Pointcut）</strong>：切点是一个表达式，它定义了哪些连接点应该被通知。在 Spring AOP 中，切点使用 <code>@Pointcut</code> 注解定义。</li><li><strong>目标对象（Target Object）</strong>：被一个或多个切面通知的对象。</li><li><strong>代理对象（Proxy Object）</strong>：在 Spring AOP 中，代理对象是 Spring 框架创建的对象，它包含了目标对象的增强方法。</li><li><strong>织入（Weaving）</strong>：织入是将切面应用到目标对象并创建代理对象的过程。织入可以发生在编译时、类加载时、运行时。</li><li><strong>引入（Introduction）</strong>：引入允许向现有的类添加新方法和属性。Spring AOP 不支持引入。</li></ul><h3 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h3><p>我们有一个 <code>UserService</code> 类，它有一个 <code>login</code> 方法，登录时我们希望记录这个方法的执行时间。</p><ol><li>目标对象 (Target Object):<br>这是我们想要增强的对象，也就是 <code>UserService</code> 类中的 <code>login</code> 方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟登录逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;User &quot;</span> + username + <span class="string">&quot; is logging in.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>切面 (Aspect):我们创建一个切面，用于记录方法执行时间的逻辑。</li></ol><p>当以@Aspect作为注解时，Spring就会知道这是一个切面，然后就可以通过各类注解来进行通知了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 切点 (Pointcut) - 指定在哪些方法上应用增强逻辑</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allUserServiceMethods</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 通知 (Advice) - 具体的增强逻辑，这里使用环绕通知来记录执行时间</span></span><br><span class="line">    <span class="meta">@Around(&quot;allUserServiceMethods()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logExecutionTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> joinPoint.proceed(); <span class="comment">// 执行目标方法</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">        System.out.println(joinPoint.getSignature() + <span class="string">&quot; executed in &quot;</span> + executionTime + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>当我们调用 login 方法时，增强逻辑（记录执行时间）会自动插入：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">userService.login(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;password123&quot;</span>);</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User Alice is logging in.</span><br><span class="line">void UserService.login(String, String) executed in 50ms</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用AOP实现数据库操作"><a href="#使用AOP实现数据库操作" class="headerlink" title="使用AOP实现数据库操作"></a>使用AOP实现数据库操作</h2><p>在AOP出现之前，使用JDBC操作数据库，往往需要：<br><img src="/../imgs/image-56.png"><br>但其中的，获取数据库连接、回滚、提交、释放连接，其实都是通用的。</p><p><img src="/../imgs/image-57.png"></p><p>使用注解<code>@Transactional</code>，就表明了该方法需要事物执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;公司培训的前辈提到：AOP可以理解为添加了一个代理类，这个代理类可以在方法执行前后添加一些操作，比如日志记录、事务管理等。这样就可以将核心业</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-单元测试</title>
    <link href="https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://kelinkong.github.io/2024/09/26/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2024-09-26T02:18:29.000Z</published>
    <updated>2024-09-26T02:59:50.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Mockito和JUnit5进行单元测试。</p><p>需要注入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>使用@Test注解标记测试方法。</li><li>测试代码和被测试代码放到同一个包中。</li></ul><h3 id="示例背景"><a href="#示例背景" class="headerlink" title="示例背景"></a>示例背景</h3><ul><li>假设有一个服务类<code>MockService</code>，其中有一个<code>serviceMethod</code>方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个临时类<code>MockTmp</code>，其中有一个<code>tmpMethod</code>方法。<code>MockTmp</code>的构造器需要传入一个<code>MockService</code>对象。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>假设有一个被测试类<code>MockUser</code>，其中包含了<code>MockService</code>类、一个私有方法、一个静态方法、一个公有方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>测试将会覆盖：私有方法测试、静态方法测试、公有方法测试、构造器测试。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建Mock对象"><a href="#创建Mock对象" class="headerlink" title="创建Mock对象"></a>创建Mock对象</h3><ol><li>使用<code>@Mock</code>注解或<code>Mockito.mock</code>方法创建Mock对象。</li><li>使用<code>@Spy</code>注解或<code>Mockito.spy</code>方法创建Mock对象。</li><li>使用<code>MockBean</code>注解创建Mock对象。</li><li>使用<code>@InjectMocks</code>注解或<code>MockitoAnnotations.initMocks</code>方法注入Mock对象。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mock</span></span><br><span class="line"><span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Spy</span></span><br><span class="line"><span class="meta">@InjectMocks</span></span><br><span class="line"><span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">    MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>@Mock</code>和<code>@Spy</code>注解的区别：</p><ul><li><code>@Mock</code>注解创建的对象是一个真正的Mock对象，它会覆盖被Mock的方法。</li><li><code>@Spy</code>注解创建的对象是一个真实的对象，它会保留被Mock的方法的原始实现。</li></ul><h3 id="Mock方法"><a href="#Mock方法" class="headerlink" title="Mock方法"></a>Mock方法</h3><ol><li>使用<code>Mockito.when</code>方法模拟方法调用。</li><li>使用<code>Mockito.doReturn</code>方法模拟方法调用。</li><li>使用<code>Mockito.doThrow</code>方法模拟方法调用。</li><li>使用<code>Mockito.doNothing</code>方法模拟方法调用。</li><li>使用<code>Mockito.doAnswer</code>方法模拟方法调用。<br>…</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.when(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)).thenReturn(<span class="string">&quot;Hello, Tom!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doReturn(<span class="string">&quot;Hello, Tom!&quot;</span>).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mockito.doNothing().when(mockService).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="verify方法和assert方法"><a href="#verify方法和assert方法" class="headerlink" title="verify方法和assert方法"></a>verify方法和assert方法</h3><ol><li>使用<code>Mockito.verify</code>方法验证方法调用。</li><li>使用<code>Assert.assertEquals</code>方法断言方法调用。</li><li>使用<code>Assert.assertTrue</code>方法断言方法调用。<br>…<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mockito.verify(mockService, Mockito.times(<span class="number">1</span>)).serviceMethod(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">Assert.assertEquals(<span class="string">&quot;Hello, Tom!&quot;</span>, mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">Assert.assertTrue(<span class="string">&quot;Hello, Tom!&quot;</span>.equals(mockService.serviceMethod(<span class="string">&quot;Tom&quot;</span>)));</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="测试私有方法"><a href="#测试私有方法" class="headerlink" title="测试私有方法"></a>测试私有方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过反射调用私有方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mockito无法直接模拟私有方法，需要通过反射调用。</p><h3 id="测试静态方法"><a href="#测试静态方法" class="headerlink" title="测试静态方法"></a>测试静态方法</h3><p><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">    name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">    assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试公有方法"><a href="#测试公有方法" class="headerlink" title="测试公有方法"></a>测试公有方法</h3><p>被调用的所有方法都mock掉，只测试公有方法。这样可以保证测试的是公有方法的逻辑，而不是依赖的其他方法。<br><strong>被测方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">        <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">        <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">        <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">        <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">        <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试方法</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">    Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">    <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">    <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">    <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">        MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">            Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        )&#123;</span><br><span class="line"></span><br><span class="line">        mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后输出的结果是<code>test test private test test test</code>。</p><p>可以看出，只有<code>privateMethod</code>方法没有被<code>mock</code>掉，其他方法都被<code>mock</code>掉了。</p><p>目前还没有找到方法去<code>mock</code>类内私有方法（基于不能修改源代码、也不能使用powerMockito）。（如果有大佬看到，求教，邮箱<a href="mailto:&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x31;&#55;&#x36;&#x33;&#54;&#x30;&#x35;&#x39;&#x38;&#x30;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>）</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">    assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><code>MockService</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serviceMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;serviceMethod&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; service&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockTmp</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockTmp</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockTmp</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tmpMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; tmp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUser</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MockUser</span><span class="params">(MockService mockService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.mockService = mockService;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">privateMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Private Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; private&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">staticMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Method Called&quot;</span>);</span><br><span class="line">        name = name + <span class="string">&quot; static&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">publicMethod</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 调用其他服务  name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> mockService.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 调用类内私有方法  name + &quot; private&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> privateMethod(name);</span><br><span class="line">            <span class="comment">// 调用静态方法 name + &quot; static&quot;</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> staticMethod(name);</span><br><span class="line">            <span class="comment">// 不带参的构造函数 name + &quot; service&quot;</span></span><br><span class="line">            <span class="type">MockService</span> <span class="variable">mockService2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockService</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> mockService2.serviceMethod(name);</span><br><span class="line">            <span class="comment">// 带参的构造函数 name + &quot; tmp&quot;</span></span><br><span class="line">            <span class="type">MockTmp</span> <span class="variable">mocktmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockTmp</span>(mockService2);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> mocktmp.tmpMethod(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> name1 + <span class="string">&quot; &quot;</span> + name2 + <span class="string">&quot; &quot;</span>  + name3 + <span class="string">&quot; &quot;</span>  + name4 + <span class="string">&quot; &quot;</span>  + name5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MockUserTest</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.mockito;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.ArgumentMatchers.anyString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockUserTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MockService mockService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Spy</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> MockUser mockUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> mockUser.getClass().getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>, String.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) method.invoke(mockUser, name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test private&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> MockUser.staticMethod(name);</span><br><span class="line">        assertEquals(<span class="string">&quot;test static&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        <span class="comment">// 想要最后的结果都是 &quot;test&quot;</span></span><br><span class="line">        Mockito.when(mockService.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 静态方法不能直接在stubbing中调用 */</span></span><br><span class="line">        <span class="comment">//Mockito.when(MockUser.staticMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个类内的私有方法无法mock</span></span><br><span class="line">        <span class="comment">//Mockito.when(mockUser.privateMethod(anyString())).thenReturn(&quot;test&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// mock新对象和静态方法</span></span><br><span class="line">        <span class="keyword">try</span>(MockedStatic&lt;MockUser&gt; mockUserStatic = Mockito.mockStatic(MockUser.class);</span><br><span class="line">            MockedConstruction&lt;MockService&gt; service = Mockito.mockConstruction(MockService.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.serviceMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            MockedConstruction&lt;MockTmp&gt; tmp = Mockito.mockConstruction(MockTmp.class, (mock, context) -&gt; &#123;</span><br><span class="line">                Mockito.when(mock.tmpMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">            )&#123;</span><br><span class="line"></span><br><span class="line">            mockUserStatic.when(() -&gt; MockUser.staticMethod(anyString())).thenReturn(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> mockUser.publicMethod(name);</span><br><span class="line">            assertEquals(<span class="string">&quot;test test private test test test&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethodException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        Mockito.doThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>()).when(mockService).serviceMethod(anyString());</span><br><span class="line">        assertThrows(RuntimeException.class, () -&gt; mockUser.publicMethod(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用Mockito和JUnit5进行单元测试。&lt;/p&gt;
&lt;p&gt;需要注入依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight xm</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java学习笔记-组合、继承、接口</title>
    <link href="https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/"/>
    <id>https://kelinkong.github.io/2024/09/25/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BB%84%E5%90%88%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%8E%A5%E5%8F%A3/</id>
    <published>2024-09-25T01:30:55.000Z</published>
    <updated>2024-09-25T08:43:26.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组合和聚合"><a href="#组合和聚合" class="headerlink" title="组合和聚合"></a>组合和聚合</h2><ul><li><p>组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。例如，“汽车拥有引擎”</p></li><li><p>聚合（Aggregation）动态的组合。</p></li></ul><p><strong>组合</strong>：表示整体与部分的关系，整体和部分的生命周期一样，整体不存在了，部分也不存在了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Engine starting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Engine engine;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Car</span><span class="params">()</span> &#123;</span><br><span class="line">        engine = <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        engine.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>聚合</strong>：表示整体与部分的关系，整体和部分的生命周期不一样，整体不存在了，部分还存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Department</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departments; <span class="comment">// Company 聚合多个 Department</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.departments = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addDepartment</span><span class="params">(Department department)</span> &#123;</span><br><span class="line">        departments.add(department);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showDepartments</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Department department : departments) &#123;</span><br><span class="line">            System.out.println(department.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Department</span> <span class="variable">hr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;HR&quot;</span>);</span><br><span class="line">        <span class="type">Department</span> <span class="variable">it</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Department</span>(<span class="string">&quot;IT&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.addDepartment(hr); <span class="comment">// Company 聚合 Department</span></span><br><span class="line">        company.addDepartment(it);</span><br><span class="line"></span><br><span class="line">        company.showDepartments();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么推荐使用组合而不是继承"><a href="#为什么推荐使用组合而不是继承" class="headerlink" title="为什么推荐使用组合而不是继承"></a>为什么推荐使用组合而不是继承</h2><ul><li>继承在某些特定情况下是有用的，比如实现“是一个”的关系（如 Dog 是一种 Animal），但由于它带来的耦合问题、封装性破坏以及灵活性不足，推荐尽可能优先使用组合。</li><li>组合更加灵活、可维护性更好，能够在不破坏现有代码结构的情况下进行修改和扩展。因此，在大多数情况下，推荐使用组合而不是继承。</li></ul><blockquote><p>组合和继承都可以实现在不修改源代码的情况下，扩张已有的类的功能。但是组合更加灵活，因为它可以在运行时动态地改变对象的行为。</p><p>组合是一种包含关系，一个类的对象包含另一个类的对象，通过调用另一个类的方法来实现功能。</p></blockquote><h2 id="继承和接口的区别"><a href="#继承和接口的区别" class="headerlink" title="继承和接口的区别"></a>继承和接口的区别</h2><p>继承：</p><ul><li>继承是面向对象编程中的一种机制，允许一个类（子类）从另一个类（父类）继承其属性和方法。</li><li>继承表示的是 “is-a” 关系，比如 Dog 继承自 Animal，意味着狗是一种动物。</li><li>在继承关系中，子类继承父类的非私有（private）的成员变量和方法，并且可以重写父类方法。</li><li>Java 中类的继承是单继承的，一个类只能有一个父类。</li></ul><p>接口：</p><ul><li>接口是一种抽象类型，定义了类必须实现的行为，但不提供具体实现。</li><li>接口表示的是 “can-do” 或者 “contract-based” 关系，意味着类必须实现接口中声明的方法。</li><li>一个类可以实现多个接口，这使得接口在多态设计中非常有用。</li><li>Java 支持多接口实现，一个类可以实现多个接口。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Swimable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Swimable &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is flying&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Duck is swimming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java中的接口和C-中的抽象类的区别"><a href="#Java中的接口和C-中的抽象类的区别" class="headerlink" title="Java中的接口和C++中的抽象类的区别"></a>Java中的接口和C++中的抽象类的区别</h2><h3 id="语法和定义"><a href="#语法和定义" class="headerlink" title="语法和定义"></a>语法和定义</h3><p>Java 的接口：</p><ul><li>接口使用 interface 关键字定义。</li><li>接口中的方法默认是抽象的（不提供实现），并且所有字段默认是 public static final（常量）。</li><li>Java 8 及之后，接口可以有 default 和 static 方法，这些方法可以有实现。</li><li>接口中的所有方法默认是 public，即使没有显式声明。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">prepareForFlight</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing for flight&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>C++ 的抽象类：</p><ul><li>抽象类使用 class 关键字定义。</li><li>抽象类可以包含抽象方法（纯虚函数）和具体方法（有实现的方法）。</li><li>抽象类可以包含成员变量，并且可以是各种访问级别：private、protected 或 public。</li><li>纯虚函数在 C++ 中用 &#x3D; 0 标记，表示该方法没有实现，必须由子类实现。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Flyable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">prepareForFlight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Preparing for flight&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数和成员变量"><a href="#构造函数和成员变量" class="headerlink" title="构造函数和成员变量"></a>构造函数和成员变量</h3><p>Java 的接口：</p><p>接口中不能有构造函数，因为接口不能直接实例化。<br>接口不能包含实例变量，只有 static 和 final 常量。</p><p>C++ 的抽象类：</p><p>抽象类可以有构造函数，尽管不能直接实例化抽象类，但它可以用来初始化子类。<br>抽象类可以包含实例变量，这些变量可以在子类中继承。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Java 的接口：</p><p>接口的方法调用通过虚拟机的动态分派机制来实现，通常比直接调用类中的方法略慢。<br>随着 JVM 优化，接口的性能已经非常接近普通类的方法调用。</p><p>C++ 的抽象类：</p><p>C++ 使用虚函数表（vtable）来处理多态调用，性能相对较高，因为是在编译时确定虚函数表，运行时通过指针查找。<br>由于虚函数机制的直接性，C++ 抽象类的多态调用在许多情况下比 Java 的接口实现更快</p><h2 id="Java是如何实现多态的"><a href="#Java是如何实现多态的" class="headerlink" title="Java是如何实现多态的"></a>Java是如何实现多态的</h2><h3 id="编译时多态（静态多态）"><a href="#编译时多态（静态多态）" class="headerlink" title="编译时多态（静态多态）"></a>编译时多态（静态多态）</h3><p>方法重载（Method Overloading）：</p><p>方法重载是指同一个类中可以有多个方法名相同，但参数类型或参数数量不同的方法。根据传入参数的不同，编译器会在编译时决定调用哪个版本的重载方法。</p><p>这是静态多态的表现形式，因为在编译阶段就确定了调用的方法。</p><h3 id="运行时多态（动态多态）"><a href="#运行时多态（动态多态）" class="headerlink" title="运行时多态（动态多态）"></a>运行时多态（动态多态）</h3><p>方法重写（Method Overriding）：</p><p>运行时多态的核心在于方法重写。当一个子类继承父类，并在子类中提供了对父类方法的不同实现时，Java 会在运行时根据对象的实际类型决定调用哪一个方法。</p><p>通过父类引用指向子类对象，调用重写的方法时，实际执行的是子类的实现。这是在运行时根据对象的实际类型动态决定的，因此称为动态多态。<br>实现方式：虚方法机制：</p><p>Java 中的所有非 final 和 private 方法都被认为是虚方法。虚方法是可以被子类重写的方法，Java 使用虚方法表（vtable）来实现多态。</p><p>当调用一个方法时，JVM 会通过对象的实际类型在运行时决定调用哪个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myAnimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();  <span class="comment">// Animal 类型引用</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">        myAnimal.sound();  <span class="comment">// 调用的是 Animal 的 sound() 方法</span></span><br><span class="line">        myDog.sound();     <span class="comment">// 调用的是 Dog 的 sound() 方法</span></span><br><span class="line">        myCat.sound();     <span class="comment">// 调用的是 Cat 的 sound() 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>Java 通过接口也可以实现多态。当一个类实现了某个接口时，接口引用可以指向该类的实例，并且在运行时会根据对象的实际类型执行具体的方法实现。</p><h3 id="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"><a href="#当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？" class="headerlink" title="当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？"></a>当传入的参数为一个接口时，如何确定调用的是哪一个接口的实现？</h3><p>如何确定调用的是哪一个接口的实现？</p><ul><li>编译时：当你传入一个接口类型的参数时，编译器只会检查这个对象是否实现了该接口，但不会关心具体是哪一个实现类。</li><li>运行时：在程序运行时，JVM 会根据<strong>传入对象</strong>的实际类型决定调用具体实现类的方法。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组合和聚合&quot;&gt;&lt;a href=&quot;#组合和聚合&quot; class=&quot;headerlink&quot; title=&quot;组合和聚合&quot;&gt;&lt;/a&gt;组合和聚合&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;组合（Composition）经常用来表示“拥有” 关系（has-a relationship）。</summary>
      
    
    
    
    <category term="Java" scheme="https://kelinkong.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>llvm中的temperature</title>
    <link href="https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/"/>
    <id>https://kelinkong.github.io/2024/09/23/llvm%E4%B8%AD%E7%9A%84temperature/</id>
    <published>2024-09-23T07:32:39.000Z</published>
    <updated>2024-09-25T01:59:43.925Z</updated>
    
    <content type="html"><![CDATA[<p>$$<br>\begin{aligned}<br>\text { for } i &amp; &#x3D;1, \ldots, L: \<br>x_i &amp; \sim p\left(x_i \mid x_{1: i-1}\right)^{1 &#x2F; T},<br>\end{aligned}<br>$$</p><p>其中  $T≥0$  是一个控制我们希望从语言模型中得到多少随机性的温度参数：</p><ul><li>T&#x3D;0：确定性地在每个位置 i 选择最可能的词元 $x_{i}$</li><li>T&#x3D;1：从纯语言模型“正常（normally）”采样</li><li>T&#x3D;∞：从整个词汇表上的均匀分布中采样</li></ul><p>这个公式和描述与语言模型的温度调节（temperature scaling）有关，常用于生成任务（如文本生成、语言建模）中，控制模型生成的随机性。它影响从模型的概率分布中采样的方式，使生成的文本更加多样化或更加确定。</p><p><img src="/../imgs/image-48.png" alt="alt text"><br><img src="/../imgs/image-49.png" alt="alt text"><br><img src="/../imgs/image-50.png" alt="alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$$&lt;br&gt;&#92;begin{aligned}&lt;br&gt;&#92;text { for } i &amp;amp; &amp;#x3D;1, &#92;ldots, L: &#92;&lt;br&gt;x_i &amp;amp; &#92;sim p&#92;left(x_i &#92;mid x_{1: i-1}&#92;right)^{1 &amp;#x2F; T},&lt;br</summary>
      
    
    
    
    <category term="LLVM" scheme="https://kelinkong.github.io/categories/LLVM/"/>
    
    
  </entry>
  
</feed>
